{"version":3,"file":"can-set-legacy.js","sources":["../node_modules/can-set-legacy/can-set-legacy.js"],"sourcesContent":["// for can-set compat\nvar Query = require(\"can-query-logic\");\nvar canReflect = require(\"can-reflect\");\nvar transform = require(\"can-key/transform/transform\");\nvar deleteKey = require(\"can-key/delete/delete\");\nvar getKey = require(\"can-key/get/get\");\nvar helpers = require(\"can-query-logic/src/helpers\");\nvar makeEnum = require(\"can-query-logic/src/types/make-enum\");\nvar SET = require(\"can-query-logic/src/set\");\n\nvar IsBoolean = function(){\n\n};\nmakeEnum(IsBoolean,[true, false], function(value) {\n\n    if(value === \"true\") {\n        return true;\n    } else if(value === \"false\") {\n        return false;\n    } else {\n        return value;\n    }\n\n});\n\nfunction hasKey(obj, keys, parent, parentKey) {\n    if(obj && typeof obj === \"object\") {\n        for(var key in obj) {\n            if(keys[key]) {\n                if(typeof keys[key] === \"function\") {\n                    parent[parentKey] = keys[key](obj);\n                } else {\n                    return true;\n                }\n\n            } else {\n                if( hasKey(obj[key], keys, obj, key) ) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nfunction convertToJSONAPISort(sortPropValue){\n    var parts = sortPropValue.split(' ');\n    var isDesc = (parts[1] || '').toLowerCase()\t=== 'desc';\n\n    return isDesc ? \"-\"+parts[0] : parts[0];\n}\nfunction convertToLegacySort(value) {\n    var result = helpers.sortData(value);\n    return result.desc ? \"-\"+result.prop : result.prop;\n}\n\nvar defaultAlgebra;\n\nvar set = {\n    UNIVERSAL: SET.UNIVERSAL,\n    // Nothing\n    EMPTY: SET.EMPTY,\n    // The set exists, but we lack the language to represent it.\n    UNDEFINABLE: SET.UNDEFINABLE,\n\n    // We don't know if this exists. Intersection between two paginated sets.\n    UNKNOWABLE: SET.UNKNOWABLE,\n    Algebra: function(){\n        var mutators = {\n            schema: [],\n            hydrate: [],\n            serialize: []\n        };\n        canReflect.eachIndex(arguments, function(value){\n            for(var prop in value) {\n                if(mutators[prop]) {\n                    mutators[prop].push(value[prop]);\n                } else {\n                    throw new Error(\"can-query-logic: This type of configuration is not supported. Please use can-query-logic directly.\");\n                }\n\n            }\n        });\n\n        var obj = canReflect.assignSymbols({},{\n            \"can.getSchema\": function(){\n                var schema = {\n                    kind: \"record\",\n                    identity: [],\n                    keys: {}\n                };\n                mutators.schema.forEach(function(updateSchema){\n                    updateSchema(schema);\n                });\n                if(!schema.identity.length) {\n                    schema.identity.push(\"id\");\n                }\n\n                return schema;\n            }\n        });\n        return new Query(obj, {\n            toQuery: function(data){\n                return mutators.hydrate.reduce(function(last, hydrator){\n                    return hydrator(last);\n                }, {filter: data});\n            },\n            toParams: function(data){\n                if(SET.isSpecial(data)) {\n                    return data;\n                }\n                /*if(data === SET.EMPTY) {\n                    return false;\n                }\n                if(data === SET.UNDEFINABLE) {\n                    return true;\n                }*/\n                if(Array.isArray(data.filter)){\n                    // OR is not supported ...\n                    return SET.UNDEFINABLE;\n                }\n\n                var filter = data.filter || {};\n                if(hasKey(filter, {\n                    \"$ne\": true,\n                    \"$in\": function(val){ return val.$in; }\n                })) {\n                    return SET.UNDEFINABLE;\n                }\n\n                var out = mutators.serialize.reduce(function(last, serializer){\n                    return serializer(last);\n                }, data);\n\n                filter = out.filter || {};\n                delete out.filter;\n                return canReflect.assign(out, filter);\n            }\n        });\n    },\n    Translate: function(clause, prop){\n        if(clause !== \"where\") {\n            throw new Error(\"can-query-logic/compat.Translate is only able to translate the where clause\");\n        }\n        return {\n            // {filter: {$where: {a:b}}} -> {filter: {a:b}}\n            hydrate: function(raw){\n                var clone = canReflect.serialize(raw);\n                var value = clone.filter[prop];\n                delete clone.filter[prop];\n                if(value) {\n                    canReflect.assign(clone.filter, value);\n                }\n\n                return clone;\n            },\n            // {filter: {foo:bar}} -> {filter: {where: {foo: bar}}}\n            serialize: function(query){\n\n                if(query.filter) {\n                    var clone = canReflect.serialize(query);\n                    var filter = query.filter;\n                    clone.filter = {};\n                    clone.filter[prop] = filter;\n                    return clone;\n                } else {\n                    return query;\n                }\n            }\n        };\n    },\n    props: {\n\n        boolean: function(prop){\n            // create boolean or enum\n            return {\n                schema: function(schema) {\n                    schema.keys[prop] = IsBoolean;\n                }\n            };\n        },\n        dotNotation: function(){\n            // This will be supported by default\n            return {};\n        },\n        enum: function(property, propertyValues) {\n            function Enum(){}\n            makeEnum(Enum, propertyValues);\n            return {\n                schema: function(schema) {\n                    schema.keys[property] = Enum;\n                }\n            };\n        },\n        id: function(id){\n            return {\n                \"schema\": function(schema){\n                    schema.identity.push(id);\n                }\n            };\n        },\n        offsetLimit: function(offset, limit){\n            offset = offset || \"offset\";\n            limit = limit || \"limit\";\n\n            return {\n                // taking what was given and making it a raw query look\n                // start -> page.start\n                // end -> page.end\n                hydrate: function(raw){\n                    var clone = canReflect.serialize(raw);\n                    if((offset in clone.filter) || (limit in clone.filter)) {\n                        clone.page = {};\n                    }\n                    if(offset in clone.filter) {\n                        clone.page.start = parseInt(clone.filter[offset], 10);\n                        delete clone.filter[offset];\n                    }\n                    if(limit in clone.filter) {\n                        clone.page.end = (clone.page.start || 0 ) + parseInt(clone.filter[limit], 10) - 1;\n                        delete clone.filter[limit];\n                    }\n                    return clone;\n                },\n                // taking the normal format and putting it back\n                // page.start -> start\n                // page.end -> end\n                serialize: function(raw){\n                    var clone = canReflect.serialize(raw);\n                    if(clone.page) {\n                        clone[offset] = clone.page.start;\n                        clone[limit] = (clone.page.end - clone.page.start) + 1;\n                        delete clone.page;\n                    }\n                    return clone;\n                }\n            };\n        },\n        rangeInclusive: function(start, end){\n            var hydrateTransfomer = {};\n            hydrateTransfomer[\"filter.\"+start] = \"page.start\";\n            hydrateTransfomer[\"filter.\"+end] = \"page.end\";\n\n            var serializeTransformer = {\n                \"page.start\": start,\n                \"page.end\": end\n            };\n            return {\n                // taking what was given and making it a raw query look\n                // start -> page.start\n                // end -> page.end\n                hydrate: function(raw){\n                    var res = transform(raw, hydrateTransfomer);\n                    if(res.page) {\n                        if(res.page.start) {\n                            res.page.start = parseInt(res.page.start, 10);\n                        }\n                        if(res.page.end) {\n                            res.page.end = parseInt(res.page.end, 10);\n                        }\n                    }\n                    return res;\n                },\n                // taking the normal format and putting it back\n                // page.start -> start\n                // page.end -> end\n                serialize: function(raw){\n                    return transform(raw, serializeTransformer);\n                }\n            };\n        },\n        ignore: function(prop){\n            return {\n                hydrate: function(raw){\n                    var clone = canReflect.serialize(raw);\n                    delete clone.filter[prop];\n                    return clone;\n                }\n            };\n        },\n        sort: function(prop, sortFunc){\n            /**\n             * var parts = sortPropValue.split(' ');\n                 return {\n                     prop: parts[0],\n                     desc: (parts[1] || '').toLowerCase()\t=== 'desc'\n                 };\n             */\n            if(!prop) {\n                prop = \"sort\";\n            }\n            if(sortFunc) {\n                throw new Error(\"can-query-logic/compat.sort - sortFunc is not supported\");\n            }\n\n            return {\n                hydrate: function(raw){\n                    var clone = canReflect.serialize(raw);\n                    var sort = getKey(clone,\"filter.\"+prop);\n                    if(sort !== undefined) {\n                        deleteKey(clone,\"filter.\"+prop);\n                        clone.sort = convertToJSONAPISort(sort);\n                    }\n\n                    return clone;\n                },\n                serialize: function(raw){\n                    var clone = canReflect.serialize(raw);\n                    var sort = clone.sort;\n                    if(sort !== undefined) {\n                        delete clone.sort;\n                        clone[prop] = convertToLegacySort(sort);\n                    }\n                    return clone;\n                }\n            };\n        }\n    }\n};\n\nfunction makeAlgebra(algebra) {\n    if(!algebra) {\n        return defaultAlgebra;\n    }\n    else if(!(algebra instanceof Query) ) {\n        return new set.Algebra(algebra);\n    }\n    return algebra;\n}\n\nfunction makeFromTwoQueries(prop) {\n    set[prop] = function( a, b, algebra ){\n        return makeAlgebra(algebra)[prop](a, b);\n    };\n}\nmakeFromTwoQueries(\"difference\");\nmakeFromTwoQueries(\"union\");\nmakeFromTwoQueries(\"intersection\");\nmakeFromTwoQueries(\"isSubset\");\nmakeFromTwoQueries(\"isEqual\");\nmakeFromTwoQueries(\"isProperSubset\");\n\nset.count = function(query, algebra) {\n    return makeAlgebra(algebra).count(query);\n};\n\nset.comparators = set.props;\n\ndefaultAlgebra = new set.Algebra();\n\nmodule.exports = set;\n"],"names":["defaultAlgebra","IsBoolean","hasKey","obj","keys","parent","parentKey","key","convertToJSONAPISort","sortPropValue","parts","split","toLowerCase","convertToLegacySort","value","result","helpers","sortData","desc","prop","makeEnum","set","UNIVERSAL","SET","EMPTY","UNDEFINABLE","UNKNOWABLE","Algebra","mutators","schema","hydrate","serialize","canReflect","eachIndex","arguments","Error","push","assignSymbols","can.getSchema","kind","identity","forEach","updateSchema","length","Query","toQuery","data","reduce","last","hydrator","filter","toParams","isSpecial","Array","isArray","$ne","$in","val","out","serializer","assign","Translate","clause","raw","clone","query","props","boolean","dotNotation","enum","property","propertyValues","Enum","id","offsetLimit","offset","limit","page","start","parseInt","end","rangeInclusive","hydrateTransfomer","serializeTransformer","page.start","page.end","res","transform","ignore","sort","sortFunc","getKey","undefined","deleteKey","makeAlgebra","algebra","makeFromTwoQueries","a","b","count","comparators"],"mappings":"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"}