{"version":3,"file":"chunk-d6693ee9.js","sources":["../node_modules/can-control/can-control.js"],"sourcesContent":["\"use strict\";\n// # can/control/control.js\n//\n// Create organized, memory-leak free, rapidly performing, stateful\n// controls with declarative eventing binding. Used when creating UI\n// controls with behaviors, bound to elements on the page.\n// ## helpers\n\nvar Construct = require(\"can-construct\");\nvar namespace = require(\"can-namespace\");\nvar assign = require(\"can-assign\");\nvar observeReader = require(\"can-stache-key\");\nvar canReflect = require(\"can-reflect\");\nvar Observation = require(\"can-observation\");\nvar canEvent = require(\"can-event-queue/map/map\");\nvar dev = require('can-log/dev/dev');\n\nvar string = require(\"can-string\");\nvar get = require(\"can-key/get/get\");\nvar domMutate = require('can-dom-mutate');\nvar canSymbol = require('can-symbol');\n\nvar controlsSymbol = canSymbol.for(\"can.controls\");\n\n\nvar processors;\n\n\n// ### bind\n// this helper binds to one element and returns a function that unbinds from that element.\nvar bind = function (el, ev, callback, queue) {\n\n    canEvent.on.call(el, ev, callback, queue);\n\n\treturn function () {\n        canEvent.off.call(el, ev, callback, queue);\n\t};\n},\n\tslice = [].slice,\n\tparamReplacer = /\\{([^\\}]+)\\}/g,\n\n\t// ### delegate\n\t//\n\t// this helper binds to elements based on a selector and returns a\n\t// function that unbinds.\n\tdelegate = function (el, selector, ev, callback) {\n        canEvent.on.call(el, ev, selector, callback);\n\n\t\treturn function () {\n            canEvent.off.call(el, ev, selector, callback);\n\t\t};\n\t},\n\n\t// ### binder\n\t//\n\t// Calls bind or unbind depending if there is a selector.\n\tbinder = function (el, ev, callback, selector) {\n\t\treturn selector ?\n\t\t\tdelegate(el, selector.trim(), ev, callback) :\n\t\t\tbind(el, ev, callback);\n\t},\n\n\tbasicProcessor;\n\nvar Control = Construct.extend(\"Control\",\n\t// ## *static functions*\n\t/**\n\t * @static\n\t */\n\t{\n\t\t// ## can.Control.setup\n\t\t//\n\t\t// This function pre-processes which methods are event listeners and which are methods of\n\t\t// the control. It has a mechanism to allow controllers to inherit default values from super\n\t\t// classes, like `can.Construct`, and will cache functions that are action functions (see `_isAction`)\n\t\t// or functions with an underscored name.\n\t\tsetup: function () {\n\t\t\tConstruct.setup.apply(this, arguments);\n\n\t\t\tif (Control) {\n\t\t\t\tvar control = this,\n\t\t\t\t\tfuncName;\n\n\t\t\t\tcontrol.actions = {};\n\t\t\t\tfor (funcName in control.prototype) {\n\t\t\t\t\tif (control._isAction(funcName)) {\n\t\t\t\t\t\tcontrol.actions[funcName] = control._action(funcName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// ## can.Control._shifter\n\t\t//\n\t\t// Moves `this` to the first argument, wraps it with `jQuery` if it's\n\t\t// an element.\n\t\t_shifter: function (context, name) {\n\t\t\tvar method = typeof name === \"string\" ? context[name] : name;\n\n\t\t\tif (typeof method !== \"function\") {\n\t\t\t\tmethod = context[method];\n\t\t\t}\n            var Control = this;\n\t\t\tfunction controlMethod() {\n\t\t\t\tvar wrapped = Control.wrapElement(this);\n\t\t\t\tcontext.called = name;\n\t\t\t\treturn method.apply(context, [wrapped].concat(slice.call(arguments, 0)));\n\t\t\t}\n      //!steal-remove-start\n      if(process.env.NODE_ENV !== 'production') {\n\t      Object.defineProperty(controlMethod, \"name\", {\n\t      \tvalue: canReflect.getName(this) + \"[\"+name+\"]\",\n\t      });\n\t     }\n      //!steal-remove-end\n      return controlMethod;\n\t\t},\n\n\t\t// ## can.Control._isAction\n\t\t//\n\t\t// Return `true` if `methodName` refers to an action. An action is a `methodName` value that\n\t\t// is not the constructor, and is either a function or string that refers to a function, or is\n\t\t// defined in `special`, `processors`. Detects whether `methodName` is also a valid method name.\n\t\t_isAction: function (methodName) {\n\t\t\tvar val = this.prototype[methodName],\n\t\t\t\ttype = typeof val;\n\n\t\t\treturn (methodName !== 'constructor') &&\n\t\t\t(type === \"function\" || (type === \"string\" && (typeof this.prototype[val] === \"function\") )) &&\n\t\t\t!! (Control.isSpecial(methodName) || processors[methodName] || /[^\\w]/.test(methodName));\n\t\t},\n\t\t// ## can.Control._action\n\t\t//\n\t\t// Takes a method name and the options passed to a control and tries to return the data\n\t\t// necessary to pass to a processor (something that binds things).\n\t\t//\n\t\t// For performance reasons, `_action` is called twice:\n\t\t// * It's called when the Control class is created. for templated method names (e.g., `{window} foo`), it returns null. For non-templated method names it returns the event binding data. That data is added to `this.actions`.\n\t\t// * It is called wehn a control instance is created, but only for templated actions.\n\t\t_action: function(methodName, options, controlInstance) {\n\t\t\tvar readyCompute,\n                unableToBind;\n\n\t\t\t// If we don't have options (a `control` instance), we'll run this later. If we have\n\t\t\t// options, run `can.sub` to replace the action template `{}` with values from the `options`\n\t\t\t// or `window`. If a `{}` template resolves to an object, `convertedName` will be an array.\n\t\t\t// In that case, the event name we want will be the last item in that array.\n\t\t\tparamReplacer.lastIndex = 0;\n\t\t\tif (options || !paramReplacer.test(methodName)) {\n                var controlActionData = function() {\n\t\t\t\t\tvar delegate;\n\n\t\t\t\t\t// Set the delegate target and get the name of the event we're listening to.\n\t\t\t\t\tvar name = methodName.replace(paramReplacer, function(matched, key) {\n\t\t\t\t\t\tvar value, parent;\n\n\t\t\t\t\t\t// If listening directly to a delegate target, set it\n\t\t\t\t\t\tif (this._isDelegate(options, key)) {\n\t\t\t\t\t\t\tdelegate = this._getDelegate(options, key);\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If key contains part of the lookup path, remove it.\n\t\t\t\t\t\t// This is needed for bindings like {viewModel.foo} in can-component's Control.\n\t\t\t\t\t\tkey = this._removeDelegateFromKey(key);\n\n\t\t\t\t\t\t// set the parent (where the key will be read from)\n\t\t\t\t\t\tparent = this._lookup(options)[0];\n\n\t\t\t\t\t\tvalue = observeReader.read(parent, observeReader.reads(key), {\n\t\t\t\t\t\t\t// if we find a compute, we should bind on that and not read it\n\t\t\t\t\t\t\treadCompute: false\n\t\t\t\t\t\t}).value;\n\n\t\t\t\t\t\t// If `value` is undefined try to get the value from the window.\n\t\t\t\t\t\tif (value === undefined && typeof window !== 'undefined') {\n\t\t\t\t\t\t\tvalue = get(window, key);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if the parent is not an observable and we don't have a value, show a warning\n\t\t\t\t\t\t// in this situation, it is not possible for the event handler to be triggered\n\t\t\t\t\t\tif (!parent || !(canReflect.isObservableLike(parent) && canReflect.isMapLike(parent)) && !value) {\n                            unableToBind = true;\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If `value` is a string we just return it, otherwise we set it as a delegate target.\n\t\t\t\t\t\tif (typeof value === \"string\") {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelegate = value;\n\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}.bind(this));\n\n\t\t\t\t\t// removing spaces that get added when converting\n\t\t\t\t\t// `{element} click` -> ` click`\n\t\t\t\t\tname = name.trim();\n\n\t\t\t\t\t// Get the name of the `event` we're listening to.\n\t\t\t\t\tvar parts = name.split(/\\s+/g),\n\t\t\t\t\t\tevent = parts.pop();\n\n\t\t\t\t\t// Return everything needed to handle the event we're listening to.\n\t\t\t\t\treturn {\n\t\t\t\t\t\tprocessor: this.processors[event] || basicProcessor,\n\t\t\t\t\t\tparts: [name, parts.join(\" \"), event],\n\t\t\t\t\t\tdelegate: delegate || undefined\n\t\t\t\t\t};\n\t\t\t\t};\n\n        //!steal-remove-start\n        if(process.env.NODE_ENV !== 'production') {\n\t\t    \tObject.defineProperty(controlActionData, \"name\", {\n\t\t      \tvalue: canReflect.getName(controlInstance || this.prototype) + \"[\"+methodName+\"].actionData\",\n\t\t      });\n\t      }\n        //!steal-remove-end\n\n\t\t\t\treadyCompute = new Observation(controlActionData, this);\n\n\n\t\t\t\tif (controlInstance) {\n\t\t\t\t\t// Create a handler function that we'll use to handle the `change` event on the `readyCompute`.\n\t\t\t\t\tvar handler = function(actionData) {\n\t\t\t\t\t\t// unbinds the old binding\n\t\t\t\t\t\tcontrolInstance._bindings.control[methodName](controlInstance.element);\n\t\t\t\t\t\t// binds the new\n\t\t\t\t\t\tcontrolInstance._bindings.control[methodName] = actionData.processor(\n\t\t\t\t\t\t\tactionData.delegate || controlInstance.element,\n\t\t\t\t\t\t\tactionData.parts[2], actionData.parts[1], methodName, controlInstance);\n\t\t\t\t\t};\n\n          //!steal-remove-start\n          if(process.env.NODE_ENV !== 'production') {\n          \tObject.defineProperty(handler, \"name\", {\n            \tvalue: canReflect.getName(controlInstance) + \"[\"+methodName+\"].handler\",\n            });\n          }\n\t\t\t\t\t//!steal-remove-end\n\n\n\t\t\t\t\tcanReflect.onValue(readyCompute, handler, \"mutate\");\n          //!steal-remove-start\n          if(process.env.NODE_ENV !== 'production') {\n\t          if(unableToBind) {\n\t          \tdev.log('can-control: No property found for handling ' + methodName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\tcontrolInstance._bindings.readyComputes[methodName] = {\n\t\t\t\t\t\tcompute: readyCompute,\n\t\t\t\t\t\thandler: handler\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn readyCompute.get();\n\t\t\t}\n\t\t},\n\t\t// the lookup path - where templated keys will be looked up\n\t\t_lookup: function (options) {\n\t\t\treturn [options, window];\n\t\t},\n\t\t// strip strings that represent delegates from the key\n\t\t_removeDelegateFromKey: function (key) {\n\t\t\treturn key;\n\t\t},\n\t\t// return whether the key is a delegate\n\t\t_isDelegate: function(options, key) {\n\t\t\treturn key === 'element';\n\t\t},\n\t\t// return the delegate object for a given key\n\t\t_getDelegate: function(options, key) {\n\t\t\treturn undefined;\n\t\t},\n\t\t// ## can.Control.processors\n\t\t//\n\t\t// An object of `{eventName : function}` pairs that Control uses to\n\t\t// hook up events automatically.\n\t\tprocessors: {},\n\t\t// ## can.Control.defaults\n\t\t// A object of name-value pairs that act as default values for a control instance\n\t\tdefaults: {},\n        // should be used to overwrite to make nodeLists on this\n        convertElement: function(element) {\n            element = typeof element === \"string\" ?\n\t\t\t\t\t\t\tdocument.querySelector(element) : element;\n\n\t\t\t\t\t\treturn this.wrapElement(element);\n        },\n        wrapElement: function(el){\n            return el;\n        },\n        unwrapElement: function(el){\n            return el;\n        },\n        // should be overwritten to look in jquery special events\n        isSpecial: function(eventName){\n            return eventName === \"inserted\" || eventName === \"removed\";\n        }\n\t}, {\n\t\t// ## *prototype functions*\n\t\t/**\n\t\t * @prototype\n\t\t */\n\t\t// ## setup\n\t\t//\n\t\t// Setup is where most of the Control's magic happens. It performs several pre-initialization steps:\n\t\t// - Sets `this.element`\n\t\t// - Adds the Control's name to the element's className\n\t\t// - Saves the Control in `$.data`\n\t\t// - Merges Options\n\t\t// - Binds event handlers using `delegate`\n\t\t// The final step is to return pass the element and prepareed options, to be used in `init`.\n\t\tsetup: function (element, options) {\n\n\t\t\tvar cls = this.constructor,\n\t\t\t\tpluginname = cls.pluginName || cls.shortName,\n\t\t\t\tarr;\n\n\t\t\tif (!element) {\n\t\t\t\tthrow new Error('Creating an instance of a named control without passing an element');\n\t\t\t}\n\t\t\t// Retrieve the raw element, then set the plugin name as a class there.\n            this.element = cls.convertElement(element);\n\n\t\t\tif (pluginname && pluginname !== 'Control' && this.element.classList) {\n                this.element.classList.add(pluginname);\n\t\t\t}\n\n\t\t\t// Set up the 'controls' data on the element. If it does not exist, initialize\n\t\t\t// it to an empty array.\n\t\t\tarr = this.element[controlsSymbol];\n\t\t\tif (!arr) {\n\t\t\t\tarr = [];\n\t\t\t\tthis.element[controlsSymbol] = arr;\n\t\t\t}\n\t\t\tarr.push(this);\n\n\t\t\t// The `this.options` property is an Object that contains configuration data\n\t\t\t// passed to a control when it is created (`new can.Control(element, options)`)\n\t\t\t//\n\t\t\t// The `options` argument passed when creating the control is merged with `can.Control.defaults`\n\t\t\t// in [can.Control.prototype.setup setup].\n\t\t\t//\n\t\t\t// If no `options` value is used during creation, the value in `defaults` is used instead\n\t\t\tif (canReflect.isObservableLike(options) && canReflect.isMapLike(options)) {\n\t\t\t\tfor (var prop in cls.defaults) {\n\t\t\t\t\tif (!options.hasOwnProperty(prop)) {\n\t\t\t\t\t\tobserveReader.set(options, prop, cls.defaults[prop]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.options = options;\n\t\t\t} else {\n\t\t\t\tthis.options = assign( assign({}, cls.defaults), options);\n\t\t\t}\n\n\t\t\tthis.on();\n\n\t\t\treturn [this.element, this.options];\n\t\t},\n\t\t// ## on\n\t\t//\n\t\t// This binds an event handler for an event to a selector under the scope of `this.element`\n\t\t// If no options are specified, all events are rebound to their respective elements. The actions,\n\t\t// which were cached in `setup`, are used and all elements are bound using `delegate` from `this.element`.\n\t\ton: function (el, selector, eventName, func) {\n\t\t\tif (!el) {\n\t\t\t\tthis.off();\n\n\t\t\t\tvar cls = this.constructor,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tactions = cls.actions,\n\t\t\t\t\telement = this.constructor.unwrapElement(this.element),\n\t\t\t\t\tdestroyCB = Control._shifter(this, \"destroy\"),\n\t\t\t\t\tfuncName, ready;\n\n\t\t\t\tfor (funcName in actions) {\n\t\t\t\t\t// Only push if we have the action and no option is `undefined`\n\t\t\t\t\tif ( actions.hasOwnProperty(funcName) ) {\n\t\t\t\t\t\tready = actions[funcName] || cls._action(funcName, this.options, this);\n\t\t\t\t\t\tif( ready ) {\n\t\t\t\t\t\t\tbindings.control[funcName]  = ready.processor(ready.delegate || element,\n\t\t\t\t\t\t\t\tready.parts[2], ready.parts[1], funcName, this);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set up the ability to `destroy` the control later.\n\t\t\t\tvar removalDisposal = domMutate.onNodeRemoval(element, function () {\n\t\t\t\t\tif (!element.ownerDocument.documentElement.contains(element)) {\n\t\t\t\t\t\tdestroyCB();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbindings.user.push(function () {\n\t\t\t\t\tif (removalDisposal) {\n\t\t\t\t\t\tremovalDisposal();\n\t\t\t\t\t\tremovalDisposal = undefined;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn bindings.user.length;\n\t\t\t}\n\n\t\t\t// if `el` is a string, use that as `selector` and re-set it to this control's element...\n\t\t\tif (typeof el === 'string') {\n\t\t\t\tfunc = eventName;\n\t\t\t\teventName = selector;\n\t\t\t\tselector = el;\n\t\t\t\tel = this.element;\n\t\t\t}\n\n\t\t\t// ...otherwise, set `selector` to null\n\t\t\tif (func === undefined) {\n\t\t\t\tfunc = eventName;\n\t\t\t\teventName = selector;\n\t\t\t\tselector = null;\n\t\t\t}\n\n\t\t\tif (typeof func === 'string') {\n\t\t\t\tfunc = Control._shifter(this, func);\n\t\t\t}\n\n\t\t\tthis._bindings.user.push(binder(el, eventName, func, selector));\n\n\t\t\treturn this._bindings.user.length;\n\t\t},\n\t\t// ## off\n\t\t//\n\t\t// Unbinds all event handlers on the controller.\n\t\t// This should _only_ be called in combination with .on()\n\t\toff: function () {\n\t\t\tvar el = this.constructor.unwrapElement(this.element),\n\t\t\t\tbindings = this._bindings;\n\t\t\tif( bindings ) {\n\t\t\t\t(bindings.user || []).forEach(function (value) {\n\t\t\t\t\tvalue(el);\n\t\t\t\t});\n\t\t\t\tcanReflect.eachKey(bindings.control || {}, function (value) {\n\t\t\t\t\tvalue(el);\n\t\t\t\t});\n\t\t\t\tcanReflect.eachKey(bindings.readyComputes || {}, function(value) {\n\t\t\t\t\tcanReflect.offValue(value.compute, value.handler, \"mutate\");\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Adds bindings.\n\t\t\tthis._bindings = {user: [], control: {}, readyComputes: {}};\n\t\t},\n\t\t// ## destroy\n\t\t//\n\t\t// Prepares a `control` for garbage collection.\n\t\t// First checks if it has already been removed. Then, removes all the bindings, data, and\n\t\t// the element from the Control instance.\n\t\tdestroy: function () {\n\t\t\tif (this.element === null) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tdev.warn(\"can-control: Control already destroyed\");\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar Class = this.constructor,\n\t\t\t\tpluginName = Class.pluginName || (Class.shortName && string.underscore(Class.shortName)),\n\t\t\t\tcontrols;\n\n\t\t\tthis.off();\n\n\t\t\tif (pluginName && pluginName !== 'can_control' && this.element.classList) {\n                this.element.classList.remove(pluginName);\n\t\t\t}\n\n\t\t\tcontrols = this.element[controlsSymbol];\n\t\t\tif (controls) {\n\t\t\t\tcontrols.splice(controls.indexOf(this), 1);\n\t\t\t}\n\n\t\t\t//canEvent.dispatch.call(this, \"destroyed\");\n\n\t\t\tthis.element = null;\n\t\t}\n\t});\n\n// ## Processors\n//\n// Processors do the binding. This basic processor binds events. Each returns a function that unbinds\n// when called.\nprocessors = Control.processors;\nbasicProcessor = function (el, event, selector, methodName, control) {\n\treturn binder(el, event, Control._shifter(control, methodName), selector);\n};\n\n// Set common events to be processed as a `basicProcessor`\n[\"beforeremove\", \"change\", \"click\", \"contextmenu\", \"dblclick\", \"keydown\", \"keyup\",\n\t\"keypress\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\",\n\t\"mouseup\", \"reset\", \"resize\", \"scroll\", \"select\", \"submit\", \"focusin\",\n\t\"focusout\", \"mouseenter\", \"mouseleave\",\n\t\"touchstart\", \"touchmove\", \"touchcancel\", \"touchend\", \"touchleave\",\n\t\"inserted\",\"removed\",\n\t\"dragstart\", \"dragenter\", \"dragover\", \"dragleave\", \"drag\", \"drop\", \"dragend\"\n].forEach(function (v) {\n\tprocessors[v] = basicProcessor;\n});\n\nmodule.exports = namespace.Control = Control;\n"],"names":["processors","basicProcessor","controlsSymbol","canSymbol","for","bind","el","ev","callback","queue","canEvent","on","call","off","slice","paramReplacer","delegate","selector","binder","trim","Control","Construct","extend","setup","apply","this","arguments","funcName","actions","prototype","_isAction","_action","_shifter","context","name","method","controlMethod","wrapped","wrapElement","called","concat","process","env","NODE_ENV","Object","defineProperty","value","canReflect","getName","methodName","val","type","isSpecial","test","options","controlInstance","readyCompute","unableToBind","lastIndex","controlActionData","replace","matched","key","parent","_isDelegate","_getDelegate","_removeDelegateFromKey","_lookup","undefined","observeReader","read","reads","readCompute","window","get","isObservableLike","isMapLike","parts","split","event","pop","processor","join","Observation","handler","actionData","_bindings","control","element","onValue","dev","log","readyComputes","compute","defaults","convertElement","document","querySelector","unwrapElement","eventName","arr","cls","constructor","pluginname","pluginName","shortName","Error","classList","add","push","prop","hasOwnProperty","set","assign","func","ready","bindings","destroyCB","removalDisposal","domMutate","onNodeRemoval","ownerDocument","documentElement","contains","user","length","forEach","eachKey","offValue","destroy","controls","Class","string","underscore","remove","splice","indexOf","warn","v","namespace"],"mappings":"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"}