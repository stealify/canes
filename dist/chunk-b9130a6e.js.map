{"version":3,"file":"chunk-b9130a6e.js","sources":["../node_modules/can-define/list/list.js"],"sourcesContent":["\"use strict\";\nvar Construct = require(\"can-construct\");\nvar define = require(\"can-define\");\nvar make = define.make;\nvar queues = require(\"can-queues\");\nvar addTypeEvents = require(\"can-event-queue/type/type\");\n\nvar ObservationRecorder = require(\"can-observation-recorder\");\nvar canLog = require(\"can-log\");\nvar canLogDev = require(\"can-log/dev/dev\");\nvar defineHelpers = require(\"../define-helpers/define-helpers\");\n\nvar assign = require(\"can-assign\");\nvar diff = require(\"can-diff/list/list\");\nvar ns = require(\"can-namespace\");\nvar canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\nvar singleReference = require(\"can-single-reference\");\n\nvar splice = [].splice;\nvar runningNative = false;\n\nvar identity = function(x) {\n\treturn x;\n};\n\n// symbols aren't enumerable ... we'd need a version of Object that treats them that way\nvar localOnPatchesSymbol = \"can.patches\";\n\nvar makeFilterCallback = function(props) {\n\treturn function(item) {\n\t\tfor (var prop in props) {\n\t\t\tif (item[prop] !== props[prop]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n};\n\nvar onKeyValue = define.eventsProto[canSymbol.for(\"can.onKeyValue\")];\nvar offKeyValue = define.eventsProto[canSymbol.for(\"can.offKeyValue\")];\nvar getSchemaSymbol = canSymbol.for(\"can.getSchema\");\n\nfunction getSchema() {\n\tvar definitions = this.prototype._define.definitions;\n\tvar schema = {\n\t\ttype: \"list\",\n\t\tkeys: {}\n\t};\n\tschema = define.updateSchemaKeys(schema, definitions);\n\tif(schema.keys[\"#\"]) {\n\t\tschema.values = definitions[\"#\"].Type;\n\t\tdelete schema.keys[\"#\"];\n\t}\n\n\treturn schema;\n}\n\n\n/** @add can-define/list/list */\nvar DefineList = Construct.extend(\"DefineList\",\n\t/** @static */\n\t{\n\t\tsetup: function(base) {\n\t\t\tif (DefineList) {\n\t\t\t\taddTypeEvents(this);\n\t\t\t\tvar prototype = this.prototype;\n\t\t\t\tvar result = define(prototype, prototype, base.prototype._define);\n\t\t\t\tdefine.makeDefineInstanceKey(this, result);\n\n\t\t\t\tvar itemsDefinition = result.definitions[\"#\"] || result.defaultDefinition;\n\n\t\t\t\tif (itemsDefinition) {\n\t\t\t\t\tif (itemsDefinition.Type) {\n\t\t\t\t\t\tthis.prototype.__type = make.set.Type(\"*\", itemsDefinition.Type, identity);\n\t\t\t\t\t} else if (itemsDefinition.type) {\n\t\t\t\t\t\tthis.prototype.__type = make.set.type(\"*\", itemsDefinition.type, identity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis[getSchemaSymbol] = getSchema;\n\t\t\t}\n\t\t}\n\t},\n\t/** @prototype */\n\t{\n\t\t// setup for only dynamic DefineMap instances\n\t\tsetup: function(items) {\n\t\t\tif (!this._define) {\n\t\t\t\tObject.defineProperty(this, \"_define\", {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tdefinitions: {\n\t\t\t\t\t\t\tlength: { type: \"number\" },\n\t\t\t\t\t\t\t_length: { type: \"number\" }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tObject.defineProperty(this, \"_data\", {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: {}\n\t\t\t\t});\n\t\t\t}\n\t\t\tdefine.setup.call(this, {}, false);\n\t\t\tObject.defineProperty(this, \"_length\", {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: 0\n\t\t\t});\n\t\t\tif (items) {\n\t\t\t\tthis.splice.apply(this, [ 0, 0 ].concat(canReflect.toArray(items)));\n\t\t\t}\n\t\t},\n\t\t__type: define.types.observable,\n\t\t_triggerChange: function(attr, how, newVal, oldVal) {\n\n\t\t\tvar index = +attr;\n\t\t\t// `batchTrigger` direct add and remove events...\n\n\t\t\t// Make sure this is not nested and not an expando\n\t\t\tif ( !isNaN(index)) {\n\t\t\t\tvar itemsDefinition = this._define.definitions[\"#\"];\n\t\t\t\tvar patches, dispatched;\n\t\t\t\tif (how === 'add') {\n\t\t\t\t\tif (itemsDefinition && typeof itemsDefinition.added === 'function') {\n\t\t\t\t\t\tObservationRecorder.ignore(itemsDefinition.added).call(this, newVal, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tpatches = [{type: \"splice\", insert: newVal, index: index, deleteCount: 0}];\n\t\t\t\t\tdispatched = {\n\t\t\t\t\t\ttype: how,\n\t\t\t\t\t\tpatches: patches\n\t\t\t\t\t};\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\tdispatched.reasonLog = [ canReflect.getName(this), \"added\", newVal, \"at\", index ];\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tthis.dispatch(dispatched, [ newVal, index ]);\n\n\t\t\t\t} else if (how === 'remove') {\n\t\t\t\t\tif (itemsDefinition && typeof itemsDefinition.removed === 'function') {\n\t\t\t\t\t\tObservationRecorder.ignore(itemsDefinition.removed).call(this, oldVal, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tpatches = [{type: \"splice\", index: index, deleteCount: oldVal.length}];\n\t\t\t\t\tdispatched = {\n\t\t\t\t\t\ttype: how,\n\t\t\t\t\t\tpatches: patches\n\t\t\t\t\t};\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\tdispatched.reasonLog = [ canReflect.getName(this), \"remove\", oldVal, \"at\", index ];\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tthis.dispatch(dispatched, [ oldVal, index ]);\n\n\t\t\t\t} else {\n\t\t\t\t\tthis.dispatch(how, [ newVal, index ]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.dispatch({\n\t\t\t\t\ttype: \"\" + attr,\n\t\t\t\t\ttarget: this\n\t\t\t\t}, [ newVal, oldVal ]);\n\t\t\t}\n\t\t},\n\t\tget: function(index) {\n\t\t\tif (arguments.length) {\n\t\t\t\tif(isNaN(index)) {\n\t\t\t\t\tObservationRecorder.add(this, index);\n\t\t\t\t} else {\n\t\t\t\t\tObservationRecorder.add(this, \"length\");\n\t\t\t\t}\n\t\t\t\treturn this[index];\n\t\t\t} else {\n\t\t\t\treturn canReflect.unwrap(this, Map);\n\t\t\t}\n\t\t},\n\t\tset: function(prop, value) {\n\t\t\t// if we are setting a single value\n\t\t\tif (typeof prop !== \"object\") {\n\t\t\t\t// We want change events to notify using integers if we're\n\t\t\t\t// setting an integer index. Note that <float> % 1 !== 0;\n\t\t\t\tprop = isNaN(+prop) || (prop % 1) ? prop : +prop;\n\t\t\t\tif (typeof prop === \"number\") {\n\t\t\t\t\t// Check to see if we're doing a .attr() on an out of\n\t\t\t\t\t// bounds index property.\n\t\t\t\t\tif (typeof prop === \"number\" &&\n\t\t\t\t\t\tprop > this._length - 1) {\n\t\t\t\t\t\tvar newArr = new Array((prop + 1) - this._length);\n\t\t\t\t\t\tnewArr[newArr.length - 1] = value;\n\t\t\t\t\t\tthis.push.apply(this, newArr);\n\t\t\t\t\t\treturn newArr;\n\t\t\t\t\t}\n\t\t\t\t\tthis.splice(prop, 1, value);\n\t\t\t\t} else {\n\t\t\t\t\tvar defined = defineHelpers.defineExpando(this, prop, value);\n\t\t\t\t\tif (!defined) {\n\t\t\t\t\t\tthis[prop] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// otherwise we are setting multiple\n\t\t\telse {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tcanLogDev.warn('can-define/list/list.prototype.set is deprecated; please use can-define/list/list.prototype.assign or can-define/list/list.prototype.update instead');\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\t//we are deprecating this in #245\n\t\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tthis.replace(prop);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanReflect.assignList(this, prop);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcanReflect.assignMap(this, prop);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tassign: function(prop) {\n\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\tcanReflect.assignList(this, prop);\n\t\t\t} else {\n\t\t\t\tcanReflect.assignMap(this, prop);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tupdate: function(prop) {\n\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\tcanReflect.updateList(this, prop);\n\t\t\t} else {\n\t\t\t\tcanReflect.updateMap(this, prop);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tassignDeep: function(prop) {\n\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\tcanReflect.assignDeepList(this, prop);\n\t\t\t} else {\n\t\t\t\tcanReflect.assignDeepMap(this, prop);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tupdateDeep: function(prop) {\n\t\t\tif (canReflect.isListLike(prop)) {\n\t\t\t\tcanReflect.updateDeepList(this, prop);\n\t\t\t} else {\n\t\t\t\tcanReflect.updateDeepMap(this, prop);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t_items: function() {\n\t\t\tvar arr = [];\n\t\t\tthis._each(function(item) {\n\t\t\t\tarr.push(item);\n\t\t\t});\n\t\t\treturn arr;\n\t\t},\n\t\t_each: function(callback) {\n\t\t\tfor (var i = 0, len = this._length; i < len; i++) {\n\t\t\t\tcallback(this[i], i);\n\t\t\t}\n\t\t},\n\t\tsplice: function(index, howMany) {\n\t\t\tvar args = canReflect.toArray(arguments),\n\t\t\t\tadded = [],\n\t\t\t\ti, len, listIndex,\n\t\t\t\tallSame = args.length > 2,\n\t\t\t\toldLength = this._length;\n\n\t\t\tindex = index || 0;\n\n\t\t\t// converting the arguments to the right type\n\t\t\tfor (i = 0, len = args.length - 2; i < len; i++) {\n\t\t\t\tlistIndex = i + 2;\n\t\t\t\targs[listIndex] = this.__type(args[listIndex], listIndex);\n\t\t\t\tadded.push(args[listIndex]);\n\n\t\t\t\t// Now lets check if anything will change\n\t\t\t\tif (this[i + index] !== args[listIndex]) {\n\t\t\t\t\tallSame = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if nothing has changed, then return\n\t\t\tif (allSame && this._length <= added.length) {\n\t\t\t\treturn added;\n\t\t\t}\n\n\t\t\t// default howMany if not provided\n\t\t\tif (howMany === undefined) {\n\t\t\t\thowMany = args[1] = this._length - index;\n\t\t\t}\n\n\t\t\trunningNative = true;\n\t\t\tvar removed = splice.apply(this, args);\n\t\t\trunningNative = false;\n\n\t\t\tqueues.batch.start();\n\t\t\tif (howMany > 0) {\n\t\t\t\t// tears down bubbling\n\t\t\t\tthis._triggerChange(\"\" + index, \"remove\", undefined, removed);\n\t\t\t}\n\t\t\tif (args.length > 2) {\n\t\t\t\tthis._triggerChange(\"\" + index, \"add\", added, removed);\n\t\t\t}\n\n\t\t\tthis.dispatch('length', [ this._length, oldLength ]);\n\n\t\t\tqueues.batch.stop();\n\t\t\treturn removed;\n\t\t},\n\n\t\t/**\n\t\t */\n\t\tserialize: function() {\n\t\t\treturn canReflect.serialize(this, Map);\n\t\t}\n\t}\n);\n\nfor(var prop in define.eventsProto) {\n\tObject.defineProperty(DefineList.prototype, prop, {\n\t\tenumerable:false,\n\t\tvalue: define.eventsProto[prop],\n\t\twritable: true\n\t});\n}\n\nvar eventsProtoSymbols = (\"getOwnPropertySymbols\" in Object) ?\n  Object.getOwnPropertySymbols(define.eventsProto) :\n  [canSymbol.for(\"can.onKeyValue\"), canSymbol.for(\"can.offKeyValue\")];\n\neventsProtoSymbols.forEach(function(sym) {\n  Object.defineProperty(DefineList.prototype, sym, {\n  \tconfigurable: true,\n    enumerable:false,\n    value: define.eventsProto[sym],\n    writable: true\n  });\n});\n\n// Converts to an `array` of arguments.\nvar getArgs = function(args) {\n\treturn args[0] && Array.isArray(args[0]) ?\n\t\targs[0] :\n\t\tcanReflect.toArray(args);\n};\n// Create `push`, `pop`, `shift`, and `unshift`\ncanReflect.eachKey({\n\tpush: \"length\",\n\tunshift: 0\n},\n\t// Adds a method\n\t// `name` - The method name.\n\t// `where` - Where items in the `array` should be added.\n\tfunction(where, name) {\n\t\tvar orig = [][name];\n\t\tDefineList.prototype[name] = function() {\n\t\t\t// Get the items being added.\n\t\t\tvar args = [],\n\t\t\t\t// Where we are going to add items.\n\t\t\t\tlen = where ? this._length : 0,\n\t\t\t\ti = arguments.length,\n\t\t\t\tres, val;\n\n\t\t\t// Go through and convert anything to a `map` that needs to be converted.\n\t\t\twhile (i--) {\n\t\t\t\tval = arguments[i];\n\t\t\t\targs[i] = this.__type(val, i);\n\t\t\t}\n\n\t\t\t// Call the original method.\n\t\t\trunningNative = true;\n\t\t\tres = orig.apply(this, args);\n\t\t\trunningNative = false;\n\n\t\t\tif (!this.comparator || args.length) {\n\t\t\t\tqueues.batch.start();\n\t\t\t\tthis._triggerChange(\"\" + len, \"add\", args, undefined);\n\t\t\t\tthis.dispatch('length', [ this._length, len ]);\n\t\t\t\tqueues.batch.stop();\n\t\t\t}\n\n\t\t\treturn res;\n\t\t};\n\t});\n\ncanReflect.eachKey({\n\tpop: \"length\",\n\tshift: 0\n},\n\t// Creates a `remove` type method\n\tfunction(where, name) {\n\t\tvar orig = [][name];\n\t\tDefineList.prototype[name] = function() {\n\t\t\tif (!this._length) {\n\t\t\t\t// For shift and pop, we just return undefined without\n\t\t\t\t// triggering events.\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tvar args = getArgs(arguments),\n\t\t\t\tlen = where && this._length ? this._length - 1 : 0,\n\t\t\t\toldLength = this._length ? this._length : 0,\n\t\t\t\tres;\n\n\t\t\t// Call the original method.\n\t\t\trunningNative = true;\n\t\t\tres = orig.apply(this, args);\n\t\t\trunningNative = false;\n\n\t\t\t// Create a change where the args are\n\t\t\t// `len` - Where these items were removed.\n\t\t\t// `remove` - Items removed.\n\t\t\t// `undefined` - The new values (there are none).\n\t\t\t// `res` - The old, removed values (should these be unbound).\n\t\t\tqueues.batch.start();\n\t\t\tthis._triggerChange(\"\" + len, \"remove\", undefined, [ res ]);\n\t\t\tthis.dispatch('length', [ this._length, oldLength ]);\n\t\t\tqueues.batch.stop();\n\n\t\t\treturn res;\n\t\t};\n\t});\n\ncanReflect.eachKey({\n\t\"map\": 3,\n\t\"filter\": 3,\n\t\"reduce\": 4,\n\t\"reduceRight\": 4,\n\t\"every\": 3,\n\t\"some\": 3\n},\nfunction a(fnLength, fnName) {\n\tDefineList.prototype[fnName] = function() {\n\t\tvar self = this;\n\t\tvar args = [].slice.call(arguments, 0);\n\t\tvar callback = args[0];\n\t\tvar thisArg = args[fnLength - 1] || self;\n\n\t\tif (typeof callback === \"object\") {\n\t\t\tcallback = makeFilterCallback(callback);\n\t\t}\n\n\t\targs[0] = function() {\n\t\t\tvar cbArgs = [].slice.call(arguments, 0);\n\t\t\t// use .get(index) to ensure observation added.\n\t\t\t// the arguments are (item, index) or (result, item, index)\n\t\t\tcbArgs[fnLength - 3] = self.get(cbArgs[fnLength - 2]);\n\t\t\treturn callback.apply(thisArg, cbArgs);\n\t\t};\n\t\tvar ret = Array.prototype[fnName].apply(this, args);\n\n\t\tif(fnName === \"map\") {\n\t\t\treturn new DefineList(ret);\n\t\t}\n\t\telse if(fnName === \"filter\") {\n\t\t\treturn new self.constructor(ret);\n\t\t} else {\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\nassign(DefineList.prototype, {\n\tindexOf: function(item, fromIndex) {\n\t\tfor (var i = fromIndex || 0, len = this.length; i < len; i++) {\n\t\t\tif (this.get(i) === item) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\tlastIndexOf: function(item, fromIndex) {\n\t\tfromIndex = typeof fromIndex === \"undefined\" ? this.length - 1: fromIndex;\n\t\tfor (var i = fromIndex; i >= 0; i--) {\n\t\t\tif (this.get(i) === item) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\tjoin: function() {\n\t\tObservationRecorder.add(this, \"length\");\n\t\treturn [].join.apply(this, arguments);\n\t},\n\treverse: function() {\n\t\t// this shouldn't be observable\n\t\tvar list = [].reverse.call(this._items());\n\t\treturn this.replace(list);\n\t},\n\tslice: function() {\n\t\t// tells computes to listen on length for changes.\n\t\tObservationRecorder.add(this, \"length\");\n\t\tvar temp = Array.prototype.slice.apply(this, arguments);\n\t\treturn new this.constructor(temp);\n\t},\n\tconcat: function() {\n\t\tvar args = [];\n\t\t// Go through each of the passed `arguments` and\n\t\t// see if it is list-like, an array, or something else\n\t\tcanReflect.eachIndex(arguments, function(arg) {\n\t\t\tif (canReflect.isListLike(arg)) {\n\t\t\t\t// If it is list-like we want convert to a JS array then\n\t\t\t\t// pass each item of the array to this.__type\n\t\t\t\tvar arr = Array.isArray(arg) ? arg : canReflect.toArray(arg);\n\t\t\t\tarr.forEach(function(innerArg) {\n\t\t\t\t\targs.push(this.__type(innerArg));\n\t\t\t\t}, this);\n\t\t\t} else {\n\t\t\t\t// If it is a Map, Object, or some primitive\n\t\t\t\t// just pass arg to this.__type\n\t\t\t\targs.push(this.__type(arg));\n\t\t\t}\n\t\t}, this);\n\n\t\t// We will want to make `this` list into a JS array\n\t\t// as well (We know it should be list-like), then\n\t\t// concat with our passed in args, then pass it to\n\t\t// list constructor to make it back into a list\n\t\treturn new this.constructor(Array.prototype.concat.apply(canReflect.toArray(this), args));\n\t},\n\tforEach: function(cb, thisarg) {\n\t\tvar item;\n\t\tfor (var i = 0, len = this.length; i < len; i++) {\n\t\t\titem = this.get(i);\n\t\t\tif (cb.call(thisarg || item, item, i, this) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\treplace: function(newList) {\n\t\tvar patches = diff(this, newList);\n\n\t\tqueues.batch.start();\n\t\tfor (var i = 0, len = patches.length; i < len; i++) {\n\t\t\tthis.splice.apply(this, [\n\t\t\t\tpatches[i].index,\n\t\t\t\tpatches[i].deleteCount\n\t\t\t].concat(patches[i].insert));\n\t\t}\n\t\tqueues.batch.stop();\n\n\t\treturn this;\n\t},\n\tsort: function(compareFunction) {\n\t\tvar sorting = Array.prototype.slice.call(this);\n\t\tArray.prototype.sort.call(sorting, compareFunction);\n\t\tthis.splice.apply(this, [0,sorting.length].concat(sorting) );\n\t\treturn this;\n\t}\n});\n\n// Add necessary event methods to this object.\nfor (var prop in define.eventsProto) {\n\tDefineList[prop] = define.eventsProto[prop];\n\tObject.defineProperty(DefineList.prototype, prop, {\n\t\tenumerable: false,\n\t\tvalue: define.eventsProto[prop],\n\t\twritable: true\n\t});\n}\n\nObject.defineProperty(DefineList.prototype, \"length\", {\n\tget: function() {\n\t\tif (!this.__inSetup) {\n\t\t\tObservationRecorder.add(this, \"length\");\n\t\t}\n\t\treturn this._length;\n\t},\n\tset: function(newVal) {\n\t\tif (runningNative) {\n\t\t\tthis._length = newVal;\n\t\t\treturn;\n\t\t}\n\n\t\t// Don't set _length if:\n\t\t//  - null or undefined\n\t\t//  - a string that doesn't convert to number\n\t\t//  - already the length being set\n\t\tif (newVal == null || isNaN(+newVal) || newVal === this._length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (newVal > this._length - 1) {\n\t\t\tvar newArr = new Array(newVal - this._length);\n\t\t\tthis.push.apply(this, newArr);\n\t\t}\n\t\telse {\n\t\t\tthis.splice(newVal);\n\t\t}\n\t},\n\tenumerable: true\n});\n\nDefineList.prototype.attr = function(prop, value) {\n\tcanLog.warn(\"DefineMap::attr shouldn't be called\");\n\tif (arguments.length === 0) {\n\t\treturn this.get();\n\t} else if (prop && typeof prop === \"object\") {\n\t\treturn this.set.apply(this, arguments);\n\t} else if (arguments.length === 1) {\n\t\treturn this.get(prop);\n\t} else {\n\t\treturn this.set(prop, value);\n\t}\n};\nDefineList.prototype.item = function(index, value) {\n\tif (arguments.length === 1) {\n\t\treturn this.get(index);\n\t} else {\n\t\treturn this.set(index, value);\n\t}\n};\nDefineList.prototype.items = function() {\n\tcanLog.warn(\"DefineList::get should should be used instead of DefineList::items\");\n\treturn this.get();\n};\n\nvar defineListProto = {\n\t// type\n\t\"can.isMoreListLikeThanMapLike\": true,\n\t\"can.isMapLike\": true,\n\t\"can.isListLike\": true,\n\t\"can.isValueLike\": false,\n\t// get/set\n\t\"can.getKeyValue\": DefineList.prototype.get,\n\t\"can.setKeyValue\": DefineList.prototype.set,\n\n\t// Called for every reference to a property in a template\n\t// if a key is a numerical index then translate to length event\n\t\"can.onKeyValue\": function(key, handler, queue) {\n\t\tvar translationHandler;\n\t\tif (isNaN(key)) {\n\t\t\treturn onKeyValue.apply(this, arguments);\n\t\t}\n\t\telse {\n\t\t\ttranslationHandler = function() {\n\t\t\t\thandler(this[key]);\n\t\t\t};\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tObject.defineProperty(translationHandler, \"name\", {\n\t\t\t\t\tvalue: \"translationHandler(\" + key + \")::\" + canReflect.getName(this) + \".onKeyValue('length',\" + canReflect.getName(handler) + \")\",\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tsingleReference.set(handler, this, translationHandler, key);\n\t\t\treturn onKeyValue.call(this, 'length',  translationHandler, queue);\n\t\t}\n\t},\n\t// Called when a property reference is removed\n\t\"can.offKeyValue\": function(key, handler, queue) {\n\t\tvar translationHandler;\n\t\tif ( isNaN(key)) {\n\t\t\treturn offKeyValue.apply(this, arguments);\n\t\t}\n\t\telse {\n\t\t\ttranslationHandler = singleReference.getAndDelete(handler, this, key);\n\t\t\treturn offKeyValue.call(this, 'length',  translationHandler, queue);\n\t\t}\n\t},\n\n\t\"can.deleteKeyValue\": function(prop) {\n\t\t// convert string key to number index if key can be an integer:\n\t\t//   isNaN if prop isn't a numeric representation\n\t\t//   (prop % 1) if numeric representation is a float\n\t\t//   In both of the above cases, leave as string.\n\t\tprop = isNaN(+prop) || (prop % 1) ? prop : +prop;\n\t\tif(typeof prop === \"number\") {\n\t\t\tthis.splice(prop, 1);\n\t\t} else if(prop === \"length\" || prop === \"_length\") {\n\t\t\treturn; // length must not be deleted\n\t\t} else {\n\t\t\tthis.set(prop, undefined);\n\t\t}\n\t\treturn this;\n\t},\n\t// shape get/set\n\t\"can.assignDeep\": function(source){\n\t\tqueues.batch.start();\n\t\tcanReflect.assignList(this, source);\n\t\tqueues.batch.stop();\n\t},\n\t\"can.updateDeep\": function(source){\n\t\tqueues.batch.start();\n\t\tthis.replace(source);\n\t\tqueues.batch.stop();\n\t},\n\n\t// observability\n\t\"can.keyHasDependencies\": function(key) {\n\t\treturn !!(this._computed && this._computed[key] && this._computed[key].compute);\n\t},\n\t\"can.getKeyDependencies\": function(key) {\n\t\tvar ret;\n\t\tif(this._computed && this._computed[key] && this._computed[key].compute) {\n\t\t\tret = {};\n\t\t\tret.valueDependencies = new Set();\n\t\t\tret.valueDependencies.add(this._computed[key].compute);\n\t\t}\n\t\treturn ret;\n\t},\n\t/*\"can.onKeysAdded\": function(handler,queue) {\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](\"add\", handler,queue);\n\t},\n\t\"can.onKeysRemoved\": function(handler,queue) {\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](\"remove\", handler,queue);\n\t},*/\n\t\"can.splice\": function(index, deleteCount, insert){\n\t\tthis.splice.apply(this, [index, deleteCount].concat(insert));\n\t},\n\t\"can.onPatches\": function(handler,queue){\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](localOnPatchesSymbol, handler,queue);\n\t},\n\t\"can.offPatches\": function(handler,queue) {\n\t\tthis[canSymbol.for(\"can.offKeyValue\")](localOnPatchesSymbol, handler,queue);\n\t}\n};\n\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\tdefineListProto[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"[]\";\n\t};\n}\n//!steal-remove-end\n\ncanReflect.assignSymbols(DefineList.prototype, defineListProto);\n\ncanReflect.setKeyValue(DefineList.prototype, canSymbol.iterator, function() {\n\tvar index = -1;\n\tif(typeof this.length !== \"number\") {\n\t\tthis.length = 0;\n\t}\n\treturn {\n\t\tnext: function() {\n\t\t\tindex++;\n\t\t\treturn {\n\t\t\t\tvalue: this[index],\n\t\t\t\tdone: index >= this.length\n\t\t\t};\n\t\t}.bind(this)\n\t};\n});\n\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\t// call `list.log()` to log all event changes\n\t// pass `key` to only log the matching event, e.g: `list.log(\"add\")`\n\tDefineList.prototype.log = defineHelpers.log;\n}\n//!steal-remove-end\n\ndefine.DefineList = DefineList;\n\nmodule.exports = ns.DefineList = DefineList;\n"],"names":["make","define","splice","runningNative","identity","x","localOnPatchesSymbol","makeFilterCallback","props","item","prop","onKeyValue","eventsProto","canSymbol","for","offKeyValue","getSchemaSymbol","getSchema","definitions","this","prototype","_define","schema","type","keys","updateSchemaKeys","values","Type","DefineList","Construct","extend","setup","base","addTypeEvents","result","makeDefineInstanceKey","itemsDefinition","defaultDefinition","__type","set","items","Object","defineProperty","enumerable","value","length","_length","call","configurable","writable","apply","concat","canReflect","toArray","types","observable","_triggerChange","attr","how","newVal","oldVal","index","isNaN","dispatch","target","dispatched","added","ObservationRecorder","ignore","patches","insert","deleteCount","process","env","NODE_ENV","reasonLog","getName","removed","get","arguments","add","unwrap","Map","newArr","Array","push","defineHelpers","defineExpando","canLogDev","warn","isListLike","replace","assignList","assignMap","assign","update","updateList","updateMap","assignDeep","assignDeepList","assignDeepMap","updateDeep","updateDeepList","updateDeepMap","_items","arr","_each","callback","i","len","howMany","listIndex","args","allSame","oldLength","undefined","queues","batch","start","stop","serialize","eventsProtoSymbols","getOwnPropertySymbols","forEach","sym","getArgs","isArray","eachKey","unshift","where","name","orig","res","val","comparator","pop","shift","map","filter","reduce","reduceRight","every","some","fnLength","fnName","self","slice","thisArg","cbArgs","ret","constructor","indexOf","fromIndex","lastIndexOf","join","reverse","list","temp","eachIndex","arg","innerArg","cb","thisarg","newList","diff","sort","compareFunction","sorting","__inSetup","canLog","defineListProto","can.isMoreListLikeThanMapLike","can.isMapLike","can.isListLike","can.isValueLike","can.getKeyValue","can.setKeyValue","can.onKeyValue","key","handler","queue","translationHandler","singleReference","can.offKeyValue","getAndDelete","can.deleteKeyValue","can.assignDeep","source","can.updateDeep","can.keyHasDependencies","_computed","compute","can.getKeyDependencies","valueDependencies","Set","can.splice","can.onPatches","can.offPatches","assignSymbols","setKeyValue","iterator","next","done","bind","log","ns"],"mappings":"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"}