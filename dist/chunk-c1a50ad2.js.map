{"version":3,"file":"chunk-c1a50ad2.js","sources":["../node_modules/can-dom-data-state/can-dom-data-state.js","../node_modules/can-attribute-observable/behaviors.js"],"sourcesContent":["'use strict';\nvar namespace = require('can-namespace');\nvar domMutate = require('can-dom-mutate');\nvar CID = require(\"can-cid\");\n\nvar isEmptyObject = function(obj){\n\t/* jshint -W098 */\n\tfor(var prop in obj) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\nvar data = {};\nvar removedDisposalMap = {};\n\n// delete this node's `data`\n// returns true if the node was deleted.\nvar deleteNode = function() {\n\tvar id = CID.get(this);\n\tvar nodeDeleted = false;\n\tif(id && data[id]) {\n\t\tnodeDeleted = true;\n\t\tdelete data[id];\n\t}\n\tif (removedDisposalMap[id]) {\n\t\tremovedDisposalMap[id]();\n\t\tdelete removedDisposalMap[id];\n\t}\n\treturn nodeDeleted;\n};\n\nvar setData = function(name, value) {\n\tvar id = CID(this);\n\tvar store = data[id] || (data[id] = {});\n\tif (name !== undefined) {\n\t\tstore[name] = value;\n\t\tvar isNode = !!(this && typeof this.nodeType === 'number');\n\t\tif (isNode && !removedDisposalMap[id]) {\n\t\t\tvar target = this;\n\t\t\tremovedDisposalMap[id] = domMutate.onNodeRemoval(target, function () {\n\t\t\t\tif (!target.ownerDocument.contains(target)) {\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tdeleteNode.call(target);\n\t\t\t\t\t}, 13);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\treturn store;\n};\n\n/*\n * Core of domData that does not depend on mutationDocument\n * This is separated in order to prevent circular dependencies\n */\nvar domDataState = {\n\t_data: data,\n\t_removalDisposalMap: removedDisposalMap,\n\n\tgetCid: function() {\n\t\t// TODO log warning! to use can-cid directly\n\t\treturn CID.get(this);\n\t},\n\n\tcid: function(){\n\t\t// TODO log warning!\n\t\treturn CID(this);\n\t},\n\n\texpando: CID.domExpando,\n\n\tget: function(key) {\n\t\tvar id = CID.get(this),\n\t\t\tstore = id && data[id];\n\t\treturn key === undefined ? store : store && store[key];\n\t},\n\n\tset: setData,\n\n\tclean: function(prop) {\n\t\tvar id = CID.get(this);\n\t\tvar itemData = data[id];\n\t\tif (itemData && itemData[prop]) {\n\t\t\tdelete itemData[prop];\n\t\t}\n\t\tif(isEmptyObject(itemData)) {\n\t\t\tdeleteNode.call(this);\n\t\t}\n\t},\n\n\tdelete: deleteNode\n};\n\nif (namespace.domDataState) {\n\tthrow new Error(\"You can't have two versions of can-dom-data-state, check your dependencies\");\n} else {\n\tmodule.exports = namespace.domDataState = domDataState;\n}\n","'use strict';\n\nvar getDocument = require(\"can-globals/document/document\");\nvar global = require(\"can-globals/global/global\")();\nvar setData = require(\"can-dom-data-state\");\nvar domEvents = require(\"can-dom-events\");\nvar domMutate = require(\"can-dom-mutate\");\nvar domMutateNode = require(\"can-dom-mutate/node\");\nvar getMutationObserver = require(\"can-globals/mutation-observer/mutation-observer\");\nvar diff = require(\"can-diff/list/list\");\nvar queues = require(\"can-queues\");\n\nvar formElements = {\"INPUT\": true, \"TEXTAREA\": true, \"SELECT\": true},\n\t// Used to convert values to strings.\n\ttoString = function(value){\n\t\tif(value == null) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn \"\"+value;\n\t\t}\n\t},\n\tisSVG = function(el){\n\t\treturn el.namespaceURI === \"http://www.w3.org/2000/svg\";\n\t},\n\ttruthy = function() { return true; },\n\tgetSpecialTest = function(special){\n\t\treturn (special && special.test) || truthy;\n\t},\n\tpropProp = function(prop, obj){\n\t\tobj = obj || {};\n\t\tobj.get = function(){\n\t\t\treturn this[prop];\n\t\t};\n\t\tobj.set = function(value){\n\t\t\tif(this[prop] !== value) {\n\t\t\t\tthis[prop] = value;\n\t\t\t}\n\t\t};\n\t\treturn obj;\n\t},\n\tbooleanProp = function(prop){\n\t\treturn {\n\t\t\tisBoolean: true,\n\t\t\tset: function(value){\n\t\t\t\tif(prop in this) {\n\t\t\t\t\tthis[prop] = value;\n\t\t\t\t} else {\n\t\t\t\t\tdomMutateNode.setAttribute.call(this, prop, \"\");\n\t\t\t\t}\n\t\t\t},\n\t\t\tremove: function(){\n\t\t\t\tthis[prop] = false;\n\t\t\t}\n\t\t};\n\t},\n\tsetupMO = function(el, callback){\n\t\tvar attrMO = setData.get.call(el, \"attrMO\");\n\t\tif(!attrMO) {\n\t\t\tvar onMutation = function(){\n\t\t\t\tcallback.call(el);\n\t\t\t};\n\t\t\tvar MO = getMutationObserver();\n\t\t\tif(MO) {\n\t\t\t\tvar observer = new MO(onMutation);\n\t\t\t\tobserver.observe(el, {\n\t\t\t\t\tchildList: true,\n\t\t\t\t\tsubtree: true\n\t\t\t\t});\n\t\t\t\tsetData.set.call(el, \"attrMO\", observer);\n\t\t\t} else {\n\t\t\t\tsetData.set.call(el, \"attrMO\", true);\n\t\t\t\tsetData.set.call(el, \"canBindingCallback\", {onMutation: onMutation});\n\t\t\t}\n\t\t}\n\t},\n\t_findOptionToSelect = function (parent, value) {\n\t\tvar child = parent.firstChild;\n\t\twhile (child) {\n\t\t\tif (child.nodeName === \"OPTION\" && value === child.value) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t\tif (child.nodeName === \"OPTGROUP\") {\n\t\t\t\tvar groupChild = _findOptionToSelect(child, value);\n\t\t\t\tif (groupChild) {\n\t\t\t\t\treturn groupChild;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t},\n\tsetChildOptions = function(el, value){\n\t\tvar option;\n\t\tif (value != null) {\n\t\t\toption = _findOptionToSelect(el, value);\n\t\t}\n\t\tif (option) {\n\t\t\toption.selected = true;\n\t\t} else {\n\t\t\tel.selectedIndex = -1;\n\t\t}\n\t},\n\tforEachOption = function (parent, fn) {\n\t\tvar child = parent.firstChild;\n\t\twhile (child) {\n\t\t\tif (child.nodeName === \"OPTION\") {\n\t\t\t\tfn(child);\n\t\t\t}\n\t\t\tif (child.nodeName === \"OPTGROUP\") {\n\t\t\t\tforEachOption(child, fn);\n\t\t\t}\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t},\n\tcollectSelectedOptions = function (parent) {\n\t\tvar selectedValues = [];\n\t\tforEachOption(parent, function (option) {\n\t\t\tif (option.selected) {\n\t\t\t\tselectedValues.push(option.value);\n\t\t\t}\n\t\t});\n\t\treturn selectedValues;\n\t},\n\tmarkSelectedOptions = function (parent, values) {\n\t\tforEachOption(parent, function (option) {\n\t\t\toption.selected = values.indexOf(option.value) !== -1;\n\t\t});\n\t},\n\t// Create a handler, only once, that will set the child options any time\n\t// the select's value changes.\n\tsetChildOptionsOnChange = function(select, aEL){\n\t\tvar handler = setData.get.call(select, \"attrSetChildOptions\");\n\t\tif(handler) {\n\t\t\treturn Function.prototype;\n\t\t}\n\t\thandler = function(){\n\t\t\tsetChildOptions(select, select.value);\n\t\t};\n\t\tsetData.set.call(select, \"attrSetChildOptions\", handler);\n\t\taEL.call(select, \"change\", handler);\n\t\treturn function(rEL){\n\t\t\tsetData.clean.call(select, \"attrSetChildOptions\");\n\t\t\trEL.call(select, \"change\", handler);\n\t\t};\n\t},\n\t// cache of rules already calculated by `attr.getRule`\n\tbehaviorRules = new Map(),\n\t// # isPropWritable\n\t// check if a property is writable on an element by finding its property descriptor\n\t// on the element or its prototype chain\n\tisPropWritable = function(el, prop) {\n\t\t   var desc = Object.getOwnPropertyDescriptor(el, prop);\n\n\t\t   if (desc) {\n\t\t\t\t   return desc.writable || desc.set;\n\t\t   } else {\n\t\t\t\t   var proto = Object.getPrototypeOf(el);\n\t\t\t\t   if (proto) {\n\t\t\t\t\t\t   return isPropWritable(proto, prop);\n\t\t\t\t   }\n\t\t   }\n\n\t\t   return false;\n\t},\n\t// # cacheRule\n\t// add a rule to the rules Map so it does not need to be calculated more than once\n\tcacheRule = function(el, attrOrPropName, rule) {\n\t\t   var rulesForElementType;\n\n\t\t   rulesForElementType = behaviorRules.get(el.prototype);\n\n\t\t   if (!rulesForElementType) {\n\t\t\t\t   rulesForElementType = {};\n\t\t\t\t   behaviorRules.set(el.constructor, rulesForElementType);\n\t\t   }\n\n\t\t   rulesForElementType[attrOrPropName] = rule;\n\n\t\t   return rule;\n\t};\n\nvar specialAttributes = {\n\tchecked: {\n\t\tget: function(){\n\t\t\treturn this.checked;\n\t\t},\n\t\tset: function(val){\n\t\t\t// - `set( truthy )` => TRUE\n\t\t\t// - `set( \"\" )`     => TRUE\n\t\t\t// - `set()`         => TRUE\n\t\t\t// - `set(undefined)` => false.\n\t\t\tvar notFalse = !!val || val === \"\" || arguments.length === 0;\n\t\t\tthis.checked = notFalse;\n\t\t\tif(notFalse && this.type === \"radio\") {\n\t\t\t\tthis.defaultChecked = true;\n\t\t\t}\n\t\t},\n\t\tremove: function(){\n\t\t\tthis.checked = false;\n\t\t},\n\t\ttest: function(){\n\t\t\treturn this.nodeName === \"INPUT\";\n\t\t}\n\t},\n\t\"class\": {\n\t\tget: function(){\n\t\t\tif(isSVG(this)) {\n\t\t\t\treturn this.getAttribute(\"class\");\n\t\t\t}\n\t\t\treturn this.className;\n\t\t},\n\t\tset: function(val){\n\t\t\tval = val || \"\";\n\n\t\t\tif(isSVG(this)) {\n\t\t\t\tdomMutateNode.setAttribute.call(this, \"class\", \"\" + val);\n\t\t\t} else {\n\t\t\t\tthis.className = val;\n\t\t\t}\n\t\t}\n\t},\n\tdisabled: booleanProp(\"disabled\"),\n\tfocused: {\n\t\tget: function(){\n\t\t\treturn this === document.activeElement;\n\t\t},\n\t\tset: function(val){\n\t\t\tvar cur = attr.get(this, \"focused\");\n\t\t\tvar docEl = this.ownerDocument.documentElement;\n\t\t\tvar element = this;\n\t\t\tfunction focusTask() {\n\t\t\t\tif (val) {\n\t\t\t\t\telement.focus();\n\t\t\t\t} else {\n\t\t\t\t\telement.blur();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cur !== val) {\n\t\t\t\tif (!docEl.contains(element)) {\n\t\t\t\t\tvar insertionDisposal = domMutate.onNodeInsertion(element, function () {\n\t\t\t\t\t\tinsertionDisposal();\n\t\t\t\t\t\tfocusTask();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// THIS MIGHT NEED TO BE PUT IN THE MUTATE QUEUE\n\t\t\t\t\tqueues.enqueueByQueue({\n\t\t\t\t\t\tmutate: [focusTask]\n\t\t\t\t\t}, null, []);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\taEL.call(this, \"focus\", handler);\n\t\t\taEL.call(this, \"blur\", handler);\n\t\t\treturn function(rEL){\n\t\t\t\trEL.call(this, \"focus\", handler);\n\t\t\t\trEL.call(this, \"blur\", handler);\n\t\t\t};\n\t\t},\n\t\ttest: function(){\n\t\t\treturn this.nodeName === \"INPUT\";\n\t\t}\n\t},\n\t\"for\": propProp(\"htmlFor\"),\n\tinnertext: propProp(\"innerText\"),\n\tinnerhtml: propProp(\"innerHTML\"),\n\tinnerHTML: propProp(\"innerHTML\", {\n\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\tvar handlers = [];\n\t\t\tvar el = this;\n\t\t\t[\"change\", \"blur\"].forEach(function(eventName){\n\t\t\t\tvar localHandler = function(){\n\t\t\t\t\thandler.apply(this, arguments);\n\t\t\t\t};\n\t\t\t\tdomEvents.addEventListener(el, eventName, localHandler);\n\t\t\t\thandlers.push([eventName, localHandler]);\n\t\t\t});\n\n\t\t\treturn function(rEL){\n\t\t\t\thandlers.forEach( function(info){\n\t\t\t\t\trEL.call(el, info[0], info[1]);\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\t}),\n\trequired: booleanProp(\"required\"),\n\treadonly: booleanProp(\"readOnly\"),\n\tselected: {\n\t\tget: function(){\n\t\t\treturn this.selected;\n\t\t},\n\t\tset: function(val){\n\t\t\tval = !!val;\n\t\t\tsetData.set.call(this, \"lastSetValue\", val);\n\t\t\tthis.selected = val;\n\t\t},\n\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\tvar option = this;\n\t\t\tvar select = this.parentNode;\n\t\t\tvar lastVal = option.selected;\n\t\t\tvar localHandler = function(changeEvent){\n\t\t\t\tvar curVal = option.selected;\n\t\t\t\tlastVal = setData.get.call(option, \"lastSetValue\") || lastVal;\n\t\t\t\tif(curVal !== lastVal) {\n\t\t\t\t\tlastVal = curVal;\n\n\t\t\t\t\tdomEvents.dispatch(option, eventName);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar removeChangeHandler = setChildOptionsOnChange(select, aEL);\n\t\t\tdomEvents.addEventListener(select, \"change\", localHandler);\n\t\t\taEL.call(option, eventName, handler);\n\n\t\t\treturn function(rEL){\n\t\t\t\tremoveChangeHandler(rEL);\n\t\t\t\tdomEvents.removeEventListener(select, \"change\", localHandler);\n\t\t\t\trEL.call(option, eventName, handler);\n\t\t\t};\n\t\t},\n\t\ttest: function(){\n\t\t\treturn this.nodeName === \"OPTION\" && this.parentNode &&\n\t\t\t\tthis.parentNode.nodeName === \"SELECT\";\n\t\t}\n\t},\n\tstyle: {\n\t\tset: (function () {\n\t\t\tvar el = global.document && getDocument().createElement(\"div\");\n\t\t\tif ( el && el.style && (\"cssText\" in el.style) ) {\n\t\t\t\treturn function (val) {\n\t\t\t\t\tthis.style.cssText = (val || \"\");\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn function (val) {\n\t\t\t\t\tdomMutateNode.setAttribute.call(this, \"style\", val);\n\t\t\t\t};\n\t\t\t}\n\t\t})()\n\t},\n\ttextcontent: propProp(\"textContent\"),\n\tvalue: {\n\t\tget: function(){\n\t\t\tvar value = this.value;\n\t\t\tif(this.nodeName === \"SELECT\") {\n\t\t\t\tif((\"selectedIndex\" in this) && this.selectedIndex === -1) {\n\t\t\t\t\tvalue = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\tset: function(value){\n\t\t\tvar nodeName = this.nodeName.toLowerCase();\n\t\t\tif(nodeName === \"input\") {\n\t\t\t\t// Do some input types support non string values?\n\t\t\t\tvalue = toString(value);\n\t\t\t}\n\t\t\tif(this.value !== value || nodeName === \"option\") {\n\t\t\t\tthis.value = value;\n\t\t\t}\n\t\t\tif (nodeName === \"input\" || nodeName === \"textarea\") {\n\t\t\t\tthis.defaultValue = value;\n\t\t\t}\n\t\t\tif(nodeName === \"select\") {\n\t\t\t\tsetData.set.call(this, \"attrValueLastVal\", value);\n\t\t\t\t//If it's null then special case\n\t\t\t\tsetChildOptions(this, value === null ? value : this.value);\n\n\t\t\t\t// If not in the document reset the value when inserted.\n\t\t\t\tvar docEl = this.ownerDocument.documentElement;\n\t\t\t\tif(!docEl.contains(this)) {\n\t\t\t\t\tvar select = this;\n\t\t\t\t\tvar insertionDisposal = domMutate.onNodeInsertion(select, function () {\n\t\t\t\t\t\tinsertionDisposal();\n\t\t\t\t\t\tsetChildOptions(select, value === null ? value : select.value);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// MO handler is only set up **ONCE**\n\t\t\t\tsetupMO(this, function(){\n\t\t\t\t\tvar value = setData.get.call(this, \"attrValueLastVal\");\n\t\t\t\t\tattr.set(this, \"value\", value);\n\t\t\t\t\tdomEvents.dispatch(this, \"change\");\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\ttest: function(){\n\t\t\treturn formElements[this.nodeName];\n\t\t}\n\t},\n\tvalues: {\n\t\tget: function(){\n\t\t\treturn collectSelectedOptions(this);\n\t\t},\n\t\tset: function(values){\n\t\t\tvalues = values || [];\n\n\t\t\t// set new DOM state\n\t\t\tmarkSelectedOptions(this, values);\n\n\t\t\t// store new DOM state\n\t\t\tsetData.set.call(this, \"stickyValues\", attr.get(this,\"values\") );\n\n\t\t\t// MO handler is only set up **ONCE**\n\t\t\t// TODO: should this be moved into addEventListener?\n\t\t\tsetupMO(this, function(){\n\n\t\t\t\t// Get the previous sticky state\n\t\t\t\tvar previousValues = setData.get.call(this,\n\t\t\t\t\t\"stickyValues\");\n\n\t\t\t\t// Set DOM to previous sticky state\n\t\t\t\tattr.set(this, \"values\", previousValues);\n\n\t\t\t\t// Get the new result after trying to maintain the sticky state\n\t\t\t\tvar currentValues = setData.get.call(this,\n\t\t\t\t\t\"stickyValues\");\n\n\t\t\t\t// If there are changes, trigger a `values` event.\n\t\t\t\tvar changes = diff(previousValues.slice().sort(),\n\t\t\t\t\tcurrentValues.slice().sort());\n\n\t\t\t\tif (changes.length) {\n\t\t\t\t\tdomEvents.dispatch(this, \"values\");\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\taddEventListener: function(eventName, handler, aEL){\n\t\t\tvar localHandler = function(){\n\t\t\t\tdomEvents.dispatch(this, \"values\");\n\t\t\t};\n\n\t\t\tdomEvents.addEventListener(this, \"change\", localHandler);\n\t\t\taEL.call(this, eventName, handler);\n\n\t\t\treturn function(rEL){\n\t\t\t\tdomEvents.removeEventListener(this, \"change\", localHandler);\n\t\t\t\trEL.call(this, eventName, handler);\n\t\t\t};\n\t\t}\n\t}\n};\n\nvar attr = {\n\t// cached rules (stored on `attr` for testing purposes)\n\trules: behaviorRules,\n\n\t// special attribute behaviors (stored on `attr` for testing purposes)\n\tspecialAttributes: specialAttributes,\n\n\t// # attr.getRule\n\t//\n\t// get the behavior rule for an attribute or property on an element\n\t//\n\t// Rule precendence:\n\t//   1. \"special\" behaviors - use the special behavior getter/setter\n\t//   2. writable properties - read and write as a property\n\t//   3. all others - read and write as an attribute\n\t//\n\t// Once rule is determined it will be cached for all elements of the same type\n\t// so that it does not need to be calculated again\n\tgetRule: function(el, attrOrPropName) {\n\t\tvar special = specialAttributes[attrOrPropName];\n\t\t// always use \"special\" if available\n\t\t// these are not cached since they would have to be cached separately\n\t\t// for each element type and it is faster to just look up in the\n\t\t// specialAttributes object\n\t\tif (special) {\n\t\t\treturn special;\n\t\t}\n\n\t\t// next use rules cached in a previous call to getRule\n\t\tvar rulesForElementType = behaviorRules.get(el.constructor);\n\t\tvar cached = rulesForElementType && rulesForElementType[attrOrPropName];\n\n\t\tif (cached) {\n\t\t\treturn cached;\n\t\t}\n\n\t\t// if the element doesn't have a property of this name, it must be an attribute\n\t\tif (!(attrOrPropName in el)) {\n\t\t\treturn this.attribute(attrOrPropName);\n\t\t}\n\n\t\t// if there is a property, check if it is writable\n\t\tvar newRule = isPropWritable(el, attrOrPropName) ?\n\t\t\tthis.property(attrOrPropName) :\n\t\t\tthis.attribute(attrOrPropName);\n\n\t\t// cache the new rule and return it\n\t\treturn cacheRule(el, attrOrPropName, newRule);\n\t},\n\n\tattribute: function(attrName) {\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\treturn this.getAttribute(attrName);\n\t\t\t},\n\t\t\tset: function(val) {\n\t\t\t\tdomMutateNode.setAttribute.call(this, attrName, val);\n\t\t\t}\n\t\t};\n\t},\n\n\tproperty: function(propName) {\n\t\treturn {\n\t\t\tget: function() {\n\t\t\t\treturn this[propName];\n\t\t\t},\n\t\t\tset: function(val) {\n\t\t\t\tthis[propName] = val;\n\t\t\t}\n\t\t};\n\t},\n\n\tfindSpecialListener: function(attributeName) {\n\t\treturn specialAttributes[attributeName] && specialAttributes[attributeName].addEventListener;\n\t},\n\n\tsetAttrOrProp: function(el, attrName, val){\n\t\treturn this.set(el, attrName, val);\n\t},\n\t// ## attr.set\n\t// Set the value an attribute on an element.\n\tset: function (el, attrName, val) {\n\t\tvar rule = this.getRule(el, attrName);\n\t\tvar setter = rule && rule.set;\n\n\t\tif (setter) {\n\t\t\treturn setter.call(el, val);\n\t\t}\n\t},\n\t// ## attr.get\n\t// Gets the value of an attribute or property.\n\t// First checks if the property is an `specialAttributes` and if so calls the special getter.\n\t// Then checks if the attribute or property is a property on the element.\n\t// Otherwise uses `getAttribute` to retrieve the value.\n\tget: function (el, attrName) {\n\t\tvar rule = this.getRule(el, attrName);\n\t\tvar getter = rule && rule.get;\n\n\t\tif (getter) {\n\t\t\treturn rule.test ?\n\t\t\t\trule.test.call(el) && getter.call(el) :\n\t\t\t\tgetter.call(el);\n\t\t}\n\t},\n\t// ## attr.remove\n\t// Removes an attribute from an element. First checks specialAttributes to see if the attribute is special and has a setter. If so calls the setter with `undefined`. Otherwise `removeAttribute` is used.\n\t// If the attribute previously had a value and the browser doesn't support MutationObservers we then trigger an \"attributes\" event.\n\tremove: function (el, attrName) {\n\t\tattrName = attrName.toLowerCase();\n\t\tvar special = specialAttributes[attrName];\n\t\tvar setter = special && special.set;\n\t\tvar remover = special && special.remove;\n\t\tvar test = getSpecialTest(special);\n\n\t\tif(typeof remover === \"function\" && test.call(el)) {\n\t\t\tremover.call(el);\n\t\t} else if(typeof setter === \"function\" && test.call(el)) {\n\t\t\tsetter.call(el, undefined);\n\t\t} else {\n\t\t\tdomMutateNode.removeAttribute.call(el, attrName);\n\t\t}\n\t}\n};\n\nmodule.exports = attr;\n"],"names":["data","removedDisposalMap","deleteNode","id","CID","get","this","nodeDeleted","domDataState","_data","_removalDisposalMap","getCid","cid","expando","domExpando","key","store","undefined","set","name","value","nodeType","target","domMutate","onNodeRemoval","ownerDocument","contains","setTimeout","call","clean","prop","itemData","obj","isEmptyObject","delete","namespace","Error","module","global","require$$0","formElements","INPUT","TEXTAREA","SELECT","toString","isSVG","el","namespaceURI","truthy","getSpecialTest","special","test","propProp","booleanProp","isBoolean","domMutateNode","setAttribute","remove","setupMO","callback","setData","onMutation","MO","getMutationObserver","observer","observe","childList","subtree","_findOptionToSelect","parent","child","firstChild","nodeName","groupChild","nextSibling","setChildOptions","option","selected","selectedIndex","forEachOption","fn","collectSelectedOptions","selectedValues","push","markSelectedOptions","values","indexOf","setChildOptionsOnChange","select","aEL","handler","Function","prototype","rEL","behaviorRules","Map","isPropWritable","desc","Object","getOwnPropertyDescriptor","writable","proto","getPrototypeOf","cacheRule","attrOrPropName","rule","rulesForElementType","constructor","specialAttributes","checked","val","notFalse","arguments","length","type","defaultChecked","class","getAttribute","className","disabled","focused","document","activeElement","cur","attr","docEl","documentElement","element","focusTask","focus","blur","queues","enqueueByQueue","mutate","insertionDisposal","onNodeInsertion","addEventListener","eventName","for","innertext","innerhtml","innerHTML","handlers","forEach","localHandler","apply","domEvents","info","required","readonly","parentNode","lastVal","changeEvent","curVal","dispatch","removeChangeHandler","removeEventListener","style","getDocument","createElement","cssText","textcontent","toLowerCase","defaultValue","previousValues","currentValues","diff","slice","sort","rules","getRule","cached","attribute","newRule","property","attrName","propName","findSpecialListener","attributeName","setAttrOrProp","setter","getter","remover","removeAttribute"],"mappings":"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"}