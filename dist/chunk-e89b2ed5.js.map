{"version":3,"file":"chunk-e89b2ed5.js","sources":["../node_modules/can-local-store/can-local-store.js"],"sourcesContent":["var canReflect = require(\"can-reflect\");\nvar makeSimpleStore = require(\"can-memory-store/make-simple-store\");\nvar namespace = require(\"can-namespace\");\n\nmodule.exports = namespace.localStore = function localStore(baseConnection){\n    baseConnection.constructor = localStore;\n    var behavior = Object.create(makeSimpleStore(baseConnection));\n\n    canReflect.assignMap(behavior, {\n\t\tclear: function(){\n\t\t\tlocalStorage.removeItem(this.name+\"/queries\");\n\t\t\tlocalStorage.removeItem(this.name+\"/records\");\n            this._recordsMap = null;\n            return Promise.resolve();\n\t\t},\n\t\tupdateQueryDataSync: function(queries){\n\t\t\tlocalStorage.setItem(this.name+\"/queries\", JSON.stringify(queries) );\n\t\t},\n\t\tgetQueryDataSync: function(){\n\t\t\treturn JSON.parse( localStorage.getItem(this.name+\"/queries\") ) || [];\n\t\t},\n\n\t\tgetRecord: function(id){\n\t\t\t// a little side-effectual mischeif for performance\n\t\t\tif(!this._recordsMap) {\n\t\t\t\tthis.getAllRecords();\n\t\t\t}\n\n\t\t\treturn this._recordsMap[id];\n\t\t},\n\t\tgetAllRecords: function(){\n\t\t\t// this._records is a in memory representation so things can be fast\n            // Must turn on `cacheLocalStorageReads` for this to work.\n\t\t\tif(!this.cacheLocalStorageReads || !this._recordsMap) {\n\t\t\t\tvar recordsMap = JSON.parse( localStorage.getItem(this.name+\"/records\") ) || {};\n\t\t\t\tthis._recordsMap = recordsMap;\n\t\t\t}\n\n\t\t\tvar records = [];\n\t\t\tfor(var id in this._recordsMap) {\n\t\t\t\trecords.push(this._recordsMap[id]);\n\t\t\t}\n\t\t\treturn records;\n\t\t},\n\t\tdestroyRecords: function(records) {\n            if(!this._recordsMap) {\n\t\t\t\tthis.getAllRecords();\n\t\t\t}\n\t\t\tcanReflect.eachIndex(records, function(record){\n\t\t\t\tvar id = canReflect.getIdentity(record, this.queryLogic.schema);\n\t\t\t\tdelete this._recordsMap[id];\n\t\t\t}, this);\n\t\t\tlocalStorage.setItem(this.name+\"/records\", JSON.stringify(this._recordsMap) );\n\t\t},\n\t\tupdateRecordsSync: function(records){\n            if(!this._recordsMap) {\n\t\t\t\tthis.getAllRecords();\n\t\t\t}\n\t\t\trecords.forEach(function(record){\n\t\t\t\tvar id = canReflect.getIdentity(record, this.queryLogic.schema);\n\t\t\t\tthis._recordsMap[id] = record;\n\t\t\t},this);\n\t\t\tlocalStorage.setItem(this.name+\"/records\", JSON.stringify(this._recordsMap) );\n\t\t}\n\t\t// ## Identifiers\n\n\t\t/**\n\t\t * @property {String} can-connect/data/localstorage-cache/localstorage-cache.name name\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.identifiers\n\t\t *\n\t\t * Specify a name to use when saving data in localstorage.\n\t\t *\n\t\t * @option {String} This name is used to find and save data in\n\t\t * localstorage. Instances are saved in `{name}/instance/{id}`\n\t\t * and sets are saved in `{name}/set/{set}`.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * ```\n\t\t * var cacheConnection = connect([\"data-localstorage-cache\"],{\n\t\t *   name: \"todos\"\n\t\t * });\n\t\t * ```\n\t\t */\n\n\n\t\t// ## External interface\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.clear clear\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Resets the memory cache so it contains nothing.\n\t\t *\n\t\t * @signature `connection.clear()`\n\t\t *\n\t\t */\n\n\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.getSets getSets\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Returns the sets contained within the cache.\n\t\t *\n\t\t * @signature `connection.getSets(set)`\n\t\t *\n\t\t *   Returns the sets added by [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n\t\t *\n\t\t *   @return {Promise<Array<Set>>} A promise that resolves to the list of sets.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * ```\n\t\t * connection.getSets() //-> Promise( [{type: \"completed\"},{user: 5}] )\n\t\t * ```\n\t\t *\n\t\t */\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.getListData getListData\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Gets a set of data from localstorage.\n\t\t *\n\t\t * @signature `connection.getListData(set)`\n\t\t *\n\t\t *   Goes through each set add by [can-connect/data/memory-cache.updateListData]. If\n\t\t *   `set` is a subset, uses [can-connect/base/base.queryLogic] to get the data for the requested `set`.\n\t\t *\n\t\t *   @param {can-query-logic/query} query An object that represents the data to load.\n\t\t *\n\t\t *   @return {Promise<can-connect.listData>} A promise that resolves if `set` is a subset of\n\t\t *   some data added by [can-connect/data/memory-cache.updateListData].  If it is not,\n\t\t *   the promise is rejected.\n\t\t */\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache.getListDataSync getListDataSync\n\t\t * @parent can-connect/data/localstorage-cache.data-methods\n\t\t *\n\t\t * Synchronously gets a set of data from localstorage.\n\t\t *\n\t\t * @signature `connection.getListDataSync(set)`\n\t\t * @hide\n\t\t */\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.getData getData\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Get an instance's data from localstorage.\n\t\t *\n\t\t * @signature `connection.getData(params)`\n\t\t *\n\t\t *   Looks in localstorage for the requested instance.\n\t\t *\n\t\t *   @param {Object} params An object that should have the [conenction.id] of the element\n\t\t *   being retrieved.\n\t\t *\n\t\t *   @return {Promise} A promise that resolves to the item if the memory cache has this item.\n\t\t *   If localstorage does not have this item, it rejects the promise.\n\t\t */\n\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.updateListData updateListData\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Saves a set of data in the cache.\n\t\t *\n\t\t * @signature `connection.updateListData(listData, set)`\n\t\t *\n\t\t *   Tries to merge this set of data with any other saved sets of data. If\n\t\t *   unable to merge this data, saves the set by itself.\n\t\t *\n\t\t *   @param {can-connect.listData} listData\n\t\t *   @param {can-query-logic/query} query\n\t\t *   @return {Promise} Promise resolves if and when the data has been successfully saved.\n\t\t */\n\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.createData createData\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Called when an instance is created and should be added to cache.\n\t\t *\n\t\t * @signature `connection.createData(props)`\n\t\t *\n\t\t *   Adds `props` to the stored list of instances. Then, goes\n\t\t *   through every set and adds props the sets it belongs to.\n\t\t */\n\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.updateData updateData\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Called when an instance is updated.\n\t\t *\n\t\t * @signature `connection.updateData(props)`\n\t\t *\n\t\t *   Overwrites the stored instance with the new props. Then, goes\n\t\t *   through every set and adds or removes the instance if it belongs or not.\n\t\t */\n\n\n\t\t/**\n\t\t * @function can-connect/data/localstorage-cache/localstorage-cache.destroyData destroyData\n\t\t * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods\n\t\t *\n\t\t * Called when an instance should be removed from the cache.\n\t\t *\n\t\t * @signature `connection.destroyData(props)`\n\t\t *\n\t\t *   Goes through each set of data and removes any data that matches\n\t\t *   `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.\n\t\t */\n\n\t});\n\n\treturn behavior;\n\n};\n"],"names":["namespace","localStore","baseConnection","constructor","behavior","Object","create","makeSimpleStore","canReflect","assignMap","clear","localStorage","removeItem","this","name","_recordsMap","Promise","resolve","updateQueryDataSync","queries","setItem","JSON","stringify","getQueryDataSync","parse","getItem","getRecord","id","getAllRecords","cacheLocalStorageReads","recordsMap","records","push","destroyRecords","eachIndex","record","getIdentity","queryLogic","schema","updateRecordsSync","forEach"],"mappings":"iOAIiBA,UAAUC,WAAa,SAASA,EAAWC,GACxDA,EAAeC,YAAcF,EAC7B,IAAIG,EAAWC,OAAOC,OAAOC,gBAAgBL,IA6NhD,OA3NGM,WAAWC,UAAUL,EAAU,CACjCM,MAAO,WAIG,OAHTC,aAAaC,WAAWC,KAAKC,KAAK,YAClCH,aAAaC,WAAWC,KAAKC,KAAK,YACzBD,KAAKE,YAAc,KACZC,QAAQC,WAEzBC,oBAAqB,SAASC,GAC7BR,aAAaS,QAAQP,KAAKC,KAAK,WAAYO,KAAKC,UAAUH,KAE3DI,iBAAkB,WACjB,OAAOF,KAAKG,MAAOb,aAAac,QAAQZ,KAAKC,KAAK,cAAiB,IAGpEY,UAAW,SAASC,GAMnB,OAJId,KAAKE,aACRF,KAAKe,gBAGCf,KAAKE,YAAYY,IAEzBC,cAAe,WAGd,IAAIf,KAAKgB,yBAA2BhB,KAAKE,YAAa,CACrD,IAAIe,EAAaT,KAAKG,MAAOb,aAAac,QAAQZ,KAAKC,KAAK,cAAiB,GAC7ED,KAAKE,YAAce,EAGpB,IAAIC,EAAU,GACd,IAAI,IAAIJ,KAAMd,KAAKE,YAClBgB,EAAQC,KAAKnB,KAAKE,YAAYY,IAE/B,OAAOI,GAERE,eAAgB,SAASF,GACXlB,KAAKE,aACjBF,KAAKe,gBAENpB,WAAW0B,UAAUH,EAAS,SAASI,GACtC,IAAIR,EAAKnB,WAAW4B,YAAYD,EAAQtB,KAAKwB,WAAWC,eACjDzB,KAAKE,YAAYY,IACtBd,MACHF,aAAaS,QAAQP,KAAKC,KAAK,WAAYO,KAAKC,UAAUT,KAAKE,eAEhEwB,kBAAmB,SAASR,GACdlB,KAAKE,aACjBF,KAAKe,gBAENG,EAAQS,QAAQ,SAASL,GACxB,IAAIR,EAAKnB,WAAW4B,YAAYD,EAAQtB,KAAKwB,WAAWC,QACxDzB,KAAKE,YAAYY,GAAMQ,GACtBtB,MACFF,aAAaS,QAAQP,KAAKC,KAAK,WAAYO,KAAKC,UAAUT,KAAKE,iBAqK1DX"}