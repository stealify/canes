{"version":3,"file":"can-map-define.js","sources":["../node_modules/can-map-define/can-map-define.js"],"sourcesContent":["\"use strict\";\n\nvar dev = require('can-log/dev/dev');\nvar extend = require('can-assign');\nvar mapEventsMixin = require('can-event-queue/map/map');\nvar queues = require('can-queues');\nvar mapHelpers = require('can-map/map-helpers');\nvar CanMap = require('can-map');\nvar compute = require('can-compute');\nvar canReflect = require('can-reflect');\nvar ObservationRecorder = require('can-observation-recorder');\nrequire('can-list');\n\nvar define = {}; // jshint ignore:line\n\nvar hasDefaultForSerialize = function(defaultDefinition) {\n\treturn (\n\t\ttypeof defaultDefinition === \"object\" &&\n\t\t\"serialize\" in defaultDefinition\n\t);\n};\n\nvar getDefaultForSerialize = function(defaultDefinition) {\n\tvar shouldSerialize = true;\n\n\tif (hasDefaultForSerialize(defaultDefinition)) {\n\t\tshouldSerialize = !!defaultDefinition.serialize;\n\t}\n\n\treturn shouldSerialize;\n};\n\nvar keysForDefinition = function(definitions) {\n\tvar keys = [];\n\tvar defaultDefinition = definitions && definitions[\"*\"];\n\tfor (var prop in definitions) {\n\t\tvar definition = definitions[prop];\n\t\tvar shouldSerialize = getDefaultForSerialize(defaultDefinition);\n\t\t// allow property definitions to override default behavior\n\t\tif (typeof definition === \"object\" && \"serialize\" in definition) {\n\t\t\tshouldSerialize = !!definition.serialize;\n\t\t} else if (\n\t\t\ttypeof definition === \"object\" &&\n\t\t\t!hasDefaultForSerialize(defaultDefinition)\n\t\t) {\n\t\t\tshouldSerialize = !definition.get;\n\t\t}\n\t\tif (shouldSerialize) {\n\t\t\tkeys.push(prop);\n\t\t}\n\t}\n\treturn keys;\n};\n\nvar getPropDefineBehavior = function(behavior, attr, define) {\n\tvar prop, defaultProp;\n\n\tif (define) {\n\t\tprop = define[attr];\n\t\tdefaultProp = define['*'];\n\n\t\tif (prop && prop[behavior] !== undefined) {\n\t\t\treturn prop[behavior];\n\t\t} else if (defaultProp && defaultProp[behavior] !== undefined) {\n\t\t\treturn defaultProp[behavior];\n\t\t}\n\t}\n};\n\n// This is called when the Map is defined\nmapHelpers.define = function(Map, baseDefine) {\n\tvar definitions = Map.prototype.define;\n\n\tif (baseDefine) {\n\t\tvar defines = {};\n\t\tmapHelpers.twoLevelDeepExtend(defines, baseDefine);\n\t\tmapHelpers.twoLevelDeepExtend(defines, definitions);\n\t\textend(definitions, defines);\n\t}\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tif (Map.define) {\n\t\t\tdev.warn(\"The define property should be on the map's prototype properties, \" +\n\t\t\t\t\"not the static properties.\");\n\t\t}\n\t}\n\t//!steal-remove-end\n\tMap.defaultGenerators = {};\n\tfor (var prop in definitions) {\n\t\tvar type = definitions[prop].type;\n\t\tif (typeof type === \"string\") {\n\t\t\tif (typeof define.types[type] === \"object\") {\n\t\t\t\tdelete definitions[prop].type;\n\t\t\t\textend(definitions[prop], define.types[type]);\n\t\t\t}\n\t\t}\n\t\tif (\"value\" in definitions[prop]) {\n\t\t\tif (typeof definitions[prop].value === \"function\") {\n\t\t\t\tMap.defaultGenerators[prop] = definitions[prop].value;\n\t\t\t} else {\n\t\t\t\tMap.defaults[prop] = definitions[prop].value;\n\t\t\t}\n\t\t}\n\t\tif (typeof definitions[prop].Value === \"function\") {\n\t\t\t(function(Constructor) {\n\t\t\t\tMap.defaultGenerators[prop] = function() {\n\t\t\t\t\treturn new Constructor();\n\t\t\t\t};\n\t\t\t})(definitions[prop].Value);\n\t\t}\n\t}\n};\n\nvar oldSetupDefaults = CanMap.prototype._setupDefaults;\nCanMap.prototype._setupDefaults = function(obj) {\n\tvar defaults = extend({},oldSetupDefaults.call(this)),\n\t\tpropsCommittedToAttr = {},\n\t\tMap = this.constructor,\n\t\toriginalGet = this._get;\n\n\t// Overwrite this._get with a version that commits defaults to\n\t// this.attr() as needed. Because calling this.attr() for each\n\t// individual default would be expensive.\n\tthis._get = function(originalProp) {\n\t\t// If a this.attr() was called using dot syntax (e.g number.0),\n\t\t// disregard everything after the \".\" until we call the\n\t\t// original this._get().\n\t\tvar prop = (originalProp.indexOf('.') !== -1 ?\n\t\t\toriginalProp.substr(0, originalProp.indexOf('.')) :\n\t\t\toriginalProp);\n\n\t\t// If this property has a default and we haven't yet committed it to\n\t\t// this.attr()\n\t\tif ((prop in defaults) && !(prop in propsCommittedToAttr)) {\n\n\t\t\t// Commit the property's default so that it can be read in\n\t\t\t// other defaultGenerators.\n\t\t\tthis.attr(prop, defaults[prop]);\n\n\t\t\t// Make not so that we don't commit this property again.\n\t\t\tpropsCommittedToAttr[prop] = true;\n\t\t}\n\n\t\treturn originalGet.apply(this, arguments);\n\t};\n\n\tfor (var prop in Map.defaultGenerators) {\n\t\t// Only call the prop's value method if the property wasn't provided\n\t\t// during instantiation.\n\t\tif (!obj || !(prop in obj)) {\n\t\t\tdefaults[prop] = Map.defaultGenerators[prop].call(this);\n\t\t}\n\t}\n\n\t// delete this._get which will default to the one on the prototype.\n\tdelete this._get;\n\n\treturn defaults;\n};\n\n\nvar proto = CanMap.prototype,\n\toldSet = proto.__set;\nproto.__set = function(prop, value, current, success, error) {\n\t//!steal-remove-start\n\tvar asyncTimer;\n\t//!steal-remove-end\n\n\tvar self = this;\n\n\t// check if there's a setter\n\tvar errorCallback = function(errors) {\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tclearTimeout(asyncTimer);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tvar stub = error && error.call(self, errors);\n\t\t\t// if 'validations' is on the page it will trigger\n\t\t\t// the error itself and we dont want to trigger\n\t\t\t// the event twice. :)\n\t\t\tif (stub !== false) {\n\t\t\t\tmapEventsMixin.dispatch.call(self, 'error', [ prop, errors ], true);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tsetter = getPropDefineBehavior(\"set\", prop, this.define),\n\t\tgetter = getPropDefineBehavior(\"get\", prop, this.define);\n\n\n\t// if we have a setter\n\tif (setter) {\n\t\t// call the setter, if returned value is undefined,\n\t\t// this means the setter is async so we\n\t\t// do not call update property and return right away\n\t\tqueues.batch.start();\n\t\tvar setterCalled = false,\n\n\t\t\tsetValue = setter.call(this, value, function(value) {\n\t\t\t\tif (getter) {\n\t\t\t\t\tself[prop](value);\n\t\t\t\t} else {\n\t\t\t\t\toldSet.call(self, prop, value, current, success, errorCallback);\n\t\t\t\t}\n\n\t\t\t\tsetterCalled = true;\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tclearTimeout(asyncTimer);\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t}, errorCallback, getter ? this._computedAttrs[prop].compute.computeInstance.lastSetValue.get() : current);\n\t\tif (getter) {\n\t\t\t// if there's a getter we don't call old set\n\t\t\t// instead we call the getter's compute with the new value\n\t\t\tif (setValue !== undefined && !setterCalled && setter.length >= 1) {\n\t\t\t\tthis._computedAttrs[prop].compute(setValue);\n\t\t\t}\n\n\t\t\tqueues.batch.stop();\n\t\t\treturn;\n\t\t}\n\t\t// if it took a setter and returned nothing, don't set the value\n\t\telse if (setValue === undefined && !setterCalled && setter.length > 1) {\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tasyncTimer = setTimeout(function() {\n\t\t\t\t\tdev.warn('can/map/define: Setter \"' + prop + '\" did not return a value or call the setter callback.');\n\t\t\t\t}, dev.warnTimeout);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tqueues.batch.stop();\n\t\t\treturn;\n\t\t} else {\n\t\t\tif (!setterCalled) {\n\t\t\t\toldSet.call(self, prop,\n\t\t\t\t\t// if no arguments, we are side-effects only\n\t\t\t\t\tsetter.length === 0 && setValue === undefined ? value : setValue,\n\t\t\t\t\tcurrent,\n\t\t\t\t\tsuccess,\n\t\t\t\t\terrorCallback);\n\t\t\t}\n\t\t\tqueues.batch.stop();\n\t\t\treturn this;\n\t\t}\n\n\t} else {\n\t\toldSet.call(self, prop, value, current, success, errorCallback);\n\t}\n\n\treturn this;\n};\n\ndefine.types = {\n\t'date': function(str) {\n\t\tvar type = typeof str;\n\t\tif (type === 'string') {\n\t\t\tstr = Date.parse(str);\n\t\t\treturn isNaN(str) ? null : new Date(str);\n\t\t} else if (type === 'number') {\n\t\t\treturn new Date(str);\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t},\n\t'number': function(val) {\n\t\tif (val == null) {\n\t\t\treturn val;\n\t\t}\n\t\treturn +(val);\n\t},\n\t'boolean': function(val) {\n\t\tif(val == null) {\n\t\t\treturn val;\n\t\t}\n\t\tif (val === 'false' || val === '0' || !val) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\t'htmlbool': function(val) {\n\t\treturn typeof val === \"string\" || !!val;\n\t},\n\t'*': function(val) {\n\t\treturn val;\n\t},\n\t'string': function(val) {\n\t\tif (val == null) {\n\t\t\treturn val;\n\t\t}\n\t\treturn '' + val;\n\t},\n\t'compute': {\n\t\tset: function(newValue, setVal, setErr, oldValue) {\n\t\t\tif (newValue && newValue.isComputed) {\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t\tif (oldValue && oldValue.isComputed) {\n\t\t\t\toldValue(newValue);\n\t\t\t\treturn oldValue;\n\t\t\t}\n\t\t\treturn newValue;\n\t\t},\n\t\tget: function(value) {\n\t\t\treturn value && value.isComputed ? value() : value;\n\t\t}\n\t}\n};\n\n// the old type sets up bubbling\nvar oldType = proto.__type;\nproto.__type = function(value, prop) {\n\tvar type = getPropDefineBehavior(\"type\", prop, this.define),\n\t\tType = getPropDefineBehavior(\"Type\", prop, this.define),\n\t\tnewValue = value;\n\n\tif (typeof type === \"string\") {\n\t\ttype = define.types[type];\n\t}\n\n\tif (type || Type) {\n\t\t// If there's a type, convert it.\n\t\tif (type) {\n\t\t\tnewValue = type.call(this, newValue, prop);\n\t\t}\n\t\t// If there's a Type and newValue is non-null create a new instance of it\n\t\tif (Type && newValue != null && !(newValue instanceof Type)) {\n\t\t\tnewValue = new Type(newValue);\n\t\t}\n\t\t// If the newValue is a Map, we need to hook it up\n\t\treturn newValue;\n\n\t}\n\t// If we pass in a object with define\n\telse if (canReflect.isPlainObject(newValue) && newValue.define) {\n\t\tnewValue = CanMap.extend(newValue);\n\t\tnewValue = new newValue();\n\t}\n\treturn oldType.call(this, newValue, prop);\n};\n\nvar oldRemove = proto.__remove;\nproto.__remove = function(prop, current) {\n\tvar remove = getPropDefineBehavior(\"remove\", prop, this.define),\n\t\tres;\n\tif (remove) {\n\t\tqueues.batch.start();\n\t\tres = remove.call(this, current);\n\n\t\tif (res === false) {\n\t\t\tqueues.batch.stop();\n\t\t\treturn;\n\t\t} else {\n\n\t\t\tres = oldRemove.call(this, prop, current);\n\t\t\tqueues.batch.stop();\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn oldRemove.call(this, prop, current);\n};\n\nvar oldSetupComputes = proto._setupComputedProperties;\nproto._setupComputedProperties = function() {\n\toldSetupComputes.apply(this, arguments);\n\tfor (var attr in this.define) {\n\t\tvar def = this.define[attr],\n\t\t\tget = def.get;\n\t\tif (get) {\n\t\t\tmapHelpers.addComputedAttr(this, attr, compute.async(undefined, get, this));\n\t\t}\n\t}\n};\n// Overwrite the invidual property serializer b/c we will overwrite it.\nvar oldSingleSerialize = proto.___serialize;\n// If the map has a define serializer for the given attr, run it.\nvar serializeProp = function(map, attr, val) {\n\tvar serializer = attr === \"*\" ? false : getPropDefineBehavior(\"serialize\", attr, map.define);\n\tif (serializer === undefined) {\n\t\treturn oldSingleSerialize.call(map, attr, val);\n\t} else if (serializer !== false) {\n\t\treturn typeof serializer === \"function\" ? serializer.call(map, val, attr) : oldSingleSerialize.call(map, attr, val);\n\t}\n};\n\nproto.___serialize = function(name, val) {\n\treturn serializeProp(this, name, val);\n};\n\n// Overwrite serialize to add in any missing define serialized properties.\nvar oldSerialize = proto.serialize;\nproto.serialize = function(property) {\n\tvar serialized = oldSerialize.apply(this, arguments);\n\tif (property) {\n\t\treturn serialized;\n\t}\n\t// add in properties not already serialized\n\n\tvar serializer,\n\t\tval;\n\t// Go through each property.\n\tfor (var attr in this.define) {\n\t\t// if it's not already defined\n\t\tif (!(attr in serialized)) {\n\t\t\t// check there is a serializer so we aren't doing extra work on serializer:false\n\t\t\t// also check for a wildcard serializer\n\t\t\tserializer = this.define && (this.define[attr] && this.define[attr].serialize || this.define['*'] && this.define['*'].serialize);\n\t\t\tif (serializer) {\n\t\t\t\tval = serializeProp(this, attr, this.attr(attr));\n\t\t\t\tif (val !== undefined) {\n\t\t\t\t\tserialized[attr] = val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn serialized;\n};\n\ncanReflect.assignSymbols(proto, {\n\t\"can.hasKey\": function(key) {\n\t\tvar defined = this.define && key in this.define;\n\t\tvar dataExists = this._data && key in this._data;\n\t\tvar propExists = key in this;\n\t\treturn defined || dataExists || propExists;\n\t},\n\n\t\"can.getOwnEnumerableKeys\": function() {\n\t\tif (!this.__inSetup) {\n\t\t\tObservationRecorder.add(this, '__keys');\n\t\t}\n\n\t\tvar definedKeys = keysForDefinition(this.define);\n\t\tvar dataKeys = Object.keys(this._data);\n\t\tvar shouldSerialize = getDefaultForSerialize(this.define && this.define[\"*\"]);\n\n\t\tvar enumerable = this.constructor.enumerable;\n\t\tdataKeys = dataKeys.filter(function(key) {\n\t\t\treturn enumerable ?\n\t\t\t\tshouldSerialize && enumerable[key] !== false :\n\t\t\t\tshouldSerialize;\n\t\t});\n\n\t\tvar i, newKey;\n\t\tfor(i=0; i<dataKeys.length; i++) {\n\t\t\tnewKey = dataKeys[i];\n\t\t\t// add keys that are in _data, but are not in `define`\n\t\t\t// keys in `define` are in `definedKeys` based on their `serialize` prop\n\t\t\tif (definedKeys.indexOf(newKey) < 0 && (!this.define || !this.define[newKey])) {\n\t\t\t\tdefinedKeys.push(dataKeys[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn definedKeys;\n\t}\n});\n\nmodule.exports = define;\n"],"names":["define","hasDefaultForSerialize","defaultDefinition","getDefaultForSerialize","shouldSerialize","serialize","keysForDefinition","definitions","keys","prop","definition","get","push","getPropDefineBehavior","behavior","attr","defaultProp","undefined","mapHelpers","Map","baseDefine","prototype","defines","twoLevelDeepExtend","extend","process","env","NODE_ENV","dev","warn","defaultGenerators","type","types","value","defaults","Value","Constructor","oldSetupDefaults","CanMap","_setupDefaults","obj","call","this","propsCommittedToAttr","constructor","originalGet","_get","originalProp","indexOf","substr","apply","arguments","proto","oldSet","__set","current","success","error","asyncTimer","self","errorCallback","errors","clearTimeout","mapEventsMixin","dispatch","setter","getter","queues","batch","start","setterCalled","setValue","_computedAttrs","compute","computeInstance","lastSetValue","length","stop","setTimeout","warnTimeout","date","str","Date","parse","isNaN","number","val","boolean","htmlbool","*","string","set","newValue","setVal","setErr","oldValue","isComputed","oldType","__type","Type","canReflect","isPlainObject","oldRemove","__remove","res","remove","oldSetupComputes","_setupComputedProperties","addComputedAttr","async","oldSingleSerialize","___serialize","serializeProp","map","serializer","name","oldSerialize","property","serialized","assignSymbols","can.hasKey","key","defined","dataExists","_data","can.getOwnEnumerableKeys","__inSetup","ObservationRecorder","add","i","newKey","definedKeys","dataKeys","Object","enumerable","filter"],"mappings":"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"}