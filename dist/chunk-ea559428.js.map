{"version":3,"file":"chunk-ea559428.js","sources":["../node_modules/can-view-scope/template-context.js","../node_modules/can-view-scope/make-compute-like.js","../node_modules/can-stache-helpers/can-stache-helpers.js","../node_modules/can-view-scope/scope-key-data.js","../node_modules/can-view-scope/compute_data.js","../node_modules/can-view-scope/can-view-scope.js"],"sourcesContent":["\"use strict\";\nvar SimpleMap = require(\"can-simple-map\");\n\nvar TemplateContext = function(options) {\n\toptions = options || {};\n\tthis.vars = new SimpleMap(options.vars || {});\n\tthis.helpers = new SimpleMap(options.helpers || {});\n\tthis.partials = new SimpleMap(options.partials || {});\n\tthis.tags = new SimpleMap(options.tags || {});\n};\n\nmodule.exports = TemplateContext;\n","\"use strict\";\nvar singleReference = require(\"can-single-reference\");\nvar canReflect = require('can-reflect');\n\nvar Compute = function(newVal){\n\tif(arguments.length) {\n\t\treturn canReflect.setValue(this, newVal);\n\t} else {\n\t\treturn canReflect.getValue(this);\n\t}\n};\n\nmodule.exports = function(observable) {\n    var compute = Compute.bind(observable);\n\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tObject.defineProperty(compute, \"name\", {\n\t\t\tvalue: \"Compute<\"+canReflect.getName(observable) + \">\",\n\t\t});\n\t}\n\t//!steal-remove-end\n\n    compute.on = compute.bind = compute.addEventListener = function(event, handler) {\n        var translationHandler = function(newVal, oldVal) {\n            handler.call(compute, {type:'change'}, newVal, oldVal);\n        };\n        singleReference.set(handler, this, translationHandler);\n        observable.on(translationHandler);\n    };\n    compute.off = compute.unbind = compute.removeEventListener = function(event, handler) {\n        observable.off( singleReference.getAndDelete(handler, this) );\n    };\n\n    canReflect.assignSymbols(compute, {\n        \"can.getValue\": function(){\n            return canReflect.getValue(observable);\n        },\n        \"can.setValue\": function(newVal){\n            return canReflect.setValue(observable, newVal);\n        },\n        \"can.onValue\": function(handler, queue){\n            return canReflect.onValue(observable, handler, queue);\n        },\n        \"can.offValue\": function(handler, queue){\n            return canReflect.offValue(observable, handler, queue);\n        },\n        \"can.valueHasDependencies\": function(){\n            return canReflect.valueHasDependencies(observable);\n        },\n        \"can.getPriority\": function(){\n    \t\treturn canReflect.getPriority( observable );\n    \t},\n    \t\"can.setPriority\": function(newPriority){\n    \t\tcanReflect.setPriority( observable, newPriority );\n    \t},\n\t\t\"can.isValueLike\": true,\n\t\t\"can.isFunctionLike\": false\n    });\n    compute.isComputed = true;\n    return compute;\n};\n","\"use strict\";\nvar namespace = require('can-namespace');\n\nif (namespace.stacheHelpers) {\n\tthrow new Error(\"You can't have two versions of can-stache-helpers, check your dependencies\");\n} else {\n\tmodule.exports = namespace.stacheHelpers = {};\n}\n","\"use strict\";\nvar Observation = require('can-observation');\nvar observeReader = require('can-stache-key');\nvar assign = require('can-assign');\n\nvar canReflect = require('can-reflect');\nvar canSymbol = require('can-symbol');\nvar ObservationRecorder = require('can-observation-recorder');\nvar makeComputeLike = require(\"./make-compute-like\");\nvar canReflectDeps = require('can-reflect-dependencies');\nvar valueEventBindings = require(\"can-event-queue/value/value\");\nvar stacheHelpers = require('can-stache-helpers');\nvar SimpleObservable = require(\"can-simple-observable\");\n\nvar dispatchSymbol = canSymbol.for(\"can.dispatch\");\n\n// The goal of this is to create a high-performance compute that represents a key value from can.view.Scope.\n// If the key value is something like {{name}} and the context is a can.Map, a faster\n// binding path will be used where new rebindings don't need to be looked for with every change of\n// the observable property.\n// However, if the property changes to a compute, then the slower `can.compute.read` method of\n// observing values will be used.\n\n// ideally, we would know the order things were read.  If the last thing read\n// was something we can observe, and the value of it matched the value of the observation,\n// and the key matched the key of the observation\n// it's a fair bet that we can just listen to that last object.\n// If the `this` is not that object ... freak out.  Though `this` is not necessarily part of it.  can-observation could make\n// this work.\n\nvar peekValue = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));\n\nvar getFastPathRoot = ObservationRecorder.ignore(function(computeData){\n\tif( computeData.reads &&\n\t\t\t\t// a single property read\n\t\t\t\tcomputeData.reads.length === 1 ) {\n\t\tvar root = computeData.root;\n\t\tif( root && root[canSymbol.for(\"can.getValue\")] ) {\n\t\t\troot = canReflect.getValue(root);\n\t\t}\n\t\t// on a map\n\t\treturn root && canReflect.isObservableLike(root) && canReflect.isMapLike(root) &&\n\t\t\t// that isn't calling a function\n\t\t\ttypeof root[computeData.reads[0].key] !== \"function\" && root;\n\t}\n\treturn;\n});\n\nvar isEventObject = function(obj){\n\treturn obj && typeof obj.batchNum === \"number\" && typeof obj.type === \"string\";\n};\n\nfunction callMutateWithRightArgs(method, mutated, reads, mutator){\n\tif(reads.length) {\n\t\tmethod.call(canReflectDeps,mutated, reads[ reads.length - 1 ].key ,mutator);\n\t} else {\n\t\tmethod.call(canReflectDeps,mutated ,mutator);\n\t}\n}\n\n// could we make this an observation first ... and have a getter for the compute?\n\n// This is a fast-path enabled Observation wrapper use many places in can-stache.\n// The goal of this is to:\n//\n// 1.  Make something that can be passed to can-view-live directly, hopefully\n//     avoiding creating expensive computes.  Instead we will only be creating\n//     `ScopeKeyData` which are thin wrappers.\nvar ScopeKeyData = function(scope, key, options){\n\n\tthis.startingScope = scope;\n\tthis.key = key;\n\tthis.read = this.read.bind(this);\n\tthis.dispatch = this.dispatch.bind(this);\n\n\t// special case debugger helper so that it is called with helperOtions\n\t// when you do {{debugger}} as it already is with {{debugger()}}\n\tif (key === \"debugger\") {\n\t\t// prevent \"Unable to find key\" warning\n\t\tthis.startingScope = { _context: stacheHelpers };\n\n\t\tthis.read = function() {\n\t\t\tvar helperOptions = { scope: scope };\n\t\t\tvar debuggerHelper = stacheHelpers[\"debugger\"];\n\t\t\treturn debuggerHelper(helperOptions);\n\t\t};\n\t}\n\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tObject.defineProperty(this.read, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".read\",\n\t\t});\n\t\tObject.defineProperty(this.dispatch, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".dispatch\",\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tvar observation = this.observation = new Observation(this.read, this);\n\tthis.options = assign({ observation: this.observation }, options);\n\n\t// things added later\n\tthis.fastPath = undefined;\n\tthis.root = undefined;\n\tthis.initialValue = undefined;\n\tthis.reads = undefined;\n\tthis.setRoot = undefined;\n\t// This is read by call expressions so it needs to be observable\n\tthis._thisArg = new SimpleObservable();\n\tthis.parentHasKey = undefined;\n\tvar valueDependencies = new Set();\n\tvalueDependencies.add(observation);\n\tthis.dependencies = {valueDependencies: valueDependencies};\n};\n\nvalueEventBindings(ScopeKeyData.prototype);\n\nfunction fastOnBoundSet_Value() {\n\tthis._value = this.newVal;\n}\n\nfunction fastOnBoundSetValue() {\n\tthis.value = this.newVal;\n}\n\nassign(ScopeKeyData.prototype, {\n\tconstructor: ScopeKeyData,\n\tdispatch: function dispatch(newVal){\n\t\tvar old = this.value;\n\t\tthis.value = newVal;\n\t\t// call the base implementation in can-event-queue\n\t\tthis[dispatchSymbol].call(this, this.value, old);\n\t},\n\tonBound: function onBound(){\n\t\tthis.bound = true;\n\t\tcanReflect.onValue(this.observation, this.dispatch, \"notify\");\n\t\t// TODO: we should check this sometime in the background.\n\t\tvar fastPathRoot = getFastPathRoot(this);\n\t\tif( fastPathRoot ) {\n\t\t\t// rewrite the observation to call its event handlers\n\t\t\tthis.toFastPath(fastPathRoot);\n\t\t}\n\t\tthis.value = peekValue(this.observation);\n\t},\n\tonUnbound: function onUnbound() {\n\t\tthis.bound = false;\n\t\tcanReflect.offValue(this.observation, this.dispatch, \"notify\");\n\t\tthis.toSlowPath();\n\t},\n\tset: function(newVal){\n\t\tvar root = this.root || this.setRoot;\n\t\tif(root) {\n\t\t\tif(this.reads.length) {\n\t\t\t\tobserveReader.write(root, this.reads, newVal, this.options);\n\t\t\t} else {\n\t\t\t\tcanReflect.setValue(root,newVal);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.startingScope.set(this.key, newVal, this.options);\n\t\t}\n\t},\n\tget: function() {\n\t\tif (ObservationRecorder.isRecording()) {\n\t\t\tObservationRecorder.add(this);\n\t\t\tif (!this.bound) {\n\t\t\t\tObservation.temporarilyBind(this);\n\t\t\t}\n\t\t}\n\n\t\tif (this.bound === true ) {\n\t\t\treturn this.value;\n\t\t} else {\n\t\t\treturn this.observation.get();\n\t\t}\n\t},\n\ttoFastPath: function(fastPathRoot){\n\t\tvar self = this,\n\t\t\tobservation = this.observation;\n\n\t\tthis.fastPath = true;\n\n\t\t// there won't be an event in the future ...\n\t\tobservation.dependencyChange = function(target, newVal){\n\t\t\tif(isEventObject(newVal)) {\n\t\t\t\tthrow \"no event objects!\";\n\t\t\t}\n\t\t\t// but I think we will be able to get at it b/c there should only be one\n\t\t\t// dependency we are binding to ...\n\t\t\tif(target === fastPathRoot && typeof newVal !== \"function\") {\n\t\t\t\tthis.newVal = newVal;\n\t\t\t} else {\n\t\t\t\t// restore\n\t\t\t\tself.toSlowPath();\n\t\t\t}\n\n\t\t\treturn Observation.prototype.dependencyChange.apply(this, arguments);\n\t\t};\n\n\t\tif (observation.hasOwnProperty(\"_value\")) {// can-observation 4.1+\n\t\t\tobservation.onBound = fastOnBoundSet_Value;\n\t\t} else {// can-observation < 4.1\n\t\t\tobservation.onBound = fastOnBoundSetValue;\n\t\t}\n\t},\n\ttoSlowPath: function(){\n\t\tthis.observation.dependencyChange = Observation.prototype.dependencyChange;\n\t\tthis.observation.onBound = Observation.prototype.onBound;\n\t\tthis.fastPath = false;\n\t},\n\tread: function(){\n\t\tvar data;\n\n\t\tif (this.root) {\n\t\t\t// if we've figured out a root observable, start reading from there\n\t\t\tdata = observeReader.read(this.root, this.reads, this.options);\n\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t// remove old dependency\n\t\t\t\tif(this.reads.length) {\n\t\t\t\t\tcallMutateWithRightArgs(canReflectDeps.deleteMutatedBy, peekValue(this._thisArg) || this.root, this.reads,this);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\t// update thisArg and add new dependency\n\t\t\tthis.thisArg = data.parent;\n\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tvar valueDeps = new Set();\n\t\t\t\tvalueDeps.add(this);\n\t\t\t\tcallMutateWithRightArgs(canReflectDeps.addMutatedBy, data.parent || this.root, this.reads,{\n\t\t\t\t\tvalueDependencies: valueDeps\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn data.value;\n\t\t}\n\t\t// If the key has not already been located in a observable then we need to search the scope for the\n\t\t// key.  Once we find the key then we need to return it's value and if it is found in an observable\n\t\t// then we need to store the observable so the next time this compute is called it can grab the value\n\t\t// directly from the observable.\n\t\tdata = this.startingScope.read(this.key, this.options);\n\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tif (data.rootObserve) {\n\t\t\t\tvar rootValueDeps = new Set();\n\t\t\t\trootValueDeps.add(this);\n\t\t\t\tcallMutateWithRightArgs(canReflectDeps.addMutatedBy, data.thisArg || data.rootObserve, data.reads,{\n\t\t\t\t\tvalueDependencies: rootValueDeps\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tthis.scope = data.scope;\n\t\tthis.reads = data.reads;\n\t\tthis.root = data.rootObserve;\n\t\tthis.setRoot = data.setRoot;\n\t\tthis.thisArg = data.thisArg;\n\t\tthis.parentHasKey = data.parentHasKey;\n\t\treturn this.initialValue = data.value;\n\t},\n\thasDependencies: function(){\n\t\treturn canReflect.valueHasDependencies( this.observation );\n\t}\n});\n\nObject.defineProperty(ScopeKeyData.prototype, \"thisArg\", {\n\tget: function(){\n\t\treturn this._thisArg.get();\n\t},\n\tset: function(newVal) {\n\t\tthis._thisArg.set(newVal);\n\t}\n});\n\nvar scopeKeyDataPrototype = {\n\t\"can.getValue\": ScopeKeyData.prototype.get,\n\t\"can.setValue\": ScopeKeyData.prototype.set,\n\t\"can.valueHasDependencies\": ScopeKeyData.prototype.hasDependencies,\n\t\"can.getValueDependencies\": function() {\n\t\treturn this.dependencies;\n\t},\n\t\"can.getPriority\": function(){\n\t\treturn canReflect.getPriority( this.observation );\n\t},\n\t\"can.setPriority\": function(newPriority){\n\t\tcanReflect.setPriority( this.observation, newPriority );\n\t}\n};\n\n//!steal-remove-start\nif (process.env.NODE_ENV !== 'production') {\n\tscopeKeyDataPrototype[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"{{\" + this.key + \"}}\";\n\t};\n}\n//!steal-remove-end\ncanReflect.assignSymbols(ScopeKeyData.prototype, scopeKeyDataPrototype);\n\n// Creates a compute-like for legacy reasons ...\nObject.defineProperty(ScopeKeyData.prototype, \"compute\", {\n\tget: function(){\n\t\tvar compute = makeComputeLike(this);\n\n\t\tObject.defineProperty(this, \"compute\", {\n\t\t\tvalue: compute,\n\t\t\twritable: false,\n\t\t\tconfigurable: false\n\t\t});\n\t\treturn compute;\n\t},\n\tconfigurable: true\n});\n\nmodule.exports = ScopeKeyData;\n","\"use strict\";\n\nvar ScopeKeyData = require('./scope-key-data');\n\nmodule.exports = function(scope, key, options){\n\treturn new ScopeKeyData(scope, key, options || {\n\t\targs: []\n\t});\n};\n","\"use strict\";\n// # can-view-scope.js\n//\n// This provides the ability to lookup values across a higherarchy of objects.  This is similar to\n// how closures work in JavaScript.\n//\n// This is done with the `Scope` type. It works by having a `_context` reference to\n// an object whose properties can be searched for values.  It also has a `_parent` reference\n// to the next Scope in which to check.  In this way, `Scope` is used to form a tree-like\n// structure.  Leaves and Nodes in the tree only point to their parent.\nvar stacheKey = require('can-stache-key');\nvar ObservationRecorder = require(\"can-observation-recorder\");\nvar TemplateContext = require('./template-context');\nvar makeComputeData = require('./compute_data');\nvar assign = require('can-assign');\nvar namespace = require('can-namespace');\nvar canReflect = require(\"can-reflect\");\nvar canLog = require('can-log/dev/dev');\nvar defineLazyValue = require('can-define-lazy-value');\nvar stacheHelpers = require('can-stache-helpers');\nvar SimpleMap = require('can-simple-map');\n\n\n// ## Helpers\n\nfunction canHaveProperties(obj){\n\treturn obj != null;\n}\nfunction returnFalse(){\n\treturn false;\n}\n\n// ### LetContext\n// Instances of this are used to create a `let` variable context.\nvar LetContext = SimpleMap.extend(\"LetContext\",{});\n\n// ## Scope\n// Represents a node in the scope tree.\nfunction Scope(context, parent, meta) {\n\t// The object that will be looked on for values.\n\t// If the type of context is TemplateContext, there will be special rules for it.\n\tthis._context = context;\n\t// The next Scope object whose context should be looked on for values.\n\tthis._parent = parent;\n\t// If this is a special context, it can be labeled here.\n\t// Options are:\n\t// - `viewModel` - This is a viewModel. This is mostly used by can-component to make `scope.vm` work.\n\t// - `notContext` - This can't be looked within using `./` and `../`. It will be skipped.\n\t//   This is for virtual contexts like those used by `%index`. This is very much like\n\t//   `variable`.  Most things should switch to `variable` in the future.\n\t// - `special` - This can't be looked within using `./` and `../`. It will be skipped.\n\t//   This is for reading properties on the scope {{scope.index}}. It's different from variable\n\t//   because it's never lookup up like {{key}}.\n\t// - `variable` - This is used to define a variable (as opposed to \"normal\" context). These\n\t//   will also be skipped when using `./` and `../`.\n\tthis._meta = meta || {};\n\n\t// A cache that can be used to store computes used to look up within this scope.\n\t// For example if someone creates a compute to lookup `name`, another compute does not\n\t// need to be created.\n\tthis.__cache = {};\n}\n\nvar parentContextSearch = /(\\.\\.\\/)|(\\.\\/)|(this[\\.@])/g;\n\n// ## Static Methods\n// The following methods are exposed mostly for testing purposes.\nassign(Scope, {\n\t// ### Scope.read\n\t// Scope.read was moved to can-stache-key.read\n\t// can-stache-key.read reads properties from a parent. A much more complex version of getObject.\n\tread: stacheKey.read,\n\tTemplateContext: TemplateContext,\n\t// ### keyInfo(key)\n\t// Returns an object that details what the `key` means with the following:\n\t// ```js\n\t// {\n\t//   remainingKey, // what would be read on a context (or this)\n\t//   isScope, // if the scope itself is being read\n\t//   inScope, // if a key on the scope is being read\n\t//   parentContextWalkCount, // how many ../\n\t//   isContextBased // if a \"normal\" context is explicitly being read\n\t// }\n\t// ```\n\tkeyInfo: function(attr){\n\n\t\tif (attr === \"./\") {\n\t\t\tattr = \"this\";\n\t\t}\n\n\t\tvar info = {remainingKey: attr};\n\n\t\t// handle scope stuff first\n\t\tinfo.isScope = attr === \"scope\";\n\t\tif(info.isScope) {\n\t\t\treturn info;\n\t\t}\n\t\tvar firstSix = attr.substr(0, 6);\n\t\tinfo.isInScope =\n\t\t\tfirstSix === \"scope.\" ||\n\t\t\tfirstSix === \"scope@\";\n\t\tif(info.isInScope) {\n\t\t\tinfo.remainingKey = attr.substr(6);\n\t\t\treturn info;\n\t\t} else if(firstSix === \"scope/\") {\n\t\t\tinfo.walkScope = true;\n\t\t\tinfo.remainingKey = attr.substr(6);\n\t\t\treturn info;\n\t\t} else if(attr.substr(0, 7) === \"@scope/\") {\n\t\t\tinfo.walkScope = true;\n\t\t\tinfo.remainingKey = attr.substr(7);\n\t\t\treturn info;\n\t\t}\n\n\t\tinfo.parentContextWalkCount = 0;\n\t\t// Searches for `../` and other context specifiers\n\t\tinfo.remainingKey = attr.replace(parentContextSearch, function(token, parentContext, dotSlash, thisContext, index){\n\t\t\tinfo.isContextBased = true;\n\t\t\tif(parentContext !== undefined) {\n\t\t\t\tinfo.parentContextWalkCount++;\n\t\t\t}\n\t\t\treturn \"\";\n\t\t});\n\t\t// ../..\n\t\tif(info.remainingKey === \"..\") {\n\t\t\tinfo.parentContextWalkCount++;\n\t\t\tinfo.remainingKey = \"this\";\n\t\t}\n\t\telse if(info.remainingKey === \".\" || info.remainingKey === \"\") {\n\t\t\tinfo.remainingKey = \"this\";\n\t\t}\n\n\t\tif(info.remainingKey === \"this\") {\n\t\t\tinfo.isContextBased = true;\n\t\t}\n\t\treturn info;\n\t},\n\t// ### isTemplateContextOrCanNotHaveProperties\n\t// Returns `true` if a template context or a `null` or `undefined`\n\t// context.\n\tisTemplateContextOrCanNotHaveProperties: function(currentScope){\n\t\tvar currentContext = currentScope._context;\n\t\tif(currentContext instanceof TemplateContext) {\n\t\t\treturn true;\n\t\t} else if( !canHaveProperties(currentContext) ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\t// ### shouldSkipIfSpecial\n\t// Return `true` if special.\n\tshouldSkipIfSpecial: function(currentScope){\n\t\tvar isSpecialContext = currentScope._meta.special === true;\n\t\tif (isSpecialContext === true) {\n\t\t\treturn true;\n\t\t}\n\t\tif( Scope.isTemplateContextOrCanNotHaveProperties(currentScope) ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\t// ### shouldSkipEverythingButSpecial\n\t// Return `true` if not special.\n\tshouldSkipEverythingButSpecial: function(currentScope){\n\t\tvar isSpecialContext = currentScope._meta.special === true;\n\t\tif (isSpecialContext === false) {\n\t\t\treturn true;\n\t\t}\n\t\tif( Scope.isTemplateContextOrCanNotHaveProperties(currentScope) ) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\t// ### makeShouldExitOnSecondNormalContext\n\t// This will keep checking until we hit a second \"normal\" context.\n\tmakeShouldExitOnSecondNormalContext: function(){\n\t\tvar foundNormalContext = false;\n\t\treturn function shouldExitOnSecondNormalContext(currentScope){\n\t\t\tvar isNormalContext = !currentScope.isSpecial();\n\t\t\tvar shouldExit = isNormalContext && foundNormalContext;\n\t\t\t// leaks some state\n\t\t\tif(isNormalContext) {\n\t\t\t\tfoundNormalContext = true;\n\t\t\t}\n\t\t\treturn shouldExit;\n\t\t};\n\t},\n\t// ### makeShouldExitAfterFirstNormalContext\n\t// This will not check anything after the first normal context.\n\tmakeShouldExitAfterFirstNormalContext: function(){\n\t\tvar foundNormalContext = false;\n\t\treturn function shouldExitAfterFirstNormalContext(currentScope){\n\t\t\tif(foundNormalContext) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar isNormalContext = !currentScope.isSpecial();\n\t\t\t// leaks some state\n\t\t\tif(isNormalContext) {\n\t\t\t\tfoundNormalContext = true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t},\n\t// ### makeShouldSkipSpecialContexts\n\t// Skips `parentContextWalkCount` contexts. This is used to\n\t// walk past scopes when `../` is used.\n\tmakeShouldSkipSpecialContexts: function(parentContextWalkCount){\n\t\tvar walkCount = parentContextWalkCount || 0;\n\t\treturn function shouldSkipSpecialContexts(currentScope){\n\t\t\t// after walking past the correct number of contexts,\n\t\t\t// should not skip notContext scopes\n\t\t\t// so that ../foo can be used to read from a notContext scope\n\t\t\tif (walkCount < 0 && currentScope._meta.notContext) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif(currentScope.isSpecial()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\twalkCount--;\n\n\t\t\tif(walkCount < 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t}\n});\n\n// ## Prototype methods\nassign(Scope.prototype, {\n\n\t// ### scope.add\n\t// Creates a new scope and sets the current scope to be the parent.\n\t// ```\n\t// var scope = new can.view.Scope([\n\t//   {name:\"Chris\"},\n\t//   {name: \"Justin\"}\n\t// ]).add({name: \"Brian\"});\n\t// scope.attr(\"name\") //-> \"Brian\"\n\t// ```\n\tadd: function(context, meta) {\n\t\tif (context !== this._context) {\n\t\t\treturn new this.constructor(context, this, meta);\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t},\n\n\t// ### scope.find\n\t// This is the equivalent of Can 3's scope walking.\n\tfind: function(attr, options) {\n\n\t\tvar keyReads = stacheKey.reads(attr);\n\t\tvar howToRead = {\n\t\t\tshouldExit: returnFalse,\n\t\t\tshouldSkip: Scope.shouldSkipIfSpecial,\n\t\t\tshouldLookForHelper: true,\n\t\t\tread: stacheKey.read\n\t\t};\n\t\tvar result = this._walk(keyReads, options, howToRead);\n\n\t\treturn result.value;\n\n\t},\n\t// ### scope.readFromSpecialContext\n\treadFromSpecialContext: function(key) {\n\t\treturn this._walk(\n\t\t\t[{key: key, at: false }],\n\t\t\t{ special: true },\n\t\t\t{\n\t\t\t\tshouldExit: returnFalse,\n\t\t\t\tshouldSkip: Scope.shouldSkipEverythingButSpecial,\n\t\t\t\tshouldLookForHelper: false,\n\t\t\t\tread: stacheKey.read\n\t\t\t}\n\t\t);\n\t},\n\n\t// ### scope.readFromTemplateContext\n\treadFromTemplateContext: function(key, readOptions) {\n\t\tvar keyReads = stacheKey.reads(key);\n\t\treturn stacheKey.read(this.templateContext, keyReads, readOptions);\n\t},\n\n\t// ### Scope.prototype.read\n\t// Reads from the scope chain and returns the first non-`undefined` value.\n\t// `read` deals mostly with setting up \"context based\" keys to start reading\n\t// from the right scope. Once the right scope is located, `_walk` is called.\n\t/**\n\t * @hide\n\t * @param {can.stache.key} attr A dot-separated path. Use `\"\\.\"` if you have a property name that includes a dot.\n\t * @param {can.view.Scope.readOptions} options that configure how this gets read.\n\t * @return {{}}\n\t *   @option {Object} parent the value's immediate parent\n\t *   @option {can.Map|can.compute} rootObserve the first observable to read from.\n\t *   @option {Array<String>} reads An array of properties that can be used to read from the rootObserve to get the value.\n\t *   @option {*} value the found value\n\t */\n\tread: function(attr, options) {\n\t\toptions = options || {};\n\t\treturn this.readKeyInfo(Scope.keyInfo(attr), options || {});\n\t},\n\treadKeyInfo: function(keyInfo, options){\n\n\t\t// Identify context based keys. Context based keys try to\n\t\t// specify a particular context a key should be within.\n\t\tvar readValue,\n\t\t\tkeyReads,\n\t\t\thowToRead = {\n\t\t\t\tread: options.read || stacheKey.read\n\t\t\t};\n\n\t\t// 1.A. Handle reading the scope itself\n\t\tif (keyInfo.isScope) {\n\t\t\treturn { value: this };\n\t\t}\n\t\t// 1.B. Handle reading something on the scope\n\t\telse if (keyInfo.isInScope) {\n\t\t\tkeyReads = stacheKey.reads(keyInfo.remainingKey);\n\t\t\t// check for a value on Scope.prototype\n\t\t\treadValue = stacheKey.read(this, keyReads, options);\n\n\t\t\t// otherwise, check the templateContext\n\t\t\tif (typeof readValue.value === 'undefined' && !readValue.parentHasKey) {\n\t\t\t\treadValue = this.readFromTemplateContext(keyInfo.remainingKey, options);\n\t\t\t}\n\n\t\t\treturn assign(readValue, {\n\t\t\t\tthisArg: keyReads.length > 0 ? readValue.parent : undefined\n\t\t\t});\n\t\t}\n\t\t// 1.C. Handle context-based reads. They should skip over special stuff.\n\t\t// this.key, ../.., .././foo\n\t\telse if (keyInfo.isContextBased) {\n\t\t\t// TODO: REMOVE\n\t\t\t// options && options.special === true && console.warn(\"SPECIAL!!!!\");\n\n\t\t\tif(keyInfo.remainingKey !== \"this\") {\n\t\t\t\tkeyReads = stacheKey.reads(keyInfo.remainingKey);\n\t\t\t} else {\n\t\t\t\tkeyReads = [];\n\t\t\t}\n\t\t\thowToRead.shouldExit = Scope.makeShouldExitOnSecondNormalContext();\n\t\t\thowToRead.shouldSkip = Scope.makeShouldSkipSpecialContexts(keyInfo.parentContextWalkCount);\n\t\t\thowToRead.shouldLookForHelper = true;\n\n\t\t\treturn this._walk(keyReads, options, howToRead);\n\t\t}\n\t\t// 1.D. Handle scope walking with scope/key\n\t\telse if(keyInfo.walkScope) {\n\t\t\thowToRead.shouldExit = returnFalse;\n\t\t\thowToRead.shouldSkip = Scope.shouldSkipIfSpecial;\n\t\t\thowToRead.shouldLookForHelper = true;\n\t\t\tkeyReads = stacheKey.reads(keyInfo.remainingKey);\n\n\t\t\treturn this._walk(keyReads, options, howToRead);\n\t\t}\n\t\t// 1.E. Handle reading without context clues\n\t\t// {{foo}}\n\t\telse {\n\t\t\tkeyReads = stacheKey.reads(keyInfo.remainingKey);\n\n\t\t\tvar isSpecialRead = options && options.special === true;\n\t\t\t// TODO: remove\n\t\t\t// options && options.special === true && console.warn(\"SPECIAL!!!!\");\n\n\t\t\thowToRead.shouldExit = Scope.makeShouldExitOnSecondNormalContext();\n\t\t\thowToRead.shouldSkip = isSpecialRead ? Scope.shouldSkipEverythingButSpecial : Scope.shouldSkipIfSpecial;\n\t\t\thowToRead.shouldLookForHelper = isSpecialRead ? false : true;\n\n\t\t\treturn this._walk(keyReads, options, howToRead);\n\t\t}\n\t},\n\n\n\t// ### scope._walk\n\t// This is used to walk up the scope chain.\n\t_walk: function(keyReads, options, howToRead) {\n\t\t// The current scope and context we are trying to find \"keyReads\" within.\n\t\tvar currentScope = this,\n\t\t\tcurrentContext,\n\n\t\t\t// If no value can be found, this is a list of of every observed\n\t\t\t// object and property name to observe.\n\t\t\tundefinedObserves = [],\n\n\t\t\t// Tracks the first found observe.\n\t\t\tcurrentObserve,\n\t\t\t// Tracks the reads to get the value from `currentObserve`.\n\t\t\tcurrentReads,\n\n\t\t\t// Tracks the most likely observable to use as a setter.\n\t\t\tsetObserveDepth = -1,\n\t\t\tcurrentSetReads,\n\t\t\tcurrentSetObserve,\n\n\t\t\treadOptions = assign({\n\t\t\t\t/* Store found observable, incase we want to set it as the rootObserve. */\n\t\t\t\tfoundObservable: function(observe, nameIndex) {\n\t\t\t\t\tcurrentObserve = observe;\n\t\t\t\t\tcurrentReads = keyReads.slice(nameIndex);\n\t\t\t\t},\n\t\t\t\tearlyExit: function(parentValue, nameIndex) {\n\t\t\t\t\tvar isVariableScope = currentScope._meta.variable === true,\n\t\t\t\t\t\tupdateSetObservable = false;\n\t\t\t\t\tif(isVariableScope === true && nameIndex === 0) {\n\t\t\t\t\t\t// we MUST have pre-defined the key in a variable scope\n\t\t\t\t\t\tupdateSetObservable = canReflect.hasKey( parentValue, keyReads[nameIndex].key);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdateSetObservable =\n\t\t\t\t\t\t\t// Has more matches\n\t\t\t\t\t\t\tnameIndex > setObserveDepth ||\n\t\t\t\t\t\t\t// The same number of matches but it has the key\n\t\t\t\t\t\t\tnameIndex === setObserveDepth && (typeof parentValue === \"object\" && canReflect.hasOwnKey( parentValue, keyReads[nameIndex].key));\n\t\t\t\t\t}\n\t\t\t\t\tif ( updateSetObservable ) {\n\t\t\t\t\t\tcurrentSetObserve = currentObserve;\n\t\t\t\t\t\tcurrentSetReads = currentReads;\n\t\t\t\t\t\tsetObserveDepth = nameIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, options);\n\n\n\n\t\tvar isRecording = ObservationRecorder.isRecording(),\n\t\t\treadAContext = false;\n\n\t\t// Goes through each scope context provided until it finds the key (attr). Once the key is found\n\t\t// then it's value is returned along with an observe, the current scope and reads.\n\t\t// While going through each scope context searching for the key, each observable found is returned and\n\t\t// saved so that either the observable the key is found in can be returned, or in the case the key is not\n\t\t// found in an observable the closest observable can be returned.\n\t\twhile (currentScope) {\n\n\t\t\tif(howToRead.shouldSkip(currentScope) === true) {\n\t\t\t\tcurrentScope = currentScope._parent;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(howToRead.shouldExit(currentScope) === true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treadAContext = true;\n\n\t\t\tcurrentContext = currentScope._context;\n\n\n\t\t\t// Prevent computes from temporarily observing the reading of observables.\n\t\t\tvar getObserves = ObservationRecorder.trap();\n\n\t\t\tvar data = howToRead.read(currentContext, keyReads, readOptions);\n\n\t\t\t// Retrieve the observes that were read.\n\t\t\tvar observes = getObserves();\n\t\t\t// If a **value was was found**, return value and location data.\n\t\t\tif (data.value !== undefined || data.parentHasKey) {\n\n\t\t\t\tif(!observes.length && isRecording) {\n\t\t\t\t\t// if we didn't actually observe anything\n\t\t\t\t\t// the reads and currentObserve don't mean anything\n\t\t\t\t\t// we just point to the current object so setting is fast\n\t\t\t\t\tcurrentObserve = data.parent;\n\t\t\t\t\tcurrentReads = keyReads.slice(keyReads.length - 1);\n\t\t\t\t} else {\n\t\t\t\t\tObservationRecorder.addMany(observes);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tscope: currentScope,\n\t\t\t\t\trootObserve: currentObserve,\n\t\t\t\t\tvalue: data.value,\n\t\t\t\t\treads: currentReads,\n\t\t\t\t\tthisArg: data.parent,\n\t\t\t\t\tparentHasKey: data.parentHasKey\n\t\t\t\t};\n\t\t\t}\n\t\t\t// Otherwise, save all observables that were read. If no value\n\t\t\t// is found, we will observe on all of them.\n\t\t\telse {\n\t\t\t\tundefinedObserves.push.apply(undefinedObserves, observes);\n\t\t\t}\n\n\t\t\tcurrentScope = currentScope._parent;\n\t\t}\n\n\t\t// The **value was not found** in the scope\n\t\t// if not looking for a \"special\" key, check in can-stache-helpers\n\t\tif (howToRead.shouldLookForHelper) {\n\t\t\tvar helper = this.getHelperOrPartial(keyReads);\n\n\t\t\tif (helper && helper.value) {\n\t\t\t\t// Don't return parent so `.bind` is not used.\n\t\t\t\treturn {value: helper.value};\n\t\t\t}\n\t\t}\n\n\t\t// The **value was not found**, return `undefined` for the value.\n\t\t// Make sure we listen to everything we checked for when the value becomes defined.\n\t\t// Once it becomes defined, we won't have to listen to so many things.\n\t\tObservationRecorder.addMany(undefinedObserves);\n\t\treturn {\n\t\t\tsetRoot: currentSetObserve,\n\t\t\treads: currentSetReads,\n\t\t\tvalue: undefined,\n\t\t\tnoContextAvailable: !readAContext\n\t\t};\n\t},\n\t// ### scope.getDataForScopeSet\n\t// Returns an object with data needed by `.set` to figure out what to set,\n\t// and how.\n\t// {\n\t//   parent: what is being set\n\t//   key: try setting a key value\n\t//   how: \"setValue\" | \"set\" | \"updateDeep\" | \"write\" | \"setKeyValue\"\n\t// }\n\t// This works by changing how `readKeyInfo` will read individual scopes.\n\t// Specifically, with something like `{{foo.bar}}` it will read `{{foo}}` and\n\t// only check if a `bar` property exists.\n\tgetDataForScopeSet: function getDataForScopeSet(key, options) {\n\t\tvar keyInfo = Scope.keyInfo(key);\n\t\tvar firstSearchedContext;\n\n\t\t// Overwrite the options to use this read.\n\t\tvar opts = assign({\n\t\t\t// This read is used by `._walk` to read from the scope.\n\t\t\t// This will use `hasKey` on the last property instead of reading it.\n\t\t\tread: function(context, keys){\n\n\t\t\t\t// If nothing can be found with the keys we are looking for, save the\n\t\t\t\t// first possible match.  This is where we will write to.\n\t\t\t\tif(firstSearchedContext === undefined && !(context instanceof LetContext)) {\n\t\t\t\t\tfirstSearchedContext = context;\n\t\t\t\t}\n\t\t\t\t// If we have multiple keys ...\n\t\t\t\tif(keys.length > 1) {\n\t\t\t\t\t// see if we can find the parent ...\n\t\t\t\t\tvar parentKeys = keys.slice(0, keys.length-1);\n\t\t\t\t\tvar parent = stacheKey.read(context, parentKeys, options).value;\n\n\t\t\t\t\t// If there is a parent, see if it has the last key\n\t\t\t\t\tif( parent != null && canReflect.hasKey(parent, keys[keys.length-1].key ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tparent: parent,\n\t\t\t\t\t\t\tparentHasKey: true,\n\t\t\t\t\t\t\tvalue: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If we have only one key, try to find a context with this key\n\t\t\t\telse if(keys.length === 1) {\n\t\t\t\t\tif( canReflect.hasKey(context, keys[0].key ) ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tparent: context,\n\t\t\t\t\t\t\tparentHasKey: true,\n\t\t\t\t\t\t\tvalue: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If we have no keys, we are reading `this`.\n\t\t\t\telse {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: context\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t},options);\n\n\n\t\t// Use the read above to figure out what we are probably writing to.\n\t\tvar readData = this.readKeyInfo(keyInfo, opts);\n\n\t\tif(keyInfo.remainingKey === \"this\") {\n\t\t\t// If we are setting a context, then return that context\n\t\t\treturn { parent: readData.value, how: \"setValue\" };\n\t\t}\n\t\t// Now we are trying to set a property on something.  Parent will\n\t\t// be the something we are setting a property on.\n\t\tvar parent;\n\n\t\tvar props = keyInfo.remainingKey.split(\".\");\n\t\tvar propName = props.pop();\n\n\t\t// If we got a `thisArg`, that's the parent.\n\t\tif(readData.thisArg) {\n\t\t\tparent = readData.thisArg;\n\t\t}\n\t\t// Otherwise, we didn't find anything, use the first searched context.\n\t\t// TODO: there is likely a bug here when trying to set foo.bar where nothing in the scope\n\t\t// has a foo.\n\t\telse if(firstSearchedContext) {\n\t\t\tparent = firstSearchedContext;\n\t\t}\n\n\t\tif (parent === undefined) {\n\t\t\treturn {\n\t\t\t\terror: \"Attempting to set a value at \" +\n\t\t\t\t\tkey + \" where the context is undefined.\"\n\t\t\t};\n\t\t}\n\t\t// Now we need to figure out how we would update this value.  The following does that.\n\t\tif(!canReflect.isObservableLike(parent) && canReflect.isObservableLike(parent[propName])) {\n\t\t\tif(canReflect.isMapLike(parent[propName])) {\n\t\t\t\treturn {\n\t\t\t\t\tparent: parent,\n\t\t\t\t\tkey: propName,\n\t\t\t\t\thow: \"updateDeep\",\n\t\t\t\t\twarn: \"can-view-scope: Merging data into \\\"\" +\n\t\t\t\t\t\tpropName + \"\\\" because its parent is non-observable\"\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if(canReflect.isValueLike(parent[propName])){\n\t\t\t\treturn { parent: parent, key: propName, how: \"setValue\" };\n\t\t\t} else {\n\t\t\t\treturn { parent: parent, how: \"write\", key: propName, passOptions: true };\n\t\t\t}\n\t\t} else {\n\t\t\treturn { parent: parent, how: \"write\", key: propName, passOptions: true };\n\t\t}\n\t},\n\n\t// ### scope.getHelper\n\t// read a helper from the templateContext or global helpers list\n\tgetHelper: function(keyReads) {\n\t\tconsole.warn(\".getHelper is deprecated, use .getHelperOrPartial\");\n\t\treturn this.getHelperOrPartial(keyReads);\n\t},\n\tgetHelperOrPartial: function(keyReads) {\n\t\t// try every template context\n\t\tvar scope = this, context, helper;\n\t\twhile (scope) {\n\t\t\tcontext = scope._context;\n\t\t\tif (context instanceof TemplateContext) {\n\t\t\t\thelper = stacheKey.read(context.helpers, keyReads, { proxyMethods: false });\n\t\t\t\tif(helper.value !== undefined) {\n\t\t\t\t\treturn helper;\n\t\t\t\t}\n\t\t\t\thelper = stacheKey.read(context.partials, keyReads, { proxyMethods: false });\n\t\t\t\tif(helper.value !== undefined) {\n\t\t\t\t\treturn helper;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscope = scope._parent;\n\t\t}\n\n\t\treturn stacheKey.read(stacheHelpers, keyReads, { proxyMethods: false });\n\t},\n\n\t// ### scope.get\n\t// Gets a value from the scope without being observable.\n\tget: function(key, options) {\n\n\t\toptions = assign({\n\t\t\tisArgument: true\n\t\t}, options);\n\n\t\tvar res = this.read(key, options);\n\t\treturn res.value;\n\t},\n\tpeek: ObservationRecorder.ignore(function(key, options) {\n\t\treturn this.get(key, options);\n\t}),\n\t// TODO: Remove in 6.0\n\tpeak: ObservationRecorder.ignore(function(key, options) {\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tcanLog.warn('peak is deprecated, please use peek instead');\n\t\t}\n\t\t//!steal-remove-end\n\t\treturn this.peek(key, options);\n\t}),\n\t// ### scope.getScope\n\t// Returns the first scope that passes the `tester` function.\n\tgetScope: function(tester) {\n\t\tvar scope = this;\n\t\twhile (scope) {\n\t\t\tif (tester(scope)) {\n\t\t\t\treturn scope;\n\t\t\t}\n\t\t\tscope = scope._parent;\n\t\t}\n\t},\n\t// ### scope.getContext\n\t// Returns the first context whose scope passes the `tester` function.\n\tgetContext: function(tester) {\n\t\tvar res = this.getScope(tester);\n\t\treturn res && res._context;\n\t},\n\t// ### scope.getTemplateContext\n\t// Returns the template context\n\tgetTemplateContext: function() {\n\t\tvar lastScope;\n\n\t\t// find the first reference scope\n\t\tvar templateContext = this.getScope(function(scope) {\n\t\t\tlastScope = scope;\n\t\t\treturn scope._context instanceof TemplateContext;\n\t\t});\n\n\t\t// if there is no reference scope, add one as the root\n\t\tif(!templateContext) {\n\t\t\ttemplateContext = new Scope(new TemplateContext());\n\n\t\t\t// add templateContext to root of the scope chain so it\n\t\t\t// can be found using `getScope` next time it is looked up\n\t\t\tlastScope._parent = templateContext;\n\t\t}\n\t\treturn templateContext;\n\t},\n\taddTemplateContext: function(){\n\t\treturn this.add(new TemplateContext());\n\t},\n\taddLetContext: function(values){\n\t\treturn this.add(new LetContext(values || {}), {variable: true});\n\t},\n\t// ### scope.getRoot\n\t// Returns the top most context that is not a references scope.\n\t// Used by `.read` to provide `%root`.\n\tgetRoot: function() {\n\t\tvar cur = this,\n\t\t\tchild = this;\n\n\t\twhile (cur._parent) {\n\t\t\tchild = cur;\n\t\t\tcur = cur._parent;\n\t\t}\n\n\t\tif (cur._context instanceof TemplateContext) {\n\t\t\tcur = child;\n\t\t}\n\t\treturn cur._context;\n\t},\n\n\t// first viewModel scope\n\tgetViewModel: function() {\n\t\tvar vmScope = this.getScope(function(scope) {\n\t\t\treturn scope._meta.viewModel;\n\t\t});\n\n\t\treturn vmScope && vmScope._context;\n\t},\n\n\t// _top_ viewModel scope\n\tgetTop: function() {\n\t\tvar top;\n\n\t\tthis.getScope(function(scope) {\n\t\t\tif (scope._meta.viewModel) {\n\t\t\t\ttop = scope;\n\t\t\t}\n\n\t\t\t// walk entire scope tree\n\t\t\treturn false;\n\t\t});\n\n\t\treturn top && top._context;\n\t},\n\n\t// ### scope.getPathsForKey\n\t// Finds all paths that will return a value for a specific key\n\t// NOTE: this is for development purposes only and is removed in production\n\tgetPathsForKey: function getPathsForKey(key) {\n\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tvar paths = {};\n\n\t\t\tvar getKeyDefinition = function(obj, key) {\n\t\t\t\tif (!obj || typeof obj !== \"object\") {\n\t\t\t\t\treturn {};\n\t\t\t\t}\n\n\t\t\t\tvar keyExistsOnObj = key in obj;\n\t\t\t\tvar objHasKey = canReflect.hasKey(obj, key);\n\n\t\t\t\treturn {\n\t\t\t\t\tisDefined: keyExistsOnObj || objHasKey,\n\t\t\t\t\tisFunction: keyExistsOnObj && typeof obj[key] === \"function\"\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// scope.foo@bar -> bar\n\t\t\tvar reads = stacheKey.reads(key);\n\t\t\tvar keyParts = reads.map(function(read) {\n\t\t\t\treturn read.key;\n\t\t\t});\n\t\t\tvar scopeIndex = keyParts.indexOf(\"scope\");\n\n\t\t\tif (scopeIndex > -1) {\n\t\t\t\tkeyParts.splice(scopeIndex, 2);\n\t\t\t}\n\t\t\tvar normalizedKey = keyParts.join(\".\");\n\n\t\t\t// check scope.vm.<key>\n\t\t\tvar vm = this.getViewModel();\n\t\t\tvar vmKeyDefinition = getKeyDefinition(vm, normalizedKey);\n\n\t\t\tif (vmKeyDefinition.isDefined) {\n\t\t\t\tpaths[\"scope.vm.\" + normalizedKey + (vmKeyDefinition.isFunction ? \"()\" : \"\")] = vm;\n\t\t\t}\n\n\t\t\t// check scope.top.<key>\n\t\t\tvar top = this.getTop();\n\t\t\tvar topKeyDefinition = getKeyDefinition(top, normalizedKey);\n\n\t\t\tif (topKeyDefinition.isDefined) {\n\t\t\t\tpaths[\"scope.top.\" + normalizedKey + (topKeyDefinition.isFunction ? \"()\" : \"\")] = top;\n\t\t\t}\n\n\t\t\t// find specific paths (like ../key)\n\t\t\tvar cur = \"\";\n\n\t\t\tthis.getScope(function(scope) {\n\t\t\t\t// `notContext` and `special` contexts can't be read using `../`\n\t\t\t\tvar canBeRead = !scope.isSpecial();\n\n\t\t\t\tif (canBeRead) {\n\t\t\t\t\tvar contextKeyDefinition = getKeyDefinition(scope._context, normalizedKey);\n\t\t\t\t\tif (contextKeyDefinition.isDefined) {\n\t\t\t\t\t\tpaths[cur + normalizedKey + (contextKeyDefinition.isFunction ? \"()\" : \"\")] = scope._context;\n\t\t\t\t\t}\n\n\t\t\t\t\tcur += \"../\";\n\t\t\t\t}\n\n\t\t\t\t// walk entire scope tree\n\t\t\t\treturn false;\n\t\t\t});\n\n\t\t\treturn paths;\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\n\t// ### scope.hasKey\n\t// returns whether or not this scope has the key\n\thasKey: function hasKey(key) {\n\t\tvar reads = stacheKey.reads(key);\n\t\tvar readValue;\n\n\t\tif (reads[0].key === \"scope\") {\n\t\t\t// read properties like `scope.vm.foo` directly from the scope\n\t\t\treadValue = stacheKey.read(this, reads.slice(1), key);\n\t\t} else {\n\t\t\t// read normal properties from the scope's context\n\t\t\treadValue = stacheKey.read(this._context, reads, key);\n\t\t}\n\n\t\treturn readValue.foundLastParent && readValue.parentHasKey;\n\t},\n\n\tset: function(key, value, options) {\n\t\toptions = options || {};\n\n\t\tvar data = this.getDataForScopeSet(key, options);\n\t\tvar parent = data.parent;\n\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tif (data.error) {\n\t\t\t\treturn canLog.error(data.error);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tif (data.warn) {\n\t\t\tcanLog.warn(data.warn);\n\t\t}\n\n\t\tswitch (data.how) {\n\t\t\tcase \"set\":\n\t\t\t\tparent.set(data.key, value, data.passOptions ? options : undefined);\n\t\t\t\tbreak;\n\n\t\t\tcase \"write\":\n\t\t\t\tstacheKey.write(parent, data.key, value, options);\n\t\t\t\tbreak;\n\n\t\t\tcase \"setValue\":\n\t\t\t\tcanReflect.setValue(\"key\" in data ? parent[data.key] : parent, value);\n\t\t\t\tbreak;\n\n\t\t\tcase \"setKeyValue\":\n\t\t\t\tcanReflect.setKeyValue(parent, data.key, value);\n\t\t\t\tbreak;\n\n\t\t\tcase \"updateDeep\":\n\t\t\t\tcanReflect.updateDeep(parent[data.key], value);\n\t\t\t\tbreak;\n\t\t}\n\t},\n\n\t// ### scope.attr\n\t// Gets or sets a value in the scope without being observable.\n\tattr: ObservationRecorder.ignore(function(key, value, options) {\n\t\tcanLog.warn(\"can-view-scope::attr is deprecated, please use peek, get or set\");\n\n\t\toptions = assign({\n\t\t\tisArgument: true\n\t\t}, options);\n\n\t\t// Allow setting a value on the context\n\t\tif (arguments.length === 2) {\n\t\t\treturn this.set(key, value, options);\n\n\t\t} else {\n\t\t\treturn this.get(key, options);\n\t\t}\n\t}),\n\n\t// ### scope.computeData\n\t// Finds the first location of the key in the scope and then provides a get-set compute that represents the key's value\n\t// and other information about where the value was found.\n\tcomputeData: function(key, options) {\n\t\treturn makeComputeData(this, key, options);\n\t},\n\n\t// ### scope.compute\n\t// Provides a get-set compute that represents a key's value.\n\tcompute: function(key, options) {\n\t\treturn this.computeData(key, options)\n\t\t\t.compute;\n\t},\n\t// ### scope.cloneFromRef\n\t//\n\t// This takes a scope and essentially copies its chain from\n\t// right before the last TemplateContext. And it does not include the ref.\n\t// this is a helper function to provide lexical semantics for refs.\n\t// This will not be needed for leakScope: false.\n\tcloneFromRef: function() {\n\t\tvar scopes = [];\n\t\tvar scope = this,\n\t\t\tcontext,\n\t\t\tparent;\n\t\twhile (scope) {\n\t\t\tcontext = scope._context;\n\t\t\tif (context instanceof TemplateContext) {\n\t\t\t\tparent = scope._parent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tscopes.unshift(scope);\n\t\t\tscope = scope._parent;\n\t\t}\n\t\tif (parent) {\n\t\t\tscopes.forEach(function(scope) {\n\t\t\t\t// For performance, re-use _meta, don't copy it.\n\t\t\t\tparent = parent.add(scope._context, scope._meta);\n\t\t\t});\n\t\t\treturn parent;\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t},\n\tisSpecial: function(){\n\t\treturn this._meta.notContext || this._meta.special || (this._context instanceof TemplateContext) || this._meta.variable;\n\t}\n});\n// Legacy name for _walk.\nScope.prototype._read = Scope.prototype._walk;\n\ncanReflect.assignSymbols(Scope.prototype, {\n\t\"can.hasKey\": Scope.prototype.hasKey\n});\n\nvar templateContextPrimitives = [\n\t\"filename\", \"lineNumber\"\n];\n\n// create getters/setters for primitives on the templateContext\n// scope.filename -> scope.readFromTemplateContext(\"filename\")\ntemplateContextPrimitives.forEach(function(key) {\n\tObject.defineProperty(Scope.prototype, key, {\n\t\tget: function() {\n\t\t\treturn this.readFromTemplateContext(key).value;\n\t\t},\n\t\tset: function(val) {\n\t\t\tthis.templateContext[key] = val;\n\t\t}\n\t});\n});\n\ndefineLazyValue(Scope.prototype, 'templateContext', function() {\n\treturn this.getTemplateContext()._context;\n});\n\ndefineLazyValue(Scope.prototype, 'root', function() {\n\tcanLog.warn('`scope.root` is deprecated. Use either `scope.top` or `scope.vm` instead.');\n\treturn this.getRoot();\n});\n\ndefineLazyValue(Scope.prototype, 'vm', function() {\n\treturn this.getViewModel();\n});\n\ndefineLazyValue(Scope.prototype, 'top', function() {\n\treturn this.getTop();\n});\n\ndefineLazyValue(Scope.prototype, 'helpers', function() {\n\treturn stacheHelpers;\n});\n\nvar specialKeywords = [\n\t'index', 'key', 'element',\n\t'event', 'viewModel','arguments',\n\t'helperOptions'\n];\n\n// create getters for \"special\" keys\n// scope.index -> scope.readFromSpecialContext(\"index\")\nspecialKeywords.forEach(function(key) {\n\tObject.defineProperty(Scope.prototype, key, {\n\t\tget: function() {\n\t\t\treturn this.readFromSpecialContext(key).value;\n\t\t}\n\t});\n});\n\n\n//!steal-remove-start\nif (process.env.NODE_ENV !== 'production') {\n\tScope.prototype.log = function() {\n\t\tvar scope = this;\n\t    var indent = \"\";\n\t\tvar contextType = \"\";\n\t\twhile(scope) {\n\t\t\tcontextType = scope._meta.notContext ? \" (notContext)\" :\n\t\t\t\tscope._meta.special ? \" (special)\" : \"\";\n\t\t\tconsole.log(indent, canReflect.getName(scope._context) + contextType, scope._context);\n\t        scope = scope._parent;\n\t        indent += \" \";\n\t    }\n\t};\n}\n//!steal-remove-end\n\n\nnamespace.view = namespace.view || {};\nmodule.exports = namespace.view.Scope = Scope;\n"],"names":["TemplateContext","options","this","vars","SimpleMap","helpers","partials","tags","Compute","newVal","arguments","length","canReflect","setValue","getValue","observable","compute","bind","process","env","NODE_ENV","Object","defineProperty","value","getName","on","addEventListener","event","handler","translationHandler","oldVal","call","type","singleReference","set","off","unbind","removeEventListener","getAndDelete","assignSymbols","can.getValue","can.setValue","can.onValue","queue","onValue","can.offValue","offValue","can.valueHasDependencies","valueHasDependencies","can.getPriority","getPriority","can.setPriority","newPriority","setPriority","can.isValueLike","can.isFunctionLike","isComputed","namespace","stacheHelpers","Error","module","dispatchSymbol","canSymbol","for","peekValue","ObservationRecorder","ignore","getFastPathRoot","computeData","reads","root","isObservableLike","isMapLike","key","isEventObject","obj","batchNum","callMutateWithRightArgs","method","mutated","mutator","canReflectDeps","ScopeKeyData","scope","startingScope","read","dispatch","_context","helperOptions","debuggerHelper","observation","Observation","assign","fastPath","undefined","initialValue","setRoot","_thisArg","SimpleObservable","parentHasKey","valueDependencies","Set","add","dependencies","fastOnBoundSet_Value","_value","fastOnBoundSetValue","valueEventBindings","prototype","constructor","old","onBound","bound","fastPathRoot","toFastPath","onUnbound","toSlowPath","observeReader","write","get","isRecording","temporarilyBind","self","dependencyChange","target","apply","hasOwnProperty","data","deleteMutatedBy","thisArg","parent","valueDeps","addMutatedBy","rootObserve","rootValueDeps","hasDependencies","scopeKeyDataPrototype","can.getValueDependencies","makeComputeLike","writable","configurable","args","canHaveProperties","returnFalse","LetContext","extend","Scope","context","meta","_parent","_meta","__cache","parentContextSearch","stacheKey","keyInfo","attr","info","remainingKey","isScope","firstSix","substr","isInScope","walkScope","parentContextWalkCount","replace","token","parentContext","dotSlash","thisContext","index","isContextBased","isTemplateContextOrCanNotHaveProperties","currentScope","currentContext","shouldSkipIfSpecial","special","shouldSkipEverythingButSpecial","makeShouldExitOnSecondNormalContext","foundNormalContext","isNormalContext","isSpecial","shouldExit","makeShouldExitAfterFirstNormalContext","makeShouldSkipSpecialContexts","walkCount","notContext","find","keyReads","howToRead","shouldSkip","shouldLookForHelper","_walk","readFromSpecialContext","at","readFromTemplateContext","readOptions","templateContext","readKeyInfo","readValue","isSpecialRead","currentObserve","currentReads","currentSetReads","currentSetObserve","undefinedObserves","setObserveDepth","foundObservable","observe","nameIndex","slice","earlyExit","parentValue","variable","hasKey","hasOwnKey","readAContext","getObserves","trap","observes","addMany","push","helper","getHelperOrPartial","noContextAvailable","getDataForScopeSet","firstSearchedContext","opts","keys","parentKeys","readData","how","propName","split","pop","error","warn","isValueLike","passOptions","getHelper","console","proxyMethods","isArgument","peek","peak","canLog","getScope","tester","getContext","res","getTemplateContext","lastScope","addTemplateContext","addLetContext","values","getRoot","cur","child","getViewModel","vmScope","viewModel","getTop","top","getPathsForKey","paths","getKeyDefinition","keyExistsOnObj","objHasKey","isDefined","isFunction","keyParts","map","scopeIndex","indexOf","splice","normalizedKey","join","vm","vmKeyDefinition","topKeyDefinition","contextKeyDefinition","foundLastParent","setKeyValue","updateDeep","makeComputeData","cloneFromRef","scopes","unshift","forEach","_read","can.hasKey","templateContextPrimitives","val","defineLazyValue","specialKeywords","log","indent","contextType","view"],"mappings":"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"}