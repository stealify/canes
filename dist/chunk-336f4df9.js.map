{"version":3,"file":"chunk-336f4df9.js","sources":["../node_modules/can-stache/src/html_section.js","../node_modules/can-stache/src/text_section.js","../node_modules/can-stache/src/mustache_core.js","../node_modules/can-stache/helpers/converter.js","../node_modules/can-stache-ast/controls.js","../node_modules/can-stache-ast/can-stache-ast.js","../node_modules/can-stache/can-stache.js"],"sourcesContent":["\"use strict\";\nvar target = require('can-view-target');\nvar utils = require('./utils');\nvar getDocument = require(\"can-globals/document/document\");\n\nvar assign = require('can-assign');\n\n\nvar last = utils.last;\n\nvar decodeHTML = typeof document !== \"undefined\" && (function(){\n\tvar el = getDocument().createElement('div');\n\treturn function(html){\n\t\tif(html.indexOf(\"&\") === -1) {\n\t\t\treturn html.replace(/\\r\\n/g,\"\\n\");\n\t\t}\n\t\tel.innerHTML = html;\n\t\treturn el.childNodes.length === 0 ? \"\" : el.childNodes.item(0).nodeValue;\n\t};\n})();\n// ## HTMLSectionBuilder\n//\n// Contains a stack of HTMLSections.\n// An HTMLSection is created everytime a subsection is found. For example:\n//\n//     {{#if(items)}} {{#items}} X\n//\n// At the point X was being processed, there would be 2 HTMLSections in the\n// stack.  One for the content of `{{#if(items)}}` and the other for the\n// content of `{{#items}}`\nvar HTMLSectionBuilder = function(filename){\n\tif (filename) {\n\t\tthis.filename = filename;\n\t}\n\tthis.stack = [new HTMLSection()];\n};\n\n\nassign(HTMLSectionBuilder.prototype,utils.mixins);\n\nassign(HTMLSectionBuilder.prototype,{\n\tstartSubSection: function(process){\n\t\tvar newSection = new HTMLSection(process);\n\t\tthis.stack.push(newSection);\n\t\treturn newSection;\n\t},\n\t// Ends the current section and returns a renderer.\n\t// But only returns a renderer if there is a template.\n\tendSubSectionAndReturnRenderer: function(){\n\t\tif(this.last().isEmpty()) {\n\t\t\tthis.stack.pop();\n\t\t\treturn null;\n\t\t} else {\n\t\t\tvar htmlSection = this.endSection();\n\t\t\treturn utils.makeView(htmlSection.compiled.hydrate.bind(htmlSection.compiled));\n\t\t}\n\t},\n\tstartSection: function( process ) {\n\t\tvar newSection = new HTMLSection(process);\n\t\tthis.last().add(newSection.targetCallback);\n\t\t// adding a section within a section ...\n\t\t// the stack has section ...\n\t\tthis.stack.push(newSection);\n\t},\n\tendSection: function(){\n\t\tthis.last().compile();\n\t\treturn this.stack.pop();\n\t},\n\tinverse: function(){\n\t\tthis.last().inverse();\n\t},\n\tcompile: function(){\n\t\tvar compiled = this.stack.pop().compile();\n\t\t// ignore observations here.  the render fn\n\t\t//  itself doesn't need to be observable.\n\t\treturn utils.makeView( compiled.hydrate.bind(compiled) );\n\t},\n\tpush: function(chars){\n\t\tthis.last().push(chars);\n\t},\n\tpop: function(){\n\t\treturn this.last().pop();\n\t},\n\tremoveCurrentNode: function() {\n\t\tthis.last().removeCurrentNode();\n\t}\n});\n\nvar HTMLSection = function(process){\n\tthis.data = \"targetData\";\n\tthis.targetData = [];\n\t// A record of what targetData element we are within.\n\tthis.targetStack = [];\n\tvar self = this;\n\tthis.targetCallback = function(scope, sectionNode){\n\t\tprocess.call(this,\n\t\t\tscope,\n\t\t\tsectionNode,\n\t\t\tself.compiled.hydrate.bind(self.compiled),\n\t\t\tself.inverseCompiled && self.inverseCompiled.hydrate.bind(self.inverseCompiled)  ) ;\n\t};\n};\nassign(HTMLSection.prototype,{\n\tinverse: function(){\n\t\tthis.inverseData = [];\n\t\tthis.data = \"inverseData\";\n\t},\n\t// Adds a DOM node.\n\tpush: function(data){\n\t\tthis.add(data);\n\t\tthis.targetStack.push(data);\n\t},\n\tpop: function(){\n\t\treturn this.targetStack.pop();\n\t},\n\tadd: function(data){\n\t\tif(typeof data === \"string\"){\n\t\t\tdata = decodeHTML(data);\n\t\t}\n\t\tif(this.targetStack.length) {\n\t\t\tlast(this.targetStack).children.push(data);\n\t\t} else {\n\t\t\tthis[this.data].push(data);\n\t\t}\n\t},\n\tcompile: function(){\n\t\tthis.compiled = target(this.targetData, getDocument());\n\t\tif(this.inverseData) {\n\t\t\tthis.inverseCompiled = target(this.inverseData, getDocument());\n\t\t\tdelete this.inverseData;\n\t\t}\n\t\tthis.targetStack = this.targetData = null;\n\t\treturn this.compiled;\n\t},\n\tremoveCurrentNode: function() {\n\t\tvar children = this.children();\n\t\treturn children.pop();\n\t},\n\tchildren: function(){\n\t\tif(this.targetStack.length) {\n\t\t\treturn last(this.targetStack).children;\n\t\t} else {\n\t\t\treturn this[this.data];\n\t\t}\n\t},\n\t// Returns if a section is empty\n\tisEmpty: function(){\n\t\treturn !this.targetData.length;\n\t}\n});\nHTMLSectionBuilder.HTMLSection = HTMLSection;\n\nmodule.exports = HTMLSectionBuilder;\n","\"use strict\";\nvar live = require('can-view-live');\n\nvar utils = require('./utils');\n\nvar domMutate = require(\"can-dom-mutate/node\");\n\nvar assign = require('can-assign');\n\nvar canReflect = require(\"can-reflect\");\nvar Observation = require(\"can-observation\");\n\nvar noop = function(){};\n\nvar TextSectionBuilder = function(){\n\tthis.stack = [new TextSection()];\n};\n\nassign(TextSectionBuilder.prototype,utils.mixins);\n\nassign(TextSectionBuilder.prototype,{\n\t// Adds a subsection.\n\tstartSection: function(process){\n\t\tvar subSection = new TextSection();\n\t\tthis.last().add({process: process, truthy: subSection});\n\t\tthis.stack.push(subSection);\n\t},\n\tendSection: function(){\n\t\tthis.stack.pop();\n\t},\n\tinverse: function(){\n\t\tthis.stack.pop();\n\t\tvar falseySection = new TextSection();\n\t\tthis.last().last().falsey = falseySection;\n\t\tthis.stack.push(falseySection);\n\t},\n\tcompile: function(state){\n\n\t\tvar renderer = this.stack[0].compile();\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tObject.defineProperty(renderer,\"name\",{\n\t\t\t\tvalue: \"textSectionRenderer<\"+state.tag+\".\"+state.attr+\">\"\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\n\t\treturn function(scope){\n\t\t\tfunction textSectionRender(){\n\t\t\t\treturn renderer(scope);\n\t\t\t}\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tObject.defineProperty(textSectionRender,\"name\",{\n\t\t\t\t\tvalue: \"textSectionRender<\"+state.tag+\".\"+state.attr+\">\"\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tvar observation = new Observation(textSectionRender, null, {isObservable: false});\n\n\t\t\tcanReflect.onValue(observation, noop);\n\n\t\t\tvar value = canReflect.getValue(observation);\n\t\t\tif( canReflect.valueHasDependencies( observation ) ) {\n\t\t\t\tif(state.textContentOnly) {\n\t\t\t\t\tlive.text(this, observation);\n\t\t\t\t}\n\t\t\t\telse if(state.attr) {\n\t\t\t\t\tlive.attr(this, state.attr, observation);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlive.attrs(this, observation, scope);\n\t\t\t\t}\n\t\t\t\tcanReflect.offValue(observation, noop);\n\t\t\t} else {\n\t\t\t\tif(state.textContentOnly) {\n\t\t\t\t\tthis.nodeValue = value;\n\t\t\t\t}\n\t\t\t\telse if(state.attr) {\n\t\t\t\t\tdomMutate.setAttribute.call(this, state.attr, value);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlive.attrs(this, value);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\nvar passTruthyFalsey = function(process, truthy, falsey){\n\treturn function(scope){\n\t\treturn process.call(this, scope, truthy, falsey);\n\t};\n};\n\nvar TextSection = function(){\n\tthis.values = [];\n};\n\nassign( TextSection.prototype, {\n\tadd: function(data){\n\t\tthis.values.push(data);\n\t},\n\tlast: function(){\n\t\treturn this.values[this.values.length - 1];\n\t},\n\tcompile: function(){\n\t\tvar values = this.values,\n\t\t\tlen = values.length;\n\n\t\tfor(var i = 0 ; i < len; i++) {\n\t\t\tvar value = this.values[i];\n\t\t\tif(typeof value === \"object\") {\n\t\t\t\tvalues[i] = passTruthyFalsey( value.process,\n\t\t\t\t    value.truthy && value.truthy.compile(),\n\t\t\t\t    value.falsey && value.falsey.compile());\n\t\t\t}\n\t\t}\n\n\t\treturn function(scope){\n\t\t\tvar txt = \"\",\n\t\t\t\tvalue;\n\t\t\tfor(var i = 0; i < len; i++){\n\t\t\t\tvalue = values[i];\n\t\t\t\ttxt += typeof value === \"string\" ? value : value.call(this, scope);\n\t\t\t}\n\t\t\treturn txt;\n\t\t};\n\t}\n});\n\nmodule.exports = TextSectionBuilder;\n","\"use strict\";\n//\n// This provides helper utilities for Mustache processing. Currently,\n// only stache uses these helpers.  Ideally, these utilities could be used\n// in other libraries implementing Mustache-like features.\nvar live = require('can-view-live');\nvar nodeLists = require('can-view-nodelist');\n\nvar Observation = require('can-observation');\nvar ObservationRecorder = require('can-observation-recorder');\nvar utils = require('./utils');\nvar expression = require('./expression');\nvar frag = require(\"can-fragment\");\nvar domMutate = require(\"can-dom-mutate\");\nvar canSymbol = require(\"can-symbol\");\nvar canReflect = require(\"can-reflect\");\nvar dev = require(\"can-log/dev/dev\");\nvar getDocument = require(\"can-globals/document/document\");\nvar defineLazyValue = require(\"can-define-lazy-value\");\n\nvar toDOMSymbol = canSymbol.for(\"can.toDOM\");\n\n// Lazily lookup the context only if it's needed.\nfunction HelperOptions(scope, nodeList, exprData, stringOnly) {\n\tthis.metadata = { rendered: false };\n\tthis.stringOnly = stringOnly;\n\tthis.scope = scope;\n\tthis.nodeList = nodeList;\n\tthis.exprData = exprData;\n}\ndefineLazyValue(HelperOptions.prototype,\"context\", function(){\n\treturn this.scope.peek(\"this\");\n});\n\n\n\n\n// ## Helpers\n\nvar mustacheLineBreakRegExp = /(?:(^|\\r?\\n)(\\s*)(\\{\\{([\\s\\S]*)\\}\\}\\}?)([^\\S\\n\\r]*)($|\\r?\\n))|(\\{\\{([\\s\\S]*)\\}\\}\\}?)/g,\n\tmustacheWhitespaceRegExp = /(\\s*)(\\{\\{\\{?)(-?)([\\s\\S]*?)(-?)(\\}\\}\\}?)(\\s*)/g,\n\tk = function(){};\nvar viewInsertSymbol = canSymbol.for(\"can.viewInsert\");\n\n\n// DOM, safeString or the insertSymbol can opt-out of updating as text\nfunction valueShouldBeInsertedAsHTML(value) {\n\treturn value !== null && typeof value === \"object\" && (\n\t\ttypeof value[toDOMSymbol] === \"function\" ||\n\t\ttypeof value[viewInsertSymbol] === \"function\" ||\n\t\ttypeof value.nodeType === \"number\" );\n}\n\n\n\n\nvar core = {\n\texpression: expression,\n\t// ## mustacheCore.makeEvaluator\n\t// Given a scope and expression, returns a function that evaluates that expression in the scope.\n\t//\n\t// This function first reads lookup values in the args and hash.  Then it tries to figure out\n\t// if a helper is being called or a value is being read.  Finally, depending on\n\t// if it's a helper, or not, and which mode the expression is in, it returns\n\t// a function that can quickly evaluate the expression.\n\t/**\n\t * @hide\n\t * Given a mode and expression data, returns a function that evaluates that expression.\n\t * @param {can-view-scope} The scope in which the expression is evaluated.\n\t * @param {can.view.Options} The option helpers in which the expression is evaluated.\n\t * @param {String} mode Either null, #, ^. > is handled elsewhere\n\t * @param {Object} exprData Data about what was in the mustache expression\n\t * @param {renderer} [truthyRenderer] Used to render a subsection\n\t * @param {renderer} [falseyRenderer] Used to render the inverse subsection\n\t * @param {String} [stringOnly] A flag to indicate that only strings will be returned by subsections.\n\t * @return {Function} An 'evaluator' function that evaluates the expression.\n\t */\n\tmakeEvaluator: function (scope, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {\n\n\t\tif(mode === \"^\") {\n\t\t\tvar temp = truthyRenderer;\n\t\t\ttruthyRenderer = falseyRenderer;\n\t\t\tfalseyRenderer = temp;\n\t\t}\n\n\t\tvar value,\n\t\t\thelperOptions = new HelperOptions(scope, nodeList, exprData, stringOnly);\n\t\t\t// set up renderers\n\t\t\tutils.createRenderers(helperOptions, scope, nodeList, truthyRenderer, falseyRenderer, stringOnly);\n\n\t\tif(exprData instanceof expression.Call) {\n\t\t\tvalue = exprData.value(scope, helperOptions);\n\t\t} else if (exprData instanceof expression.Bracket) {\n\t\t\tvalue = exprData.value(scope);\n\t\t} else if (exprData instanceof expression.Lookup) {\n\t\t\tvalue = exprData.value(scope);\n\t\t} else if (exprData instanceof expression.Helper && exprData.methodExpr instanceof expression.Bracket) {\n\t\t\t// Brackets get wrapped in Helpers when used in attributes\n\t\t\t// like `<p class=\"{{ foo[bar] }}\" />`\n\t\t\tvalue = exprData.methodExpr.value(scope, helperOptions);\n\t\t} else {\n\t\t\tvalue = exprData.value(scope, helperOptions);\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\t// {{#something()}}foo{{/something}}\n\t\t// return evaluator for no mode or rendered value if a renderer was called\n\t\tif(!mode || helperOptions.metadata.rendered) {\n\t\t\treturn value;\n\t\t} else if( mode === \"#\" || mode === \"^\" ) {\n\n\t\t\treturn function(){\n\t\t\t\t// Get the value\n\t\t\t\tvar finalValue = canReflect.getValue(value);\n\t\t\t\tvar result;\n\n\t\t\t\t// if options.fn or options.inverse was called, we take the observable's return value\n\t\t\t\t// as what should be put in the DOM.\n\t\t\t\tif(helperOptions.metadata.rendered) {\n\t\t\t\t\tresult = finalValue;\n\t\t\t\t}\n\t\t\t\t// If it's an array, render.\n\t\t\t\telse if ( typeof finalValue !== \"string\" && canReflect.isListLike(finalValue) ) {\n\t\t\t\t\tvar isObserveList = canReflect.isObservableLike(finalValue) &&\n\t\t\t\t\t\tcanReflect.isListLike(finalValue);\n\n\t\t\t\t\tif(canReflect.getKeyValue(finalValue, \"length\")) {\n\t\t\t\t\t\tif (stringOnly) {\n\t\t\t\t\t\t\tresult = utils.getItemsStringContent(finalValue, isObserveList, helperOptions);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult = frag(utils.getItemsFragContent(finalValue, helperOptions, scope));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = helperOptions.inverse(scope);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult = finalValue ? helperOptions.fn(finalValue || scope) : helperOptions.inverse(scope);\n\t\t\t\t}\n\t\t\t\t// We always set the rendered result back to false.\n\t\t\t\t// - Future calls might change from returning a value to calling `.fn`\n\t\t\t\t// - We are calling `.fn` and `.inverse` ourselves.\n\t\t\t\thelperOptions.metadata.rendered = false;\n\t\t\t\treturn result;\n\t\t\t};\n\t\t} else {\n\t\t\t// not supported!\n\t\t}\n\t},\n\t// ## mustacheCore.makeLiveBindingPartialRenderer\n\t// Returns a renderer function that live binds a partial.\n\t/**\n\t * @hide\n\t * Returns a renderer function that live binds a partial.\n\t * @param {String} expressionString\n\t * @param {Object} state The html state of where the expression was found.\n\t * @return {function(this:HTMLElement,can-view-scope,can.view.Options)} A renderer function\n\t * live binds a partial.\n\t */\n\tmakeLiveBindingPartialRenderer: function(expressionString, state){\n\t\texpressionString = expressionString.trim();\n\t\tvar exprData,\n\t\t\t\tpartialName = expressionString.split(/\\s+/).shift();\n\n\t\tif(partialName !== expressionString) {\n\t\t\texprData = core.expression.parse(expressionString);\n\t\t}\n\n\t\treturn function(scope, parentSectionNodeList){\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tscope.set('scope.filename', state.filename);\n\t\t\t\tscope.set('scope.lineNumber', state.lineNo);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tvar nodeList = [this];\n\t\t\tnodeList.expression = \">\" + partialName;\n\t\t\tnodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);\n\n\t\t\tvar partialFrag = new Observation(function(){\n\t\t\t\tvar localPartialName = partialName;\n\t\t\t\t// If the second parameter of a partial is a custom context\n\t\t\t\tif(exprData && exprData.argExprs.length === 1) {\n\t\t\t\t\tvar newContext = canReflect.getValue( exprData.argExprs[0].value(scope) );\n\t\t\t\t\tif(typeof newContext === \"undefined\") {\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t\tdev.warn('The context ('+ exprData.argExprs[0].key +') you passed into the' +\n\t\t\t\t\t\t\t\t'partial ('+ partialName +') is not defined in the scope!');\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t}else{\n\t\t\t\t\t\tscope = scope.add(newContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Look up partials in templateContext first\n\t\t\t\tvar partial = canReflect.getKeyValue(scope.templateContext.partials, localPartialName);\n\t\t\t\tvar renderer;\n\n\t\t\t\tif (partial) {\n\t\t\t\t\trenderer = function() {\n\t\t\t\t\t\treturn partial.render ? partial.render(scope, nodeList)\n\t\t\t\t\t\t\t: partial(scope);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// Use can.view to get and render the partial.\n\t\t\t\telse {\n\t\t\t\t\tvar scopePartialName = scope.read(localPartialName, {\n\t\t\t\t\t\tisArgument: true\n\t\t\t\t\t}).value;\n\n\t\t\t\t\tif (scopePartialName === null || !scopePartialName && localPartialName[0] === '*') {\n\t\t\t\t\t\treturn frag(\"\");\n\t\t\t\t\t}\n\t\t\t\t\tif (scopePartialName) {\n\t\t\t\t\t\tlocalPartialName = scopePartialName;\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer = function() {\n\t\t\t\t\t\tif(typeof localPartialName === \"function\"){\n\t\t\t\t\t\t\treturn localPartialName(scope, {}, nodeList);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar domRenderer = core.getTemplateById(localPartialName);\n\t\t\t\t\t\t\treturn domRenderer ? domRenderer(scope, {}, nodeList) : getDocument().createDocumentFragment();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvar res = ObservationRecorder.ignore(renderer)();\n\t\t\t\treturn frag(res);\n\t\t\t});\n\t\t\tcanReflect.setPriority(partialFrag,nodeList.nesting );\n\n\t\t\tlive.html(this, partialFrag, this.parentNode, nodeList);\n\t\t};\n\t},\n\t// ## mustacheCore.makeStringBranchRenderer\n\t// Return a renderer function that evalutes to a string and caches\n\t// the evaluator on the scope.\n\t/**\n\t * @hide\n\t * Return a renderer function that evaluates to a string.\n\t * @param {String} mode\n\t * @param {can.stache.Expression} expression\n\t * @param {Object} state The html state of where the expression was found.\n\t * @return {function(can.view.Scope,can.view.Options, can-stache.view, can.view.renderer)}\n\t */\n\tmakeStringBranchRenderer: function(mode, expressionString, state){\n\t\tvar exprData = core.expression.parse(expressionString),\n\t\t\t// Use the full mustache expression as the cache key.\n\t\t\tfullExpression = mode+expressionString;\n\n\t\t// A branching renderer takes truthy and falsey renderer.\n\t\tvar branchRenderer = function branchRenderer(scope, truthyRenderer, falseyRenderer){\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tscope.set('scope.filename', state.filename);\n\t\t\t\tscope.set('scope.lineNumber', state.lineNo);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\t// Check the scope's cache if the evaluator already exists for performance.\n\t\t\tvar evaluator = scope.__cache[fullExpression];\n\t\t\tif(mode || !evaluator) {\n\t\t\t\tevaluator = makeEvaluator( scope, null, mode, exprData, truthyRenderer, falseyRenderer, true);\n\t\t\t\tif(!mode) {\n\t\t\t\t\tscope.__cache[fullExpression] = evaluator;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar gotObservableValue = evaluator[canSymbol.for(\"can.onValue\")],\n\t\t\t\tres;\n\n\t\t\t// Run the evaluator and return the result.\n\t\t\tif(gotObservableValue) {\n\t\t\t\tres = canReflect.getValue(evaluator);\n\t\t\t} else {\n\t\t\t\tres = evaluator();\n\t\t\t}\n\n\n\t\t\treturn res == null ? \"\" : \"\"+res;\n\t\t};\n\n\t\tbranchRenderer.exprData = exprData;\n\n\t\treturn branchRenderer;\n\t},\n\t// ## mustacheCore.makeLiveBindingBranchRenderer\n\t// Return a renderer function that evaluates the mustache expression and\n\t// sets up live binding if a compute with dependencies is found. Otherwise,\n\t// the element's value is set.\n\t//\n\t// This function works by creating a `can.compute` from the mustache expression.\n\t// If the compute has dependent observables, it passes the compute to `can.view.live`; otherwise,\n\t// it updates the element's property based on the compute's value.\n\t/**\n\t * @hide\n\t * Returns a renderer function that evaluates the mustache expression.\n\t * @param {String} mode\n\t * @param {can.stache.Expression} expression\n\t * @param {Object} state The html state of where the expression was found.\n\t */\n\tmakeLiveBindingBranchRenderer: function(mode, expressionString, state){\n\t\t// Pre-process the expression.\n\t\tvar exprData = core.expression.parse(expressionString);\n\t\tif(!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call) && !(exprData instanceof expression.Bracket) && !(exprData instanceof expression.Lookup)) {\n\t\t\texprData = new expression.Helper(exprData,[],{});\n\t\t}\n\t\t// A branching renderer takes truthy and falsey renderer.\n\t\tvar branchRenderer = function branchRenderer(scope, parentSectionNodeList, truthyRenderer, falseyRenderer){\n\t\t\t// If this is within a tag, make sure we only get string values.\n\t\t\tvar stringOnly = state.tag;\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tscope.set('scope.filename', state.filename);\n\t\t\t\tscope.set('scope.lineNumber', state.lineNo);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tvar nodeList = [this];\n\t\t\tnodeList.expression = expressionString;\n\t\t\t// register this nodeList.\n\t\t\t// Register it with its parent ONLY if this is directly nested.  Otherwise, it's unnecessary.\n\t\t\tnodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);\n\n\t\t\t// Get the evaluator. This does not need to be cached (probably) because if there\n\t\t\t// an observable value, it will be handled by `can.view.live`.\n\t\t\tvar evaluator = makeEvaluator( scope, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly );\n\n\t\t\t// Create a compute that can not be observed by other\n\t\t\t// computes. This is important because this renderer is likely called by\n\t\t\t// parent expressions.  If this value changes, the parent expressions should\n\t\t\t// not re-evaluate. We prevent that by making sure this compute is ignored by\n\t\t\t// everyone else.\n\t\t\t//var compute = can.compute(evaluator, null, false);\n\t\t\tvar gotObservableValue = evaluator[canSymbol.for(\"can.onValue\")];\n\t\t\tvar observable;\n\t\t\tif(gotObservableValue) {\n\t\t\t\tobservable = evaluator;\n\t\t\t} else {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tObject.defineProperty(evaluator,\"name\",{\n\t\t\t\t\t\tvalue: \"{{\"+(mode || \"\")+expressionString+\"}}\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t\tobservable = new Observation(evaluator,null,{isObservable: false});\n\t\t\t}\n\n\t\t\tif(canReflect.setPriority(observable, nodeList.nesting) === false) {\n\t\t\t\tthrow new Error(\"can-stache unable to set priority on observable\");\n\t\t\t}\n\n\t\t\t// Bind on the computeValue to set the cached value. This helps performance\n\t\t\t// so live binding can read a cached value instead of re-calculating.\n\t\t\tcanReflect.onValue(observable, k);\n\n\t\t\tvar value = canReflect.getValue(observable);\n\n\t\t\t// If value is a function and not a Lookup ({{foo}}),\n\t\t\t// it's a helper that returned a function and should be called.\n\t\t\tif(typeof value === \"function\" && !(exprData instanceof expression.Lookup)) {\n\n\t\t\t\t// A helper function should do it's own binding.  Similar to how\n\t\t\t\t// we prevented this function's compute from being noticed by parent expressions,\n\t\t\t\t// we hide any observables read in the function by saving any observables that\n\t\t\t\t// have been read and then setting them back which overwrites any `can.__observe` calls\n\t\t\t\t// performed in value.\n\t\t\t\tObservationRecorder.ignore(value)(this);\n\n\t\t\t}\n\t\t\t// If the computeValue has observable dependencies, setup live binding.\n\t\t\telse if( canReflect.valueHasDependencies(observable) ) {\n\t\t\t\t// Depending on where the template is, setup live-binding differently.\n\t\t\t\tif(state.attr) {\n\t\t\t\t\tlive.attr(this, state.attr, observable);\n\t\t\t\t}\n\t\t\t\telse if( state.tag )  {\n\t\t\t\t\tlive.attrs( this, observable );\n\t\t\t\t}\n\t\t\t\telse if(state.text && !valueShouldBeInsertedAsHTML(value)) {\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\tif(value !== null && typeof value === \"object\") {\n\t\t\t\t\t\t\tdev.warn(\"Previously, the result of \"+\n\t\t\t\t\t\t\t\texpressionString+\" in \"+state.filename+\":\"+state.lineNo+\n\t\t\t\t\t\t\t\t\", was being inserted as HTML instead of TEXT. Please use stache.safeString(obj) \"+\n\t\t\t\t\t\t\t\t\"if you would like the object to be treated as HTML.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tlive.text(this, observable, this.parentNode, nodeList);\n\t\t\t\t} else {\n\t\t\t\t\tlive.html(this, observable, this.parentNode, {\n\t\t\t\t\t\tnodeList: nodeList\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If the computeValue has no observable dependencies, just set the value on the element.\n\t\t\telse {\n\n\t\t\t\tif(state.attr) {\n\t\t\t\t\tdomMutate.setAttribute(this, state.attr, value);\n\t\t\t\t}\n\t\t\t\telse if(state.tag) {\n\t\t\t\t\tlive.attrs(this, value);\n\t\t\t\t}\n\t\t\t\telse if(state.text && !valueShouldBeInsertedAsHTML(value)) {\n\t\t\t\t\tthis.nodeValue = live.makeString(value);\n\t\t\t\t}\n\t\t\t\telse if( value != null ){\n\t\t\t\t\tif (typeof value[viewInsertSymbol] === \"function\") {\n\t\t\t\t\t\tvar insert = value[viewInsertSymbol]({\n\t\t\t\t\t\t\tnodeList: nodeList\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvar oldNodes = nodeLists.update(nodeList, [insert]);\n\t\t\t\t\t\tnodeLists.replace(oldNodes, insert);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnodeLists.replace([this], frag(value, this.ownerDocument));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Unbind the compute.\n\t\t\tcanReflect.offValue(observable, k);\n\t\t};\n\n\t\tbranchRenderer.exprData = exprData;\n\n\t\treturn branchRenderer;\n\t},\n\t// ## mustacheCore.splitModeFromExpression\n\t// Returns the mustache mode split from the rest of the expression.\n\t/**\n\t * @hide\n\t * Returns the mustache mode split from the rest of the expression.\n\t * @param {can.stache.Expression} expression\n\t * @param {Object} state The state of HTML where the expression was found.\n\t */\n\tsplitModeFromExpression: function(expression, state){\n\t\texpression = expression.trim();\n\t\tvar mode = expression.charAt(0);\n\n\t\tif( \"#/{&^>!<\".indexOf(mode) >= 0 ) {\n\t\t\texpression =  expression.substr(1).trim();\n\t\t} else {\n\t\t\tmode = null;\n\t\t}\n\t\t// Triple braces do nothing within a tag.\n\t\tif(mode === \"{\" && state.node) {\n\t\t\tmode = null;\n\t\t}\n\t\treturn {\n\t\t\tmode: mode,\n\t\t\texpression: expression\n\t\t};\n\t},\n\t// ## mustacheCore.cleanLineEndings\n\t// Removes line breaks accoding to the mustache specification.\n\t/**\n\t * @hide\n\t * Prunes line breaks accoding to the mustache specification.\n\t * @param {String} template\n\t * @return {String}\n\t */\n\tcleanLineEndings: function(template){\n\n\t\t// Finds mustache tags with space around them or no space around them.\n\t\treturn template.replace( mustacheLineBreakRegExp,\n\t\t\tfunction(whole,\n\t\t\t\treturnBefore,\n\t\t\t\tspaceBefore,\n\t\t\t\tspecial,\n\t\t\t\texpression,\n\t\t\t\tspaceAfter,\n\t\t\t\treturnAfter,\n\t\t\t\t// A mustache magic tag that has no space around it.\n\t\t\t\tspaceLessSpecial,\n\t\t\t\tspaceLessExpression,\n\t\t\t\tmatchIndex){\n\n\t\t\t// IE 8 will provide undefined\n\t\t\tspaceAfter = (spaceAfter || \"\");\n\t\t\treturnBefore = (returnBefore || \"\");\n\t\t\tspaceBefore = (spaceBefore || \"\");\n\n\t\t\tvar modeAndExpression = splitModeFromExpression(expression || spaceLessExpression,{});\n\n\t\t\t// If it's a partial or tripple stache, leave in place.\n\t\t\tif(spaceLessSpecial || \">{\".indexOf( modeAndExpression.mode) >= 0) {\n\t\t\t\treturn whole;\n\t\t\t}  else if( \"^#!/\".indexOf(  modeAndExpression.mode ) >= 0 ) {\n\t\t\t\t// Return the magic tag and a trailing linebreak if this did not\n\t\t\t\t// start a new line and there was an end line.\n\t\t\t\t// Add a normalized leading space, if there was any leading space, in case this abuts a tag name\n\t\t\t\tspaceBefore = (returnBefore + spaceBefore) && \" \";\n\t\t\t\treturn spaceBefore+special+( matchIndex !== 0 && returnAfter.length ? returnBefore+\"\\n\" :\"\");\n\n\n\t\t\t} else {\n\t\t\t\t// There is no mode, return special with spaces around it.\n\t\t\t\treturn spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== 0 ? returnBefore+\"\\n\" : \"\");\n\t\t\t}\n\n\t\t});\n\t},\n\t// ## mustacheCore.cleanWhitespaceControl\n\t// Removes whitespace according to the whitespace control.\n\t/**\n\t * @hide\n\t * Prunes whitespace according to the whitespace control.\n\t * @param {String} template\n\t * @return {String}\n\t */\n\tcleanWhitespaceControl: function(template) {\n\t\treturn template.replace(mustacheWhitespaceRegExp, function(\n\t\t\twhole,\n\t\t\tspaceBefore,\n\t\t\tbracketBefore,\n\t\t\tcontrolBefore,\n\t\t\texpression,\n\t\t\tcontrolAfter,\n\t\t\tbracketAfter,\n\t\t\tspaceAfter,\n\t\t\tmatchIndex\n\t\t) {\n\n\t\t\tif (controlBefore === '-') {\n\t\t\t\tspaceBefore = '';\n\t\t\t}\n\n\t\t\tif (controlAfter === '-') {\n\t\t\t\tspaceAfter = '';\n\t\t\t}\n\n\t\t\treturn spaceBefore + bracketBefore + expression + bracketAfter + spaceAfter;\n\n\t\t});\n\t},\n\tgetTemplateById: function(){}\n};\n\n// ## Local Variable Cache\n//\n// The following creates slightly more quickly accessible references of the following\n// core functions.\nvar makeEvaluator = core.makeEvaluator,\n\tsplitModeFromExpression = core.splitModeFromExpression;\n\nmodule.exports = core;\n","\"use strict\";\nvar helpers = require(\"./core\");\nvar SetIdentifier = require(\"../src/set-identifier\");\nvar canReflect = require(\"can-reflect\");\n\n\nfunction makeConverter(getterSetter){\n\tgetterSetter = getterSetter || {};\n\treturn function(newVal, source) {\n\t\tvar args = canReflect.toArray(arguments);\n\t\tif(newVal instanceof SetIdentifier) {\n\t\t\treturn typeof getterSetter.set === \"function\" ?\n\t\t\t\tgetterSetter.set.apply(this, [newVal.value].concat(args.slice(1))) :\n\t\t\t\tsource(newVal.value);\n\t\t} else {\n\t\t\treturn typeof getterSetter.get === \"function\" ?\n\t\t\t\tgetterSetter.get.apply(this, args) :\n\t\t\t\targs[0];\n\t\t}\n\t};\n}\n\nvar converterPackages = new WeakMap();\nhelpers.addConverter = function(name, getterSetter) {\n\tif(typeof name === \"object\") {\n\t\tif(!converterPackages.has(name)) {\n\t\t\tconverterPackages.set(name, true);\n\t\t\tcanReflect.eachKey(name, function(getterSetter, name) {\n\t\t\t\thelpers.addConverter(name, getterSetter);\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\tvar helper = makeConverter(getterSetter);\n\thelper.isLiveBound = true;\n\thelpers.registerHelper(name, helper );\n};\n\nhelpers.registerConverter = function(name, getterSetter) {\n\thelpers.registerHelper(name, makeConverter(getterSetter) );\n};\n\nvar converterHelpers = {\n\t\"not\": {\n\t\tget: function(obs, options){\n\t\t\tif(helpers.looksLikeOptions(options)) {\n\t\t\t\treturn canReflect.getValue(obs) ? options.inverse() : options.fn();\n\t\t\t} else {\n\t\t\t\treturn !canReflect.getValue(obs);\n\t\t\t}\n\n\t\t},\n\t\tset: function(newVal, obs){\n\t\t\tcanReflect.setValue(obs, !newVal);\n\t\t}\n\t}\n};\n\nhelpers.addConverter(converterHelpers);\n\nmodule.exports = helpers;\n","\"use strict\";\nvar mustacheLineBreakRegExp = /(?:(^|\\r?\\n)(\\s*)(\\{\\{([\\s\\S]*)\\}\\}\\}?)([^\\S\\n\\r]*)($|\\r?\\n))|(\\{\\{([\\s\\S]*)\\}\\}\\}?)/g,\n\tmustacheWhitespaceRegExp = /(\\s*)(\\{\\{\\{?)(-?)([\\s\\S]*?)(-?)(\\}\\}\\}?)(\\s*)/g;\n\nfunction splitModeFromExpression(expression, state){\n\texpression = expression.trim();\n\tvar mode = expression.charAt(0);\n\n\tif( \"#/{&^>!<\".indexOf(mode) >= 0 ) {\n\t\texpression =  expression.substr(1).trim();\n\t} else {\n\t\tmode = null;\n\t}\n\t// Triple braces do nothing within a tag.\n\tif(mode === \"{\" && state.node) {\n\t\tmode = null;\n\t}\n\treturn {\n\t\tmode: mode,\n\t\texpression: expression\n\t};\n}\n\nfunction cleanLineEndings(template) {\n\t\t// Finds mustache tags with space around them or no space around them.\n\t\treturn template.replace( mustacheLineBreakRegExp,\n\t\t\tfunction(whole,\n\t\t\t\treturnBefore,\n\t\t\t\tspaceBefore,\n\t\t\t\tspecial,\n\t\t\t\texpression,\n\t\t\t\tspaceAfter,\n\t\t\t\treturnAfter,\n\t\t\t\t// A mustache magic tag that has no space around it.\n\t\t\t\tspaceLessSpecial,\n\t\t\t\tspaceLessExpression,\n\t\t\t\tmatchIndex){\n\n\t\t\t// IE 8 will provide undefined\n\t\t\tspaceAfter = (spaceAfter || \"\");\n\t\t\treturnBefore = (returnBefore || \"\");\n\t\t\tspaceBefore = (spaceBefore || \"\");\n\n\t\t\tvar modeAndExpression = splitModeFromExpression(expression || spaceLessExpression,{});\n\n\t\t\t// If it's a partial or tripple stache, leave in place.\n\t\t\tif(spaceLessSpecial || \">{\".indexOf( modeAndExpression.mode) >= 0) {\n\t\t\t\treturn whole;\n\t\t\t}  else if( \"^#!/\".indexOf(  modeAndExpression.mode ) >= 0 ) {\n\t\t\t\t// Return the magic tag and a trailing linebreak if this did not\n\t\t\t\t// start a new line and there was an end line.\n\t\t\t\t// Add a normalized leading space, if there was any leading space, in case this abuts a tag name\n\t\t\t\tspaceBefore = (returnBefore + spaceBefore) && \" \";\n\t\t\t\treturn spaceBefore+special+( matchIndex !== 0 && returnAfter.length ? returnBefore+\"\\n\" :\"\");\n\n\n\t\t\t} else {\n\t\t\t\t// There is no mode, return special with spaces around it.\n\t\t\t\treturn spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== 0 ? returnBefore+\"\\n\" : \"\");\n\t\t\t}\n\t\t});\n}\n\nfunction whiteSpaceReplacement(\n\twhole,\n\tspaceBefore,\n\tbracketBefore,\n\tcontrolBefore,\n\texpression,\n\tcontrolAfter,\n\tbracketAfter,\n\tspaceAfter\n) {\n\n\tif (controlBefore === '-') {\n\t\tspaceBefore = '';\n\t}\n\n\tif (controlAfter === '-') {\n\t\tspaceAfter = '';\n\t}\n\n\treturn spaceBefore + bracketBefore + expression + bracketAfter + spaceAfter;\n}\n\nfunction cleanWhitespaceControl(template) {\n\treturn template.replace(mustacheWhitespaceRegExp, whiteSpaceReplacement);\n}\n\nexports.cleanLineEndings = cleanLineEndings;\nexports.cleanWhitespaceControl = cleanWhitespaceControl;\n","\"use strict\";\nvar controls = require(\"./controls\");\nvar parser = require('can-view-parser');\n\nexports.parse = function(filename, source){\n\tif (arguments.length === 1) {\n\t\tsource = arguments[0];\n\t\tfilename = undefined;\n\t}\n\n\tvar template = source;\n\ttemplate = controls.cleanWhitespaceControl(template);\n\ttemplate = controls.cleanLineEndings(template);\n\n\tvar imports = [],\n\t\tdynamicImports = [],\n\t\timportDeclarations = [],\n\t\tases = {},\n\t\tattributes = new Map(),\n\t\tinImport = false,\n\t\tinFrom = false,\n\t\tinAs = false,\n\t\tisUnary = false,\n\t\timportIsDynamic = false,\n\t\tcurrentAs = \"\",\n\t\tcurrentFrom = \"\",\n\t\tcurrentAttrName = null;\n\n\tfunction processImport(line) {\n\t\tif(currentAs) {\n\t\t\tases[currentAs] = currentFrom;\n\t\t\tcurrentAs = \"\";\n\t\t}\n\t\tif(importIsDynamic) {\n\t\t\tdynamicImports.push(currentFrom);\n\t\t} else {\n\t\t\timports.push(currentFrom);\n\t\t}\n\t\timportDeclarations.push({\n\t\t\tspecifier: currentFrom,\n\t\t\tloc: {\n\t\t\t\tline: line\n\t\t\t},\n\t\t\tattributes: attributes\n\t\t});\n\n\t\t// Reset this scope value so that the next import gets new attributes.\n\t\tattributes = new Map();\n\t}\n\n\tvar program = parser(template, {\n\t\tfilename: filename,\n\t\tstart: function( tagName, unary ){\n\t\t\tif(tagName === \"can-import\") {\n\t\t\t\tisUnary = unary;\n\t\t\t\timportIsDynamic = false; // assume static import unless there is content (chars/tags/special).\n\t\t\t\tinImport = true;\n\t\t\t} else if(tagName === \"can-dynamic-import\") {\n\t\t\t\tisUnary = unary;\n\t\t\t\timportIsDynamic = true;\n\t\t\t\tinImport = true;\n\t\t\t} else if(inImport) {\n\t\t\t\timportIsDynamic = true;  // found content inside can-import tag.\n\t\t\t\tinImport = false;\n\t\t\t}\n\t\t},\n\t\tattrStart: function( attrName ){\n\t\t\tcurrentAttrName = attrName;\n\t\t\t// Default to a boolean attribute, the attrValue hook will replace that.\n\t\t\tattributes.set(currentAttrName, true);\n\n\t\t\tif(attrName === \"from\") {\n\t\t\t\tinFrom = true;\n\t\t\t} else if(attrName === \"as\" || attrName === \"export-as\") {\n\t\t\t\tinAs = true;\n\t\t\t}\n\t\t},\n\t\tattrEnd: function( attrName ){\n\t\t\tif(attrName === \"from\") {\n\t\t\t\tinFrom = false;\n\t\t\t} else if(attrName === \"as\" || attrName === \"export-as\") {\n\t\t\t\tinAs = false;\n\t\t\t}\n\t\t},\n\t\tattrValue: function( value ){\n\t\t\tif(inImport) {\n\t\t\t\tattributes.set(currentAttrName, value);\n\t\t\t}\n\t\t\tif(inFrom && inImport) {\n\t\t\t\tcurrentFrom = value;\n\t\t\t} else if(inAs && inImport) {\n\t\t\t\tcurrentAs = value;\n\t\t\t}\n\t\t},\n\t\tend: function(tagName, unary, line){\n\t\t\tif((tagName === \"can-import\" || tagName === \"can-dynamic-import\") && isUnary) {\n\t\t\t\tprocessImport(line);\n\t\t\t}\n\t\t},\n\t\tclose: function(tagName, unary, line){\n\t\t\tif((tagName === \"can-import\" || tagName === \"can-dynamic-import\")) {\n\t\t\t\tprocessImport(line);\n\t\t\t}\n\t\t},\n\t\tchars: function(text) {\n\t\t\tif(text.trim().length > 0) {\n\t\t\t\timportIsDynamic = true;\n\t\t\t}\n\t\t},\n\t\tspecial: function() {\n\t\t\timportIsDynamic = true;\n\t\t}\n\t}, true);\n\n\treturn {\n\t\tintermediate: program,\n\t\tprogram: program,\n\t\timports: imports,\n\t\tdynamicImports: dynamicImports,\n\t\timportDeclarations: importDeclarations,\n\t\tases: ases,\n\t\texports: ases\n\t};\n};\n","\"use strict\";\n/* jshint undef: false */\n\nvar parser = require('can-view-parser');\nvar viewCallbacks = require('can-view-callbacks');\n\nvar HTMLSectionBuilder = require('./src/html_section');\nvar TextSectionBuilder = require('./src/text_section');\nvar mustacheCore = require('./src/mustache_core');\nvar mustacheHelpers = require('./helpers/core');\nrequire('./helpers/converter');\nvar getIntermediateAndImports = require('can-stache-ast').parse;\nvar utils = require('./src/utils');\nvar makeRendererConvertScopes = utils.makeRendererConvertScopes;\nvar last = utils.last;\n\nvar attributeEncoder = require('can-attribute-encoder');\nvar dev = require('can-log/dev/dev');\nvar namespace = require('can-namespace');\nvar DOCUMENT = require('can-globals/document/document');\nvar assign = require('can-assign');\nvar importer = require('can-import-module');\nvar canReflect = require('can-reflect');\nvar Scope = require('can-view-scope');\nvar TemplateContext = require(\"can-view-scope/template-context\");\nvar ObservationRecorder = require('can-observation-recorder');\nvar canSymbol = require(\"can-symbol\");\n// Make sure that we can also use our modules with Stache as a plugin\n\nrequire('can-view-target');\nrequire('can-view-nodelist');\n\n\nif(!viewCallbacks.tag(\"content\")) {\n\t// This was moved from the legacy view/scanner.js to here.\n\t// This makes sure content elements will be able to have a callback.\n\tviewCallbacks.tag(\"content\", function(el, tagData) {\n\t\treturn tagData.scope;\n\t});\n}\n\nvar isViewSymbol = canSymbol.for(\"can.isView\");\n\nvar wrappedAttrPattern = /[{(].*[)}]/;\nvar colonWrappedAttrPattern = /^on:|(:to|:from|:bind)$|.*:to:on:.*/;\nvar svgNamespace = \"http://www.w3.org/2000/svg\";\nvar namespaces = {\n\t\"svg\": svgNamespace,\n\t// this allows a partial to start with g.\n\t\"g\": svgNamespace\n},\n\ttextContentOnlyTag = {style: true, script: true};\n\nfunction stache (filename, template) {\n\tif (arguments.length === 1) {\n\t\ttemplate = arguments[0];\n\t\tfilename = undefined;\n\t}\n\n\tvar inlinePartials = {};\n\n\t// Remove line breaks according to mustache's specs.\n\tif(typeof template === \"string\") {\n\t\ttemplate = mustacheCore.cleanWhitespaceControl(template);\n\t\ttemplate = mustacheCore.cleanLineEndings(template);\n\t}\n\n\t// The HTML section that is the root section for the entire template.\n\tvar section = new HTMLSectionBuilder(filename),\n\t\t// Tracks the state of the parser.\n\t\tstate = {\n\t\t\tnode: null,\n\t\t\tattr: null,\n\t\t\t// A stack of which node / section we are in.\n\t\t\t// There is probably a better way of doing this.\n\t\t\tsectionElementStack: [],\n\t\t\t// If text should be inserted and HTML escaped\n\t\t\ttext: false,\n\t\t\t// which namespace we are in\n\t\t\tnamespaceStack: [],\n\t\t\t// for style and script tags\n\t\t\t// we create a special TextSectionBuilder and add things to that\n\t\t\t// when the element is done, we compile the text section and\n\t\t\t// add it as a callback to `section`.\n\t\t\ttextContentOnly: null\n\n\t\t},\n\n\t\t// This function is a catch all for taking a section and figuring out\n\t\t// how to create a \"renderer\" that handles the functionality for a\n\t\t// given section and modify the section to use that renderer.\n\t\t// For example, if an HTMLSection is passed with mode `#` it knows to\n\t\t// create a liveBindingBranchRenderer and pass that to section.add.\n\t\t// jshint maxdepth:5\n\t\tmakeRendererAndUpdateSection = function(section, mode, stache, lineNo){\n\n\t\t\tif(mode === \">\") {\n\t\t\t\t// Partials use liveBindingPartialRenderers\n\t\t\t\tsection.add(mustacheCore.makeLiveBindingPartialRenderer(stache, copyState({ filename: section.filename, lineNo: lineNo })));\n\n\t\t\t} else if(mode === \"/\") {\n\n\t\t\t\tvar createdSection = section.last();\n\t\t\t\tif ( createdSection.startedWith === \"<\" ) {\n\t\t\t\t\tinlinePartials[ stache ] = section.endSubSectionAndReturnRenderer();\n\t\t\t\t\tsection.removeCurrentNode();\n\t\t\t\t} else {\n\t\t\t\t\tsection.endSection();\n\t\t\t\t}\n\n\t\t\t\t// to avoid \"Blocks are nested too deeply\" when linting\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tif(section instanceof HTMLSectionBuilder) {\n\t\t\t\t\t\tvar last = state.sectionElementStack[state.sectionElementStack.length - 1];\n\t\t\t\t\t\tif (last.tag && last.type === \"section\" && stache !== \"\" && stache !== last.tag) {\n\t\t\t\t\t\t\tif (filename) {\n\t\t\t\t\t\t\t\tdev.warn(filename + \":\" + lineNo + \": unexpected closing tag {{/\" + stache + \"}} expected {{/\" + last.tag + \"}}\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdev.warn(lineNo + \": unexpected closing tag {{/\" + stache + \"}} expected {{/\" + last.tag + \"}}\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\tif(section instanceof HTMLSectionBuilder) {\n\t\t\t\t\tstate.sectionElementStack.pop();\n\t\t\t\t}\n\t\t\t} else if(mode === \"else\") {\n\n\t\t\t\tsection.inverse();\n\n\t\t\t} else {\n\n\t\t\t\t// If we are an HTMLSection, we will generate a\n\t\t\t\t// a LiveBindingBranchRenderer; otherwise, a StringBranchRenderer.\n\t\t\t\t// A LiveBindingBranchRenderer function processes\n\t\t\t\t// the mustache text, and sets up live binding if an observable is read.\n\t\t\t\t// A StringBranchRenderer function processes the mustache text and returns a\n\t\t\t\t// text value.\n\t\t\t\tvar makeRenderer = section instanceof HTMLSectionBuilder ?\n\t\t\t\t\tmustacheCore.makeLiveBindingBranchRenderer:\n\t\t\t\t\tmustacheCore.makeStringBranchRenderer;\n\n\t\t\t\tif(mode === \"{\" || mode === \"&\") {\n\n\t\t\t\t\t// Adds a renderer function that just reads a value or calls a helper.\n\t\t\t\t\tsection.add(makeRenderer(null,stache, copyState({ filename: section.filename, lineNo: lineNo })));\n\n\t\t\t\t} else if(mode === \"#\" || mode === \"^\" || mode === \"<\") {\n\t\t\t\t\t// Adds a renderer function and starts a section.\n\t\t\t\t\tvar renderer = makeRenderer(mode, stache, copyState({ filename: section.filename, lineNo: lineNo }));\n\t\t\t\t\tvar sectionItem = {\n\t\t\t\t\t\ttype: \"section\"\n\t\t\t\t\t};\n\t\t\t\t\tsection.startSection(renderer);\n\t\t\t\t\tsection.last().startedWith = mode;\n\n\t\t\t\t\t// If we are a directly nested section, count how many we are within\n\t\t\t\t\tif(section instanceof HTMLSectionBuilder) {\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t\tvar tag = typeof renderer.exprData.closingTag === 'function' ?\n\t\t\t\t\t\t\t\trenderer.exprData.closingTag() : '';\n\t\t\t\t\t\t\tsectionItem.tag = tag;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\t\tstate.sectionElementStack.push(sectionItem);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Adds a renderer function that only updates text.\n\t\t\t\t\tsection.add(makeRenderer(null, stache, copyState({text: true, filename: section.filename, lineNo: lineNo })));\n\t\t\t\t}\n\n\t\t\t}\n\t\t},\n\t\tisDirectlyNested = function() {\n\t\t\tvar lastElement = state.sectionElementStack[state.sectionElementStack.length - 1];\n\t\t\treturn state.sectionElementStack.length ?\n\t\t\t\tlastElement.type === \"section\" || lastElement.type === \"custom\": true;\n\t\t},\n\t\t// Copys the state object for use in renderers.\n\t\tcopyState = function(overwrites){\n\n\t\t\tvar cur = {\n\t\t\t\ttag: state.node && state.node.tag,\n\t\t\t\tattr: state.attr && state.attr.name,\n\t\t\t\t// <content> elements should be considered direclty nested\n\t\t\t\tdirectlyNested: isDirectlyNested(),\n\t\t\t\ttextContentOnly: !!state.textContentOnly\n\t\t\t};\n\t\t\treturn overwrites ? assign(cur, overwrites) : cur;\n\t\t},\n\t\taddAttributesCallback = function(node, callback){\n\t\t\tif( !node.attributes ) {\n\t\t\t\tnode.attributes = [];\n\t\t\t}\n\t\t\tnode.attributes.unshift(callback);\n\t\t};\n\n\tparser(template, {\n\t\tfilename: filename,\n\t\tstart: function(tagName, unary, lineNo){\n\t\t\tvar matchedNamespace = namespaces[tagName];\n\n\t\t\tif (matchedNamespace && !unary ) {\n\t\t\t\tstate.namespaceStack.push(matchedNamespace);\n\t\t\t}\n\n\t\t\t// either add templates: {} here or check below and decorate\n\t\t\t// walk up the stack/targetStack until you find the first node\n\t\t\t// with a templates property, and add the popped renderer\n\t\t\tstate.node = {\n\t\t\t\ttag: tagName,\n\t\t\t\tchildren: [],\n\t\t\t\tnamespace: matchedNamespace || last(state.namespaceStack)\n\t\t\t};\n\t\t},\n\t\tend: function(tagName, unary, lineNo){\n\t\t\tvar isCustomTag =  viewCallbacks.tag(tagName);\n\t\t\tvar directlyNested = isDirectlyNested();\n\t\t\tif(unary){\n\t\t\t\t// If it's a custom tag with content, we need a section renderer.\n\t\t\t\tsection.add(state.node);\n\t\t\t\tif(isCustomTag) {\n\t\t\t\t\t// Call directlyNested now as it's stateful.\n\t\t\t\t\taddAttributesCallback(state.node, function(scope, parentNodeList){\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t\tscope.set('scope.lineNumber', lineNo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\tviewCallbacks.tagHandler(this,tagName, {\n\t\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\t\tsubtemplate: null,\n\t\t\t\t\t\t\ttemplateType: \"stache\",\n\t\t\t\t\t\t\tparentNodeList: parentNodeList,\n\t\t\t\t\t\t\tdirectlyNested: directlyNested\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsection.push(state.node);\n\n\t\t\t\tstate.sectionElementStack.push({\n\t\t\t\t\ttype: isCustomTag ? \"custom\" : null,\n\t\t\t\t\ttag: isCustomTag ? null : tagName,\n\t\t\t\t\ttemplates: {},\n\t\t\t\t\tdirectlyNested: directlyNested\n\t\t\t\t});\n\n\t\t\t\t// If it's a custom tag with content, we need a section renderer.\n\t\t\t\tif( isCustomTag ) {\n\t\t\t\t\tsection.startSubSection();\n\t\t\t\t} else if(textContentOnlyTag[tagName]) {\n\t\t\t\t\tstate.textContentOnly = new TextSectionBuilder();\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tstate.node =null;\n\n\t\t},\n\t\tclose: function(tagName, lineNo) {\n\t\t\tvar matchedNamespace = namespaces[tagName];\n\n\t\t\tif (matchedNamespace  ) {\n\t\t\t\tstate.namespaceStack.pop();\n\t\t\t}\n\n\t\t\tvar isCustomTag = viewCallbacks.tag(tagName),\n\t\t\t\trenderer;\n\n\t\t\tif( isCustomTag ) {\n\t\t\t\trenderer = section.endSubSectionAndReturnRenderer();\n\t\t\t}\n\n\t\t\tif(textContentOnlyTag[tagName]) {\n\t\t\t\tsection.last().add(state.textContentOnly.compile(copyState()));\n\t\t\t\tstate.textContentOnly = null;\n\t\t\t}\n\n\t\t\tvar oldNode = section.pop();\n\t\t\tif( isCustomTag ) {\n\t\t\t\tif (tagName === \"can-template\") {\n\t\t\t\t\t// If we find a can-template we want to go back 2 in the stack to get it's inner content\n\t\t\t\t\t// rather than the <can-template> element itself\n\t\t\t\t\tvar parent = state.sectionElementStack[state.sectionElementStack.length - 2];\n\t\t\t\t\tif (renderer) {// Only add the renderer if the template has content\n\t\t\t\t\t\tparent.templates[oldNode.attrs.name] = makeRendererConvertScopes(renderer);\n\t\t\t\t\t}\n\t\t\t\t\tsection.removeCurrentNode();\n\t\t\t\t} else {\n\t\t\t\t\t// Get the last element in the stack\n\t\t\t\t\tvar current = state.sectionElementStack[state.sectionElementStack.length - 1];\n\t\t\t\t\taddAttributesCallback(oldNode, function(scope, parentNodeList){\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t\tscope.set('scope.lineNumber', lineNo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\tviewCallbacks.tagHandler(this,tagName, {\n\t\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\t\tsubtemplate: renderer  ? makeRendererConvertScopes(renderer) : renderer,\n\t\t\t\t\t\t\ttemplateType: \"stache\",\n\t\t\t\t\t\t\tparentNodeList: parentNodeList,\n\t\t\t\t\t\t\ttemplates: current.templates,\n\t\t\t\t\t\t\tdirectlyNested: current.directlyNested\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tstate.sectionElementStack.pop();\n\t\t},\n\t\tattrStart: function(attrName, lineNo){\n\t\t\tif(state.node.section) {\n\t\t\t\tstate.node.section.add(attrName+\"=\\\"\");\n\t\t\t} else {\n\t\t\t\tstate.attr = {\n\t\t\t\t\tname: attrName,\n\t\t\t\t\tvalue: \"\"\n\t\t\t\t};\n\t\t\t}\n\n\t\t},\n\t\tattrEnd: function(attrName, lineNo){\n\t\t\tif(state.node.section) {\n\t\t\t\tstate.node.section.add(\"\\\" \");\n\t\t\t} else {\n\t\t\t\tif(!state.node.attrs) {\n\t\t\t\t\tstate.node.attrs = {};\n\t\t\t\t}\n\n\t\t\t\tstate.node.attrs[state.attr.name] =\n\t\t\t\t\tstate.attr.section ? state.attr.section.compile(copyState()) : state.attr.value;\n\n\t\t\t\tvar attrCallback = viewCallbacks.attr(attrName);\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tvar decodedAttrName = attributeEncoder.decode(attrName);\n\t\t\t\t\tvar weirdAttribute = !!wrappedAttrPattern.test(decodedAttrName) || !!colonWrappedAttrPattern.test(decodedAttrName);\n\t\t\t\t\tif (weirdAttribute && !attrCallback) {\n\t\t\t\t\t\tdev.warn(\"unknown attribute binding \" + decodedAttrName + \". Is can-stache-bindings imported?\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\tif(attrCallback) {\n\t\t\t\t\tif( !state.node.attributes ) {\n\t\t\t\t\t\tstate.node.attributes = [];\n\t\t\t\t\t}\n\t\t\t\t\tstate.node.attributes.push(function(scope, nodeList){\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t\tscope.set('scope.lineNumber', lineNo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\tattrCallback(this,{\n\t\t\t\t\t\t\tattributeName: attrName,\n\t\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\t\tnodeList: nodeList\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tstate.attr = null;\n\t\t\t}\n\t\t},\n\t\tattrValue: function(value, lineNo){\n\t\t\tvar section = state.node.section || state.attr.section;\n\t\t\tif(section){\n\t\t\t\tsection.add(value);\n\t\t\t} else {\n\t\t\t\tstate.attr.value += value;\n\t\t\t}\n\t\t},\n\t\tchars: function(text, lineNo) {\n\t\t\t(state.textContentOnly || section).add(text);\n\t\t},\n\t\tspecial: function(text, lineNo){\n\t\t\tvar firstAndText = mustacheCore.splitModeFromExpression(text, state),\n\t\t\t\tmode = firstAndText.mode,\n\t\t\t\texpression = firstAndText.expression;\n\n\n\t\t\tif(expression === \"else\") {\n\t\t\t\tvar inverseSection;\n\t\t\t\tif(state.attr && state.attr.section) {\n\t\t\t\t\tinverseSection = state.attr.section;\n\t\t\t\t} else if(state.node && state.node.section ) {\n\t\t\t\t\tinverseSection = state.node.section;\n\t\t\t\t} else {\n\t\t\t\t\tinverseSection = state.textContentOnly || section;\n\t\t\t\t}\n\t\t\t\tinverseSection.inverse();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(mode === \"!\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(state.node && state.node.section) {\n\n\t\t\t\tmakeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);\n\n\t\t\t\tif(state.node.section.subSectionDepth() === 0){\n\t\t\t\t\tstate.node.attributes.push( state.node.section.compile(copyState()) );\n\t\t\t\t\tdelete state.node.section;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// `{{}}` in an attribute like `class=\"{{}}\"`\n\t\t\telse if(state.attr) {\n\n\t\t\t\tif(!state.attr.section) {\n\t\t\t\t\tstate.attr.section = new TextSectionBuilder();\n\t\t\t\t\tif(state.attr.value) {\n\t\t\t\t\t\tstate.attr.section.add(state.attr.value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmakeRendererAndUpdateSection(state.attr.section, mode, expression, lineNo);\n\n\t\t\t}\n\t\t\t// `{{}}` in a tag like `<div {{}}>`\n\t\t\telse if(state.node) {\n\n\t\t\t\tif(!state.node.attributes) {\n\t\t\t\t\tstate.node.attributes = [];\n\t\t\t\t}\n\t\t\t\tif(!mode) {\n\t\t\t\t\tstate.node.attributes.push(mustacheCore.makeLiveBindingBranchRenderer(null, expression, copyState({ filename: section.filename, lineNo: lineNo })));\n\t\t\t\t} else if( mode === \"#\" || mode === \"^\" ) {\n\t\t\t\t\tif(!state.node.section) {\n\t\t\t\t\t\tstate.node.section = new TextSectionBuilder();\n\t\t\t\t\t}\n\t\t\t\t\tmakeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(mode+\" is currently not supported within a tag.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmakeRendererAndUpdateSection(state.textContentOnly || section, mode, expression, lineNo);\n\t\t\t}\n\t\t},\n\t\tcomment: function(text) {\n\t\t\t// create comment node\n\t\t\tsection.add({\n\t\t\t\tcomment: text\n\t\t\t});\n\t\t},\n\t\tdone: function(lineNo){}\n\t});\n\n\tvar renderer = section.compile();\n\n\tvar scopifiedRenderer = ObservationRecorder.ignore(function(scope, options, nodeList){\n\n\t\t// Support passing nodeList as the second argument\n\t\tif (nodeList === undefined && canReflect.isListLike(options)) {\n\t\t\tnodeList = options;\n\t\t\toptions = undefined;\n\t\t}\n\n\t\t// if an object is passed to options, assume it is the helpers object\n\t\tif (options && !options.helpers && !options.partials && !options.tags) {\n\t\t\toptions = {\n\t\t\t\thelpers: options\n\t\t\t};\n\t\t}\n\t\t// mark passed in helper so they will be automatically passed\n\t\t// helperOptions (.fn, .inverse, etc) when called as Call Expressions\n\t\tcanReflect.eachKey(options && options.helpers, function(helperValue) {\n\t\t\thelperValue.requiresOptionsArgument = true;\n\t\t});\n\n\t\t// helpers, partials, tags, vars\n\t\tvar templateContext = new TemplateContext(options);\n\n\t\t// copy inline partials over\n\t\tcanReflect.eachKey(inlinePartials, function(partial, partialName) {\n\t\t\tcanReflect.setKeyValue(templateContext.partials, partialName, partial);\n\t\t});\n\n\t\t// allow the current renderer to be called with {{>scope.view}}\n\t\tcanReflect.setKeyValue(templateContext, 'view', scopifiedRenderer);\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tcanReflect.setKeyValue(templateContext, 'filename', section.filename);\n\t\t}\n\t\t//!steal-remove-end\n\n\n\t\t// now figure out the final structure ...\n\t\tif ( !(scope instanceof Scope) ) {\n\t\t\tscope = new Scope(templateContext).add(scope);\n\t\t} else {\n\t\t\t// we are going to split ...\n\t\t\tvar templateContextScope = new Scope(templateContext);\n\t\t\ttemplateContextScope._parent = scope._parent;\n\t\t\tscope._parent = templateContextScope;\n\t\t}\n\n\t\treturn renderer(scope.addLetContext(), nodeList);\n\t});\n\n\t// Identify is a view type\n\tscopifiedRenderer[isViewSymbol] = true;\n\n\treturn scopifiedRenderer;\n}\n\n// At this point, can.stache has been created\nassign(stache, mustacheHelpers);\n\nstache.safeString = function(text){\n\n\treturn canReflect.assignSymbols({},{\n\t\t\"can.toDOM\": function(){\n\t\t\treturn text;\n\t\t}\n\t});\n};\nstache.async = function(source){\n\tvar iAi = getIntermediateAndImports(source);\n\tvar importPromises = iAi.imports.map(function(moduleName){\n\t\treturn importer(moduleName);\n\t});\n\treturn Promise.all(importPromises).then(function(){\n\t\treturn stache(iAi.intermediate);\n\t});\n};\nvar templates = {};\nstache.from = mustacheCore.getTemplateById = function(id){\n\tif(!templates[id]) {\n\t\tvar el = DOCUMENT().getElementById(id);\n\t\tif(el) {\n\t\t\ttemplates[id] = stache(\"#\" + id, el.innerHTML);\n\t\t}\n\t}\n\treturn templates[id];\n};\n\nstache.registerPartial = function(id, partial) {\n\ttemplates[id] = (typeof partial === \"string\" ? stache(partial) : partial);\n};\n\nstache.addBindings = viewCallbacks.attrs;\n\nmodule.exports = namespace.stache = stache;\n"],"names":["last","utils","decodeHTML","document","el","getDocument","createElement","html","indexOf","replace","innerHTML","childNodes","length","item","nodeValue","HTMLSectionBuilder","filename","this","stack","HTMLSection","assign","prototype","mixins","startSubSection","process","newSection","push","endSubSectionAndReturnRenderer","isEmpty","pop","htmlSection","endSection","makeView","compiled","hydrate","bind","startSection","add","targetCallback","compile","inverse","chars","removeCurrentNode","data","targetData","targetStack","self","scope","sectionNode","call","inverseCompiled","inverseData","children","target","noop","TextSectionBuilder","TextSection","subSection","truthy","falseySection","falsey","state","renderer","env","NODE_ENV","Object","defineProperty","value","tag","attr","textSectionRender","observation","Observation","isObservable","canReflect","onValue","getValue","valueHasDependencies","textContentOnly","live","text","attrs","offValue","domMutate","setAttribute","passTruthyFalsey","values","len","i","txt","expression","require$$0","toDOMSymbol","canSymbol","for","HelperOptions","nodeList","exprData","stringOnly","metadata","rendered","defineLazyValue","peek","mustacheLineBreakRegExp","mustacheWhitespaceRegExp","k","viewInsertSymbol","valueShouldBeInsertedAsHTML","nodeType","core","makeEvaluator","mode","truthyRenderer","falseyRenderer","temp","helperOptions","createRenderers","Call","Bracket","Lookup","Helper","methodExpr","result","finalValue","isListLike","isObserveList","isObservableLike","getKeyValue","getItemsStringContent","frag","getItemsFragContent","fn","makeLiveBindingPartialRenderer","expressionString","partialName","trim","split","shift","parse","parentSectionNodeList","set","lineNo","nodeLists","register","directlyNested","partialFrag","localPartialName","argExprs","newContext","dev","warn","key","partial","templateContext","partials","render","scopePartialName","read","isArgument","domRenderer","getTemplateById","createDocumentFragment","res","ObservationRecorder","ignore","setPriority","nesting","parentNode","makeStringBranchRenderer","fullExpression","branchRenderer","evaluator","__cache","makeLiveBindingBranchRenderer","observable","Error","makeString","insert","oldNodes","update","ownerDocument","splitModeFromExpression","charAt","substr","node","cleanLineEndings","template","whole","returnBefore","spaceBefore","special","spaceAfter","returnAfter","spaceLessSpecial","spaceLessExpression","matchIndex","modeAndExpression","cleanWhitespaceControl","bracketBefore","controlBefore","controlAfter","bracketAfter","makeConverter","getterSetter","newVal","source","args","toArray","arguments","SetIdentifier","apply","concat","slice","get","converterPackages","WeakMap","helpers","addConverter","name","helper","isLiveBound","registerHelper","has","eachKey","registerConverter","converterHelpers","not","obs","options","looksLikeOptions","setValue","whiteSpaceReplacement","undefined","controls","imports","dynamicImports","importDeclarations","ases","attributes","Map","inImport","inFrom","inAs","isUnary","importIsDynamic","currentAs","currentFrom","currentAttrName","processImport","line","specifier","loc","program","parser","start","tagName","unary","attrStart","attrName","attrEnd","attrValue","end","close","intermediate","exports","getIntermediateAndImports","require$$1","makeRendererConvertScopes","viewCallbacks","tagData","isViewSymbol","wrappedAttrPattern","colonWrappedAttrPattern","svgNamespace","namespaces","svg","g","textContentOnlyTag","style","script","stache","inlinePartials","mustacheCore","section","sectionElementStack","namespaceStack","makeRendererAndUpdateSection","copyState","startedWith","type","makeRenderer","sectionItem","closingTag","isDirectlyNested","lastElement","overwrites","cur","addAttributesCallback","callback","unshift","matchedNamespace","namespace","isCustomTag","parentNodeList","tagHandler","subtemplate","templateType","templates","oldNode","parent","current","attrCallback","decodedAttrName","attributeEncoder","decode","test","attributeName","firstAndText","subSectionDepth","comment","done","scopifiedRenderer","tags","helperValue","requiresOptionsArgument","TemplateContext","setKeyValue","Scope","templateContextScope","_parent","addLetContext","mustacheHelpers","safeString","assignSymbols","can.toDOM","async","iAi","importPromises","map","moduleName","importer","Promise","all","then","from","id","DOCUMENT","getElementById","registerPartial","addBindings"],"mappings":"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"}