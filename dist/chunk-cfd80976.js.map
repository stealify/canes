{"version":3,"file":"chunk-cfd80976.js","sources":["../node_modules/can-attribute-observable/event.js","../node_modules/can-attribute-observable/get-event-name.js","../node_modules/can-attribute-observable/can-attribute-observable.js","../node_modules/can-stache-bindings/can-stache-bindings.js"],"sourcesContent":["\"use strict\";\nvar canReflect = require(\"can-reflect\");\nvar domEvents = require(\"can-dom-events\");\nvar isDomEventTarget = require(\"can-dom-events/helpers/util\").isDomEventTarget;\n\nvar canEvent = {\n\ton: function on(eventName, handler, queue) {\n\t\tif (isDomEventTarget(this)) {\n\t\t\tdomEvents.addEventListener(this, eventName, handler, queue);\n\t\t} else {\n\t\t\tcanReflect.onKeyValue(this, eventName, handler, queue);\n\t\t}\n\t},\n\toff: function off(eventName, handler, queue) {\n\t\tif (isDomEventTarget(this)) {\n\t\t\tdomEvents.removeEventListener(this, eventName, handler, queue);\n\t\t} else {\n\t\t\tcanReflect.offKeyValue(this, eventName, handler, queue);\n\t\t}\n\t},\n\tone: function one(event, handler, queue) {\n\t\t// Unbind the listener after it has been executed\n\t\tvar one = function() {\n\t\t\tcanEvent.off.call(this, event, one, queue);\n\t\t\treturn handler.apply(this, arguments);\n\t\t};\n\n\t\t// Bind the altered listener\n\t\tcanEvent.on.call(this, event, one, queue);\n\t\treturn this;\n\t}\n};\n\nmodule.exports = canEvent;\n","\"use strict\";\nvar attr = require(\"./behaviors\");\n\nvar isRadioInput = function isRadioInput(el) {\n\treturn el.nodeName.toLowerCase() === \"input\" && el.type === \"radio\";\n};\n\nvar isValidProp = function isValidProp(prop, bindingData) {\n\treturn prop === \"checked\" && !bindingData.legacyBindings;\n};\n\n// Determine the event or events we need to listen to when this value changes.\nmodule.exports = function getEventName(el, prop, bindingData) {\n\tvar event = \"change\";\n\n\tif (isRadioInput(el) && isValidProp(prop, bindingData)) {\n\t\tevent = \"can-attribute-observable-radiochange\";\n\t}\n\n\tif (attr.findSpecialListener(prop)) {\n\t\tevent = prop;\n\t}\n\n\treturn event;\n};\n","\"use strict\";\nvar queues = require(\"can-queues\");\nvar canEvent = require(\"./event\");\nvar canReflect = require(\"can-reflect\");\nvar Observation = require(\"can-observation\");\nvar attr = require(\"./behaviors\");\nvar getEventName = require(\"./get-event-name\");\nvar canReflectDeps = require(\"can-reflect-dependencies\");\nvar ObservationRecorder = require(\"can-observation-recorder\");\nvar SettableObservable = require(\"can-simple-observable/settable/settable\");\n\n// We register a namespaced radiochange event with the global\n// event registry so it does not interfere with user-defined events.\nvar domEvents = require(\"can-dom-events\");\nvar radioChangeEvent = require(\"can-event-dom-radiochange\");\nvar internalRadioChangeEventType = \"can-attribute-observable-radiochange\";\ndomEvents.addEvent(radioChangeEvent, internalRadioChangeEventType);\n\nvar isSelect = function isSelect(el) {\n\treturn el.nodeName.toLowerCase() === \"select\";\n};\n\nvar isMultipleSelect = function isMultipleSelect(el, prop) {\n\treturn isSelect(el) && prop === \"value\" && el.multiple;\n};\n\nvar slice = Array.prototype.slice;\n\nfunction canUtilAEL () {\n\tvar args = slice.call(arguments, 0);\n\targs.unshift(this);\n\treturn domEvents.addEventListener.apply(null, args);\n}\n\nfunction canUtilREL () {\n\tvar args = slice.call(arguments, 0);\n\targs.unshift(this);\n\treturn domEvents.removeEventListener.apply(null, args);\n}\n\nfunction AttributeObservable(el, prop, bindingData, event) {\n\tthis.el = el;\n\tthis.bound = false;\n\tthis.bindingData = bindingData;\n\tthis.prop = isMultipleSelect(el, prop) ? \"values\" : prop;\n\tthis.event = event || getEventName(el, prop, bindingData);\n\tthis.handler = this.handler.bind(this);\n\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\t// register what changes the element's attribute\n\t\tcanReflectDeps.addMutatedBy(this.el, this.prop, this);\n\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function getName() {\n\t\t\t\treturn (\n\t\t\t\t\t\"AttributeObservable<\" +\n\t\t\t\t\tel.nodeName.toLowerCase() +\n\t\t\t\t\t\".\" +\n\t\t\t\t\tthis.prop +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\t//!steal-remove-end\n}\n\nAttributeObservable.prototype = Object.create(SettableObservable.prototype);\n\nObject.assign(AttributeObservable.prototype, {\n\tconstructor: AttributeObservable,\n\n\tget: function get() {\n\t\tif (ObservationRecorder.isRecording()) {\n\t\t\tObservationRecorder.add(this);\n\t\t\tif (!this.bound) {\n\t\t\t\tObservation.temporarilyBind(this);\n\t\t\t}\n\t\t}\n\t\tvar value = attr.get(this.el, this.prop);\n\t\tif (typeof value === 'function') {\n\t\t\tvalue = value.bind(this.el);\n\t\t}\n\t\treturn value;\n\t},\n\n\tset: function set(newVal) {\n\t\tvar setterDispatchedEvents = attr.setAttrOrProp(this.el, this.prop, newVal);\n\t\t// update the observation internal value\n\t\tif(!setterDispatchedEvents) {\n\t\t\tthis._value = newVal;\n\t\t}\n\n\n\t\treturn newVal;\n\t},\n\n\thandler: function handler(newVal, event) {\n\t\tvar old = this._value;\n\t\tvar queuesArgs = [];\n\t\tthis._value = attr.get(this.el, this.prop);\n\n\t\tif (this._value !== old) {\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\t\tthis._log(old, newVal);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.handlers.getNode([]),\n  \t\t\tthis,\n  \t\t\t[newVal, old]\n  \t\t];\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tqueuesArgs = [\n\t\t\t\t\tthis.handlers.getNode([]),\n\t\t\t\t\tthis,\n\t\t\t\t\t[newVal, old]\n\t\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t\t,null\n\t\t\t\t\t,[this.el,this.prop,\"changed to\", newVal, \"from\", old, \"by\", event]\n\t\t\t\t\t/* jshint laxcomma: false */\n\t\t\t\t];\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\t// adds callback handlers to be called w/i their respective queue.\n\t\t\tqueues.enqueueByQueue.apply(queues, queuesArgs);\n\t\t}\n\t},\n\n\tonBound: function onBound() {\n\t\tvar observable = this;\n\n\t\tobservable.bound = true;\n\n\t\t// make sure `this.handler` gets the new value instead of\n\t\t// the event object passed to the event handler\n\t\tobservable._handler = function(event) {\n\t\t\tobservable.handler(attr.get(observable.el, observable.prop), event);\n\t\t};\n\n\t\tif (observable.event === internalRadioChangeEventType) {\n\t\t\tcanEvent.on.call(observable.el, \"change\", observable._handler);\n\t\t}\n\n\t\tvar specialBinding = attr.findSpecialListener(observable.prop);\n\t\tif (specialBinding) {\n\t\t\tobservable._specialDisposal = specialBinding.call(observable.el, observable.prop, observable._handler, canUtilAEL);\n\t\t}\n\n\t\tcanEvent.on.call(observable.el, observable.event, observable._handler);\n\n\t\t// initial value\n\t\tthis._value = attr.get(this.el, this.prop);\n\t},\n\n\tonUnbound: function onUnbound() {\n\t\tvar observable = this;\n\n\t\tobservable.bound = false;\n\n\t\tif (observable.event === internalRadioChangeEventType) {\n\t\t\tcanEvent.off.call(observable.el, \"change\", observable._handler);\n\t\t}\n\n\t\tif (observable._specialDisposal) {\n\t\t\tobservable._specialDisposal.call(observable.el, canUtilREL);\n\t\t\tobservable._specialDisposal = null;\n\t\t}\n\n\t\tcanEvent.off.call(observable.el, observable.event, observable._handler);\n\t},\n\n\tvalueHasDependencies: function valueHasDependencies() {\n\t\treturn true;\n\t},\n\n\tgetValueDependencies: function getValueDependencies() {\n\t\tvar m = new Map();\n\t\tvar s = new Set();\n\t\ts.add(this.prop);\n\t\tm.set(this.el, s);\n\t\treturn {\n\t\t\tkeyDependencies: m\n\t\t};\n\t}\n});\n\ncanReflect.assignSymbols(AttributeObservable.prototype, {\n\t\"can.isMapLike\": false,\n\t\"can.getValue\": AttributeObservable.prototype.get,\n\t\"can.setValue\": AttributeObservable.prototype.set,\n\t\"can.onValue\": AttributeObservable.prototype.on,\n\t\"can.offValue\": AttributeObservable.prototype.off,\n\t\"can.valueHasDependencies\": AttributeObservable.prototype.hasDependencies,\n\t\"can.getValueDependencies\": AttributeObservable.prototype.getValueDependencies\n});\n\nmodule.exports = AttributeObservable;\n","\"use strict\";\n// # can-stache-bindings.js\n//\n// This module provides CanJS's default data and event bindings.\n// It's broken up into several parts:\n//\n// - Behaviors - Binding behaviors that run given an attribute or element.\n// - Attribute Syntaxes - Hooks up custom attributes to their behaviors.\n// - getObservableFrom - Methods that return a observable cross bound to the scope, viewModel, or element.\n// - bind - Methods for setting up cross binding\n// - getBindingInfo - A helper that returns the details of a data binding given an attribute.\n// - makeDataBinding - A helper method for setting up a data binding.\n// - initializeValues - A helper that initializes a data binding.\nvar Bind = require('can-bind');\nvar expression = require('can-stache/src/expression');\nvar viewCallbacks = require('can-view-callbacks');\nvar canViewModel = require('can-view-model');\nvar observeReader = require('can-stache-key');\nvar ObservationRecorder = require('can-observation-recorder');\nvar SimpleObservable = require('can-simple-observable');\n\nvar assign = require('can-assign');\nvar dev = require('can-log/dev/dev');\nvar domMutate = require('can-dom-mutate');\nvar domData = require('can-dom-data-state');\nvar canSymbol = require(\"can-symbol\");\nvar canReflect = require(\"can-reflect\");\nvar canReflectDeps = require(\"can-reflect-dependencies\");\nvar encoder = require(\"can-attribute-encoder\");\nvar queues = require(\"can-queues\");\nvar SettableObservable = require(\"can-simple-observable/setter/setter\");\nvar AttributeObservable = require(\"can-attribute-observable\");\nvar makeCompute = require(\"can-view-scope/make-compute-like\");\nvar ViewNodeList = require(\"can-view-nodelist\");\n\nvar canEvent = require(\"can-attribute-observable/event\");\n\n// Contains all of the stache bindings that will be exported.\nvar bindings = new Map();\n\nvar onMatchStr = \"on:\",\n\tvmMatchStr = \"vm:\",\n\telMatchStr = \"el:\",\n\tbyMatchStr = \":by:\",\n\ttoMatchStr = \":to\",\n\tfromMatchStr = \":from\",\n\tbindMatchStr = \":bind\",\n\tviewModelBindingStr = \"viewModel\",\n\tattributeBindingStr = \"attribute\",\n\tscopeBindingStr = \"scope\",\n\tviewModelOrAttributeBindingStr = \"viewModelOrAttribute\";\n\nvar throwOnlyOneTypeOfBindingError = function() {\n\tthrow new Error(\"can-stache-bindings - you can not have contextual bindings ( this:from='value' ) and key bindings ( prop:from='value' ) on one element.\");\n};\n\n// This function checks if there bindings that are trying\n// to set a property ON the viewModel _conflicting_ with bindings trying to\n// set THE viewModel ITSELF.\n// If there is a conflict, an error is thrown.\nvar checkBindingState = function(bindingState, bindingInfo) {\n\tvar isSettingOnViewModel = bindingInfo.parentToChild && bindingInfo.child === viewModelBindingStr;\n\tif (isSettingOnViewModel) {\n\t\tvar bindingName = bindingInfo.childName;\n\t\tvar isSettingViewModel = isSettingOnViewModel && ( bindingName === 'this' || bindingName === '.' );\n\n\t\tif (isSettingViewModel) {\n\t\t\tif (bindingState.isSettingViewModel || bindingState.isSettingOnViewModel) {\n\t\t\t\tthrowOnlyOneTypeOfBindingError();\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tisSettingViewModel: true,\n\t\t\t\t\tinitialViewModelData: undefined\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\t// just setting on viewModel\n\t\t\tif (bindingState.isSettingViewModel) {\n\t\t\t\tthrowOnlyOneTypeOfBindingError();\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tisSettingOnViewModel: true,\n\t\t\t\t\tinitialViewModelData: bindingState.initialViewModelData\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn bindingState;\n\t}\n};\n\nvar makeScopeFromEvent = function(element, event, viewModel, args, data){\n\tvar specialValues = {\n\t\telement: element,\n\t\tevent: event,\n\t\tviewModel: viewModel,\n\t\targuments: args\n\t};\n\n\t// make a scope with these things just under\n\treturn data.scope.add(specialValues, { special: true });\n};\n\nvar runEventCallback = function (el, ev, data, scope, expr, attributeName, attrVal) {\n\t// create \"special\" values that can be looked up using\n\t// {{scope.element}}, etc\n\n\tvar updateFn = function() {\n\t\tvar value = expr.value(scope, {\n\t\t\tdoNotWrapInObservation: true\n\t\t});\n\n\t\tvalue = canReflect.isValueLike(value) ?\n\t\t\tcanReflect.getValue(value) :\n\t\t\tvalue;\n\n\t\treturn typeof value === 'function' ?\n\t\t\tvalue(el) :\n\t\t\tvalue;\n\t};\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tObject.defineProperty(updateFn, \"name\", {\n\t\t\tvalue: attributeName + '=\"' + attrVal + '\"'\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tqueues.batch.start();\n\tvar mutateQueueArgs = [];\n\tmutateQueueArgs = [\n\t\tupdateFn,\n\t\tnull,\n\t\tnull,\n\t\t{}\n\t];\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tmutateQueueArgs = [\n\t\t\tupdateFn,\n\t\t\tnull,\n\t\t\tnull, {\n\t\t\t\treasonLog: [el, ev, attributeName+\"=\"+attrVal]\n\t\t\t}\n\t\t];\n\t}\n\t//!steal-remove-end\n\tqueues.mutateQueue.enqueue.apply(queues.mutateQueue, mutateQueueArgs);\n\tqueues.batch.stop();\n};\n\n// ## Behaviors\nvar behaviors = {\n\t// ### bindings.behaviors.viewModel\n\t// Sets up all of an element's data binding attributes to a \"soon-to-be-created\"\n\t// `viewModel`.\n\t// This is primarily used by `can.Component` to ensure that its\n\t// `viewModel` is initialized with values from the data bindings as quickly as possible.\n\t// Component could look up the data binding values itself.  However, that lookup\n\t// would have to be duplicated when the bindings are established.\n\t// Instead, this uses the `makeDataBinding` helper, which allows creation of the `viewModel`\n\t// after scope values have been looked up.\n\t//\n\t// - `makeViewModel(initialViewModelData)` - a function that returns the `viewModel`.\n\t// - `initialViewModelData` any initial data that should already be added to the `viewModel`.\n\t//\n\t// Returns:\n\t// - `function` - a function that tears all the bindings down. Component\n\t// wants all the bindings active so cleanup can be done during a component being removed.\n\tviewModel: function(el, tagData, makeViewModel, initialViewModelData, staticDataBindingsOnly) {\n\n\t\tvar viewModel,\n\t\t\t// Stores callbacks for when the viewModel is created.\n\t\t\tonCompleteBindings = [],\n\t\t\t// Stores what needs to be called when the element is removed\n\t\t\t// to prevent memory leaks.\n\t\t\tonTeardowns = {},\n\t\t\t// Track info about each binding, we need this for binding attributes correctly.\n\t\t\tbindingInfos = {},\n\t\t\tattributeViewModelBindings = assign({}, initialViewModelData),\n\t\t\tbindingsState = {\n\t\t\t\t// if we have a binding like {something}=\"foo\"\n\t\t\t\tisSettingOnViewModel: false,\n\t\t\t\t// if we have binding like {this}=\"bar\"\n\t\t\t\tisSettingViewModel: false,\n\t\t\t\tinitialViewModelData: initialViewModelData || {}\n\t\t\t},\n\t\t\thasDataBinding = false;\n\n\t\t// For each attribute, we start the binding process,\n\t\t// and save what's returned to be used when the `viewModel` is created,\n\t\t// the element is removed, or the attribute changes values.\n\t\tcanReflect.each(el.attributes || [], function(node) {\n\t\t\tvar dataBinding = makeDataBinding(node, el, {\n\t\t\t\ttemplateType: tagData.templateType,\n\t\t\t\tscope: tagData.scope,\n\t\t\t\tgetViewModel: function() {\n\t\t\t\t\treturn viewModel;\n\t\t\t\t},\n\t\t\t\tattributeViewModelBindings: attributeViewModelBindings,\n\t\t\t\talreadyUpdatedChild: true,\n\t\t\t\tnodeList: tagData.parentNodeList,\n\t\t\t\t// force viewModel bindings in cases when it is ambiguous whether you are binding\n\t\t\t\t// on viewModel or an attribute (:to, :from, :bind)\n\t\t\t\tfavorViewModel: true\n\t\t\t});\n\n\t\t\tif (dataBinding) {\n\t\t\t\tvar bindingInfo = dataBinding.bindingInfo;\n\t\t\t\tbindingsState = checkBindingState(bindingsState, bindingInfo);\n\t\t\t\thasDataBinding = true;\n\n\t\t\t\t// For bindings that change the viewModel,\n\t\t\t\t// save the initial value on the viewModel.\n\t\t\t\tif (bindingInfo.parentToChild) {\n\t\t\t\t\tvar parentValue = bindingInfo.stickyParentToChild ? makeCompute(dataBinding.parent) : dataBinding.canBinding.parentValue;\n\n\t\t\t\t\tif (parentValue !== undefined) {\n\n\t\t\t\t\t\tif (bindingsState.isSettingViewModel) {\n\t\t\t\t\t\t\t// the initial data is the context\n\t\t\t\t\t\t\t// TODO: this is covered by can-component’s tests but not can-stache-bindings’ tests\n\t\t\t\t\t\t\tbindingsState.initialViewModelData = parentValue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbindingsState.initialViewModelData[cleanVMName(bindingInfo.childName, tagData.scope)] = parentValue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Save what needs to happen after the `viewModel` is created.\n\t\t\t\tonCompleteBindings.push(dataBinding.canBinding.start.bind(dataBinding.canBinding));\n\n\t\t\t\tonTeardowns[node.name] = dataBinding.canBinding.stop.bind(dataBinding.canBinding);\n\t\t\t}\n\t\t});\n\t\tif (staticDataBindingsOnly && !hasDataBinding) {\n\t\t\treturn;\n\t\t}\n\t\t// Create the `viewModel` and call what needs to happen after `viewModel` is created.\n\t\tviewModel = makeViewModel(bindingsState.initialViewModelData, hasDataBinding, bindingsState);\n\n\t\tfor (var i = 0, len = onCompleteBindings.length; i < len; i++) {\n\t\t\tonCompleteBindings[i]();\n\t\t}\n\n\t\t// Listen to attribute changes and re-initialize\n\t\t// the bindings.\n\t\tvar attributeDisposal;\n\t\tif (!bindingsState.isSettingViewModel) {\n\t\t\tattributeDisposal = domMutate.onNodeAttributeChange(el, function(ev) {\n\t\t\t\tvar attrName = ev.attributeName,\n\t\t\t\t\tvalue = el.getAttribute(attrName);\n\n\t\t\t\tif (onTeardowns[attrName]) {\n\t\t\t\t\tonTeardowns[attrName]();\n\t\t\t\t}\n\t\t\t\t// Parent attribute bindings we always re-setup.\n\t\t\t\tvar parentBindingWasAttribute = bindingInfos[attrName] && bindingInfos[attrName].parent === attributeBindingStr;\n\n\t\t\t\tif (value !== null || parentBindingWasAttribute) {\n\t\t\t\t\tvar dataBinding = makeDataBinding({\n\t\t\t\t\t\tname: attrName,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t}, el, {\n\t\t\t\t\t\ttemplateType: tagData.templateType,\n\t\t\t\t\t\tscope: tagData.scope,\n\t\t\t\t\t\tgetViewModel: function() {\n\t\t\t\t\t\t\treturn viewModel;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tattributeViewModelBindings: attributeViewModelBindings,\n\t\t\t\t\t\t// always update the viewModel accordingly.\n\t\t\t\t\t\tinitializeValues: true,\n\t\t\t\t\t\tnodeList: tagData.parentNodeList\n\t\t\t\t\t});\n\t\t\t\t\tif (dataBinding) {\n\t\t\t\t\t\t// The viewModel is created, so call callback immediately.\n\t\t\t\t\t\tdataBinding.canBinding.start();\n\t\t\t\t\t\tbindingInfos[attrName] = dataBinding.bindingInfo;\n\t\t\t\t\t\tonTeardowns[attrName] = dataBinding.canBinding.stop.bind(dataBinding.canBinding);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn function() {\n\t\t\tif (attributeDisposal) {\n\t\t\t\tattributeDisposal();\n\t\t\t\tattributeDisposal = undefined;\n\t\t\t}\n\t\t\tfor (var attrName in onTeardowns) {\n\t\t\t\tonTeardowns[attrName]();\n\t\t\t}\n\t\t};\n\t},\n\t// ### bindings.behaviors.data\n\t// This is called when an individual data binding attribute is placed on an element.\n\t// For example `{^value}=\"name\"`.\n\tdata: function(el, attrData) {\n\t\tif (domData.get.call(el, \"preventDataBindings\")) {\n\t\t\treturn;\n\t\t}\n\t\tvar viewModel,\n\t\t\tgetViewModel = ObservationRecorder.ignore(function() {\n\t\t\t\treturn viewModel || (viewModel = canViewModel(el));\n\t\t\t}),\n\t\t\tteardown,\n\t\t\tattributeDisposal,\n\t\t\tremovedDisposal;\n\n\t\t// Setup binding\n\t\tvar dataBinding = makeDataBinding({\n\t\t\tname: attrData.attributeName,\n\t\t\tvalue: el.getAttribute(attrData.attributeName),\n\t\t\tnodeList: attrData.nodeList\n\t\t}, el, {\n\t\t\ttemplateType: attrData.templateType,\n\t\t\tscope: attrData.scope,\n\t\t\tgetViewModel: getViewModel,\n\t\t\tsyncChildWithParent: false\n\t\t});\n\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tif (dataBinding.bindingInfo.child === \"viewModel\" && !domData.get(el, \"viewModel\")) {\n\t\t\t\tdev.warn('This element does not have a viewModel. (Attempting to bind `' + dataBinding.bindingInfo.bindingAttributeName + '=\"' + dataBinding.bindingInfo.parentName + '\"`)');\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tdataBinding.canBinding.start();\n\n\t\tvar attributeListener = function(ev) {\n\t\t\tvar attrName = ev.attributeName,\n\t\t\t\tvalue = el.getAttribute(attrName);\n\n\t\t\tif (attrName === attrData.attributeName) {\n\t\t\t\tif (teardown) {\n\t\t\t\t\tteardown();\n\t\t\t\t}\n\n\t\t\t\tif(value !== null  ) {\n\t\t\t\t\tvar dataBinding = makeDataBinding({name: attrName, value: value}, el, {\n\t\t\t\t\t\ttemplateType: attrData.templateType,\n\t\t\t\t\t\tscope: attrData.scope,\n\t\t\t\t\t\tgetViewModel: getViewModel,\n\t\t\t\t\t\t// always update the viewModel accordingly.\n\t\t\t\t\t\tinitializeValues: true,\n\t\t\t\t\t\tnodeList: attrData.nodeList,\n\t\t\t\t\t\tsyncChildWithParent: false\n\t\t\t\t\t});\n\t\t\t\t\tif(dataBinding) {\n\t\t\t\t\t\t// The viewModel is created, so call callback immediately.\n\t\t\t\t\t\tdataBinding.canBinding.start();\n\t\t\t\t\t\tteardown = dataBinding.canBinding.stop.bind(dataBinding.canBinding);\n\t\t\t\t\t}\n\t\t\t\t\tteardown = dataBinding.onTeardown;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\t\tvar tearItAllDown = function() {\n\t\t\tif (teardown) {\n\t\t\t\tteardown();\n\t\t\t\tteardown = undefined;\n\t\t\t}\n\n\t\t\tif (removedDisposal) {\n\t\t\t\tremovedDisposal();\n\t\t\t\tremovedDisposal = undefined;\n\t\t\t}\n\t\t\tif (attributeDisposal) {\n\t\t\t\tattributeDisposal();\n\t\t\t\tattributeDisposal = undefined;\n\t\t\t}\n\t\t};\n\t\tif (attrData.nodeList) {\n\t\t\tViewNodeList.register([], tearItAllDown, attrData.nodeList, false);\n\t\t}\n\n\n\t\t// Listen for changes\n\t\tteardown = dataBinding.canBinding.stop.bind(dataBinding.canBinding);\n\n\t\tattributeDisposal = domMutate.onNodeAttributeChange(el, attributeListener);\n\t\tremovedDisposal = domMutate.onNodeRemoval(el, function() {\n\t\t\tvar doc = el.ownerDocument;\n\t\t\tvar ownerNode = doc.contains ? doc : doc.documentElement;\n\t\t\tif (ownerNode.contains(el) === false) {\n\t\t\t\ttearItAllDown();\n\t\t\t}\n\t\t});\n\t},\n\t// ### bindings.behaviors.event\n\t// The following section contains code for implementing the can-EVENT attribute.\n\t// This binds on a wildcard attribute name. Whenever a view is being processed\n\t// and can-xxx (anything starting with can-), this callback will be run.  Inside, its setting up an event handler\n\t// that calls a method identified by the value of this attribute.\n\tevent: function(el, data) {\n\n\t\t// Get the `event` name and if we are listening to the element or viewModel.\n\t\t// The attribute name is the name of the event.\n\t\tvar attributeName = encoder.decode(data.attributeName),\n\t\t\t// the name of the event we are binding\n\t\t\tevent,\n\t\t\t// if we are binding on the element or the VM\n\t\t\tbindingContext;\n\n\t\t// check for `on:event:value:to` type things and call data bindings\n\t\tif (attributeName.indexOf(toMatchStr + \":\") !== -1 ||\n\t\t\tattributeName.indexOf(fromMatchStr + \":\") !== -1 ||\n\t\t\tattributeName.indexOf(bindMatchStr + \":\") !== -1\n\t\t) {\n\t\t\treturn this.data(el, data);\n\t\t}\n\n\t\tif (startsWith.call(attributeName, onMatchStr)) {\n\t\t\tevent = attributeName.substr(onMatchStr.length);\n\t\t\tvar viewModel = el[canSymbol.for('can.viewModel')];\n\n\t\t\t// when using on:prop:by:obj\n\t\t\t// bindingContext should be scope.obj\n\t\t\tvar byParent = data.scope;\n\n\t\t\t// get the bindingContext\n\t\t\t// on:el:prop -> bindingContext = element\n\t\t\t// on:vm:prop -> bindingContext = viewModel\n\t\t\t// otherwise,\n\t\t\t// bind on the element if there is not a viewModel\n\t\t\tif (startsWith.call(event, elMatchStr)) {\n\t\t\t\tevent = event.substr(elMatchStr.length);\n\t\t\t\tbindingContext = el;\n\t\t\t} else {\n\t\t\t\tif (startsWith.call(event, vmMatchStr)) {\n\t\t\t\t\tevent = event.substr(vmMatchStr.length);\n\t\t\t\t\tbindingContext = viewModel;\n\n\t\t\t\t\t// when using on:vm:prop:by:obj\n\t\t\t\t\t// bindingContext should be viewModel.obj\n\t\t\t\t\tbyParent = viewModel;\n\t\t\t\t} else {\n\t\t\t\t\tbindingContext = viewModel || el;\n\t\t\t\t}\n\n\t\t\t\t// update the bindingContext and event if using :by:\n\t\t\t\t// on:prop:by:obj\n\t\t\t\t//   -> bindingContext = byParent.get('obj')\n\t\t\t\t//   -> event = 'prop'\n\t\t\t\tvar byIndex = event.indexOf(byMatchStr);\n\t\t\t\tif (byIndex >= 0) {\n\t\t\t\t\tbindingContext = byParent.get(event.substr(byIndex + byMatchStr.length));\n\t\t\t\t\tevent = event.substr(0, byIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"can-stache-bindings - unsupported event bindings \" + attributeName);\n\t\t}\n\n\t\t// This is the method that the event will initially trigger. It will look up the method by the string name\n\t\t// passed in the attribute and call it.\n\t\tvar handler = function(ev) {\n\t\t\tvar attrVal = el.getAttribute(encoder.encode(attributeName));\n\t\t\tif (!attrVal) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar viewModel = canViewModel(el);\n\n\t\t\t// expression.parse will read the attribute\n\t\t\t// value and parse it identically to how mustache helpers\n\t\t\t// get parsed.\n\t\t\tvar expr = expression.parse(attrVal, {\n\t\t\t\tlookupRule: function() {\n\t\t\t\t\treturn expression.Lookup;\n\t\t\t\t},\n\t\t\t\tmethodRule: \"call\"\n\t\t\t});\n\n\t\t\tvar runScope = makeScopeFromEvent(el, ev, viewModel, arguments, data);\n\n\t\t\tif (expr instanceof expression.Hashes) {\n\t\t\t\tvar hashExprs = expr.hashExprs;\n\t\t\t\tvar key = Object.keys(hashExprs)[0];\n\t\t\t\tvar value = expr.hashExprs[key].value(runScope);\n\t\t\t\tvar isObservableValue = canReflect.isObservableLike(value) && canReflect.isValueLike(value);\n\t\t\t\trunScope.set(key, isObservableValue ? canReflect.getValue(value) : value);\n\t\t\t} else if (expr instanceof expression.Call) {\n\t\t\t\trunEventCallback(el, ev, data, runScope, expr, attributeName, attrVal);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"can-stache-bindings: Event bindings must be a call expression. Make sure you have a () in \" + data.attributeName + \"=\" + JSON.stringify(attrVal));\n\t\t\t}\n\t\t};\n\n\t\tvar attributesDisposal,\n\t\t\tremovalDisposal;\n\n\t\t// Unbind the event when the attribute is removed from the DOM\n\t\tvar attributesHandler = function(ev) {\n\t\t\tvar isEventAttribute = ev.attributeName === attributeName;\n\t\t\tvar isRemoved = !el.getAttribute(attributeName);\n\t\t\tvar isEventAttributeRemoved = isEventAttribute && isRemoved;\n\t\t\tif (isEventAttributeRemoved) {\n\t\t\t\tunbindEvent();\n\t\t\t}\n\t\t};\n\t\tvar removalHandler = function() {\n\t\t\tvar doc = el.ownerDocument;\n\t\t\tvar ownerNode = doc.contains ? doc : doc.documentElement;\n\t\t\tif (!ownerNode.contains(el)) {\n\t\t\t\tunbindEvent();\n\t\t\t}\n\t\t};\n\t\tvar unbindEvent = function() {\n\t\t\tcanEvent.off.call(bindingContext, event, handler);\n\t\t\tif (attributesDisposal) {\n\t\t\t\tattributesDisposal();\n\t\t\t\tattributesDisposal = undefined;\n\t\t\t}\n\t\t\tif (removalDisposal) {\n\t\t\t\tremovalDisposal();\n\t\t\t\tremovalDisposal = undefined;\n\t\t\t}\n\t\t};\n\n\t\t// Bind the handler defined above to the element we're currently processing and the event name provided in this\n\t\t// attribute name (can-click=\"foo\")\n\t\tcanEvent.on.call(bindingContext, event, handler);\n\t\tattributesDisposal = domMutate.onNodeAttributeChange(el, attributesHandler);\n\t\tremovalDisposal = domMutate.onNodeRemoval(el, removalHandler);\n\t}\n};\n\n\n// ## Attribute Syntaxes\n// The following sets up the bindings functions to be called\n// when called in a template.\n\n\n// value:to=\"bar\" data bindings\n// these are separate so that they only capture at the end\n// to avoid (toggle)=\"bar\" which is encoded as :lp:toggle:rp:=\"bar\"\nbindings.set(/[\\w\\.:]+:to$/, behaviors.data);\nbindings.set(/[\\w\\.:]+:from$/, behaviors.data);\nbindings.set(/[\\w\\.:]+:bind$/, behaviors.data);\nbindings.set(/[\\w\\.:]+:raw$/, behaviors.data);\n// value:to:on:input=\"bar\" data bindings\nbindings.set(/[\\w\\.:]+:to:on:[\\w\\.:]+/, behaviors.data);\nbindings.set(/[\\w\\.:]+:from:on:[\\w\\.:]+/, behaviors.data);\nbindings.set(/[\\w\\.:]+:bind:on:[\\w\\.:]+/, behaviors.data);\n\n\n// `(EVENT)` event bindings.\nbindings.set(/on:[\\w\\.:]+/, behaviors.event);\n\n// ## getObservableFrom\n// An object of helper functions that make a getter/setter observable\n// on different types of objects.\nvar getObservableFrom = {\n\t// ### getObservableFrom.viewModelOrAttribute\n\tviewModelOrAttribute: function(el, scope, vmNameOrProp, bindingData, mustBeGettable, stickyCompute, event) {\n\t\tvar viewModel = el[canSymbol.for('can.viewModel')];\n\n\t\t// if we have a viewModel, use it; otherwise, setup attribute binding\n\t\tif (viewModel) {\n\t\t\treturn this.viewModel.apply(this, arguments);\n\t\t} else {\n\t\t\treturn this.attribute.apply(this, arguments);\n\t\t}\n\t},\n\t// ### getObservableFrom.scope\n\t// Returns a compute from the scope.  This handles expressions like `someMethod(.,1)`.\n\tscope: function(el, scope, scopeProp, bindingData, mustBeGettable, stickyCompute) {\n\t\tif (!scopeProp) {\n\t\t\treturn new SimpleObservable();\n\t\t} else {\n\t\t\t// Check if we need to spend time building a scope-key-data\n\t\t\t// If we have a '(', it likely means a call expression.\n\t\t\tif (mustBeGettable || scopeProp.indexOf(\"(\") >= 0 ) {\n\t\t\t\tvar parentExpression = expression.parse(scopeProp,{baseMethodType: \"Call\"});\n\t\t\t\treturn parentExpression.value(scope);\n\t\t\t} else {\n\t\t\t\tvar observation = {};\n\t\t\t\tcanReflect.assignSymbols(observation, {\n\t\t\t\t\t\"can.getValue\": function getValue() {},\n\n\t\t\t\t\t\"can.valueHasDependencies\": function hasValueDependencies() {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\n\t\t\t\t\t\"can.setValue\": function setValue(newVal) {\n\t\t\t\t\t\tscope.set(cleanVMName(scopeProp, scope), newVal);\n\t\t\t\t\t},\n\n\t\t\t\t\t// Register what the custom observation changes\n\t\t\t\t\t\"can.getWhatIChange\": function getWhatIChange() {\n\t\t\t\t\t\tvar data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));\n\t\t\t\t\t\tvar m = new Map();\n\t\t\t\t\t\tvar s = new Set();\n\t\t\t\t\t\ts.add(data.key);\n\t\t\t\t\t\tm.set(data.parent, s);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tmutate: {\n\t\t\t\t\t\t\t\tkeyDependencies: m\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\n\t\t\t\t\t\"can.getName\": function getName() {\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t\tvar result = \"ObservableFromScope<>\";\n\t\t\t\t\t\t\tvar data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));\n\n\t\t\t\t\t\t\tif (data.parent && data.key) {\n\t\t\t\t\t\t\t\tresult = \"ObservableFromScope<\" +\n\t\t\t\t\t\t\t\t\tcanReflect.getName(data.parent) +\n\t\t\t\t\t\t\t\t\t\".\" +\n\t\t\t\t\t\t\t\t\tdata.key +\n\t\t\t\t\t\t\t\t\t\">\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tvar data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));\n\t\t\t\tif (data.parent && data.key) {\n\t\t\t\t\t// Register what changes the Scope's parent key\n\t\t\t\t\tcanReflectDeps.addMutatedBy(data.parent, data.key, observation);\n\t\t\t\t}\n\n\t\t\t\treturn observation;\n\t\t\t}\n\t\t}\n\t},\n\t// ### getObservableFrom.viewModel\n\t// Returns a compute that's two-way bound to the `viewModel` returned by\n\t// `options.getViewModel()`.\n\tviewModel: function(el, scope, vmName, bindingData, mustBeGettable, stickyCompute, childEvent) {\n\t\tvar setName = cleanVMName(vmName, scope);\n\t\tvar isBoundToContext = vmName === \".\" || vmName === \"this\";\n\t\tvar keysToRead = isBoundToContext ? [] : observeReader.reads(vmName);\n\n\t\tfunction getViewModelProperty() {\n\t\t\tvar viewModel = bindingData.getViewModel();\n\t\t\treturn observeReader.read(viewModel, keysToRead, {}).value;\n\t\t}\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\n\t\t\tObject.defineProperty(getViewModelProperty, \"name\", {\n\t\t\t\tvalue: \"<\"+el.tagName.toLowerCase()+\">.\" + vmName\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tvar observation = new SettableObservable(\n\t\t\tgetViewModelProperty,\n\n\t\t\tfunction setViewModelProperty(newVal) {\n\t\t\t\tvar viewModel = bindingData.getViewModel();\n\n\t\t\t\tif (stickyCompute) {\n\t\t\t\t\t// TODO: Review what this is used for.\n\t\t\t\t\tvar oldValue = canReflect.getKeyValue(viewModel, setName);\n\t\t\t\t\tif (canReflect.isObservableLike(oldValue)) {\n\t\t\t\t\t\tcanReflect.setValue(oldValue, newVal);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanReflect.setKeyValue(\n\t\t\t\t\t\t\tviewModel,\n\t\t\t\t\t\t\tsetName,\n\t\t\t\t\t\t\tnew SimpleObservable(canReflect.getValue(stickyCompute))\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isBoundToContext) {\n\t\t\t\t\t\tcanReflect.setValue(viewModel, newVal);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanReflect.setKeyValue(viewModel, setName, newVal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tvar viewModel = bindingData.getViewModel();\n\t\t\tif (viewModel && setName) {\n\t\t\t\tcanReflectDeps.addMutatedBy(viewModel, setName, observation);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\treturn observation;\n\t},\n\t// ### getObservableFrom.attribute\n\t// Returns a compute that is two-way bound to an attribute or property on the element.\n\tattribute: function(el, scope, prop, bindingData, mustBeGettable, stickyCompute, event, bindingInfo) {\n\t\treturn new AttributeObservable(el, prop, bindingData, event);\n\t}\n};\n\nvar startsWith = String.prototype.startsWith || function(text){\n\treturn this.indexOf(text) === 0;\n};\n\n// Gets an event name in the after part.\nfunction getEventName(result) {\n\tif (result.special.on !== undefined) {\n\t\treturn result.tokens[result.special.on + 1];\n\t}\n}\n\nvar bindingRules = {\n\tto: {\n\t\tchildToParent: true,\n\t\tparentToChild: false,\n\t\tsyncChildWithParent: false\n\t},\n\tfrom: {\n\t\tchildToParent: false,\n\t\tparentToChild: true,\n\t\tsyncChildWithParent: false,\n\t},\n\tbind: {\n\t\tchildToParent: true,\n\t\tparentToChild: true,\n\t\tsyncChildWithParent: true,\n\t},\n\traw: {\n\t\tchildToParent: false,\n\t\tparentToChild: true,\n\t\tsyncChildWithParent: false\n\t}\n};\nvar bindingNames = [];\nvar special = {\n\tvm: true,\n\ton: true\n};\ncanReflect.each(bindingRules, function(value, key) {\n\tbindingNames.push(key);\n\tspecial[key] = true;\n});\n\n// \"on:click:value:to\" //-> {tokens: [...], special: {on: 0, to: 3}}\nfunction tokenize(source) {\n\tvar splitByColon = source.split(\":\");\n\t// combine tokens that are not to, from, vm,\n\tvar result = {\n\t\ttokens: [],\n\t\tspecial: {}\n\t};\n\tsplitByColon.forEach(function(token) {\n\t\tif (special[token]) {\n\t\t\tresult.special[token] = result.tokens.push(token) - 1;\n\t\t} else {\n\t\t\tresult.tokens.push(token);\n\t\t}\n\t});\n\n\treturn result;\n}\n\n// ## getChildBindingStr\nvar getChildBindingStr = function(tokens, favorViewModel) {\n\tif (tokens.indexOf('vm') >= 0) {\n\t\treturn viewModelBindingStr;\n\t} else if (tokens.indexOf('el') >= 0) {\n\t\treturn attributeBindingStr;\n\t} else {\n\t\treturn favorViewModel ? viewModelBindingStr : viewModelOrAttributeBindingStr;\n\t}\n};\n\n// ## getBindingInfo\n// takes a node object like {name, value} and returns\n// an object with information about that binding.\n// Properties:\n// - `parent` - where is the parentName read from: \"scope\", \"attribute\", \"viewModel\".\n// - `parentName` - what is the parent property that should be read.\n// - `child` - where is the childName read from: \"scope\", \"attribute\", \"viewModel\".\n//  - `childName` - what is the child property that should be read.\n// - `parentToChild` - should changes in the parent update the child.\n// - `childToParent` - should changes in the child update the parent.\n// - `bindingAttributeName` - the attribute name that created this binding.\n// - `initializeValues` - should parent and child be initialized to their counterpart.\n// If undefined is return, there is no binding.\nvar getBindingInfo = function(node, attributeViewModelBindings, templateType, tagName, favorViewModel) {\n\tvar bindingInfo,\n\t\tattributeName = encoder.decode(node.name),\n\t\tattributeValue = node.value || \"\";\n\n\t// START: check new binding syntaxes ======\n\tvar result = tokenize(attributeName),\n\t\tdataBindingName,\n\t\tspecialIndex;\n\n\n\n\t// check if there's a match of a binding name with at least a value before it\n\tbindingNames.forEach(function(name) {\n\t\tif (result.special[name] !== undefined && result.special[name] > 0) {\n\t\t\tdataBindingName = name;\n\t\t\tspecialIndex = result.special[name];\n\t\t\treturn false;\n\t\t}\n\t});\n\n\tif (dataBindingName) {\n\t\tvar childEventName = getEventName(result);\n\t\tvar initializeValues = childEventName && dataBindingName !== \"bind\" ? false : true;\n\t\tbindingInfo = assign({\n\t\t\tparent: scopeBindingStr,\n\t\t\tchild: getChildBindingStr(result.tokens, favorViewModel),\n\t\t\t// the child is going to be the token before the special location\n\t\t\tchildName: result.tokens[specialIndex - 1],\n\t\t\tchildEvent: childEventName,\n\t\t\tbindingAttributeName: attributeName,\n\t\t\tparentName: result.special.raw ? ('\"' + attributeValue + '\"') : attributeValue,\n\t\t\tinitializeValues: initializeValues,\n\t\t}, bindingRules[dataBindingName]);\n\t\tif (attributeValue.trim().charAt(0) === \"~\") {\n\t\t\tbindingInfo.stickyParentToChild = true;\n\t\t}\n\t\treturn bindingInfo;\n\t}\n\t// END: check new binding syntaxes ======\n\n};\n\n\n\n// ## makeDataBinding\n// Makes a data binding for an attribute `node`.  Returns an object with information\n// about the binding, including an `onTeardown` method that undoes the binding.\n// If the data binding involves a `viewModel`, an `onCompleteBinding` method is returned on\n// the object.  This method must be called after the element has a `viewModel` with the\n// `viewModel` to complete the binding.\n//\n// - `node` - an attribute node or an object with a `name` and `value` property.\n// - `el` - the element this binding belongs on.\n// - `bindingData` - an object with:\n//   - `templateType` - the type of template.\n//   - `scope` - the `Scope`,\n//   - `getViewModel`  - a function that returns the `viewModel` when called.  This function can be passed around (not called) even if the\n//      `viewModel` doesn't exist yet.\n//   - `attributeViewModelBindings` - properties already specified as being a viewModel<->attribute (as opposed to viewModel<->scope) binding.\n//\n// Returns:\n// - `undefined` - If this isn't a data binding.\n// - `object` - An object with information about the binding.\nvar makeDataBinding = function(node, el, bindingData) {\n\t// Get information about the binding.\n\tvar bindingInfo = getBindingInfo(node, bindingData.attributeViewModelBindings,\n\t\tbindingData.templateType, el.nodeName.toLowerCase(), bindingData.favorViewModel);\n\tif (!bindingInfo) {\n\t\treturn;\n\t}\n\n\t// Get computes for the parent and child binding\n\tvar parentObservable = getObservableFrom[bindingInfo.parent](\n\t\tel,\n\t\tbindingData.scope,\n\t\tbindingInfo.parentName,\n\t\tbindingData,\n\t\tbindingInfo.parentToChild,\n\t\tundefined,\n\t\tundefined,\n\t\tbindingInfo\n\t),\n\tchildObservable = getObservableFrom[bindingInfo.child](\n\t\tel,\n\t\tbindingData.scope,\n\t\tbindingInfo.childName,\n\t\tbindingData,\n\t\tbindingInfo.childToParent,\n\t\tbindingInfo.stickyParentToChild && parentObservable,\n\t\tbindingInfo.childEvent,\n\t\tbindingInfo\n\t);\n\n\t// Check for child:bind=\"~parent\" (it’s not supported because it’s unclear\n\t// what the “right” behavior should be)\n\tvar childToParent = !!bindingInfo.childToParent;\n\tvar parentToChild = !!bindingInfo.parentToChild;\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tif (bindingInfo.stickyParentToChild && childToParent && parentToChild) {\n\t\t\tdev.warn(\"Two-way binding computes is not supported.\");\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\tvar bindingOptions = {\n\t\tchild: childObservable,\n\t\tchildToParent: childToParent,\n\t\tcycles: 0,\n\t\tonInitDoNotUpdateChild: bindingData.alreadyUpdatedChild,\n\t\tonInitSetUndefinedParentIfChildIsDefined: true,\n\t\tparent: parentObservable,\n\t\tparentToChild: parentToChild,\n\t\tpriority: bindingData.nodeList ? bindingData.nodeList.nesting + 1 : undefined,\n\t\tqueue: \"domUI\",\n\t\tsticky: bindingInfo.syncChildWithParent ? \"childSticksToParent\" : undefined\n\t};\n\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tvar nodeHTML = encoder.decode(node.name)+\"=\"+JSON.stringify(node.value);\n\t\tvar tagStart = \"<\"+el.nodeName.toLowerCase(),\n\t\t\ttag = tagStart+\">\";\n\n\t\tvar makeUpdateName = function(child, childName) {\n\n\t\t\tif(child === \"viewModel\") {\n\t\t\t\treturn tag+\".\"+childName;\n\t\t\t}\n\t\t\telse if(child === \"scope\") {\n\t\t\t\treturn \"{{\"+childName+\"}}\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn \"\"+child+\".\"+childName;\n\t\t\t}\n\t\t};\n\t\tbindingOptions.updateChildName = tagStart+\" \"+nodeHTML+\"> updates \"+\n\t\t\tmakeUpdateName(bindingInfo.child, bindingInfo.childName)+\n\t\t\t\" from \"+makeUpdateName(bindingInfo.parent, bindingInfo.parentName);\n\n\t\tbindingOptions.updateParentName = tagStart+\" \"+nodeHTML+\"> updates \"+\n\t\t\tmakeUpdateName(bindingInfo.parent, bindingInfo.parentName)+\n\t\t\t\" from \"+makeUpdateName(bindingInfo.child, bindingInfo.childName);\n\t}\n\t//!steal-remove-end\n\n\t// Create the binding\n\tvar canBinding = new Bind(bindingOptions);\n\n\t// Immediately bind to the parent\n\t// TODO: it doesn’t appear that there are any tests that cover this behavior\n\tcanBinding.startParent();\n\n\treturn {\n\t\tbindingInfo: bindingInfo,\n\t\tcanBinding: canBinding,\n\t\tparent: parentObservable\n\t};\n};\n\nvar cleanVMName = function(name, scope) {\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tif (name.indexOf(\"@\") >= 0) {\n\t\t\tvar filename = scope.peek('scope.filename');\n\t\t\tvar lineNumber = scope.peek('scope.lineNumber');\n\n\t\t\tdev.warn(\n\t\t\t\t(filename ? filename + ':' : '') +\n\t\t\t\t(lineNumber ? lineNumber + ': ' : '') +\n\t\t\t\t'functions are no longer called by default so @ is unnecessary in \\'' + name + '\\'.');\n\t\t}\n\t}\n\t//!steal-remove-end\n\treturn name.replace(/@/g, \"\");\n};\n\nvar canStacheBindings = {\n\tbehaviors: behaviors,\n\tgetBindingInfo: getBindingInfo,\n\tbindings: bindings\n};\n\ncanStacheBindings[canSymbol.for(\"can.callbackMap\")] = bindings;\nviewCallbacks.attrs(canStacheBindings);\n\nmodule.exports = canStacheBindings;\n"],"names":["isDomEventTarget","require$$0","canEvent","on","eventName","handler","queue","this","domEvents","addEventListener","canReflect","onKeyValue","off","removeEventListener","offKeyValue","one","event","call","apply","arguments","isRadioInput","el","nodeName","toLowerCase","type","isValidProp","prop","bindingData","legacyBindings","attr","findSpecialListener","internalRadioChangeEventType","addEvent","radioChangeEvent","isSelect","isMultipleSelect","multiple","slice","Array","prototype","canUtilAEL","args","unshift","canUtilREL","AttributeObservable","bound","getEventName","bind","process","env","NODE_ENV","canReflectDeps","addMutatedBy","assignSymbols","can.getName","Object","create","SettableObservable","assign","constructor","get","ObservationRecorder","isRecording","add","Observation","temporarilyBind","value","set","newVal","setAttrOrProp","_value","old","queuesArgs","_log","handlers","getNode","queues","enqueueByQueue","onBound","observable","_handler","specialBinding","_specialDisposal","onUnbound","valueHasDependencies","getValueDependencies","m","Map","s","Set","keyDependencies","can.isMapLike","can.getValue","can.setValue","can.onValue","can.offValue","can.valueHasDependencies","hasDependencies","can.getValueDependencies","bindings","onMatchStr","vmMatchStr","elMatchStr","byMatchStr","toMatchStr","fromMatchStr","bindMatchStr","viewModelBindingStr","attributeBindingStr","scopeBindingStr","viewModelOrAttributeBindingStr","throwOnlyOneTypeOfBindingError","Error","checkBindingState","bindingState","bindingInfo","isSettingOnViewModel","parentToChild","child","bindingName","childName","isSettingViewModel","initialViewModelData","undefined","makeScopeFromEvent","element","viewModel","data","specialValues","scope","special","runEventCallback","ev","expr","attributeName","attrVal","updateFn","doNotWrapInObservation","isValueLike","getValue","defineProperty","batch","start","mutateQueueArgs","reasonLog","mutateQueue","enqueue","stop","behaviors","tagData","makeViewModel","staticDataBindingsOnly","onCompleteBindings","onTeardowns","bindingInfos","attributeViewModelBindings","bindingsState","hasDataBinding","each","attributes","node","dataBinding","makeDataBinding","templateType","getViewModel","alreadyUpdatedChild","nodeList","parentNodeList","favorViewModel","parentValue","stickyParentToChild","makeCompute","parent","canBinding","cleanVMName","push","name","i","len","length","attributeDisposal","domMutate","onNodeAttributeChange","attrName","getAttribute","parentBindingWasAttribute","initializeValues","attrData","domData","teardown","removedDisposal","ignore","canViewModel","syncChildWithParent","dev","warn","bindingAttributeName","parentName","tearItAllDown","ViewNodeList","register","onTeardown","onNodeRemoval","doc","ownerDocument","contains","documentElement","bindingContext","encoder","decode","indexOf","startsWith","substr","canSymbol","for","byParent","byIndex","attributesDisposal","removalDisposal","encode","expression","parse","lookupRule","Lookup","methodRule","runScope","Hashes","hashExprs","key","keys","isObservableValue","isObservableLike","Call","JSON","stringify","unbindEvent","isEventAttribute","isRemoved","getObservableFrom","viewModelOrAttribute","vmNameOrProp","mustBeGettable","stickyCompute","attribute","scopeProp","baseMethodType","observation","can.getWhatIChange","getDataForScopeSet","mutate","result","getName","SimpleObservable","vmName","childEvent","setName","isBoundToContext","keysToRead","observeReader","reads","getViewModelProperty","read","tagName","oldValue","getKeyValue","setValue","setKeyValue","String","text","tokens","bindingRules","to","childToParent","from","raw","bindingNames","vm","tokenize","source","splitByColon","split","forEach","token","getChildBindingStr","getBindingInfo","dataBindingName","specialIndex","attributeValue","childEventName","trim","charAt","parentObservable","childObservable","bindingOptions","cycles","onInitDoNotUpdateChild","onInitSetUndefinedParentIfChildIsDefined","priority","nesting","sticky","nodeHTML","tagStart","tag","makeUpdateName","updateChildName","updateParentName","Bind","startParent","filename","peek","lineNumber","replace","canStacheBindings","viewCallbacks","attrs"],"mappings":"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"}