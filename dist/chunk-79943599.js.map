{"version":3,"file":"chunk-79943599.js","sources":["../node_modules/can-event-queue/value/value.js"],"sourcesContent":["\"use strict\";\nvar queues = require(\"can-queues\");\nvar KeyTree = require(\"can-key-tree\");\nvar canReflect = require(\"can-reflect\");\nvar defineLazyValue = require(\"can-define-lazy-value\");\nvar mergeDependencyRecords = require(\"../dependency-record/merge\");\n\nvar properties = {\n\t/**\n\t * @function can-event-queue/value/value.on on\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Listen to changes in the observable's value.\n\t *\n\t * @signature `.on( handler[, queue='mutate'] )`\n\t *\n\t * This adds an event handler in the observable's [can-event-queue/value/value.handlers]\n\t * tree. If this is the first handler, the observable's [can-event-queue/value/value.onBound] method is called.\n\t *\n\t * ```js\n\t * observable.on(function(newVal){ ... });\n\t * observable.on(function(newVal){ ... }, \"notify\");\n\t * ```\n\t *\n\t * @param {function(*)} handler(newValue,oldValue) A handler that will be called with the new value of the\n\t * observable and optionally the old value of the observable.\n\t * @param {String} [queue] The [can-queues] queue this event handler should be bound to.  By default the handler will\n\t * be called within the `mutate` queue.\n\t */\n\ton: function(handler, queue) {\n\t\tthis.handlers.add([queue || \"mutate\", handler]);\n\t},\n\t/**\n\t * @function can-event-queue/value/value.off off\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Stop listening to changes in the observable's value.\n\t *\n\t * @signature `.off( [handler [, queue='mutate']] )`\n\t *\n\t * Removes one or more event handler in the observable's [can-event-queue/value/value.handlers]\n\t * tree. If the las handler is removed, the observable's [can-event-queue/value/value.onUnbound] method is called.\n\t *\n\t * ```js\n\t * observable.off(function(newVal){ ... });\n\t * observable.off(function(newVal){ ... }, \"notify\");\n\t * observable.off();\n\t * observable.off(undefined, \"mutate\");\n\t * ```\n\t *\n\t * @param {function(*)} handler(newValue,oldValue) The handler to be removed.  If no handler is provided and no\n\t * `queue` is provided, all handlers will be removed.\n\t * @param {String} [queue] The [can-queues] queue this event handler should be removed from.\n\t *\n\t *  If a `handler` is\n\t *  provided and no `queue` is provided, the `queue` will default to `\"mutate\"`.\n\t *\n\t *   If a `handler` is not provided, but a `queue` is provided, all handlers for the provided queue will be\n\t *   removed.\n\t */\n\toff: function(handler, queueName) {\n\t\tif (handler === undefined) {\n\t\t\tif (queueName === undefined) {\n\t\t\t\tthis.handlers.delete([]);\n\t\t\t} else {\n\t\t\t\tthis.handlers.delete([queueName]);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.handlers.delete([queueName || \"mutate\", handler]);\n\t\t}\n\t}\n};\n\nvar symbols = {\n\t/**\n\t * @function can-event-queue/value/value.can.onValue @can.onValue\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Listen to changes in this observable value.\n\t *\n\t * This is an alias for [can-event-queue/value/value.on].  It satisfies [can-reflect].[can-reflect/observe.onValue].\n\t */\n\t\"can.onValue\": properties.on,\n\t/**\n\t * @function can-event-queue/value/value.can.offValue @can.offValue\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Stop listening to changes in this observable value.\n\t *\n\t * This is an alias for [can-event-queue/value/value.off].  It satisfies [can-reflect].[can-reflect/observe.offValue].\n\t */\n\t\"can.offValue\": properties.off,\n\t/**\n\t * @function can-event-queue/value/value.can.dispatch @can.dispatch\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Dispatch all event handlers within their appropriate queues.\n\t *\n\t * @signature `@can.dispatch(newValue, oldValue)`\n\t *\n\t * This is a helper method that will dispatch all [can-event-queue/value/value.handlers] within\n\t * their appropriate [can-queues] queue.\n\t *\n\t * Furthermore, it will make sure the handlers include useful meta data for debugging.\n\t *\n\t * ```js\n\t * var observable = mixinValueBindings({});\n\t * observable[canSymbol.for(\"can.dispatch\")]( 2, 1 );\n\t * ```\n\t *\n\t * @param {Any} newValue The new value of the observable.\n\t * @param {Any} oldValue The old value of the observable.\n\t */\n\t\"can.dispatch\": function(value, old) {\n\t\tvar queuesArgs = [];\n\t\tqueuesArgs = [\n\t\t\tthis.handlers.getNode([]),\n\t\t\tthis,\n\t\t\t[value, old]\n\t\t];\n\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.handlers.getNode([]),\n\t\t\t\tthis,\n\t\t\t\t[value, old]\n\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t, null\n\t\t\t\t, [canReflect.getName(this), \"changed to\", value, \"from\", old]\n\t\t\t\t/* jshint laxcomma: false */\n\t\t\t];\n\t\t}\n\t\t//!steal-remove-end\n\t\tqueues.enqueueByQueue.apply(queues, queuesArgs);\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\tthis._log(old, value);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t/**\n\t * @function can-event-queue/value/value.can.getWhatIChange @can.getWhatIChange\n\t * @parent can-event-queue/value/value\n\t *\n\t * @description Return observables whose values are affected by attached event handlers\n\t * @signature `@can.getWhatIChange()`\n\t *\n\t * The `@@can.getWhatIChange` symbol is added to make sure [can-debug] can report\n\t * all the observables whose values are set by value-like observables.\n\t *\n\t * This function iterates over the event handlers attached to  the observable's value\n\t * event and collects the result of calling `@@can.getChangesDependencyRecord` on each\n\t * handler; this symbol allows the caller to tell what observables are being mutated\n\t * by the event handler when it is executed.\n\t *\n\t * In the following example a [can-simple-observable] instance named `month` is\n\t * created and when its value changes the `age` property of the `map` [can-simple-map]\n\t * instance is set. The event handler that causes the mutation is then decatorated with\n\t * `@@can.getChangesDependencyRecord` to register the mutation dependency.\n\t *\n\t * ```js\n\t * var month = new SimpleObservable(11);\n\t * var map = new SimpleMap({ age: 30 });\n\t * var canReflect = require(\"can-reflect\");\n\t *\n\t * var onValueChange = function onValueChange() {\n\t *\tmap.set(\"age\", 31);\n\t * };\n\t *\n\t * onValueChange[canSymbol.for(\"can.getChangesDependencyRecord\")] = function() {\n\t *\treturn {\n\t *\t\tkeyDependencies: new Map([ [map, new Set([\"age\"])] ])\n\t *\t}\n\t * };\n\t *\n\t * canReflect.onValue(month, onValueChange);\n\t * month[canSymbol.for(\"can.getWhatIChange\")]();\n\t * ```\n\t *\n\t * The dependency records collected from the event handlers are divided into\n\t * two categories:\n\t *\n\t * - mutate: Handlers in the mutate/domUI queues\n\t * - derive: Handlers in the notify queue\n\t *\n\t * Since event handlers are added by default to the \"mutate\" queue, calling\n\t * `@@can.getWhatIChange` on the `month` instance returns an object with a mutate\n\t * property and the `keyDependencies` Map registered on the `onValueChange` handler.\n\t *\n\t * If multiple event handlers were attached to `month`, the dependency records\n\t * of each handler are merged by `@@can.getWhatIChange`. Please check out the\n\t * [can-reflect-dependencies] docs to learn more about how this symbol is used\n\t * to keep track of custom observable dependencies.\n\t */\n\t\"can.getWhatIChange\": function getWhatIChange() {\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tvar whatIChange = {};\n\n\t\t\tvar notifyHandlers = this.handlers.get([\"notify\"]);\n\t\t\tvar mutateHandlers = [].concat(\n\t\t\t\tthis.handlers.get([\"mutate\"]),\n\t\t\t\tthis.handlers.get([\"domUI\"])\n\t\t\t);\n\n\t\t\tif (notifyHandlers.length) {\n\t\t\t\tnotifyHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.derive;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.derive = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (mutateHandlers.length) {\n\t\t\t\tmutateHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.mutate;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.mutate = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn Object.keys(whatIChange).length ? whatIChange : undefined;\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\n\t/**\n\t * @function can-event-queue/value/value.can.isBound @can.isBound\n\t * @parent can-event-queue/value/value\n\t */\n\t\"can.isBound\": function isBound() {\n\t\treturn !this.handlers.isEmpty();\n\t}\n};\n\n/**\n * @property {can-key-tree} can-event-queue/value/value.handlers handlers\n * @parent can-event-queue/value/value\n *\n * @description Access the handlers tree directly.\n *\n * @type {can-key-tree}\n *\n *  The handlers property is a [can-define-lazy-value lazily] defined property containing\n *  all handlers bound with [can-event-queue/value/value.on] and\n *  [can-event-queue/value/value.can.onValue].  It is a [can-key-tree] defined like:\n *\n *  ```js\n *  this.handlers = new KeyTree([Object, Array])\n *  ```\n *\n *  It is configured to call [can-event-queue/value/value.onBound] and\n *  [can-event-queue/value/value.onUnbound] on the instances when the first item is\n *  added to the tree and when the tree is emptied.\n */\nfunction defineLazyHandlers(){\n\treturn new KeyTree([Object, Array], {\n\t\tonFirst: this.onBound !== undefined && this.onBound.bind(this),\n\t\tonEmpty: this.onUnbound !== undefined && this.onUnbound.bind(this)\n\t});\n}\n\n/**\n * @function can-event-queue/value/value.onBound onBound\n * @parent can-event-queue/value/value\n *\n * @description Perform operations when an observable is gains its first event handler.\n *\n * @signature `.onBound()`\n *\n * This method is not implemented by `can-event-queue/value/value`. Instead, the object\n * should implement it if it wants to perform some actions when it becomes bound.\n *\n * ```js\n * var mixinValueBindings = require(\"can-event-queue/value/value\");\n *\n * var observable = mixinValueBindings({\n *   onBound: function(){\n *     console.log(\"I AM BOUND!\");\n *   }\n * });\n *\n * observable.on(function(){});\n * // Logs: \"I AM BOUND!\"\n * ```\n *\n */\n\n/**\n * @function can-event-queue/value/value.onUnbound onUnbound\n * @parent can-event-queue/value/value\n *\n * @description Perform operations when an observable loses all of its event handlers.\n *\n * @signature `.onBound()`\n *\n * This method is not implemented by `can-event-queue/value/value`. Instead, the object\n * should implement it if it wants to perform some actions when it becomes unbound.\n *\n * ```js\n * var mixinValueBindings = require(\"can-event-queue/value/value\");\n *\n * var observable = mixinValueBindings({\n *   onUnbound: function(){\n *     console.log(\"I AM UNBOUND!\");\n *   }\n * });\n * var handler = function(){}\n * observable.on(function(){});\n * observable.off(function(){});\n * // Logs: \"I AM UNBOUND!\"\n * ```\n */\n\n/**\n * @module {function} can-event-queue/value/value\n * @parent can-event-queue\n *\n * @description Mixin methods and symbols to make this object or prototype object\n * behave like a single-value observable.\n *\n * @signature `mixinValueBindings( obj )`\n *\n * Adds symbols and methods that make `obj` or instances having `obj` on their prototype\n * behave like single-value observables.\n *\n * When `mixinValueBindings` is called on an `obj` like:\n *\n * ```js\n * var mixinValueBindings = require(\"can-event-queue/value/value\");\n *\n * var observable = mixinValueBindings({});\n *\n * observable.on(function(newVal, oldVal){\n *   console.log(newVal);\n * });\n *\n * observable[canSymbol.for(\"can.dispatch\")](2,1);\n * // Logs: 2\n * ```\n *\n * `mixinValueBindings` adds the following properties and symbols to the object:\n *\n * - [can-event-queue/value/value.on]\n * - [can-event-queue/value/value.off]\n * - [can-event-queue/value/value.can.dispatch]\n * - [can-event-queue/value/value.can.getWhatIChange]\n * - [can-event-queue/value/value.handlers]\n *\n * When the object is bound to for the first time with `.on` or `@can.onValue`, it will look for an [can-event-queue/value/value.onBound]\n * function on the object and call it.\n *\n * When the object is has no more handlers, it will look for an [can-event-queue/value/value.onUnbound]\n * function on the object and call it.\n */\nvar mixinValueEventBindings = function(obj) {\n\tcanReflect.assign(obj, properties);\n\tcanReflect.assignSymbols(obj, symbols);\n\tdefineLazyValue(obj,\"handlers\",defineLazyHandlers, true);\n\treturn obj;\n};\n\n// callbacks is optional\nmixinValueEventBindings.addHandlers = function(obj, callbacks) {\n\tconsole.warn(\"can-event-queue/value: Avoid using addHandlers. Add onBound and onUnbound methods instead.\");\n\tobj.handlers = new KeyTree([Object, Array], callbacks);\n\treturn obj;\n};\n\nmodule.exports = mixinValueEventBindings;\n"],"names":["properties","on","handler","queue","this","handlers","add","off","queueName","undefined","delete","symbols","can.onValue","can.offValue","can.dispatch","value","old","queuesArgs","getNode","process","env","NODE_ENV","canReflect","getName","queues","enqueueByQueue","apply","_log","can.getWhatIChange","whatIChange","notifyHandlers","get","mutateHandlers","concat","length","forEach","changes","getChangesDependencyRecord","record","derive","mergeDependencyRecords","mutate","Object","keys","can.isBound","isEmpty","defineLazyHandlers","KeyTree","Array","onFirst","onBound","bind","onEmpty","onUnbound","mixinValueEventBindings","obj","assign","assignSymbols","defineLazyValue","addHandlers","callbacks","console","warn"],"mappings":"+ZAOA,IAAIA,WAAa,CAsBhBC,GAAI,SAASC,EAASC,GACrBC,KAAKC,SAASC,IAAI,CAACH,GAAS,SAAUD,KA8BvCK,IAAK,SAASL,EAASM,QACNC,IAAZP,OACeO,IAAdD,EACHJ,KAAKC,SAASK,OAAO,IAErBN,KAAKC,SAASK,OAAO,CAACF,IAGvBJ,KAAKC,SAASK,OAAO,CAACF,GAAa,SAAUN,MAK5CS,QAAU,CASbC,cAAeZ,WAAWC,GAS1BY,eAAgBb,WAAWO,IAsB3BO,eAAgB,SAASC,EAAOC,GAC/B,IAAIC,EAAa,GACjBA,EAAa,CACZb,KAAKC,SAASa,QAAQ,IACtBd,KACA,CAACW,EAAOC,IAImB,eAAzBG,UAAQC,IAAIC,WACdJ,EAAa,CACZb,KAAKC,SAASa,QAAQ,IACtBd,KACA,CAACW,EAAOC,GAEN,KACA,CAACM,WAAWC,QAAQnB,MAAO,aAAcW,EAAO,OAAQC,KAK5DQ,OAAOC,eAAeC,MAAMF,OAAQP,GAER,eAAzBE,UAAQC,IAAIC,UACW,mBAAdjB,KAAKuB,MACfvB,KAAKuB,KAAKX,EAAKD,IA2DlBa,qBAAsB,WAErB,GAA4B,eAAzBT,UAAQC,IAAIC,SAA2B,CACzC,IAAIQ,EAAc,GAEdC,EAAiB1B,KAAKC,SAAS0B,IAAI,CAAC,WACpCC,EAAiB,GAAGC,OACvB7B,KAAKC,SAAS0B,IAAI,CAAC,WACnB3B,KAAKC,SAAS0B,IAAI,CAAC,WA+BpB,OA5BID,EAAeI,QAClBJ,EAAeK,QAAQ,SAASjC,GAC/B,IAAIkC,EAAUd,WAAWe,2BAA2BnC,GAEpD,GAAIkC,EAAS,CACZ,IAAIE,EAAST,EAAYU,OACpBD,IACJA,EAAUT,EAAYU,OAAS,IAEhCC,uBAAuBF,EAAQF,MAK9BJ,EAAeE,QAClBF,EAAeG,QAAQ,SAASjC,GAC/B,IAAIkC,EAAUd,WAAWe,2BAA2BnC,GAEpD,GAAIkC,EAAS,CACZ,IAAIE,EAAST,EAAYY,OACpBH,IACJA,EAAUT,EAAYY,OAAS,IAEhCD,uBAAuBF,EAAQF,MAK3BM,OAAOC,KAAKd,GAAaK,OAASL,OAAcpB,IASzDmC,cAAe,WACd,OAAQxC,KAAKC,SAASwC,YAwBxB,SAASC,qBACR,OAAO,IAAIC,QAAQ,CAACL,OAAQM,OAAQ,CACnCC,aAA0BxC,IAAjBL,KAAK8C,SAAyB9C,KAAK8C,QAAQC,KAAK/C,MACzDgD,aAA4B3C,IAAnBL,KAAKiD,WAA2BjD,KAAKiD,UAAUF,KAAK/C,QAiG/D,UAAIkD,wBAA0B,SAASC,GAItC,OAHAjC,WAAWkC,OAAOD,EAAKvD,YACvBsB,WAAWmC,cAAcF,EAAK5C,SAC9B+C,gBAAgBH,EAAI,WAAWT,oBAAoB,GAC5CS,GAIRD,wBAAwBK,YAAc,SAASJ,EAAKK,GAGnD,OAFAC,QAAQC,KAAK,8FACbP,EAAIlD,SAAW,IAAI0C,QAAQ,CAACL,OAAQM,OAAQY,GACrCL,UAGSD,6BAAAA"}