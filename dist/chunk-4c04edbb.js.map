{"version":3,"file":"chunk-4c04edbb.js","sources":["../node_modules/can-connect/helpers/validate.js","../node_modules/can-connect/helpers/weak-reference-map.js","../node_modules/can-diff/update-deep-except-identity/update-deep-except-identity.js","../node_modules/can-connect/helpers/id-merge.js","../node_modules/can-connect/constructor/constructor.js","../node_modules/can-connect/data/parse/parse.js","../node_modules/can-util/js/is-array-like/is-array-like.js","../node_modules/can-util/js/is-iterable/is-iterable.js","../node_modules/can-util/js/each/each.js","../node_modules/can-make-rest/can-make-rest.js","../node_modules/can-connect/helpers/make-promise.js","../node_modules/can-connect/data/url/url.js","../node_modules/can-diff/assign-deep-except-identity/assign-deep-except-identity.js","../node_modules/can-connect/can/map/map.js"],"sourcesContent":["\"use strict\";\n// return wrapped can-connect behavior mixin that validates interface of the input behavior being extended\n// deprecate this and use can-validate-interface decorator once available\n\nvar makeInterfaceValidator = require('can-validate-interface');\n\nmodule.exports = function(extendingBehavior, interfaces){\n\tvar validatedBehaviour = validateArgumentInterface(extendingBehavior, 0, interfaces, function(errors, baseBehavior) {\n\t\tthrow new BehaviorInterfaceError(baseBehavior, extendingBehavior, errors);\n\t});\n\n\t// copy properties on behavior to validator wrapped behavior\n\tObject.keys(extendingBehavior).forEach(function (k) {\n\t\tvalidatedBehaviour[k] = extendingBehavior[k];\n\t});\n\t// add interfaces for building behavior ordering\n\tvalidatedBehaviour.__interfaces = interfaces;\n\n\treturn validatedBehaviour;\n};\n\nfunction validateArgumentInterface(func, argIndex, interfaces, errorHandler) {\n\treturn function() {\n\t\tvar errors = makeInterfaceValidator(interfaces)(arguments[argIndex]);\n\t\tif (errors && errorHandler) {\n\t\t\terrorHandler(errors, arguments[argIndex]);\n\t\t}\n\n\t\treturn func.apply(this, arguments);\n\t}\n}\n\n\n// change to 'BehaviourInterfaceError extends Error' once we drop support for pre-ES2015\nfunction BehaviorInterfaceError(baseBehavior, extendingBehavior, missingProps) {\n\tvar extendingName = extendingBehavior.behaviorName || 'anonymous behavior',\n\t\tbaseName = baseBehavior.__behaviorName || 'anonymous behavior',\n\t\tmessage = 'can-connect: Extending behavior \"' + extendingName + '\" found base behavior \"' + baseName\n\t\t\t+ '\" was missing required properties: ' + JSON.stringify(missingProps.related),\n\t\tinstance = new Error(message);\n\n\tif (Object.setPrototypeOf){\n\t\tObject.setPrototypeOf(instance, Object.getPrototypeOf(this));\n\t}\n\treturn instance;\n}\nBehaviorInterfaceError.prototype = Object.create(Error.prototype, {\n\tconstructor: {value: Error}\n});\nif (Object.setPrototypeOf){\n\tObject.setPrototypeOf(BehaviorInterfaceError, Error);\n} else {\n\tBehaviorInterfaceError.__proto__ = Error;\n}","\"use strict\";\nvar assign = require(\"can-reflect\").assignMap;\n\n/**\n * @module {function} can-connect/helpers/weak-reference-map WeakReferenceMap\n * @parent can-connect.modules\n *\n * Provides a map that only contains keys that are referenced.\n *\n * @signature `new WeakReferenceMap()`\n *\n *   Creates a new weak reference map.\n *\n * @body\n *\n * ## Use\n *\n * ```\n * var WeakReferenceMap = require(\"can-connect/helpers/weak-reference-map\");\n * var wrm = new WeakReferenceMap();\n * var task1 = {id: 1, name: \"do dishes\"};\n *\n * wrm.addReference(\"1\", task1);\n * wrm.has(\"1\") //-> true\n * wrm.addReference(\"1\", task1);\n * wrm.has(\"1\") //-> true\n * wrm.deleteReference(\"1\");\n * wrm.has(\"1\") //-> true\n * wrm.deleteReference(\"1\");\n * wrm.has(\"1\") //-> false\n * ```\n */\n\nvar WeakReferenceMap = function(){\n\tthis.set = {};\n};\n\n// if weakmap, we can add and never worry ...\n// otherwise, we need to have a count ...\n\nassign(WeakReferenceMap.prototype,\n/**\n * @prototype\n */\n\t{\n\t/**\n\t * @function can-connect/helpers/weak-reference-map.prototype.has has\n\t * @signature `weakReferenceMap.has(key)`\n\t *\n\t *   Returns if key is in the set.\n\t *\n\t *   @param  {String} key A key to look for.\n\t *   @return {Boolean} If the key exists.\n\t */\n\thas: function(key){\n\t\treturn !!this.set[key];\n\t},\n\t/**\n\t * @function can-connect/helpers/weak-reference-map.prototype.addReference addReference\n\t * @signature `WeakReferenceMap.addReference(key, item)`\n\t *\n\t *   Adds a reference to item as key and increments the reference count. This should be called\n\t *   when a value should be managed by something, typically the [can-connect/constructor/store/store].\n\t *\n\t *   @param  {String} key The key of the item in the store.\n\t */\n\taddReference: function(key, item, referenceCount){\n\t\t// !steal-remove-start\n\t\tif (typeof key === 'undefined'){\n\t\t\tthrow new Error(\"can-connect: You must provide a key to store a value in a WeakReferenceMap\");\n\t\t}\n\t\t// !steal-remove-end\n\t\tvar data = this.set[key];\n\t\tif(!data) {\n\t\t\tdata = this.set[key] = {\n\t\t\t\titem: item,\n\t\t\t\treferenceCount: 0,\n\t\t\t\tkey: key\n\t\t\t};\n\t\t}\n\t\tdata.referenceCount += (referenceCount || 1);\n\t},\n\treferenceCount: function(key) {\n\t\tvar data = this.set[key];\n\t\tif(data) {\n\t\t\treturn data.referenceCount;\n\t\t}\n\t},\n\t/**\n\t * @function can-connect/helpers/weak-reference-map.prototype.deleteReference deleteReference\n\t * @signature `weakReferenceMap.deleteReference(key)`\n\t *\n\t *   Decrements the reference count for key and removes it if the reference count is `0`. This should be called\n\t *   when a value should not be managed by something, typically the [can-connect/constructor/store/store].\n\t *\n\t *   @param  {String} key The key of the item in the store.\n\t */\n\tdeleteReference: function(key){\n\t\tvar data = this.set[key];\n\t\tif(data){\n\t\t\tdata.referenceCount--;\n\t\t\tif( data.referenceCount === 0 ) {\n\t\t\t\tdelete this.set[key];\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * @function can-connect/helpers/weak-reference-map.prototype.get get\n\t * @signature `weakReferenceMap.get(key)`\n\t *\n\t *   Returns the value stored at key if it's in the store.\n\t *\n\t *   @param  {String} key The key of the item in the store.\n\t *   @return {*|undefined} The item if it's available.\n\t */\n\tget: function(key){\n\t\tvar data = this.set[key];\n\t\tif(data) {\n\t\t\treturn data.item;\n\t\t}\n\t},\n\t/**\n\t * @function can-connect/helpers/weak-reference-map.prototype.forEach forEach\n\t * @signature `weakReferenceMap.forEach(callback)`\n\t *\n\t *   Calls `callback` for every value in the store.\n\t *\n\t *   @param  {function(*,String)} callback(item,key) A callback handler.\n\t */\n\tforEach: function(cb){\n\t\tfor(var id in this.set) {\n\t\t\tcb(this.set[id].item, id);\n\t\t}\n\t}\n});\n\nmodule.exports = WeakReferenceMap;\n","\"use strict\";\nvar canReflect = require(\"can-reflect\");\n\nmodule.exports = function updateExceptIdentity(obj, data, schema) {\n    if(!schema) {\n        schema = canReflect.getSchema(obj);\n    }\n    if(!schema) {\n        throw new Error(\"can-diff/update-except-id is unable to update without a schema.\");\n    }\n    // copy the keys onto data\n    schema.identity.forEach(function(key){\n        var id = canReflect.getKeyValue(obj, key);\n        if(id!== undefined) {\n            canReflect.setKeyValue(data, key, id );\n        }\n    });\n\n    canReflect.updateDeep(obj, data);\n};\n","\"use strict\";\nvar map = [].map;\n\nvar diffList = require(\"can-diff/list/list\")\nvar canReflect = require(\"can-reflect\");\nmodule.exports = function(list, update, id, make){\n\n\tvar patches = diffList(list, update, function(a, b){\n\t\treturn id(a) === id(b);\n\t});\n\tpatches.forEach(function(patch){\n\t\tcanReflect.splice(list, patch.index, patch.deleteCount, patch.insert.map(make));\n\t});\n};\n","\n\n\"use strict\";\n\n/**\n * @module {connect.Behavior} can-connect/constructor/constructor constructor\n * @parent can-connect.behaviors\n * @group can-connect/constructor/constructor.options 1 behavior options\n * @group can-connect/constructor/constructor.crud 2 CRUD methods\n * @group can-connect/constructor/constructor.callbacks 3 CRUD callbacks\n * @group can-connect/constructor/constructor.hydrators 4 hydrators\n * @group can-connect/constructor/constructor.serializers 5 serializers\n * @group can-connect/constructor/constructor.helpers 6 helpers\n *\n * Adds an interface to interact with custom types via the connection instead of plain Objects and Arrays.\n *\n * @signature `constructor( baseConnection )`\n *\n * Adds an interface that allows the connection to operate on custom types. These fall into the categories:\n * - [can-connect/constructor/constructor#CRUDMethods CRUD Methods] - create, read, update and delete typed instances via the data source\n * - [can-connect/constructor/constructor#CRUDCallbacks CRUD Callbacks] - activities run on typed instances following data source operations\n * - [can-connect/constructor/constructor#Hydrator Hydrators] - conversion of raw data to typed data\n * - [can-connect/constructor/constructor#Serializers Serializers] - conversion of typed data to raw data\n *\n * @param {{}} baseConnection `can-connect` connection object that is having the `constructor` behavior added\n * on to it.\n *\n * @return {Object} A `can-connect` connection containing the method implementations provided by `constructor`.\n *\n * @body\n *\n * ## Use\n *\n * The `constructor` behavior allows you to instantiate the raw representation of the data source's data into a\n * custom typed representation with additional methods and behaviors.\n\n * An example might be loading data from a `\"/todos\"` service and being able to call `.timeLeft()`  on the todos that\n * you get back like:\n *\n * ```js\n * todoConnection.get({id: 6}).then(function(todo){\n *   todo.timeLeft() //-> 60000\n * })\n * ```\n *\n * The following creates a `todoConnection` that does exactly that:\n *\n * ```js\n * // require connection plugins\n * var constructor = require(\"can-connect/constructor/\");\n * var dataUrl = require(\"can-connect/data/url/\");\n *\n * // define type constructor function\n * var Todo = function(data){\n *   // add passed properties to new instance\n *   for(var prop in data) {\n *    this[prop] = data;\n *   }\n * };\n *\n * // add method to get time left before due, in milliseconds\n * Todo.prototype.timeLeft = function(){\n *   return new Date() - this.dueDate\n * };\n *\n * // create connection, passing function to instantiate new instances\n * var todoConnection = connect([constuctor, dataUrl], {\n *   url: \"/todos\",\n *   instance: function(data){\n *     return new Todo(data);\n *   }\n * });\n * ```\n *\n * The `constructor` behavior is still useful even if you want to keep your data as untyped objects (which is the\n * default behavior when no [can-connect/constructor/constructor.instance `instance`] implementation is provided).  The\n * behavior provides an interface to the data held by the client. For example,\n * [can-connect/constructor/constructor.updatedInstance] provides an extension point for logic that needs to be executed\n * after an instance held by the client finishes an update request. This is valuable whether that instance is typed or not.\n * Extensions like [can-connect/real-time/real-time] or [can-connect/fall-through-cache/fall-through-cache]\n * require this interface for advanced behavior.\n *\n * ## Interface\n *\n * `constructor` provides the following categories of methods to interact with typed data:\n *\n * ### <span id=\"CRUDMethods\">CRUD Methods</span>\n *\n * Methods that create, read, update and delete (CRUD) typed representations of raw connection data:\n *\n * - [can-connect/constructor/constructor.get] - retrieve a single typed instance from the data source\n * - [can-connect/constructor/constructor.getList] - retrieve a typed list of instances from the data source\n * - [can-connect/constructor/constructor.save] - save a typed instance's data to the data source\n * - [can-connect/constructor/constructor.destroy] - delete a typed instance's data from the data source\n *\n * ### <span id=\"CRUDCallbacks\">CRUD Callbacks</span>\n *\n * \"CRUD Methods\" call these methods with request response data and a related instance. Their implementation here\n * updates the related instance with that data:\n *\n * - [can-connect/constructor/constructor.createdInstance] - after [can-connect/constructor/constructor.save saving] new instance to data source, update that instance with response data\n * - [can-connect/constructor/constructor.updatedInstance] - after [can-connect/constructor/constructor.save saving] existing instance to data source, update that instance with response data\n * - [can-connect/constructor/constructor.destroyedInstance] - after [can-connect/constructor/constructor.destroy deleting] instance from data source, update that instance with response data\n * - [can-connect/constructor/constructor.updatedList] - after new data is read from the data source, update an existing list with instances created from that data\n *\n * ### <span id=\"CRUDMethods\">Hydrators</span>\n *\n * These methods are used to create a typed instance or typed list given raw data objects:\n * - [can-connect/constructor/constructor.hydrateInstance] - create a typed instance given raw instance data\n * - [can-connect/constructor/constructor.hydrateList] - create a typed list of typed instances given given raw list data\n *\n * ### <span id=\"Serializers\">Serializers</span>\n *\n * These methods convert a typed instance or typed list into a raw object:\n * - [can-connect/constructor/constructor.serializeInstance] - return raw data representing the state of the typed instance argument\n * - [can-connect/constructor/constructor.serializeList] - return raw data representing the state of the typed list argument\n *\n */\nvar canReflect = require(\"can-reflect\");\nvar makeArray = canReflect.toArray;\nvar assign = canReflect.assignMap;\nvar WeakReferenceMap = require(\"../helpers/weak-reference-map\");\nvar updateDeepExceptIdentity = require(\"can-diff/update-deep-except-identity/update-deep-except-identity\");\nvar idMerge = require(\"../helpers/id-merge\");\nvar behavior = require(\"../behavior\");\n\nmodule.exports = behavior(\"constructor\",function(baseConnection){\n\n\tvar behavior = {\n\t\t// stores references to instances\n\t\t// for now, only during create\n\t\t/**\n\t\t * @property {can-connect/helpers/weak-reference-map} can-connect/constructor/constructor.cidStore cidStore\n\t\t * @parent can-connect/constructor/constructor.helpers\n\t\t *\n\t\t * Temporarily hold references to new instances via their [can-cid] while they are undergoing creation.\n\t\t *\n\t\t * @option {can-connect/helpers/weak-reference-map} Temporarily holds references to instances by\n\t\t * [can-cid] when they are in the process of being created and don't yet have an `id`s. This is typically\n\t\t * accessed in `createdData` handlers (e.g [can-connect/real-time/real-time.createdData real-time.createdData]) that\n\t\t * need to lookup the instance that was being created during a particular request.\n\t\t */\n\t\tcidStore: new WeakReferenceMap(),\n\t\t_cid: 0,\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.get get\n\t\t * @parent can-connect/constructor/constructor.crud\n\t\t *\n\t\t * Retrieve a single instance from the connection data source.\n\t\t *\n\t\t * @signature `connection.get(params)`\n\t\t *\n\t\t * Retrieves instance data from [can-connect/connection.getData], runs the resulting data through\n\t\t * [can-connect/constructor/constructor.hydrateInstance], creating a typed instance with the retrieved data.\n\t\t *\n\t\t * @param {Object} params data specifying the instance to retrieve.  Normally, this is something like like:\n\t\t * `{id: 5}`.\n\t\t *\n\t\t * @return {Promise<can-connect/Instance>} `Promise` resolving to the instance returned by\n\t\t * [can-connect/constructor/constructor.hydrateInstance].\n\t\t *\n\t\t * ### Usage\n\t\t *\n\t\t * Call `.get()` with the parameters that identify the instance you want to load.  `.get()` will return a promise\n\t\t * that resolves to that instance:\n\t\t * ```js\n\t\t * todoConnection.get({id: 6}).then(function(todo){\n\t\t *   todo.id; // 6\n\t\t *   todo.name; // 'Take out the garbage'\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * `.get()` above will call [can-connect/connection.getData `getData`] on the [can-connect/data/url/url]\n\t\t * behavior, which will make an HTTP GET request to `/todos/6`.\n\t\t */\n\t\tget: function(params) {\n\t\t\tvar self = this;\n\t\t\treturn this.getData(params).then(function(data){\n\t\t\t\treturn self.hydrateInstance(data);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.getList getList\n\t\t * @parent can-connect/constructor/constructor.crud\n\t\t *\n\t\t * Retrieve a list of instances from the connection data source.\n\t\t *\n\t\t * @signature `connection.getList(set)`\n\t\t *\n\t\t * Retrieves list data from [can-connect/connection.getListData] and runs the resulting data through\n\t\t * [can-connect/constructor/constructor.hydrateList], creating a typed list of typed instances from  the retrieved\n\t\t * data.\n\t\t *\n\t\t * @param {can-query-logic/query} query data specifying the range of instances to retrieve. This might look something like:\n\t\t * ```{start: 0, end: 50, due: 'today'}```\n\t\t *\n\t\t * @return {Promise<can-connect.List<can-connect/Instance>>} `Promise` resolving to the typed list returned by\n\t\t * [can-connect/constructor/constructor.hydrateList].\n\t\t *\n\t\t * ### Usage\n\t\t *\n\t\t * Call `getList` with the parameters that specify the set of data you want to load.  `.getList()` will return\n\t\t * a promise that resolves to a [can-connect.List] created from that set.\n\t\t *\n\t\t * ```js\n\t\t * todoConnection.getList({due: 'today'}).then(function(todos){\n\t\t *   todos[0].name; // 'Take out the garbage'\n\t\t *   todos[0].due > startOfDay && todos[0].due < endOfDay; // true\n\t\t * })\n\t\t * ```\n\t\t *\n\t\t */\n\t\tgetList: function(set) {\n\t\t\tset = set ||  {};\n\t\t\tvar self = this;\n\t\t\treturn this.getListData( set ).then(function(data){\n\t\t\t\treturn self.hydrateList(data, set);\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.hydrateList hydrateList\n\t\t * @parent can-connect/constructor/constructor.hydrators\n\t\t *\n\t\t * Produce a typed list from the provided raw list data.\n\t\t *\n\t\t * @signature `connection.hydrateList(listData, set)`\n\t\t *\n\t\t *   Call [can-connect/constructor/constructor.hydrateInstance] for each item in the raw list data, and then call\n\t\t *   [can-connect/constructor/constructor.list] with an array of the typed instances returned from\n\t\t *   [can-connect/constructor/constructor.hydrateInstance] .  If [can-connect/constructor/constructor.list] is not\n\t\t *   provided as an argument or implemented by another behavior, a normal array is created.\n\t\t *\n\t\t *   @param {can-connect.listData} listData the raw list data returned by the data source, often via [can-connect/connection.getListData]\n\t\t *   @param {can-query-logic/query} query description of the set of data `listData` represents\n\t\t *\n\t\t *   @return {can-connect.List} a typed list containing typed instances generated from `listData`\n\t\t */\n\t\thydrateList: function(listData, set){\n\t\t\tif(Array.isArray(listData)) {\n\t\t\t\tlistData = {data: listData};\n\t\t\t}\n\n\t\t\tvar arr = [];\n\t\t\tfor(var i = 0; i < listData.data.length; i++) {\n\t\t\t\tarr.push( this.hydrateInstance(listData.data[i]) );\n\t\t\t}\n\t\t\tlistData.data = arr;\n\t\t\tif(this.list) {\n\t\t\t\treturn this.list(listData, set);\n\t\t\t} else {\n\t\t\t\tvar list = listData.data.slice(0);\n\t\t\t\tlist[this.listQueryProp || \"__listQuery\"] = set;\n\t\t\t\tcopyMetadata(listData, list);\n\t\t\t\treturn list;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.hydrateInstance hydrateInstance\n\t\t * @parent can-connect/constructor/constructor.hydrators\n\t\t *\n\t\t * Produce a typed object containing the provided raw data.\n\t\t *\n\t\t * @signature `connection.hydrateInstance(props)`\n\t\t *\n\t\t * If [can-connect/constructor/constructor.instance] has been passed as an option, or defined by another behavior,\n\t\t * pass `props` to it and return the value. Otherwise, return a clone of `props`.\n\t\t *\n\t\t * @param {Object} props the raw instance data returned by the data source, often via [can-connect/connection.getData]\n\t\t * @return {can-connect/Instance} a typed instance containing the data from `props`\n\t\t */\n\t\thydrateInstance: function(props){\n\t\t\tif(this.instance) {\n\t\t\t\treturn this.instance(props);\n\t\t\t}  else {\n\t\t\t\treturn assign({}, props);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.save save\n\t\t * @parent can-connect/constructor/constructor.crud\n\t\t *\n\t\t * @description Create or update an instance on the connection data source\n\t\t *\n\t\t * @signature `connection.save( instance )`\n\t\t *\n\t\t *   First checks if the instance has an [can-connect/base/base.id] or not.  If it has an id, the instance will be\n\t\t *   updated; otherwise, it will be created.\n\t\t *\n\t\t *   When creating an instance, the instance is added to the [can-connect/constructor/constructor.cidStore], and its\n\t\t *   [can-connect/constructor/constructor.serializeInstance serialized data] is passed to\n\t\t *   [can-connect/connection.createData].  If `createData`'s promise resolves to anything other than `undefined`,\n\t\t *   [can-connect/constructor/constructor.createdInstance] is called with that data.\n\t\t *\n\t\t *   When updating an instance, its [can-connect/constructor/constructor.serializeInstance serialized data] is\n\t\t *   passed to [can-connect/connection.updateData]. If `updateData`'s promise resolves to anything other than\n\t\t *   `undefined`, [can-connect/constructor/constructor.updatedInstance] is called with that data.\n\t\t *\n\t\t *   @param {can-connect/Instance} instance the instance to create or save\n\t\t *\n\t\t *   @return {Promise<can-connect/Instance>} `Promise` resolving to the same instance that was passed to `save`\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * To use `save` to create an instance, create a connection, then an instance, and call `.save()` on it:\n\t\t *\n\t\t * ```js\n\t\t * // Create a connection\n\t     * var constructor = require('can-connect/constructor/');\n\t\t * var dataUrl = require('can-connect/data/url/');\n\t\t * var todoConnection = connect([dataUrl, constructor], {\n\t\t *   url: \"/todos\"\n\t\t * });\n\t\t *\n\t\t * // Create an instance\n\t\t * var todo = {name: \"do dishes\"};\n\t\t *\n\t\t * // Call .save()\n\t\t * todoConnection.save(todo)\n\t\t * ```\n\t\t *\n\t\t * `.save(todo)` above will call [can-connect/data/url/url.createData `createData`] on the [can-connect/data/url/url]\n\t\t * behavior, which will make an HTTP POST request to `/todos` with the serialized `todo` data.  The server response\n\t\t * data may look something like:\n\t\t *\n\t\t * ```js\n\t\t * {\n\t\t *  id: 5,\n\t\t *  ownerId: 9\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * That data will be passed to [can-connect/constructor/constructor.createdInstance] which by default\n\t\t * adds those properties to `todo`, resulting in `todo` looking like:\n\t\t *\n\t\t * ```js\n\t\t * {\n\t\t *  name: \"do dishes\",\n\t\t *  id: 5,\n\t\t *  ownerId: 9\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * As an example of updating an instance, change a property on `todo` and call `.save()` again:\n\t\t *\n\t\t * ```js\n\t\t * // Change a property\n\t\t * todo.name = \"Do dishes now!!\";\n\t\t *\n\t\t * // Call .save()\n\t\t * todoConnection.save(todo)\n\t\t * ```\n\t\t *\n\t\t * The `.save(todo)` above will call [can-connect/data/url/url.updateData `updateData`] on the\n\t\t * [can-connect/data/url/url] behavior, which will make an HTTP PUT request to `/todos` with the serialized `todo`\n\t\t * data.\n\t\t *\n\t\t * A successful server response body should look something like:\n\t\t *\n\t\t * ```js\n\t\t * {\n\t\t *  name: \"Do dishes now!!\",\n\t\t *  id: 5,\n\t\t *  ownerId: 9\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * This data will be passed to [can-connect/constructor/constructor.updatedInstance] which by default sets\n\t\t * all of `todo`'s properties to look like the response data, even removing properties that are missing from the\n\t\t * response data.\n\t\t */\n\t\tsave: function(instance){\n\t\t\tvar serialized = this.serializeInstance(instance);\n\t\t\tvar id = this.id(instance);\n\t\t\tvar self = this;\n\t\t\tif(id === undefined) {\n\t\t\t\t// If `id` is undefined, we are creating this instance.\n\t\t\t\t// It should be given a local id and temporarily added to the cidStore\n\t\t\t\t// so other hooks can get back the instance that's being created.\n\t\t\t\tvar cid = this._cid++;\n\t\t\t\t// cid is really a token to be able to reference this transaction.\n\t\t\t\tthis.cidStore.addReference(cid, instance);\n\n\t\t\t\t// Call the data layer.\n\t\t\t\t// If the data returned is undefined, don't call `createdInstance`\n\t\t\t\treturn this.createData(serialized, cid).then(function(data){\n\t\t\t\t\t// if undefined is returned, this can't be created, or someone has taken care of it\n\t\t\t\t\tif(data !== undefined) {\n\t\t\t\t\t\tself.createdInstance(instance, data);\n\t\t\t\t\t}\n\t\t\t\t\tself.cidStore.deleteReference(cid, instance);\n\t\t\t\t\treturn instance;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn this.updateData(serialized).then(function(data){\n\t\t\t\t\tif(data !== undefined) {\n\t\t\t\t\t\tself.updatedInstance(instance, data);\n\t\t\t\t\t}\n\t\t\t\t\treturn instance;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.destroy destroy\n\t\t * @parent can-connect/constructor/constructor.crud\n\t\t * @description Delete an instance from the connection data source\n\t\t *\n\t\t * @signature `connection.destroy( instance )`\n\t\t *\n\t\t *   To destroy an instance, it's [can-connect/constructor/constructor.serializeInstance serialized data] is passed\n\t\t *   to [can-connect/connection.destroyData]. If [can-connect/connection.destroyData]'s promise resolves to anything\n\t\t *   other than `undefined`, [can-connect/constructor/constructor.destroyedInstance] is called.\n\t\t *\n\t\t *   @param {can-connect/Instance} instance the instance being deleted from the data source\n\t\t *\n\t\t *   @return {Promise<can-connect/Instance>} `Promise` resolving to the same instance that was passed to `destroy`\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * To use `destroy`, create a connection, retrieve an instance, and then call `.destroy()` with it.\n\t\t *\n\t\t * ```js\n\t\t * // create a connection\n\t\t * var constructor = require('can-connect/constructor/');\n\t\t * var dataUrl = require('can-connect/data/url/');\n\t\t * var todoConnection = connect([dataUrl, constructor], {\n\t\t *   url: \"/todos\"\n\t\t * })\n\t\t *\n\t\t * // retrieve a todo instance\n\t\t * todoConnection.get({id: 5}).then(function(todo){\n\t\t *   // Call .destroy():\n\t\t *   todoConnection.destroy(todo)\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * `.destroy()` above will call [can-connect/connection.destroyData `destroyData`] on the [can-connect/data/url/url]\n\t\t * behavior, which will make an HTTP DELETE request to `/todos/5` with the serialized `todo` data.  The server\n\t\t * response data may look something like:\n\t\t *\n\t\t * ```js\n\t\t * {\n\t\t *   deleted: true\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * That response data will be passed to [can-connect/constructor/constructor.destroyedInstance], which by default\n\t\t * adds those properties to `todo`.\n\t\t */\n\t\t// ## destroy\n\t\t// Calls the data interface `destroyData` and as long as it\n\t\t// returns something, uses that data to call `destroyedInstance`.\n\t\tdestroy: function(instance){\n\t\t\tvar serialized = this.serializeInstance(instance),\n\t\t\t\tself = this;\n\n\t\t\treturn this.destroyData(serialized).then(function(data){\n\t\t\t\tif(data !== undefined) {\n\t\t\t\t\tself.destroyedInstance(instance, data);\n\t\t\t\t}\n\t\t\t\treturn instance;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.createdInstance createdInstance\n\t\t * @parent can-connect/constructor/constructor.callbacks\n\t\t *\n\t\t * A method run whenever a new instance has been saved to the data source. Updates the instance with response data.\n\t\t *\n\t\t * @signature `connection.createdInstance( instance, props )`\n\t\t *\n\t\t * `createdInstance` is run whenever a new instance is saved to the data source. This implementation updates the\n\t\t * instance with the data returned by [can-connect/connection.createData] which made the request to save the raw\n\t\t * instance data.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance that was created\n\t\t * @param {Object} props the data returned from [can-connect/connection.createData] that will update the properties of `instance`\n\t\t */\n\t\tcreatedInstance: function(instance, props){\n\t\t\tassign(instance, props);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.updatedInstance updatedInstance\n\t\t * @parent can-connect/constructor/constructor.callbacks\n\t\t *\n\t\t * A method run whenever an existing instance has been saved to the data source. Overwrites the instance with response\n\t\t * data.\n\t\t *\n\t\t * @signature `connection.updatedInstance( instance, props )`\n\t\t *\n\t\t * `updatedInstance` is run whenever an existing instance is saved to the data source. This implementation overwrites\n\t\t * the instance with the data returned bu [can-connect/connection.updatedData] which made the request to save the\n\t\t * modified instance data.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance that was updated\n\t\t * @param {Object} props the data from [can-connect/connection.updateData] that will overwrite the properties of `instance`\n\t\t */\n\t\tupdatedInstance: function(instance, data){\n\t\t\tupdateDeepExceptIdentity(instance, data, this.queryLogic.schema);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.updatedList updatedList\n\t\t * @parent can-connect/constructor/constructor.callbacks\n\t\t *\n\t\t * A method run whenever new data for an existing list is retrieved from the data source. Updates the list to\n\t\t * include the new data.\n\t\t *\n\t\t * @signature `connection.updatedList( list, listData, set )`\n\t\t *\n\t\t * [can-connect/constructor/constructor.hydrateInstance Hydrates instances] from `listData`'s data and attempts to\n\t\t * merge them into `list`.  The merge is able to identify simple insertions and removals of elements instead of\n\t\t * replacing the entire list.\n\t\t *\n\t\t * @param {can-connect/Instance} list an existing list\n\t\t * @param {can-connect.listData} listData raw data that should be included as part of `list` after conversion to typed instances\n\t\t * @param {can-query-logic/query} query description of the set of data `list` represents\n\t\t */\n\t\tupdatedList: function(list, listData, set) {\n\t\t\tvar instanceList = [];\n\t\t\tfor(var i = 0; i < listData.data.length; i++) {\n\t\t\t\tinstanceList.push( this.hydrateInstance(listData.data[i]) );\n\t\t\t}\n\t\t\t// This only works with \"referenced\" instances because it will not\n\t\t\t// update and assume the instance is already updated\n\t\t\t// this could be overwritten so that if the ids match, then a merge of properties takes place\n\t\t\tidMerge(list, instanceList, this.id.bind(this), this.hydrateInstance.bind(this));\n\n\t\t\tcopyMetadata(listData, list);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.destroyedInstance destroyedInstance\n\t\t * @parent can-connect/constructor/constructor.callbacks\n\t\t *\n\t\t * A method run whenever an instance has been deleted from the data source. Overwrites the instance with response data.\n\t\t *\n\t\t * @signature `connection.destroyedInstance( instance, props )`\n\t\t *\n\t\t * `destroyedInstance` is run whenever an existing instance is deleted from the data source. This implementation\n\t\t * overwrites the instance with the data returned by [can-connect/connection.destroyData] which made the request to\n\t\t * delete the raw instance data.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance that was deleted\n\t\t * @param {Object} props the data returned from [can-connect/connection.destroyData] that will overwrite the\n\t\t * properties of `instance`\n\t\t */\n\t\tdestroyedInstance: function(instance, data){\n\t\t\tupdateDeepExceptIdentity(instance, data, this.queryLogic.schema);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.serializeInstance serializeInstance\n\t\t * @parent can-connect/constructor/constructor.serializers\n\t\t *\n\t\t * @description Generate the serialized form of a typed instance.\n\t\t *\n\t\t * @signature `connection.serializeInstance( instance )`\n\t\t *\n\t\t *   Generate a raw object representation of a typed instance. This default implementation simply clones the\n\t\t *   `instance` object, copying all the properties of the object (excluding properties of it's prototypes) to a new\n\t\t *   object. This is equivalent to `Object.assign({}, instance)`.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance to serialize\n\t\t * @return {Object} a serialized representation of the instance\n\t\t */\n\t\tserializeInstance: function(instance){\n\t\t\treturn assign({}, instance);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.serializeList serializeList\n\t\t * @parent can-connect/constructor/constructor.serializers\n\t\t *\n\t\t * @description Generate the serialized form of a typed list.\n\t\t *\n\t\t * @signature `connection.serializeList( list )`\n\t\t *\n\t\t *   Generate a raw array representation of a typed list. This default implementation simply returns a plain `Array`\n\t\t *   containing the result of calling [can-connect/constructor/constructor.serializeInstance] on each item in the\n\t\t *   typed list.\n\t\t *\n\t\t * @param {can-connect.List} list The instance to serialize.\n\t\t * @return {Object|Array} A serialized representation of the list.\n\t\t */\n\t\tserializeList: function(list){\n\t\t\tvar self = this;\n\t\t\treturn makeArray(list).map(function(instance){\n\t\t\t\treturn self.serializeInstance(instance);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/constructor.isNew isNew\n\t\t * @parent can-connect/constructor/constructor.helpers\n\t\t *\n\t\t * Returns if the instance has not been loaded from or saved to the data source.\n\t\t *\n\t\t * @signature `connection.isNew(instance)`\n\t\t * @param {Object} instance the instance to test\n\t\t * @return {Boolean} `true` if [can-connect/base/base.id] is `null` or `undefined`\n\t\t */\n\t\tisNew: function(instance){\n\t\t\tvar id = this.id(instance);\n\t\t\treturn !(id || id === 0);\n\t\t}\n\n\t\t/**\n\t\t * @property can-connect/constructor/constructor.list list\n\t\t * @parent can-connect/constructor/constructor.options\n\t\t *\n\t\t * Behavior option provided to create a typed list from a raw array.\n\t\t *\n\t\t * @signature `connection.list( listData, set )`\n\t\t *\n\t\t * Takes a `listData` argument with a `data` property, that is an array of typed instances, each produced by\n\t\t * [can-connect/constructor/constructor.hydrateInstance], and returns a new typed list containing those typed\n\t\t * instances.\n\t\t * This method is passed as an option to the connection.\n\t\t * Called by [can-connect/constructor/constructor.hydrateList].\n\t\t *\n\t\t * @param {can-connect.listData} listData an object with a `data` property, which is an array of instances.\n\t\t * @param {can-query-logic/query} query the set description of this list\n\t\t * @return {can-connect.List} a typed list type containing the typed instances\n\t\t *\n\t\t * ### Usage\n\t\t *\n\t\t * The following example makes the connection produce `MyList` typed lists including a `completed` method:\n\t\t *\n\t\t * ```js\n\t\t * var constructor = require(\"can-connect/constructor/\");\n\t\t * var dataUrl = require(\"can-connect/data/url/\");\n\t\t *\n\t\t * // define custom list type constructor\n\t\t * var MyList = function(items) {\n\t\t *  this.push.apply(this, items);\n\t\t * }\n\t\t * // inherit Array functionality\n\t\t * MyList.prototype = Object.create(Array.prototype);\n\t\t * // add custom methods to new list type\n\t\t * MyList.prototype.completed = function(){\n\t\t *  return this.filter(function(){ return this.completed });\n\t\t * };\n\t\t *\n\t\t * // create connection\n\t\t * var todosConnection = connect([constructor, dataUrl], {\n\t\t *   url: \"/todos\",\n\t\t *   list: function(listData, set){\n\t\t *     // create custom list instance\n\t\t *     var collection = new MyList(listData.data);\n\t\t *     // add set info for use by other behaviors\n\t\t *     collection.__listQuery = set;\n\t\t *     return collection;\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * // use connection to get typed list & use custom method\n\t\t * todosConnection.getList({}).then(function(todoList){\n\t\t *   console.log(\"There are\", todoList.completed().length, \"completed todos\");\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * **Note:** we added the [can-connect/base/base.listQueryProp] property (`Symbol.for(\"can.listQuery\")` by default) on the list. This is\n\t\t * expected by other behaviors.\n\t\t */\n\n\t\t/**\n\t\t * @property can-connect/constructor/constructor.instance instance\n\t\t * @parent can-connect/constructor/constructor.options\n\t\t *\n\t\t * Behavior option provided to create a typed form of passed raw data.\n\t\t *\n\t\t * @signature `connection.instance( props )`\n\t\t *\n\t\t * Creates a typed instance for the passed raw data object. This method is passed as an option to the connection.\n\t\t * Called by [can-connect/constructor/constructor.hydrateInstance].\n\t\t *\n\t\t * @param {Object} props a raw object containing the properties from the data source\n\t\t * @return {can-connect/Instance} the typed instance created from the passed `props` object\n\t\t *\n\t\t * ### Usage\n\t\t *\n\t\t * The following example makes the connection produce `Todo` typed objects including a `complete` method:\n\t\t *\n\t\t * ```js\n\t\t * var constructor = require(\"can-connect/constructor/\");\n\t\t * var dataUrl = require(\"can-connect/data/url/\");\n\t\t *\n\t\t * // define type constructor\n\t\t * var Todo = function(rawData){\n\t\t *   // add raw data to new instance\n\t\t *   Object.assign(this, rawData);\n\t\t * };\n\t\t *\n\t\t * // add methods to custom type\n\t\t * Todo.prototype.complete = function(){\n\t\t *   this.completed = true;\n\t\t * }\n\t\t *\n\t\t * // create connection\n\t\t * var todosConnection = connect([constructor, dataUrl], {\n\t\t *   url: \"/todos\",\n\t\t *   instance: function(rawData) {\n\t\t *     return new Todo(rawData);\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * // use connection to get typed instance & use custom method\n\t\t * todosConnection.get({id: 5}).then(function(todo){\n\t\t *   todo.completed; // false\n\t\t *   todo.complete();\n\t\t *   todo.completed; // true\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t */\n\t};\n\n\treturn behavior;\n\n});\n\nfunction copyMetadata(listData, list){\n\tfor(var prop in listData) {\n\t\tif(prop !== \"data\") {\n\t\t\t// this is map infultrating constructor, but it's alright here.\n\t\t\tif(typeof list.set === \"function\") {\n\t\t\t\tlist.set(prop, listData[prop]);\n\t\t\t} else if(typeof list.attr === \"function\") {\n\t\t\t\tlist.attr(prop, listData[prop]);\n\t\t\t} else {\n\t\t\t\tlist[prop] = listData[prop];\n\t\t\t}\n\n\t\t}\n\t}\n}\n","\"use strict\";\n/**\n * @module {connect.Behavior} can-connect/data/parse/parse\n * @parent can-connect.behaviors\n *\n * Extract response data into a format needed for other extensions.\n *\n * @signature `dataParse( baseConnection )`\n *\n *   Overwrites the [can-connect/DataInterface] methods to run their results through\n *   either [can-connect/data/parse/parse.parseInstanceData] or [can-connect/data/parse/parse.parseListData].\n *\n *   @param {{}} baseConnection The base connection.\n *\n * @body\n *\n * ## Use\n *\n * `data/parse` is used to modify the response data of \"data interface\" methods to comply with what\n * is expected by \"instance interface\" methods.  For example, if a service was returning list data\n * at the `/services/todos` url like:\n *\n * ```\n * {\n *   todos: [\n *     {todo: {id: 0, name: \"dishes\"}},\n *     {todo: {id: 2, name: \"lawn\"}}\n *   ]\n * }\n * ```\n *\n * That service does not return [can-connect.listData] in the right format which should look like:\n *\n * ```\n * {\n *   data: [\n *     {id: 0, name: \"dishes\"},\n *     {id: 2, name: \"lawn\"}\n *   ]\n * }\n * ```\n *\n * To correct this, you can configure `data-parse` to use the [can-connect/data/parse/parse.parseListProp] and [can-connect/data/parse/parse.parseInstanceProp]\n * as follows:\n *\n * ```\n * connect([\n *   require(\"can-connect/data/parse/parse\"),\n *   require(\"can-connect/data/url/url\")\n * ],{\n *  parseListProp: \"todos\",\n *  parseInstanceProp: \"todo\"\n * })\n * ```\n *\n */\nvar each = require(\"can-reflect\").each;\nvar getObject = require(\"can-key/get/get\");\nvar behavior = require(\"../../behavior\");\n\nmodule.exports = behavior(\"data/parse\",function(baseConnection){\n\n\tvar behavior = {\n    /**\n     * @function can-connect/data/parse/parse.parseListData parseListData\n     * @parent can-connect/data/parse/parse\n     *\n     * @description Given a response from [can-connect/connection.getListData] returns its data in the\n     * proper [can-connect.listData] format.\n     *\n     * @signature `connection.parseListData(responseData)`\n     *\n     *   This function uses [can-connect/data/parse/parse.parseListProp] to find the array\n     *   containing the data for each instance.  Then it uses [can-connect/data/parse/parse.parseInstanceData]\n     *   on each item in the array  Finally, it returns data in the\n     *   [can-connect.listData] format.\n     *\n     *   @param {Object} responseData The response data from the AJAX request.\n     *\n     *   @return {can-connect.listData} An object like `{data: [props, props, ...]}`.\n     *\n     * @body\n     *\n     * ## Use\n     *\n     * `parseListData` comes in handy when dealing with an irregular API\n     * that can be improved with data transformation.\n     *\n     * Suppose an endpoint responds with a status of 200 OK, even when the\n     * request generates an empty result set. Worse yet, instead of representing\n     * an emtpy set with an empty list, it removes the property.\n     *\n     * A request to `/services/todos` may return:\n     *\n     * ```\n     * {\n     *   todos: [\n     *     {todo: {id: 0, name: \"dishes\"}},\n     *     {todo: {id: 2, name: \"lawn\"}}\n     *   ]\n     * }\n     * ```\n     *\n     * What if a request for `/services/todos?filterName=bank` responds with\n     * 200 OK:\n     *\n     * ```\n     * {\n     * }\n     * ```\n     *\n     * This response breaks its own schema. One way to bring it in line\n     * with a format compatible with [can-connect.listData] is:\n     *\n     * ```\n     * connect([\n     *   require(\"can-connect/data/parse/parse\"),\n     *   require(\"can-connect/data/url/url\")\n     * ],{\n     *   parseListProp: \"todos\",\n     *   parseListData(responseData) {\n     *     if (responseData && !responseData.todos) {\n     *       responseData = { todos: [] };\n     *     }\n     *\n     *     return responseData;\n     *   }\n     * })\n     * ```\n     */\n\t\tparseListData: function( responseData ) {\n\n\t\t\t// call any base parseListData\n\t\t\tif(baseConnection.parseListData) {\n\t\t\t   responseData = baseConnection.parseListData.apply(this, arguments);\n\t\t\t}\n\n\t\t\tvar result;\n\t\t\tif( Array.isArray(responseData) ) {\n\t\t\t\tresult = {data: responseData};\n\t\t\t} else {\n\t\t\t\tvar prop = this.parseListProp || 'data';\n\n\t\t\t\tresponseData.data = getObject(responseData, prop);\n\t\t\t\tresult = responseData;\n\t\t\t\tif(prop !== \"data\") {\n\t\t\t\t\tdelete responseData[prop];\n\t\t\t\t}\n\t\t\t\tif(!Array.isArray(result.data)) {\n\t\t\t\t\tthrow new Error('Could not get any raw data while converting using .parseListData');\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tvar arr = [];\n\t\t\tfor(var i =0 ; i < result.data.length; i++) {\n\t\t\t\tarr.push( this.parseInstanceData(result.data[i]) );\n\t\t\t}\n\t\t\tresult.data = arr;\n\t\t\treturn result;\n\t\t},\n    /**\n     * @function can-connect/data/parse/parse.parseInstanceData parseInstanceData\n     * @parent can-connect/data/parse/parse\n     *\n     * @description Returns the properties that should be used to [can-connect/constructor/constructor.hydrateInstance make an instance]\n     * given the results of [can-connect/connection.getData], [can-connect/connection.createData], [can-connect/connection.updateData],\n     * and [can-connect/connection.destroyData].\n     *\n     * @signature `connection.parseInstanceData(responseData)`\n     *\n     *   This function will use [can-connect/data/parse/parse.parseInstanceProp] to find the data object\n     *   representing the instance that will be created.\n     *\n     *   @param {Object} responseData The response data from [can-connect/connection.getData], [can-connect/connection.createData], or [can-connect/connection.updateData].\n     *\n     *   @return {Object} The data that should be passed to [can-connect/constructor/constructor.hydrateInstance].\n     *\n     * @body\n     *\n     * ## Use\n     *\n     * `parseInstanceData` comes in handy when dealing with an irregular API\n     * that can be improved with data transformation.\n     *\n     * Suppose a request to `/services/todos` returns:\n     * ```\n     * {\n     *   baseUrl: \"/proxy/share\",\n     *   todo: {\n     *     id: 0,\n     *     name: \"dishes\",\n     *     friendFaceUrl: \"friendface?id=0\",\n     *     fiddlerUrl: \"fiddler?id=0\"\n     *   }\n     * }\n     * ```\n     *\n     * The baseUrl property is meta-data that needs to be incorporated into the\n     * instance data. One way to deal with this is:\n     *\n     * ```\n     * connect([\n     *   require(\"can-connect/data/parse/parse\"),\n     *   require(\"can-connect/data/url/url\")\n     * ],{\n     *   parseInstanceProp: \"todo\",\n     *   parseInstanceData(responseData) {\n     *     ['friendFaceUrl', 'fiddlerUrl'].map(urlProp => {\n     *       responseData.todo[urlProp] = [\n     *         responseData.baseUrl,\n     *         responseData.todo[urlProp]\n     *       ].join('/');\n     *     });\n     *\n     *     return responseData;\n     *   }\n     * })\n     * ```\n     *\n     * This results in an object like:\n     *\n     * ```js\n     * {\n     *   id: 0,\n     *   name: \"dishes\",\n     *   friendFaceUrl: \"/proxy/share/friendface?id=0\",\n     *   fiddlerUrl: \"/proxy/share/fiddler?id=0\"\n     * }\n     * ```\n     */\n\t\tparseInstanceData: function( props ) {\n\t\t\t// call any base parseInstanceData\n\t\t\tif(baseConnection.parseInstanceData) {\n\t\t\t\t// It's possible this might be looking for a property that only exists in some\n\t\t\t\t// responses. So if it doesn't return anything, go back to using props.\n\t\t\t   props = baseConnection.parseInstanceData.apply(this, arguments) || props;\n\t\t\t}\n\t\t\treturn this.parseInstanceProp ? getObject(props, this.parseInstanceProp) || props : props;\n\t\t}\n\t\t/**\n\t\t * @property {String} can-connect/data/parse/parse.parseListProp parseListProp\n\t\t * @parent can-connect/data/parse/parse\n\t\t *\n\t\t * The property to find the array-like data that represents each instance item.\n\t\t *\n\t\t * @option {String} [can-connect/data/parse/parse.parseListData] uses this property to find an array-like data struture\n\t\t * on the result of [can-connect/connection.getListData].\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * Set `parseListProp` if your response data does not look like: `{data: [props, props]}`.\n\t\t *\n\t\t * For example, if [can-connect/connection.getListData] returns data like:\n\t\t *\n\t\t * ```\n\t\t * {\n\t\t * \t  todos: [{id: 1, name: \"dishes\"}, {id: 2, name: \"lawn\"}]\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * Set `parseListProp` to `\"todos\"` like:\n\t\t *\n\t\t * ```\n\t\t * connect([\n         *   require(\"can-connect/data/parse/parse\"),\n         *   require(\"can-connect/data/url/url\")\n         * ],{\n\t\t *   url : \"/todos\",\n\t\t *   parseListProp: \"todos\"\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t */\n\t\t/**\n\t\t * @property {String} can-connect/data/parse/parse.parseInstanceProp parseInstanceProp\n\t\t * @parent can-connect/data/parse/parse\n\t\t *\n\t\t * The property to find the data that represents an instance item.\n\t\t *\n\t\t * @option {String} [can-connect/data/parse/parse.parseInstanceData] uses this property's value to\n\t\t * [can-connect/constructor/constructor.hydrateInstance make an instance].\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * Set `parseInstanceData` if your response data does not directly contain the data you would like to pass to\n\t\t * [connection.hydrateInstance].\n\t\t *\n\t\t * For example, if [can-connect/connection.getData] returns data like:\n\t\t *\n\t\t * ```\n\t\t * {\n\t\t *   todo: {\n\t\t * \t   id: 1,\n\t\t *     name: \"dishes\"\n\t\t *   }\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * Set `parseInstanceProp` to `\"todo\"` like:\n\t\t *\n\t\t * ```\n\t\t * connect([\n         *   require(\"can-connect/data/parse/parse\"),\n         *   require(\"can-connect/data/url/url\")\n         * ],{\n\t\t *   url : \"/todos\",\n\t\t *   parseInstanceProp: \"todo\"\n\t\t * });\n\t\t * ```\n\t\t */\n\n\t};\n\n\teach(pairs, function(parseFunction, name){\n\t\tbehavior[name] = function(params){\n\t\t\tvar self = this;\n\t\t\treturn baseConnection[name].call(this, params).then(function(){\n\t\t\t\treturn self[parseFunction].apply(self, arguments);\n\t\t\t});\n\t\t};\n\t});\n\n\treturn behavior;\n\n});\n\nvar pairs = {\n\tgetListData: \"parseListData\",\n\tgetData: \"parseInstanceData\",\n\tcreateData: \"parseInstanceData\",\n\tupdateData: \"parseInstanceData\",\n\tdestroyData: \"parseInstanceData\"\n};\n","'use strict';\n\nvar namespace = require(\"can-namespace\");\n\n// The following is from jQuery\nfunction isArrayLike(obj){\n\tvar type = typeof obj;\n\tif(type === \"string\") {\n\t\treturn true;\n\t}\n\telse if(type === \"number\") {\n\t\treturn false;\n\t}\n\t// The `in` check is from jQuery’s fix for an iOS 8 64-bit JIT object length bug:\n\t// https://github.com/jquery/jquery/pull/2185\n\tvar length = obj && type !== 'boolean' &&\n\t\ttypeof obj !== 'number' &&\n\t\t\"length\" in obj && obj.length;\n\n\t// var length = \"length\" in obj && obj.length;\n\treturn typeof obj !== \"function\" &&\n\t\t( length === 0 || typeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\n}\n\nmodule.exports = namespace.isArrayLike = isArrayLike;\n","'use strict';\n\nvar canSymbol = require(\"can-symbol\");\n\nmodule.exports = function(obj) {\n\treturn obj && !!obj[canSymbol.iterator || canSymbol.for(\"iterator\")];\n};\n","'use strict';\n\n/* jshint maxdepth:7*/\nvar isArrayLike = require('../is-array-like/is-array-like');\nvar has = Object.prototype.hasOwnProperty;\nvar isIterable = require(\"../is-iterable/is-iterable\");\nvar canSymbol = require(\"can-symbol\");\nvar namespace = require(\"can-namespace\");\n\nfunction each(elements, callback, context) {\n\tvar i = 0,\n\t\tkey,\n\t\tlen,\n\t\titem;\n\tif (elements) {\n\t\tif ( isArrayLike(elements) ) {\n\n\t\t\tfor (len = elements.length; i < len; i++) {\n\t\t\t\titem = elements[i];\n\t\t\t\tif (callback.call(context || item, item, i, elements) === false) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Works in anything that implements Symbol.iterator\n\t\telse if(isIterable(elements)) {\n\t\t\tvar iter = elements[canSymbol.iterator || canSymbol.for(\"iterator\")]();\n\t\t\tvar res, value;\n\n\t\t\twhile(!(res = iter.next()).done) {\n\t\t\t\tvalue = res.value;\n\t\t\t\tcallback.call(context || elements, Array.isArray(value) ?\n\t\t\t\t\t\t\t\t\t\t\tvalue[1] : value, value[0]);\n\t\t\t}\n\t\t}\n\t\t else if (typeof elements === \"object\") {\n\t\t\tfor (key in elements) {\n\t\t\t\tif (has.call(elements, key) &&\n\t\t\t\t\t\tcallback.call(context || elements[key],\n\t\t\t\t\t\t\t\t\t\t\t\t\telements[key], key, elements) === false) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn elements;\n}\n\nmodule.exports = namespace.each = each;\n","var each = require(\"can-util/js/each/each\");\n\nvar methodMapping = {\n\titem: {\n\t\t'GET': 'getData',\n\t\t'PUT': 'updateData',\n\t\t'DELETE': 'destroyData',\n\t},\n\tlist: {\n\t\t'GET': 'getListData',\n\t\t'POST': 'createData'\n\t}\n};\n\n\nfunction inferIdProp (url) {\n\tvar wrappedInBraces = /\\{(.*)\\}/;\n\tvar matches = url.match(wrappedInBraces);\n\tvar isUniqueMatch = matches && matches.length === 2;\n\tif (isUniqueMatch) {\n\t\treturn matches[1];\n\t}\n}\n\nfunction getItemAndListUrls (url, idProp) {\n\tidProp = idProp || inferIdProp(url) || \"id\";\n\tvar itemRegex = new RegExp('\\\\/\\\\{' + idProp+\"\\\\}.*\" );\n\tvar rootIsItemUrl = itemRegex.test(url);\n\tvar listUrl = rootIsItemUrl ? url.replace(itemRegex, \"\") : url;\n\tvar itemUrl = rootIsItemUrl ? url : (url.trim() + \"/{\" + idProp + \"}\");\n\treturn {item: itemUrl, list: listUrl};\n}\n\n\n\nmodule.exports = function(url, idProp){\n\tvar data= {};\n\teach( getItemAndListUrls(url, idProp), function(url, type){\n\t\teach(methodMapping[type], function(interfaceMethod, method){\n\t\t\tdata[interfaceMethod] = {\n\t\t\t\tmethod: method,\n\t\t\t\turl: url\n\t\t\t};\n\t\t});\n\t});\n\treturn data;\n};\n","var canReflect = require(\"can-reflect\");\nmodule.exports = function(obj){\n\tif (obj && typeof obj.then === \"function\" && !canReflect.isPromise(obj)) {\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tobj.then(resolve, reject);\n\t\t});\n\t}\n\telse {\n\t\treturn obj;\n\t}\n};\n","\"use strict\";\n/**\n * @module {connect.Behavior} can-connect/data/url/url data/url\n * @parent can-connect.behaviors\n * @group can-connect/data/url/url.data-methods data methods\n * @group can-connect/data/url/url.option options\n *\n * @option {connect.Behavior}\n *\n * Uses the [can-connect/data/url/url.url] option to implement the behavior of\n * [can-connect/connection.getListData],\n * [can-connect/connection.getData],\n * [can-connect/connection.createData],\n * [can-connect/connection.updateData], and\n * [can-connect/connection.destroyData] to make an AJAX request\n * to urls.\n *\n * @body\n *\n * ## Use\n *\n * The `data/url` behavior implements many of the [can-connect/DataInterface]\n * methods to send instance data to a URL.\n *\n * For example, the following `todoConnection`:\n *\n * ```js\n * var todoConnection = connect([\n *   require(\"can-connect/data/url/url\")\n * ],{\n *   url: {\n *     getListData: \"GET /todos\",\n *     getData: \"GET /todos/{id}\",\n *     createData: \"POST /todos\",\n *     updateData: \"PUT /todos/{id}\",\n *     destroyData: \"DELETE /todos/{id}\"\n *   }\n * });\n * ```\n *\n * Will make the following request when the following\n * methods are called:\n *\n * ```\n * // GET /todos?due=today\n * todoConnection.getListData({due: \"today\"});\n *\n * // GET /todos/5\n * todosConnection.getData({id: 5})\n *\n * // POST /todos \\\n * // name=take out trash\n * todosConnection.createData({\n *   name: \"take out trash\"\n * });\n *\n * // PUT /todos/5 \\\n * // name=do the dishes\n * todosConnection.updateData({\n *   name: \"do the dishes\",\n *   id: 5\n * });\n *\n * // DELETE /todos/5\n * todosConnection.destroyData({\n *   id: 5\n * });\n * ```\n *\n * There's a few things to notice:\n *\n * 1. URL values can include simple templates like `{id}`\n *    that replace that part of the URL with values in the data\n *    passed to the method.\n * 2. GET and DELETE request data is put in the URL using [can-param].\n * 3. POST and PUT requests put data that is not templated in the URL in POST or PUT body\n *    as JSON-encoded data.  To use form-encoded requests instead, add the property\n *    `contentType:'application/x-www-form-urlencoded'` to your [can-connect/data/url/url.url].\n * 4. If a provided URL doesn't include the method, the following default methods are provided:\n *    - `getListData` - `GET`\n *    - `getData` - `GET`\n *    - `createData` - `POST`\n *    - `updateData` - `PUT`\n *    - `destroyData` - `DELETE`\n *\n * If [can-connect/data/url/url.url] is provided as a string like:\n *\n * ```js\n * var todoConnection = connect([\n *   require(\"can-connect/data/url/url\")\n * ],{\n *   url: \"/todos\"\n * });\n * ```\n *\n * This does the same thing as the first `todoConnection` example.\n */\nvar ajax = require(\"can-ajax\");\nvar replaceWith = require(\"can-key/replace-with/replace-with\");\nvar canReflect = require(\"can-reflect\");\nvar dev = require(\"can-log/dev/dev\");\nvar behavior = require(\"../../behavior\");\nvar makeRest = require(\"can-make-rest\");\n\nvar defaultRest = makeRest(\"/resource/{id}\");\n\nvar makePromise = require(\"../../helpers/make-promise\");\n\n// # can-connect/data/url/url\n// For each pair, create a function that checks the url object\n// and creates an ajax request.\nvar urlBehavior = behavior(\"data/url\", function(baseConnection) {\n\tvar behavior = {};\n\tcanReflect.eachKey(defaultRest, function(defaultData, dataInterfaceName){\n\t\tbehavior[dataInterfaceName] = function(params) {\n\t\t\tvar meta = methodMetaData[dataInterfaceName];\n\n\t\t\tif(typeof this.url === \"object\") {\n\t\t\t\tif(typeof this.url[dataInterfaceName] === \"function\") {\n\n\t\t\t\t\treturn makePromise(this.url[dataInterfaceName](params));\n\t\t\t\t}\n\t\t\t\telse if(this.url[dataInterfaceName]) {\n\t\t\t\t\tvar promise = makeAjax(\n\t\t\t\t\t\t\tthis.url[dataInterfaceName],\n\t\t\t\t\t\t\tparams,\n\t\t\t\t\t\t\tdefaultData.method,\n\t\t\t\t\t\t\tthis.ajax || ajax,\n\t\t\t\t\t\t\tfindContentType(this.url, defaultData.method),\n\t\t\t\t\t\t\tmeta);\n\t\t\t\t\treturn makePromise(promise);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar resource = typeof this.url === \"string\" ? this.url : this.url.resource;\n\t\t\tif( resource ) {\n\t\t\t\tvar idProps = canReflect.getSchema(this.queryLogic).identity;\n\t\t\t\tvar resourceWithoutTrailingSlashes = resource.replace(/\\/+$/, \"\");\n\t\t\t\tvar result = makeRest(resourceWithoutTrailingSlashes, idProps[0])[dataInterfaceName];\n\t\t\t\treturn makePromise(makeAjax( result.url,\n\t\t\t\t\tparams, result.method,\n\t\t\t\t\tthis.ajax || ajax,\n\t\t\t\t\tfindContentType(this.url, result.method),\n\t\t\t\t\tmeta));\n\t\t\t}\n\n\t\t\treturn baseConnection[name].call(this, params);\n\t\t};\n\t});\n\n\treturn behavior;\n});\n/**\n * @property {String|Object} can-connect/data/url/url.url url\n * @parent can-connect/data/url/url.option\n *\n * Specify the url and methods that should be used for the \"Data Methods\".\n *\n * @option {String} If a string is provided, it's assumed to be a RESTful interface. For example,\n * if the following is provided:\n *\n * ```\n * url: \"/services/todos\"\n * ```\n *\n * ... the following methods and requests are used:\n *\n *  - `getListData` - `GET /services/todos`\n *  - `getData` - `GET /services/todos/{id}`\n *  - `createData` - `POST /services/todos`\n *  - `updateData` - `PUT /services/todos/{id}`\n *  - `destroyData` - `DELETE /services/todos/{id}`\n *\n * @option {Object} If an object is provided, it can customize each method and URL directly\n * like:\n *\n * ```\n * url: {\n *   getListData: \"GET /services/todos\",\n *   getData: \"GET /services/todo/{id}\",\n *   createData: \"POST /services/todo\",\n *   updateData: \"PUT /services/todo/{id}\",\n *   destroyData: \"DELETE /services/todo/{id}\"\n * }\n * ```\n *\n * You can provide a `resource` property that works like providing `url` as a string, but overwrite\n * other values like:\n *\n * ```\n * url: {\n *   resource: \"/services/todo\",\n *   getListData: \"GET /services/todos\"\n * }\n * ```\n *\n * Finally, you can provide your own method to totally control how the request is made:\n *\n * ```\n * url: {\n *   resource: \"/services/todo\",\n *   getListData: \"GET /services/todos\",\n *   getData: function(param){\n *     return new Promise(function(resolve, reject){\n *       $.get(\"/services/todo\", {identifier: param.id}).then(resolve, reject);\n *     });\n *   }\n * }\n * ```\n */\n\n\n /**\n  * @property {function} can-connect/data/url/url.ajax ajax\n  * @parent can-connect/data/url/url.option\n  *\n  * Specify the ajax functionality that should be used to make the request.\n  *\n  * @option {function} Provides an alternate function to be used to make\n  * ajax requests.  By default [can-ajax] provides the ajax\n  * functionality. jQuery's ajax method can be substituted as follows:\n  *\n  * ```js\n  * connect([\n  *   require(\"can-connect/data/url/url\")\n  * ],{\n  *   url: \"/things\",\n  *   ajax: $.ajax\n  * });\n  * ```\n  *\n  *   @param {Object} settings Configuration options for the AJAX request.\n  *   @return {Promise} A Promise that resolves to the data.\n  */\n\n// ## methodMetaData\n// Metadata on different methods that is passed to makeAjax\nvar methodMetaData = {\n\t/**\n\t * @function can-connect/data/url/url.getListData getListData\n\t * @parent can-connect/data/url/url.data-methods\n\t *\n\t * @signature `getListData(set)`\n\t *\n\t *   Retrieves list data for a particular set given the [can-connect/data/url/url.url] settings.\n\t *   If `url.getListData` is a function, that function will be called.  If `url.getListData` is a\n\t *   string, a request to that string will be made. If `url` is a string, a `GET` request is made to\n\t *   `url`.\n\t *\n\t *   @param {can-query-logic/query} query A object that represents the set of data needed to be loaded.\n\t *   @return {Promise<can-connect.listData>} A promise that resolves to the ListData format.\n\t */\n\tgetListData: {},\n\t/**\n\t * @function can-connect/data/url/url.getData getData\n\t * @parent can-connect/data/url/url.data-methods\n\t *\n\t * @signature `getData(params)`\n\t *\n\t *   Retrieves raw instance data given the [can-connect/data/url/url.url] settings.\n\t *   If `url.getData` is a function, that function will be called.  If `url.getData` is a\n\t *   string, a request to that string will be made. If `url` is a string, a `GET` request is made to\n\t *   `url+\"/\"+IDPROP`.\n\t *\n\t *   @param {Object} params A object that represents the set of data needed to be loaded.\n\t *   @return {Promise<Object>} A promise that resolves to the instance data.\n\t */\n\tgetData: {},\n\t/**\n\t * @function can-connect/data/url/url.createData createData\n\t * @parent can-connect/data/url/url.data-methods\n\t *\n\t * @signature `createData(instanceData, cid)`\n\t *\n\t *   Creates instance data given the serialized form of the data and\n\t *   the [can-connect/data/url/url.url] settings.\n\t *   If `url.createData` is a function, that function will be called.  If `url.createData` is a\n\t *   string, a request to that string will be made. If `url` is a string, a `POST` request is made to\n\t *   `url`.\n\t *\n\t *   @param {Object} instanceData The serialized data of the instance.\n\t *   @param {Number} cid A unique id that represents the instance that is being created.\n\t *   @return {Promise<Object>} A promise that resolves to the newly created instance data.\n\t */\n\tcreateData: {},\n\t/**\n\t * @function can-connect/data/url/url.updateData updateData\n\t * @parent can-connect/data/url/url.data-methods\n\t *\n\t * @signature `updateData(instanceData)`\n\t *\n\t * Updates instance data given the serialized form of the data and\n\t *   the [can-connect/data/url/url.url] settings.\n\t *   If `url.updateData` is a function, that function will be called.  If `url.updateData` is a\n\t *   string, a request to that string will be made. If `url` is a string, a `PUT` request is made to\n\t *   `url+\"/\"+IDPROP`.\n\t *\n\t *   @param {Object} instanceData The serialized data of the instance.\n\t *   @return {Promise<Object>} A promise that resolves to the updated instance data.\n\t */\n\tupdateData: {},\n\t/**\n\t * @function can-connect/data/url/url.destroyData destroyData\n\t * @parent can-connect/data/url/url.data-methods\n\t *\n\t * @signature `destroyData(instanceData)`\n\t *\n\t * Deletes instance data given the serialized form of the data and\n\t *   the [can-connect/data/url/url.url] settings.\n\t *   If `url.destroyData` is a function, that function will be called.  If `url.destroyData` is a\n\t *   string, a request to that string will be made. If `url` is a string, a `DELETE` request is made to\n\t *   `url+\"/\"+IDPROP`.\n\t *\n\t *   @param {Object} instanceData The serialized data of the instance.\n\t *   @return {Promise<Object>} A promise that resolves to the deleted instance data.\n\t */\n\tdestroyData: {includeData: false}\n};\n\nvar findContentType = function( url, method ) {\n\tif ( typeof url === 'object' && url.contentType ) {\n\t\tvar acceptableType = url.contentType === 'application/x-www-form-urlencoded' ||\n\t\t\turl.contentType === 'application/json';\n\t\tif ( acceptableType ) {\n\t\t\treturn url.contentType;\n\t\t} else {\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tdev.warn(\"Unacceptable contentType on can-connect request. \" +\n\t\t\t\t\t\"Use 'application/json' or 'application/x-www-form-urlencoded'\");\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t}\n\t}\n\treturn method === \"GET\" ? \"application/x-www-form-urlencoded\" : \"application/json\";\n};\n\nfunction urlParamEncoder (key, value) {\n\treturn encodeURIComponent(value)\n}\n\nvar makeAjax = function ( ajaxOb, data, type, ajax, contentType, reqOptions ) {\n\n\tvar params = {};\n\n\t// A string here would be something like `\"GET /endpoint\"`.\n\tif (typeof ajaxOb === 'string') {\n\t\t// Split on spaces to separate the HTTP method and the URL.\n\t\tvar parts = ajaxOb.split(/\\s+/);\n\t\tparams.url = parts.pop();\n\t\tif (parts.length) {\n\t\t\tparams.type = parts.pop();\n\t\t}\n\t} else {\n\t\t// If the first argument is an object, just load it into `params`.\n\t\tcanReflect.assignMap(params, ajaxOb);\n\t}\n\n\t// If the `data` argument is a plain object, copy it into `params`.\n\tparams.data = typeof data === \"object\" && !Array.isArray(data) ?\n\t\tcanReflect.assignMap(params.data || {}, data) : data;\n\n\t// Substitute in data for any templated parts of the URL.\n\tparams.url = replaceWith(params.url, params.data, urlParamEncoder, true);\n\tparams.contentType = contentType;\n\n\tif(reqOptions.includeData === false) {\n\t\tdelete params.data;\n\t}\n\n\treturn ajax(canReflect.assignMap({\n\t\ttype: type || 'post',\n\t\tdataType: 'json'\n\t}, params));\n};\n\nmodule.exports = urlBehavior;\n\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\tvar validate = require(\"../../helpers/validate\");\n\tmodule.exports = validate(urlBehavior, ['url']);\n}\n//!steal-remove-end\n","\"use strict\";\nvar canReflect = require(\"can-reflect\");\n\nmodule.exports = function assignExceptIdentity(obj, data, schema) {\n    if(!schema) {\n        schema = canReflect.getSchema(obj);\n    }\n    if(!schema) {\n        throw new Error(\"can-diff/update-except-id is unable to update without a schema.\");\n    }\n    // copy the keys onto data\n    schema.identity.forEach(function(key){\n        var id = canReflect.getKeyValue(obj, key);\n        if(id!== undefined) {\n            canReflect.setKeyValue(data, key, id );\n        }\n    });\n\n    canReflect.assignDeep(obj, data);\n};\n","\"use strict\";\n\nvar canReflect = require(\"can-reflect\");\nvar each = canReflect.each;\nvar isPlainObject = canReflect.isPlainObject;\n\nvar queues = require(\"can-queues\");\nvar eventQueue = require(\"can-event-queue/map/map\");\nvar ObservationRecorder = require(\"can-observation-recorder\");\nvar canSymbol = require(\"can-symbol\");\nvar QueryLogic = require(\"can-query-logic\");\n\nvar dev = require(\"can-log/dev/dev\");\n\nvar behavior = require(\"../../behavior\");\nvar updateDeepExceptIdentity = require(\"can-diff/update-deep-except-identity/update-deep-except-identity\");\nvar assignDeepExceptIdentity = require(\"can-diff/assign-deep-except-identity/assign-deep-except-identity\");\nvar smartMerge = require('can-diff/merge-deep/merge-deep');\nvar canSymbol = require(\"can-symbol\");\nvar getNameSymbol = canSymbol.for(\"can.getName\");\n\nfunction smartMergeExceptIdentity(dest, source, schema) {\n\tif(!schema) {\n        schema = canReflect.getSchema(dest);\n    }\n    if(!schema) {\n        throw new Error(\"can-connect/can/map/ is unable to update without a schema.\");\n    }\n\tschema.identity.forEach(function(key){\n        var id = canReflect.getKeyValue(dest, key);\n        if(id!== undefined) {\n            canReflect.setKeyValue(source, key, id );\n        }\n    });\n\tsmartMerge(dest, source);\n}\n\nvar canMapBehavior = behavior(\"can/map\",function(baseConnection){\n\n\t// overwrite\n\tvar behavior = {\n\t\tinit: function(){\n\t\t\tif(!this.Map) {\n\t\t\t\tthrow new Error(\"can-connect/can/map/map must be configured with a Map type\");\n\t\t\t}\n\t\t\tif(!this[getNameSymbol]) {\n\t\t\t\tthis[getNameSymbol] = function(){\n\t\t\t\t\tif(this.name) {\n\t\t\t\t\t\treturn \"Connection{\"+this.name+\"}\";\n\t\t\t\t\t} else if(this.Map) {\n\t\t\t\t\t\treturn \"Connection{\"+canReflect.getName(this.Map)+\"}\";\n\t\t\t\t\t} else if(typeof this.url === \"string\") {\n\t\t\t\t\t\treturn \"Connection{\"+this.url+\"}\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn \"Connection{}\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.List = this.List || this.Map.List;\n\t\t\tif(!this.List) {\n\t\t\t\tthrow new Error(\"can-connect/can/map/map - \"+canReflect.getName(this)+\" must be configured with a List type.\");\n\t\t\t}\n\n\t\t\toverwrite(this, this.Map, mapOverwrites);\n\t\t\toverwrite(this, this.List, listOverwrites);\n\n\t\t\tif(!this.queryLogic) {\n\t\t\t\tthis.queryLogic = new QueryLogic(this.Map);\n\t\t\t}\n\n\n\t\t\tvar connection = this;\n\n\t\t\t// ### Setup store updates\n\t\t\tif(this.Map[canSymbol.for(\"can.onInstanceBoundChange\")]) {\n\t\t\t\tvar canConnectMap_onMapBoundChange = function (instance, isBound){\n\t\t\t\t\tvar method = isBound ? \"addInstanceReference\" : \"deleteInstanceReference\";\n\t\t\t\t\tif(connection[method]) {\n\t\t\t\t\t\tconnection[method](instance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-start\n\t\t\t\tObject.defineProperty(canConnectMap_onMapBoundChange, \"name\", {\n\t\t\t\t\tvalue: canReflect.getName(this.Map) + \" boundChange\",\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\t\t\t\t//!steal-remove-end\n\t\t\t\tthis.Map[canSymbol.for(\"can.onInstanceBoundChange\")](canConnectMap_onMapBoundChange)\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"can-connect/can/map is unable to listen to onInstanceBoundChange on the Map type\")\n\t\t\t}\n\n\t\t\tif(this.List[canSymbol.for(\"can.onInstanceBoundChange\")]) {\n\t\t\t\tvar canConnectMap_onListBoundChange = function(list, isBound){\n\t\t\t\t\tvar method = isBound ? \"addListReference\" : \"deleteListReference\";\n\t\t\t\t\tif(connection[method]) {\n\t\t\t\t\t\tconnection[method](list);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-start\n\t\t\t\tObject.defineProperty(canConnectMap_onListBoundChange, \"name\", {\n\t\t\t\t\tvalue: canReflect.getName(this.List) + \" boundChange\",\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\t\t\t\t//!steal-remove-end\n\t\t\t\tthis.List[canSymbol.for(\"can.onInstanceBoundChange\")](canConnectMap_onListBoundChange);\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"can-connect/can/map is unable to listen to onInstanceBoundChange on the List type\")\n\t\t\t}\n\t\t\t// Adds the instance when its `id` property is set\n\t\t\tif(this.Map[canSymbol.for(\"can.onInstancePatches\")]) {\n\t\t\t\tthis.Map[canSymbol.for(\"can.onInstancePatches\")](function canConnectMap_onInstancePatches(instance, patches){\n\t\t\t\t\tpatches.forEach(function(patch){\n\t\t\t\t\t\tif( (patch.type === \"add\" || patch.type === \"set\") &&\n\t\t\t\t\t\t\tpatch.key === connection.idProp &&\n\t\t\t\t\t\t\tinstance[canSymbol.for(\"can.isBound\")]()) {\n\t\t\t\t\t\t\tconnection.addInstanceReference(instance);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"can-connect/can/map is unable to listen to onInstancePatches on the Map type\");\n\t\t\t}\n\t\t\tbaseConnection.init.apply(this, arguments);\n\t\t},\n\t\t/**\n\t\t * @function can-connect/can/map/map.serializeInstance serializeInstance\n\t\t * @parent can-connect/can/map/map.serializers\n\t\t *\n\t\t * Returns the properties of an instance that should be sent to the data source when saving. Done by calling\n\t\t * [can-define/map/map.prototype.serialize `instance.serialize()`].\n\t\t *\n\t\t * @signature `connection.serializeInstance(instance)`\n\t\t * Simply calls [can-define/map/map.prototype.serialize] on the `instance` argument.\n\t\t *\n\t\t * @param {can-connect/can/map/map._Map} instance the instance to serialize\n\t\t * @return {Object} the result of calling [can-define/map/map.prototype.serialize `instance.serialize()`]\n\t\t */\n\t\tserializeInstance: function(instance){\n\t\t\treturn canReflect.serialize(instance);\n\t\t},\n\t\t/**\n\t\t * @function can-connect/can/map/map.serializeList serializeList\n\t\t * @parent can-connect/can/map/map.serializers\n\t\t *\n\t\t * Returns the properties of a list that should be sent to the data source when saving. Done by calling\n\t\t * [can-define/list/list.prototype.serialize `list.serialize()`].\n\t\t *\n\t\t * @signature `connection.serializeList(list)`\n\t\t * Simply calls [can-define/list/list.prototype.serialize] on the `list` argument.\n\t\t *\n\t\t * @param {can-connect/can/map/map._List} list the list to serialize\n\t\t * @return {Object} the result of calling [can-define/list/list.prototype.serialize `list.serialize()`]\n\t\t */\n\t\tserializeList: function(list){\n\t\t\treturn canReflect.serialize(list);\n\t\t},\n\t\t/**\n\t\t * @property {Boolean} can-connect/can/map/map.updateInstanceWithAssignDeep updateInstanceWithAssignDeep\n\t\t * @parent can-connect/can/map/map.options\n\t\t *\n\t\t * Use the response from `save()` and `destroy()` to assign properties, never delete them.\n\t\t *\n\t\t * @option {Boolean}\n\t\t *\n\t\t * Setting `updateInstanceWithAssignDeep` to `true` changes how instances get updated. Instead of using\n\t\t * [can-diff/merge-deep/merge-deep], records will be updated with [can-reflect.assignDeep].\n\t\t *\n\t\t * The following example shows that the response from `.save()` only includes the `id`\n\t\t * property. Normally, this would delete all other properties (`name`).  But setting `updateInstanceWithAssignDeep`\n\t\t * to `true` prevents this:\n\t\t *\n\t\t * **Usage:**\n\t\t *\n\t\t * ```js\n\t\t * import {DefineMap, restModel} from \"can\";\n\t\t *\n\t\t * var Todo = DefineMap.extend({\n\t\t *   id: {type: \"number\", identity: true},\n\t\t *   name: \"string\"\n\t\t * });\n\t\t *\n\t\t * // restModel uses `can-connect/can/map/map`\n\t\t * restModel({\n\t\t *   Map: Todo,\n\t\t *   url: \"/todos\",\n\t\t *   updateInstanceWithAssignDeep: true\n\t\t * });\n\t\t *\n\t\t *\n\t\t * var todo = new Todo({name: \"learn canjs\"})\n\t\t *\n\t\t * var savePromise = todo.save()\n\t\t * // SERVER SENDS\n\t\t * // -> POST /todos {name: \"learn canjs\"}\n\t\t *\n\t\t * // SERVER RESPONDS WITH:\n\t\t * // <- {id: 5}\n\t\t *\n\t\t * savePromise.then(function(){\n\t\t *   // Name still exists even though the server did not\n\t\t *   // respond with it.\n\t\t *   todo.name //-> \"learn canjs\"\n\t\t * })\n\t\t * ```\n\t\t *\n\t\t * __NOTE__: [can-diff/merge-deep/merge-deep] is able to work _MUCH_ better with nested\n\t\t * data than [can-reflect.assignDeep]. Specifically, it is able to better\n\t\t * prevent overwriting one instance's data with another. The _Use_ section of [can-diff/merge-deep/merge-deep]\n\t\t * goes over this ability. Make sure you understand its capabilities before turning it off.\n\t\t */\n\n\t\t/**\n\t\t * @property {connection.Map} can-connect/can/map/map._Map Map\n\t\t * @parent can-connect/can/map/map.options\n\t\t *\n\t\t * Specify the type of the `[can-define/map/map DefineMap]` that should be instantiated by the connection.\n\t\t *\n\t\t * @option {connection.Map}\n\t\t *\n\t\t * **Usage:**\n\t\t *\n\t\t * ```js\n\t\t * var DefineMap = require(\"can-define/map/map\");\n\t\t * var canMap = require(\"can-connect/can/map/map\");\n\t\t * var constructor = require(\"can-connect/constructor/constructor\");\n\t\t * var dataUrl = require(\"can-connect/data/url/url\");\n\t\t *\n\t\t * var Todo = DefineMap.extend({\n\t\t *   completed: \"boolean\",\n\t\t *   complete: function(){\n\t\t *     this.completed = true\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * var todoConnection = connect([dataUrl, constructor, canMap], {\n\t\t *   Map: Todo,\n\t\t *   url: \"/todos\"\n\t\t * });\n\t\t *\n\t\t * todoConnect.get({id:1}).then(function(item) {\n\t\t *   item instanceof Todo // true\n\t\t * });\n\t\t * ```\n\t\t */\n\n\t\t/**\n\t\t * @property {connection.List} can-connect/can/map/map._List List\n\t\t * @parent can-connect/can/map/map.options\n\t\t *\n\t\t * Specify the type of the `[can-define/list/list DefineList]` that should be instantiated by the connection.\n\t\t *\n\t\t * @option {connection.List} If this option is not specified it defaults to the [can-connect/can/map/map._Map Map].List\n\t\t * property.\n\t\t *\n\t\t * **Usage:**\n\t\t * ```js\n\t\t * var DefineMap = require(\"can-define/map/map\");\n\t\t * var DefineList = require(\"can-define/list/list\");\n\t\t * var canMap = require(\"can-connect/can/map/map\");\n\t\t * var constructor = require(\"can-connect/constructor/constructor\");\n\t\t * var dataUrl = require(\"can-connect/data/url/url\");\n\t\t *\n\t\t * var Todo = DefineMap.extend({\n\t\t *   completed: \"boolean\",\n\t\t *   complete: function(){\n\t\t *     this.completed = true\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * var Todo.List = DefineList.extend({\n\t\t *   \"#\": Todo,\n\t\t *   completed: function(){\n\t\t *     this.filter(function(todo){\n\t\t *       return todo.completed;\n\t\t *     });\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * var todoConnection = connect([dataUrl, constructor, canMap],{\n\t\t *   Map: Todo,\n\t\t *   List: Todo.List,\n\t\t *   url: \"/todos\"\n\t\t * });\n\t\t *\n\t\t * todoConnection.getList({}).then(function(list) {\n\t\t *   list instanceOf Todo.List // true\n\t\t * })\n\t\t * ```\n\t\t *\n\t\t */\n\n\t\t/**\n\t\t * @function can-connect/can/map/map.instance instance\n\t\t * @parent can-connect/can/map/map.hydrators\n\t\t *\n\t\t * Creates a [can-connect/can/map/map._Map] instance given raw data.\n\t\t *\n\t\t * @signature `connection.instance(props)`\n\t\t *\n\t\t *   Create an instance of [can-connect/can/map/map._Map].\n\t\t *\n\t\t *   @param {Object} props the raw instance data.\n\t\t *   @return [can-connect/can/map/map._Map] a [can-connect/can/map/map._Map] instance containing the `props`.\n\t\t */\n\t\tinstance: function(props){\n\t\t\tvar _Map = this.Map;\n\t\t\treturn new _Map(props);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/can/map/map.list list\n\t\t * @parent can-connect/can/map/map.hydrators\n\t\t *\n\t\t * Creates a [can-connect/can/map/map._List] instance given raw data.\n\t\t *\n\t\t * @signature `connection.list(listData, set)`\n\t\t *\n\t\t *   Creates an instance of [can-connect/can/map/map._List] if available, otherwise creates\n\t\t *   [can-connect/can/map/map._Map].List if available.\n\t\t *\n\t\t *   This will add properties on the raw `listData` array to the created list instance. e.g:\n\t\t *   ```js\n\t\t *   var listData = [{id: 1, name:\"do dishes\"}, ...];\n\t\t *   listData.loadedFrom; // \"shard 5\"\n\t\t *\n\t\t *   var todoList = todoConnection.list(listData, {});\n\t\t *   todoList.loadedFrom; // \"shard 5\"\n\t\t *   ```\n\t\t *\n\t\t *   @param {can-connect.listData} listData the raw list data.\n\t\t *   @param {can-query-logic/query} query the set the data belongs to.\n\t\t *   @return {can-connect.List} a [can-connect/can/map/map._List] instance containing instances of\n\t\t *   [can-connect/can/map/map._Map] built from the list items in `listData`.\n\t\t */\n\t\tlist: function(listData, set){\n\t\t\tvar _List = this.List || (this.Map && this.Map.List);\n\t\t\tvar list = new _List(listData.data);\n\t\t\tcanReflect.eachKey(listData, function (val, prop) {\n\t\t\t\tif (prop !== 'data') {\n\t\t\t\t\tcanReflect.setKeyValue(list, prop, val);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tlist[this.listQueryProp] = set;\n\t\t\treturn list;\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/can/map/map.updatedList updatedList\n\t\t * @parent can-connect/can/map/map.instance-callbacks\n\t\t *\n\t\t * Implements the [can-connect/constructor/constructor.updatedList] callback so it updates the list and it's items\n\t\t * during a single [can-event/batch/batch batched event].\n\t\t *\n\t\t * @signature `connection.updatedList(list, listData, set)`\n\t\t *\n\t\t *   Updates the list and the items within it during a single [can-event/batch/batch batched event].\n\t\t *\n\t\t *   @param {can-connect.List} list the list to be updated.\n\t\t *   @param {can-connect.listData} listData raw list data.\n\t\t *   @param {can-query-logic/query} query the set of the list being updated.\n\t\t */\n\t\tupdatedList: function(list, listData, set){\n\t\t\tqueues.batch.start();\n\t\t\tvar enqueueOptions = {};\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tenqueueOptions = {\n    \t\t\t\treasonLog: [\"set\", set,\"list\", list,\"updated with\", listData]\n  \t\t\t\t};\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tqueues.mutateQueue.enqueue(baseConnection.updatedList, this, arguments, enqueueOptions);\n\t\t\tqueues.batch.stop();\n\n\t\t},\n\t\tsave: function(instance){\n\t\t\tcanReflect.setKeyValue(instance, \"_saving\", true);\n\t\t\t//canEvent.dispatch.call(instance, \"_saving\", [true, false]);\n\t\t\tvar done = function(){\n\t\t\t\tcanReflect.setKeyValue(instance, \"_saving\", false);\n\t\t\t\t//canEvent.dispatch.call(instance, \"_saving\", [false, true]);\n\t\t\t};\n\t\t\tvar base = baseConnection.save.apply(this, arguments);\n\t\t\tbase.then(done,done);\n\t\t\treturn base;\n\t\t},\n\t\tdestroy: function(instance){\n\t\t\tcanReflect.setKeyValue(instance, \"_destroying\", true);\n\t\t\t//canEvent.dispatch.call(instance, \"_destroying\", [true, false]);\n\t\t\tvar done = function(){\n\t\t\t\tcanReflect.setKeyValue(instance, \"_destroying\", false);\n\t\t\t\t//canEvent.dispatch.call(instance, \"_destroying\", [false, true]);\n\t\t\t};\n\t\t\tvar base = baseConnection.destroy.apply(this, arguments);\n\t\t\tbase.then(done,done);\n\t\t\treturn base;\n\t\t}\n\t};\n\n\teach([\n\t\t/**\n\t\t * @function can-connect/can/map/map.createdInstance createdInstance\n\t\t * @parent can-connect/can/map/map.instance-callbacks\n\t\t *\n\t\t * Implements the [can-connect/constructor/constructor.createdInstance] callback so it dispatches an event and\n\t\t * updates the instance.\n\t\t *\n\t\t * @signature `connection.createdInstance(instance, props)`\n\t\t *\n\t\t *   Updates the instance with `props` and dispatches a \"created\" event on the instance and the instances's\n\t\t *   constructor function ([can-connect/can/map/map._Map]).\n\t\t *\n\t\t *   Calls [can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore] to ensure new instances\n\t\t *   are moved into the [can-connect/constructor/store/store.instanceStore] after being saved.\n\t\t *\n\t\t *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance\n\t\t *   @param {Object} props the data in the response from [can-connect/connection.createData]\n\t\t */\n\t\t\"created\",\n\t\t/**\n\t\t * @function can-connect/can/map/map.updatedInstance updatedInstance\n\t\t * @parent can-connect/can/map/map.instance-callbacks\n\t\t *\n\t\t * Implements the [can-connect/constructor/constructor.updatedInstance] callback so it dispatches an event and\n\t\t * updates the instance.\n\t\t *\n\t\t * @signature `connection.updatedInstance(instance, props)`\n\t\t *\n\t\t *   Updates the instance with `props` and dispatches an \"updated\" event on the instance and the instances's\n\t\t *   constructor function ([can-connect/can/map/map._Map]).\n\t\t *\n\t\t *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance\n\t\t *   @param {Object} props the data in the response from [can-connect/connection.updateData]\n\t\t */\n\t\t\"updated\",\n\t\t/**\n\t\t * @function can-connect/can/map/map.destroyedInstance destroyedInstance\n\t\t * @parent can-connect/can/map/map.instance-callbacks\n\t\t *\n\t\t * Implements the [can-connect/constructor/constructor.destroyedInstance] callback so it dispatches an event and\n\t\t * updates the instance.\n\t\t *\n\t\t * @signature `connection.destroyedInstance(instance, props)`\n\t\t *\n\t\t *   Updates the instance with `props` and dispatches a \"destroyed\" event on the instance and the instances's\n\t\t *   constructor function ([can-connect/can/map/map._Map]).\n\t\t *\n\t\t *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance\n\t\t *   @param {Object} props the data in the response from [can-connect/connection.destroyData]\n\t\t */\n\t\t\"destroyed\"\n\t], function (funcName) {\n\t\t// Each of these is pretty much the same, except for the events they trigger.\n\t\tbehavior[funcName+\"Instance\"] = function (instance, props) {\n\n\t\t\t// Update attributes if attributes have been passed\n\t\t\tif(props && typeof props === 'object') {\n\n\t\t\t\tif(funcName === \"destroyed\" && canReflect.size(props) === 0) {\n\t\t\t\t\t// If destroy is passed an empty object, ignore update\n\t\t\t\t\t// This isn't tested except by can-rest-model.\n\t\t\t\t} else {\n\t\t\t\t\tif(this.constructor.removeAttr) {\n\t\t\t\t\t\tupdateDeepExceptIdentity(instance, props, this.queryLogic.schema);\n\t\t\t\t\t}\n\t\t\t\t\t// this is legacy\n\t\t\t\t\telse if(this.updateInstanceWithAssignDeep){\n\t\t\t\t\t\tassignDeepExceptIdentity(instance, props, this.queryLogic.schema);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsmartMergeExceptIdentity( instance, props, this.queryLogic.schema);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// This happens in constructor/store, but we don't call base, so we have to do it ourselves.\n\t\t\tif(funcName === \"created\" && this.moveCreatedInstanceToInstanceStore) {\n\t\t\t\tthis.moveCreatedInstanceToInstanceStore(instance);\n\t\t\t}\n\n\t\t\tcanMapBehavior.callbackInstanceEvents(funcName, instance);\n\t\t};\n\t});\n\n\n\treturn behavior;\n\n});\n\n/**\n * @function can-connect/can/map/map.callbackInstanceEvents callbackInstanceEvents\n * @parent can-connect/can/map/map.static\n *\n * Utility function to dispatch events for instance callbacks, e.g. [can-connect/can/map/map.updatedInstance].\n *\n * @signature `connection.callbackInstanceEvents(cbName, instance)`\n *\n *   Used to dispatch events as part of instance callbacks implementations. This method could be useful in other\n *   behaviors that implement instance callbacks. E.g. a behavior overriding the\n *   [can-connect/can/map/map.updatedInstance `updatedInstance`] callback:\n *\n *   ```\n *   connect([canMap, {\n *       updatedInstance: function(instance, props) {\n *           instance = smartMerge(instance, props);\n *           canMapBehavior.callbackInstanceEvents(\"updated\", instance);\n *       }\n *   }], {})\n *   ```\n *\n *   @param {String} eventName name of the the event to be triggered\n *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance.\n */\ncanMapBehavior.callbackInstanceEvents = function (funcName, instance) {\n\tvar constructor = instance.constructor;\n\n\t// triggers change event that bubble's like\n\t// handler( 'change','1.destroyed' ). This is used\n\t// to remove items on destroyed from Model Lists.\n\t// but there should be a better way.\n\tqueues.batch.start();\n\teventQueue.dispatch.call(instance, {type: funcName, target: instance});\n\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tif (this.id) {\n\t\t\tdev.log(\"can-connect/can/map/map.js - \" + (constructor.shortName || this.name) + \" \" + this.id(instance) + \" \" + funcName);\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// Call event on the instance's Class\n\teventQueue.dispatch.call(constructor, funcName, [instance]);\n\tqueues.batch.stop();\n};\n\n\nvar mapOverwrites = {\n\tstatic: {\n\t\t/**\n\t\t * @function can-connect/can/map/map.getList getList\n\t\t * @parent can-connect/can/map/map.map-static\n\t\t *\n\t\t * Retrieve a list of instance.\n\t\t *\n\t\t * @signature `Map.getList(query)`\n\t\t *\n\t\t * `.getList` is added to the configured [can-connect/can/map/map._Map] type. Retrieves a [can-connect/can/map/map._List] of\n\t\t * [can-connect/can/map/map._Map] instances via the connection.\n\t\t *\n\t\t * ```js\n\t\t * // import connection plugins\n\t\t * var canMap = require(\"can-connect/can/map/map\");\n\t\t * var constructor = require(\"can-connect/constructor/constructor\");\n\t\t * var dataUrl = require(\"can-connect/data/url/url\");\n\t\t *\n\t\t * // define connection types\n\t\t * var Todo = DefineMap.extend({\n\t\t *   id: \"number\",\n\t\t *   complete: \"boolean\",\n\t\t *   name: \"string\"\n\t\t * });\n\t\t *\n\t\t * Todo.List = DefineList.extend({\n\t\t *   completed: function() {\n\t\t *     return this.filter(function(item) { return item.completed; });\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * // create connection\n\t\t * connect([canMap, constructor, dataUrl],{\n\t\t *   Map: Todo,\n\t\t *   url: \"/todos\"\n\t\t * })\n\t\t *\n\t\t * // retrieve instances\n\t\t * Todo.getList({filter: {due: \"today\"}}).then(function(todos){\n\t\t *   ...\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * @param {can-query-logic/query} query Definition of the list being retrieved.\n\t\t * @return {Promise<Map>} `Promise` returning the [can-connect/can/map/map._List] of instances being retrieved\n\t\t *\n\t\t *\n\t\t *\n\t\t *\n\t\t */\n\t\tgetList: function (base, connection) {\n\t\t\treturn function(set) {\n\t\t\t\treturn connection.getList(set);\n\t\t\t};\n\t\t},\n\t\t/**\n\t\t * @function can-connect/can/map/map.findAll findAll\n\t\t * @parent can-connect/can/map/map.map-static\n\t\t * @hide\n\t\t *\n\t\t * Alias of [can-connect/can/map/map.getList]. You should use `.getList()`.\n\t\t */\n\t\tfindAll: function (base, connection) {\n\t\t\treturn function(set) {\n\t\t\t\treturn connection.getList(set);\n\t\t\t};\n\t\t},\n\t\t/**\n\t\t * @function can-connect/can/map/map.get get\n\t\t * @parent can-connect/can/map/map.map-static\n\t\t *\n\t\t * Use it to get a single instance by id.\n\t\t *\n\t\t * @signature `Map.get(params)`\n\t\t *\n\t\t * `.get()` is added to the configured [can-connect/can/map/map._Map] type.\n\t\t * Use it to get a single instance by the identity keys of the Map type.\n\t\t *\n\t\t * ```js\n\t\t * // import connection plugins\n\t\t * var canMap = require(\"can-connect/can/map/map\");\n\t\t * var constructor = require(\"can-connect/constructor/constructor\");\n\t\t * var dataUrl = require(\"can-connect/data/url/url\");\n\t\t *\n\t\t * // define connection type\n\t\t * var Todo = DefineMap.extend({\n\t\t *   id: \"number\",\n\t\t *   complete: \"boolean\",\n\t\t *   name: \"string\"\n\t\t * });\n\t\t *\n\t\t * // create connection\n\t\t * connect([canMap, constructor, dataUrl],{\n\t\t *   Map: Todo,\n\t\t *   url: \"/todos\"\n\t\t * })\n\t\t *\n\t\t * // retrieve instance\n\t\t * Todo.get({id: 5}).then(function(todo){\n\t\t *   ...\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * @param {Object} params Identifying parameters of the instance to retrieve. Typically, this is an object\n\t\t * with the identity property and its value like: `{_id: 5}`.\n\t\t * @return {Promise<Map>} `Promise` returning the [can-connect/can/map/map._Map] instance being retrieved\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Get a single record by filtering non-identity keys\n\t\t *\n\t\t * Sometimes, you want a single record, but by filtering non-identity keys.  Instead of using\n\t\t * `.get`, use `.getList` like:\n\t\t *\n\t\t * ```js\n\t\t * var firstCompleteTodo = Todo.getList({\n\t\t *   filter: {complete: false},\n\t\t *   page: {start: 0, end: 0}\n\t\t * }).then(function(list){\n\t\t *   return list.length ? list[0] : Promise.reject({message: \"reject message\"});\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t */\n\t\tget: function (base, connection) {\n\t\t\treturn function(params) {\n\t\t\t\t// adds .then for compat\n\t\t\t\treturn connection.get(params);\n\t\t\t};\n\t\t},\n\t\t/**\n\t\t * @function can-connect/can/map/map.findOne findOne\n\t\t * @parent can-connect/can/map/map.map-static\n\t\t * @hide\n\t\t *\n\t\t * Alias of [can-connect/can/map/map.get]. You should use `.get()`.\n\t\t */\n\t\tfindOne: function (base, connection) {\n\t\t\treturn function(params) {\n\t\t\t\t// adds .then for compat\n\t\t\t\treturn connection.get(params);\n\t\t\t};\n\t\t}\n\t},\n\tprototype: {\n\t\tisNew: function (base, connection) {\n\t\t\t/**\n\t\t\t * @function can-connect/can/map/map.prototype.isNew isNew\n\t\t\t * @parent can-connect/can/map/map.map\n\t\t\t *\n\t\t\t * If the data is not in the dat\n\t\t\t *\n\t\t\t * @signature `instance.isNew()`\n\t\t\t *\n\t\t\t * Returns if the instance has not been loaded from or saved to the data source.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * connect([...],{\n\t\t\t *   Map: Todo\n\t\t\t * });\n\t\t\t *\n\t\t\t * var todo = new Todo();\n\t\t\t * todo.isNew()   //-> true\n\t\t\t *\n\t\t\t * todo.save().then(function(){\n\t\t\t *   todo.isNew() //-> false\n\t\t\t * })\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @return {Boolean} Returns `true` if [can-connect/base/base.id] is `null` or `undefined`.\n\t\t\t */\n\t\t\treturn function () {\n\t\t\t\treturn connection.isNew(this);\n\t\t\t}\n\t\t},\n\n\t\tisSaving: function (base, connection) {\n\t\t\t/**\n\t\t\t * @function can-connect/can/map/map.prototype.isSaving isSaving\n\t\t\t * @parent can-connect/can/map/map.map\n\t\t\t *\n\t\t\t * Returns if the instance is currently being saved.\n\t\t\t *\n\t\t\t * @signature `instance.isSaving()`\n\t\t\t *\n\t\t\t * Observes if a promise returned by [can-connect/connection.save `connection.save`] is in progress for this\n\t\t\t * instance.  This is often used in a template like:\n\t\t\t *\n\t\t\t * ```html\n\t\t\t * <button on:click=\"todo.save()\"\n\t\t\t *    disabled:from=\"todo.isSaving()\">\n\t\t\t *   Save Changes\n\t\t\t * </button>\n\t\t\t * ```\n\t\t\t *\n\t\t\t *   @return {Boolean} Returns `true` if [can-connect/connection.save `connection.save`] has been called for this\n\t\t\t *   instance but the returned promise has not yet resolved.\n\t\t\t */\n\t\t\treturn function () {\n\t\t\t\treturn !!canReflect.getKeyValue(this,\"_saving\");\n\t\t\t};\n\t\t},\n\n\t\tisDestroying: function (base, connection) {\n\t\t\t/**\n\t\t\t * @function can-connect/can/map/map.prototype.isDestroying isDestroying\n\t\t\t * @parent can-connect/can/map/map.map\n\t\t\t *\n\t\t\t * Returns if the instance is currently being destroyed.\n\t\t\t *\n\t\t\t * @signature `instance.isDestroying()`\n\t\t\t *\n\t\t\t * Observes if a promise returned by [can-connect/connection.destroy `connection.destroy`] is in progress for this\n\t\t\t * instance.  This is often used in a template like:\n\t\t\t *\n\t\t\t * ```html\n\t\t\t * <button on:click=\"todo.destroy()\"\n\t\t\t *         disabled:from=\"todo.isDestroying()\">\n\t\t\t *   Delete\n\t\t\t * </button>\n\t\t\t * ```\n\t\t\t *\n\t\t\t *   @return {Boolean} `true` if [can-connect/connection.destroy `connection.destroy`] has been called for this\n\t\t\t *   instance but the returned promise has not resolved.\n\t\t\t */\n\t\t\treturn function () {\n\t\t\t\treturn !!canReflect.getKeyValue(this,\"_destroying\");\n\t\t\t};\n\t\t},\n\n\t\tsave: function (base, connection) {\n\t\t\t/**\n\t\t\t * @function can-connect/can/map/map.prototype.save save\n\t\t\t * @parent can-connect/can/map/map.map\n\t\t\t *\n\t\t\t * Save or update client data to the persisted data source.\n\t\t\t *\n\t\t\t * @signature `instance.save(success, error)`\n\t\t\t *\n\t\t\t * Calls [can-connect/connection.save].\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * // import connection plugins\n\t\t\t * var canMap = require(\"can-connect/can/map/map\");\n\t\t\t * var constructor = require(\"can-connect/constructor/constructor\");\n\t\t\t * var dataUrl = require(\"can-connect/data/url/url\");\n\t\t\t *\n\t\t\t * // define connection types\n\t\t\t * var Todo = DefineMap.extend({\n\t\t\t *   id: \"number\",\n\t\t\t *   complete: \"boolean\",\n\t\t\t *   name: \"string\"\n\t\t\t * });\n\t\t\t *\n\t\t\t * // create connection\n\t\t\t * connect([canMap, constructor, dataUrl], {\n\t\t\t *   Map: Todo,\n\t\t\t *   url: \"/todos\"\n\t\t\t * })\n\t\t\t *\n\t\t\t * new Todo({name: \"dishes\"}).save();\n\t\t\t * ```\n\t\t\t *\n\t\t\t *   @param {function} success A function that is called if the save is successful.\n\t\t\t *   @param {function} error A function that is called if the save is rejected.\n\t\t\t *   @return {Promise<Instance>} A promise that resolves to the instance if successful.\n\t\t\t *\n\t\t\t *\n\t\t\t */\n\t\t\treturn function(success, error){\n\t\t\t\t// return only one item for compatability\n\t\t\t\tvar promise = connection.save(this);\n\t\t\t\tpromise.then(success,error);\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t},\n\t\tdestroy: function (base, connection) {\n\t\t\t/**\n\t\t\t * @function can-connect/can/map/map.prototype.destroy destroy\n\t\t\t * @parent can-connect/can/map/map.map\n\t\t\t *\n\t\t\t * Delete an instance from the service via the connection.\n\t\t\t *\n\t\t\t * @signature `instance.destroy(success, error)`\n\t\t\t *\n\t\t\t * Calls [can-connect/connection.destroy] for the `instance`.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * // import connection plugins\n\t\t\t * var canMap = require(\"can-connect/can/map/map\");\n\t\t\t * var constructor = require(\"can-connect/constructor/constructor\");\n\t\t\t * var dataUrl = require(\"can-connect/data/url/url\");\n\t\t\t *\n\t\t\t * // define connection types\n\t\t\t * var Todo = DefineMap.extend({\n\t\t\t *   id: \"number\",\n\t\t\t *   complete: \"boolean\",\n\t\t\t *   name: \"string\"\n\t\t\t * });\n\t\t\t *\n\t\t\t * // create connection\n\t\t\t * connect([canMap, constructor, dataUrl],{\n\t\t\t *   Map: Todo,\n\t\t\t *   url: \"/todos\"\n\t\t\t * })\n\t\t\t *\n\t\t\t * // read instance\n\t\t\t * Todo.get({id: 5}).then(function(todo){\n\t\t\t *   if (todo.complete) {\n\t\t\t *     // delete instance\n\t\t\t *     todo.destroy();\n\t\t\t *   }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @param {function} success a function that is called if the [can-connect/connection.destroy] call is successful.\n\t\t\t * @param {function} error a function that is called if the [can-connect/connection.destroy] call is rejected.\n\t\t\t * @return {Promise<Instance>} a promise that resolves to the instance if successful\n\t\t\t *\n\t\t\t *\n\t\t\t */\n\t\t\treturn function(success, error){\n\t\t\t\tvar promise;\n\t\t\t\tif (this.isNew()) {\n\n\t\t\t\t\tpromise = Promise.resolve(this);\n\t\t\t\t\tconnection.destroyedInstance(this, {});\n\t\t\t\t} else {\n\t\t\t\t\tpromise = connection.destroy(this);\n\t\t\t\t}\n\n\t\t\t\tpromise.then(success,error);\n\t\t\t\treturn promise;\n\t\t\t};\n\t\t}\n\t},\n\tproperties: {\n\t\t_saving: {enumerable: false, value: false, configurable: true, writable: true},\n\t\t_destroying: {enumerable: false, value: false, configurable: true, writable: true}\n\t}\n};\n\nvar listOverwrites = {\n\tstatic:  {\n\t\t_bubbleRule: function(base, connection) {\n\t\t\treturn function(eventName, list) {\n\t\t\t\tvar bubbleRules = base(eventName, list);\n\t\t\t\tbubbleRules.push('destroyed');\n\t\t\t\treturn bubbleRules;\n\t\t\t};\n\t\t}\n\t},\n\tprototype: {\n\t\tsetup: function(base, connection){\n\t\t\treturn function (params) {\n\t\t\t\t// If there was a plain object passed to the List constructor,\n\t\t\t\t// we use those as parameters for an initial getList.\n\t\t\t\tif (isPlainObject(params) && !Array.isArray(params)) {\n\t\t\t\t\tthis[connection.listQueryProp] = params;\n\t\t\t\t\tbase.apply(this);\n\t\t\t\t\tthis.replace(canReflect.isPromise(params) ? params : connection.getList(params));\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, set up the list like normal.\n\t\t\t\t\tbase.apply(this, arguments);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\tproperties: {}\n};\n\nvar overwrite = function( connection, Constructor, overwrites) {\n\tvar prop;\n\tfor(prop in overwrites.properties) {\n\t\tcanReflect.defineInstanceKey(Constructor, prop, overwrites.properties[prop]);\n\t}\n\tfor(prop in overwrites.prototype) {\n\t\tConstructor.prototype[prop] = overwrites.prototype[prop](Constructor.prototype[prop], connection);\n\t}\n\tif(overwrites.static) {\n\t\tfor(prop in overwrites.static) {\n\t\t\tConstructor[prop] = overwrites.static[prop](Constructor[prop], connection);\n\t\t}\n\t}\n};\n\nmodule.exports = canMapBehavior;\n\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\tvar validate = require(\"../../helpers/validate\");\n\n\tmodule.exports = validate(\n\t\tcanMapBehavior,\n\t\t[\n\t\t\t'id', 'get', 'updatedList', 'destroy', 'save', 'getList'\n\t\t]\n\t);\n}\n//!steal-remove-end\n"],"names":["extendingBehavior","interfaces","validatedBehaviour","validateArgumentInterface","errors","baseBehavior","BehaviorInterfaceError","Object","keys","forEach","k","__interfaces","func","argIndex","errorHandler","makeInterfaceValidator","arguments","apply","this","missingProps","message","behaviorName","__behaviorName","JSON","stringify","related","instance","Error","setPrototypeOf","getPrototypeOf","prototype","create","constructor","value","__proto__","assign","require$$0","assignMap","WeakReferenceMap","set","has","key","addReference","item","referenceCount","data","deleteReference","get","cb","id","obj","schema","canReflect","getSchema","identity","getKeyValue","undefined","setKeyValue","updateDeep","list","update","make","diffList","a","b","patch","splice","index","deleteCount","insert","map","makeArray","toArray","behavior","baseConnection","cidStore","_cid","params","self","getData","then","hydrateInstance","getList","getListData","hydrateList","listData","Array","isArray","arr","i","length","push","slice","listQueryProp","copyMetadata","props","save","serialized","serializeInstance","cid","createData","createdInstance","updateData","updatedInstance","destroy","destroyData","destroyedInstance","updateDeepExceptIdentity","queryLogic","updatedList","instanceList","idMerge","bind","serializeList","isNew","prop","attr","each","parseListData","responseData","result","parseListProp","getObject","parseInstanceData","parseInstanceProp","pairs","parseFunction","name","call","isArrayLike","type","namespace","canSymbol","iterator","for","hasOwnProperty","elements","callback","context","len","isIterable","res","iter","next","done","methodMapping","GET","PUT","DELETE","POST","inferIdProp","url","matches","match","getItemAndListUrls","idProp","itemRegex","RegExp","rootIsItemUrl","test","listUrl","replace","trim","interfaceMethod","method","isPromise","Promise","resolve","reject","defaultRest","makeRest","urlBehavior","eachKey","defaultData","dataInterfaceName","meta","methodMetaData","makePromise","promise","makeAjax","ajax","findContentType","resource","idProps","resourceWithoutTrailingSlashes","includeData","contentType","process","env","NODE_ENV","dev","warn","urlParamEncoder","encodeURIComponent","ajaxOb","reqOptions","parts","split","pop","replaceWith","dataType","module","validate","assignDeep","isPlainObject","getNameSymbol","canMapBehavior","init","Map","getName","List","overwrite","mapOverwrites","listOverwrites","QueryLogic","connection","canConnectMap_onMapBoundChange","isBound","defineProperty","configurable","console","canConnectMap_onListBoundChange","patches","addInstanceReference","serialize","_Map","val","queues","batch","start","enqueueOptions","reasonLog","mutateQueue","enqueue","stop","base","funcName","size","removeAttr","updateInstanceWithAssignDeep","assignDeepExceptIdentity","dest","source","smartMerge","smartMergeExceptIdentity","moveCreatedInstanceToInstanceStore","callbackInstanceEvents","eventQueue","dispatch","target","log","shortName","static","findAll","findOne","isSaving","isDestroying","success","error","properties","_saving","enumerable","writable","_destroying","_bubbleRule","eventName","bubbleRules","setup","Constructor","overwrites","defineInstanceKey"],"mappings":"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"}