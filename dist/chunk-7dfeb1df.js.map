{"version":3,"file":"chunk-7dfeb1df.js","sources":["../node_modules/can-observation/recorder-dependency-helpers.js","../node_modules/can-observation/temporarily-bind.js","../node_modules/can-observation/can-observation.js"],"sourcesContent":["\"use strict\";\n// # Recorder Dependency Helpers\n// This exposes two helpers:\n// - `updateObservations` - binds and unbinds a diff of two observation records\n//   (see can-observation-recorder for details on this data type).\n// - `stopObserving` - unbinds an observation record.\nvar canReflect = require(\"can-reflect\");\n\n\n\n// ## Helpers\n// The following helpers all use `this` to pass additional arguments. This\n// is for performance reasons as it avoids creating new functions.\n\nfunction addNewKeyDependenciesIfNotInOld(event) {\n    // Expects `this` to have:\n    // - `.observable` - the observable we might be binding to.\n    // - `.oldEventSet` - the bound keys on the old dependency record for `observable`.\n    // - `.onDependencyChange` - the handler we will call back when the key is changed.\n    // If there wasn't any keys, or when we tried to delete we couldn't because the key\n    // wasn't in the set, start binding.\n    if(this.oldEventSet === undefined || this.oldEventSet[\"delete\"](event) === false) {\n        canReflect.onKeyValue(this.observable, event, this.onDependencyChange,\"notify\");\n    }\n}\n\n// ### addObservablesNewKeyDependenciesIfNotInOld\n// For each event in the `eventSet` of new observables,\n// setup a binding (or delete the key).\nfunction addObservablesNewKeyDependenciesIfNotInOld(eventSet, observable){\n    eventSet.forEach(addNewKeyDependenciesIfNotInOld, {\n        onDependencyChange: this.onDependencyChange,\n        observable: observable,\n        oldEventSet: this.oldDependencies.keyDependencies.get(observable)\n    });\n}\n\nfunction removeKeyDependencies(event) {\n    canReflect.offKeyValue(this.observable, event, this.onDependencyChange,\"notify\");\n}\n\nfunction removeObservablesKeyDependencies(oldEventSet, observable){\n    oldEventSet.forEach(removeKeyDependencies, {onDependencyChange: this.onDependencyChange, observable: observable});\n}\n\nfunction addValueDependencies(observable) {\n    // If we were unable to delete the key in the old set, setup a binding.\n    if(this.oldDependencies.valueDependencies.delete(observable) === false) {\n        canReflect.onValue(observable, this.onDependencyChange,\"notify\");\n    }\n}\nfunction removeValueDependencies(observable) {\n    canReflect.offValue(observable, this.onDependencyChange,\"notify\");\n}\n\n\nmodule.exports = {\n    // ## updateObservations\n    //\n    // Binds `observationData.onDependencyChange` to dependencies in `observationData.newDependencies` that are not currently in\n    // `observationData.oldDependencies`.  Anything in `observationData.oldDependencies`\n    // left over is unbound.\n    //\n    // The algorthim works by:\n    // 1. Loop through the `new` dependencies, checking if an equivalent is in the `old` bindings.\n    //    - If there is an equivalent binding, delete that dependency from `old`.\n    //    - If there is __not__ an equivalent binding, setup a binding from that dependency to `.onDependencyChange`.\n    // 2. Loop through the remaining `old` dependencies, teardown bindings.\n    //\n    // For performance, this method mutates the values in `.oldDependencies`.\n    updateObservations: function(observationData){\n        observationData.newDependencies.keyDependencies.forEach(addObservablesNewKeyDependenciesIfNotInOld, observationData);\n        observationData.oldDependencies.keyDependencies.forEach(removeObservablesKeyDependencies, observationData);\n        observationData.newDependencies.valueDependencies.forEach(addValueDependencies, observationData);\n        observationData.oldDependencies.valueDependencies.forEach(removeValueDependencies, observationData);\n    },\n    stopObserving: function(observationReciever, onDependencyChange){\n        observationReciever.keyDependencies.forEach(removeObservablesKeyDependencies, {onDependencyChange: onDependencyChange});\n        observationReciever.valueDependencies.forEach(removeValueDependencies, {onDependencyChange: onDependencyChange});\n    }\n};\n","\"use strict\";\nvar canReflect = require(\"can-reflect\");\n\nvar temporarilyBoundNoOperation = function(){};\n// A list of temporarily bound computes\nvar observables;\n// Unbinds all temporarily bound computes.\nvar unbindTemporarilyBoundValue = function () {\n\tfor (var i = 0, len = observables.length; i < len; i++) {\n\t\tcanReflect.offValue(observables[i], temporarilyBoundNoOperation);\n\t}\n\tobservables = null;\n};\n\n// ### temporarilyBind\n// Binds computes for a moment to cache their value and prevent re-calculating it.\nfunction temporarilyBind(compute) {\n\tvar computeInstance = compute.computeInstance || compute;\n\tcanReflect.onValue(computeInstance, temporarilyBoundNoOperation);\n\tif (!observables) {\n\t\tobservables = [];\n\t\tsetTimeout(unbindTemporarilyBoundValue, 10);\n\t}\n\tobservables.push(computeInstance);\n}\n\nmodule.exports = temporarilyBind;\n","\"use strict\";\n/* global require */\n// # can-observation\nvar namespace = require('can-namespace');\nvar canReflect = require('can-reflect');\nvar queues = require(\"can-queues\");\nvar ObservationRecorder = require(\"can-observation-recorder\");\n\nvar canSymbol = require(\"can-symbol\");\nvar dev = require(\"can-log/dev/dev\");\nvar valueEventBindings = require(\"can-event-queue/value/value\");\n\nvar recorderHelpers = require(\"./recorder-dependency-helpers\");\nvar temporarilyBind = require(\"./temporarily-bind\");\n\nvar dispatchSymbol = canSymbol.for(\"can.dispatch\");\nvar getChangesSymbol = canSymbol.for(\"can.getChangesDependencyRecord\");\nvar getValueDependenciesSymbol = canSymbol.for(\"can.getValueDependencies\");\n\n// ## Observation constructor\nfunction Observation(func, context, options){\n\tthis.func = func;\n\tthis.context = context;\n\tthis.options = options || {priority: 0, isObservable: true};\n\t// A flag if we are bound or not\n\tthis.bound = false;\n\n\t// Set _value to undefined so can-view-scope & can-compute can check for it\n\tthis._value = undefined;\n\n\t// These properties will manage what our new and old dependencies are.\n\tthis.newDependencies = ObservationRecorder.makeDependenciesRecord();\n\tthis.oldDependencies = null;\n\n\t// Make functions we need to pass around and maintain `this`.\n\tvar self = this;\n\tthis.onDependencyChange = function(newVal){\n\t\tself.dependencyChange(this, newVal);\n\t};\n\tthis.update = this.update.bind(this);\n\n\n\t// Add debugging names.\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tthis.onDependencyChange[getChangesSymbol] = function getChanges() {\n\t\t\tvar s = new Set();\n\t\t\ts.add(self);\n\t\t\treturn {\n\t\t\t\tvalueDependencies: s\n\t\t\t};\n\t\t};\n\t\tObject.defineProperty(this.onDependencyChange, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".onDependencyChange\",\n\t\t});\n\t\tObject.defineProperty(this.update, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".update\",\n\t\t});\n\t}\n\t//!steal-remove-end\n}\n\n// ## Observation prototype methods\n\n// Mixin value event bindings. This is where the following are added:\n// - `.handlers` which call `onBound` and `onUnbound`\n// - `.on` / `.off`\n// - `can.onValue` `can.offValue`\n// - `can.getWhatIChange`\nvalueEventBindings(Observation.prototype);\n\ncanReflect.assign(Observation.prototype, {\n\t// Starts observing changes and adds event listeners.\n\tonBound: function(){\n\t\tthis.bound = true;\n\n\t\t// Store the old dependencies\n\t\tthis.oldDependencies = this.newDependencies;\n\t\t// Start recording dependencies.\n\t\tObservationRecorder.start();\n\t\t// Call the observation's function and update the new value.\n\t\tthis._value = this.func.call(this.context);\n\t\t// Get the new dependencies.\n\t\tthis.newDependencies = ObservationRecorder.stop();\n\n\t\t// Diff and update the bindings. On change, everything will call\n\t\t// `this.onDependencyChange`, which calls `this.dependencyChange`.\n\t\trecorderHelpers.updateObservations(this);\n\t},\n\t// This is called when any of the dependencies change.\n\t// It queues up an update in the `deriveQueue` to be run after all source\n\t// observables have had time to notify all observables that \"derive\" their value.\n\tdependencyChange: function(context, args){\n\t\tif(this.bound === true) {\n\t\t\tvar queuesArgs = [];\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.update,\n\t\t\t\tthis,\n\t\t\t\t[],\n\t\t\t\t{\n\t\t\t\t\tpriority: this.options.priority\n\t\t\t\t}\n\t\t\t];\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tqueuesArgs = [\n\t\t\t\t\tthis.update,\n\t\t\t\t\tthis,\n\t\t\t\t\t[],\n\t\t\t\t\t{\n\t\t\t\t\t\tpriority: this.options.priority\n\t\t\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t\t\t, log: [ canReflect.getName(this.update) ]\n\t\t\t\t\t\t/* jshint laxcomma: false */\n\t\t\t\t\t}\n\t\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t\t, [canReflect.getName(context), \"changed\"]\n\t\t\t\t\t/* jshint laxcomma: false */\n\t\t\t\t];\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\t// Update this observation after all `notify` tasks have been run.\n\t\t\tqueues.deriveQueue.enqueue.apply(queues.deriveQueue, queuesArgs);\n\t\t}\n\t},\n\t// Called to update its value as part of the `derive` queue.\n\tupdate: function() {\n\t\tif (this.bound === true) {\n\t\t\t// Keep the old value.\n\t\t\tvar oldValue = this._value;\n\t\t\tthis.oldValue = null;\n\t\t\t// Re-run `this.func` and update dependency bindings.\n\t\t\tthis.onBound();\n\t\t\t// If our value changed, call the `dispatch` method provided by `can-event-queue/value/value`.\n\t\t\tif (oldValue !== this._value) {\n\t\t\t\tthis[dispatchSymbol](this._value, oldValue);\n\t\t\t}\n\t\t}\n\t},\n\t// Called when nothing is bound to this observation.\n\t// Removes all event listeners on all dependency observables.\n\tonUnbound: function(){\n\t\tthis.bound = false;\n\t\trecorderHelpers.stopObserving(this.newDependencies, this.onDependencyChange);\n\t\t// Setup newDependencies in case someone binds again to this observable.\n\t\tthis.newDependencies = ObservationRecorder.makeDependenciesRecorder();\n\t},\n\t// Reads the value of the observation.\n\tget: function(){\n\n\t\t// If an external observation is tracking observables and\n\t\t// this compute can be listened to by \"function\" based computes ....\n\t\tif( this.options.isObservable && ObservationRecorder.isRecording() ) {\n\n\t\t\t// ... tell the tracking compute to listen to change on this observation.\n\t\t\tObservationRecorder.add(this);\n\t\t\t// ... if we are not bound, we should bind so that\n\t\t\t// we don't have to re-read to get the value of this observation.\n\t\t\tif (!this.bound) {\n\t\t\t\tObservation.temporarilyBind(this);\n\t\t\t}\n\n\t\t}\n\n\n\t\tif(this.bound === true ) {\n\t\t\t// It's possible that a child dependency of this observable might be queued\n\t\t\t// to change. Check all child dependencies and make sure they are up-to-date by\n\t\t\t// possibly running what they have registered in the derive queue.\n\t\t\tif(queues.deriveQueue.tasksRemainingCount() > 0) {\n\t\t\t\tObservation.updateChildrenAndSelf(this);\n\t\t\t}\n\n\t\t\treturn this._value;\n\t\t} else {\n\t\t\t// If we are not bound, just call the function.\n\t\t\treturn this.func.call(this.context);\n\t\t}\n\t},\n\n\thasDependencies: function(){\n\t\tvar newDependencies = this.newDependencies;\n\t\treturn this.bound ?\n\t\t\t(newDependencies.valueDependencies.size + newDependencies.keyDependencies.size) > 0  :\n\t\t\tundefined;\n\t},\n\t/**\n\t * @function can-observation.prototype.log log\n\t * @parent can-observation.prototype prototype\n\t *\n\t * @signature `observation.log()`\n\t *\n\t * Turns on logging of changes to the browser console.\n\t */\n\tlog: function() {\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tvar quoteString = function quoteString(x) {\n\t\t\t\treturn typeof x === \"string\" ? JSON.stringify(x) : x;\n\t\t\t};\n\t\t\tthis._log = function(previous, current) {\n\t\t\t\tdev.log(\n\t\t\t\t\tcanReflect.getName(this),\n\t\t\t\t\t\"\\n is  \", quoteString(current),\n\t\t\t\t\t\"\\n was \", quoteString(previous)\n\t\t\t\t);\n\t\t\t};\n\t\t}\n\t\t//!steal-remove-end\n\t}\n});\n\nObject.defineProperty(Observation.prototype, \"value\", {\n\tget: function() {\n\t\treturn this.get();\n\t}\n});\n\nvar observationProto = {\n\t\"can.getValue\": Observation.prototype.get,\n\t\"can.isValueLike\": true,\n\t\"can.isMapLike\": false,\n\t\"can.isListLike\": false,\n\t\"can.valueHasDependencies\": Observation.prototype.hasDependencies,\n\t\"can.getValueDependencies\": function(){\n\t\tif (this.bound === true) {\n\t\t\t// Only provide `keyDependencies` and `valueDependencies` properties\n\t\t\t// if there's actually something there.\n\t\t\tvar deps = this.newDependencies,\n\t\t\t\tresult = {};\n\n\t\t\tif (deps.keyDependencies.size) {\n\t\t\t\tresult.keyDependencies = deps.keyDependencies;\n\t\t\t}\n\n\t\t\tif (deps.valueDependencies.size) {\n\t\t\t\tresult.valueDependencies = deps.valueDependencies;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\treturn undefined;\n\t},\n\t\"can.getPriority\": function(){\n\t\treturn this.options.priority;\n\t},\n\t\"can.setPriority\": function(priority){\n\t\tthis.options.priority = priority;\n\t}\n};\n\n//!steal-remove-start\nif (process.env.NODE_ENV !== 'production') {\n\tobservationProto[\"can.getName\"] = function() {\n\t\treturn canReflect.getName(this.constructor) + \"<\" + canReflect.getName(this.func) + \">\";\n\t};\n}\n//!steal-remove-end\ncanReflect.assignSymbols(Observation.prototype, observationProto);\n\n// ## Observation.updateChildrenAndSelf\n// This recursively checks if an observation's dependencies might be in the `derive` queue.\n// If it is, we need to update that value so the reading of this value will be correct.\n// This can happen if an observation suddenly switches to depending on something that has higher\n// priority than itself.  We need to make sure that value is completely updated.\nObservation.updateChildrenAndSelf = function(observation){\n\t// If the observable has an `update` method and it's enqueued, flush that task immediately so\n\t// the value is right.\n\t// > NOTE: This only works for `Observation` right now.  We need a way of knowing how\n\t// > to find what an observable might have in the `deriveQueue`.\n\tif(observation.update !== undefined && queues.deriveQueue.isEnqueued( observation.update ) === true) {\n\t\t// TODO: In the future, we should be able to send log information\n\t\t// to explain why this needed to be updated.\n\t\tqueues.deriveQueue.flushQueuedTask(observation.update);\n\t\treturn true;\n\t}\n\n\t// If we can get dependency values from this observable ...\n\tif(observation[getValueDependenciesSymbol]) {\n\t\t// ... Loop through each dependency and see if any of them (or their children) needed an update.\n\t\tvar childHasChanged = false;\n\t\tvar valueDependencies = observation[getValueDependenciesSymbol]().valueDependencies || [];\n\t\tvalueDependencies.forEach(function(observable){\n\t\t\tif( Observation.updateChildrenAndSelf( observable ) === true) {\n\t\t\t\tchildHasChanged = true;\n\t\t\t}\n\t\t});\n\t\treturn childHasChanged;\n\t} else {\n\t\treturn false;\n\t}\n};\n\n// ## Legacy Stuff\n// Warn when `ObservationRecorder` methods are called on `Observation`.\nvar alias = {addAll: \"addMany\"};\n[\"add\",\"addAll\",\"ignore\",\"trap\",\"trapsCount\",\"isRecording\"].forEach(function(methodName){\n\tObservation[methodName] = function(){\n\t\tvar name = alias[methodName] ? alias[methodName] : methodName;\n\t\tconsole.warn(\"can-observation: Call \"+name+\"() on can-observation-recorder.\");\n\t\treturn ObservationRecorder[name].apply(this, arguments);\n\t};\n});\nObservation.prototype.start = function(){\n\tconsole.warn(\"can-observation: Use .on and .off to bind.\");\n\treturn this.onBound();\n};\nObservation.prototype.stop = function(){\n\tconsole.warn(\"can-observation: Use .on and .off to bind.\");\n\treturn this.onUnbound();\n};\n\n// ### temporarilyBind\n// Will bind an observable value temporarily.  This should be part of queues probably.\nObservation.temporarilyBind = temporarilyBind;\n\n\nmodule.exports = namespace.Observation = Observation;\n"],"names":["addNewKeyDependenciesIfNotInOld","event","undefined","this","oldEventSet","canReflect","onKeyValue","observable","onDependencyChange","addObservablesNewKeyDependenciesIfNotInOld","eventSet","forEach","oldDependencies","keyDependencies","get","removeKeyDependencies","offKeyValue","removeObservablesKeyDependencies","addValueDependencies","valueDependencies","delete","onValue","removeValueDependencies","offValue","observables","updateObservations","observationData","newDependencies","stopObserving","observationReciever","temporarilyBoundNoOperation","unbindTemporarilyBoundValue","i","len","length","temporarilyBind","compute","computeInstance","setTimeout","push","dispatchSymbol","canSymbol","for","getChangesSymbol","getValueDependenciesSymbol","Observation","func","context","options","priority","isObservable","bound","_value","ObservationRecorder","makeDependenciesRecord","self","newVal","dependencyChange","update","bind","process","env","NODE_ENV","s","Set","add","Object","defineProperty","value","getName","valueEventBindings","prototype","assign","onBound","start","call","stop","recorderHelpers","args","queuesArgs","log","queues","deriveQueue","enqueue","apply","oldValue","onUnbound","makeDependenciesRecorder","isRecording","tasksRemainingCount","updateChildrenAndSelf","hasDependencies","size","quoteString","x","JSON","stringify","_log","previous","current","dev","observationProto","can.getValue","can.isValueLike","can.isMapLike","can.isListLike","can.valueHasDependencies","can.getValueDependencies","deps","result","can.getPriority","can.setPriority","constructor","assignSymbols","observation","isEnqueued","flushQueuedTask","childHasChanged","alias","addAll","methodName","name","console","warn","arguments","namespace"],"mappings":"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"}