{"version":3,"file":"chunk-2fc7c20b.js","sources":["../node_modules/can-simple-observable/make-compute/make-compute.js","../node_modules/can-route/src/string-coercion.js","../node_modules/can-route/src/routedata.js","../node_modules/can-route/src/binding-proxy.js","../node_modules/can-route/src/regexps.js","../node_modules/can-route/src/register.js","../node_modules/can-route/src/deparam.js","../node_modules/can-route/src/param.js","../node_modules/can-route/src/url-helpers.js","../node_modules/can-globals/is-web-worker/is-web-worker.js","../node_modules/can-route/can-route.js"],"sourcesContent":["\"use strict\";\nvar canReflect = require(\"can-reflect\");\n\nvar Compute = function(newVal) {\n\tif (arguments.length) {\n\t\treturn canReflect.setValue(this, newVal);\n\t} else {\n\t\treturn canReflect.getValue(this);\n\t}\n};\n\nvar translationHelpers = new WeakMap();\n\nmodule.exports = function(observable) {\n\tvar compute = Compute.bind(observable);\n\tcompute.on = compute.bind = compute.addEventListener = function(\n\t\tevent,\n\t\thandler\n\t) {\n\t\tvar translationHandler = translationHelpers.get(handler);\n\t\tif (!translationHandler) {\n\t\t\ttranslationHandler = function(newVal, oldVal) {\n\t\t\t\thandler.call(compute, { type: \"change\" }, newVal, oldVal);\n\t\t\t};\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tObject.defineProperty(translationHandler, \"name\", {\n\t\t\t\t\tvalue:\n\t\t\t\t\t\t\"translationHandler(\" +\n\t\t\t\t\t\tevent +\n\t\t\t\t\t\t\")::\" +\n\t\t\t\t\t\tcanReflect.getName(observable) +\n\t\t\t\t\t\t\".onValue(\" +\n\t\t\t\t\t\tcanReflect.getName(handler) +\n\t\t\t\t\t\t\")\"\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\ttranslationHelpers.set(handler, translationHandler);\n\t\t}\n\t\tcanReflect.onValue(observable, translationHandler);\n\t};\n\tcompute.off = compute.unbind = compute.removeEventListener = function(\n\t\tevent,\n\t\thandler\n\t) {\n\t\tcanReflect.offValue(observable, translationHelpers.get(handler));\n\t};\n\n\tcanReflect.assignSymbols(compute, {\n\t\t\"can.getValue\": function() {\n\t\t\treturn canReflect.getValue(observable);\n\t\t},\n\t\t\"can.setValue\": function(newVal) {\n\t\t\treturn canReflect.setValue(observable, newVal);\n\t\t},\n\t\t\"can.onValue\": function(handler, queue) {\n\t\t\treturn canReflect.onValue(observable, handler, queue);\n\t\t},\n\t\t\"can.offValue\": function(handler, queue) {\n\t\t\treturn canReflect.offValue(observable, handler, queue);\n\t\t},\n\t\t\"can.valueHasDependencies\": function() {\n\t\t\treturn canReflect.valueHasDependencies(observable);\n\t\t},\n\t\t\"can.getPriority\": function() {\n\t\t\treturn canReflect.getPriority(observable);\n\t\t},\n\t\t\"can.setPriority\": function(newPriority) {\n\t\t\tcanReflect.setPriority(observable, newPriority);\n\t\t},\n\t\t\"can.isValueLike\": true,\n\t\t\"can.isFunctionLike\": false\n\t});\n\tcompute.isComputed = true;\n\treturn compute;\n};\n","var canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\n\n// Helper for convert any object (or value) to stringified object (or value)\nvar stringify = function (obj) {\n\t// Object is array, plain object, Map or List\n\tif (obj && typeof obj === \"object\") {\n\t\tif (obj && typeof obj === \"object\" && (\"serialize\" in obj)) {\n\t\t\tobj = obj.serialize();\n\t\t} else {\n\t\t\t// Get array from array-like or shallow-copy object\n\t\t\tobj = typeof obj.slice === \"function\" ? obj.slice() : canReflect.assign({}, obj);\n\t\t}\n\t\t// Convert each object property or array item into stringified new\n\t\tcanReflect.eachKey(obj, function (val, prop) {\n\t\t\tobj[prop] = stringify(val);\n\t\t});\n\t\t// Object supports toString function\n\t} else if (obj !== undefined && obj !== null && (typeof obj.toString === \"function\" )) {\n\t\tobj = obj.toString();\n\t}\n\n\treturn obj;\n};\n\n// everything in the backing Map is a string\n// add type coercion during Map setter to coerce all values to strings so unexpected conflicts don't happen.\n// https://github.com/canjs/canjs/issues/2206\nvar stringCoercingMapDecorator = function(map) {\n\tvar sym = canSymbol.for(\"can.route.stringCoercingMapDecorator\");\n\tif(!map.attr[sym]) {\n\t\tvar attrSuper = map.attr;\n\n\t\tmap.attr = function(prop, val) {\n\t\t\tvar serializable = typeof prop === \"string\" &&\n\t\t\t\t(this.define === undefined || this.define[prop] === undefined || !!this.define[prop].serialize),\n\t\t\t\targs;\n\n\t\t\tif (serializable) { // if setting non-str non-num attr\n\t\t\t\targs = stringify(Array.apply(null, arguments));\n\t\t\t} else {\n\t\t\t\targs = arguments;\n\t\t\t}\n\n\t\t\treturn attrSuper.apply(this, args);\n\t\t};\n\t\tcanReflect.setKeyValue(map.attr, sym, true);\n\t}\n\n\treturn map;\n};\n\nexports.stringCoercingMapDecorator = stringCoercingMapDecorator;\nexports.stringify = stringify;\n","var DefineMap = require(\"can-define/map/map\");\nvar stringify = require(\"./string-coercion\").stringify;\n\nmodule.exports = DefineMap.extend(\"RouteData\", { seal: false }, {\n\t\"*\": {\n\t\ttype: stringify\n\t}\n});\n","\"use strict\";\nvar canReflect = require('can-reflect');\nvar canSymbol = require(\"can-symbol\");\nvar SimpleObservable = require(\"can-simple-observable\");\n\nvar urlDataObservable = new SimpleObservable(null);\n\ncanReflect.setName(urlDataObservable,\"route.urlData\");\nvar bindingProxy = {\n    defaultBinding: null,\n    urlDataObservable: urlDataObservable,\n    bindings: {},\n    call: function(){\n        var args = canReflect.toArray(arguments),\n            prop = args.shift(),\n            binding = urlDataObservable.value;\n        if(binding === null) {\n            throw new Error(\"there is no current binding!!!\");\n        }\n        var method = binding[prop.indexOf(\"can.\") === 0 ? canSymbol.for(prop) : prop];\n        if (method.apply) {\n            return method.apply(binding, args);\n        } else {\n            return method;\n        }\n    }\n};\nmodule.exports = bindingProxy;\n","\"use strict\";\nmodule.exports = {\n    curlies: /\\{\\s*([\\w.]+)\\s*\\}/g,\n    colon: /\\:([\\w.]+)/g\n};\n","\"use strict\";\n// This file contains the function that allows the registration of routes\nvar canReflect = require(\"can-reflect\");\n\nvar dev = require('can-log/dev/dev');\n\nvar bindingProxy = require(\"./binding-proxy\");\nvar regexps = require(\"./regexps\");\n\nvar diff = require('can-diff/list/list');\nvar diffObject = require('can-diff/map/map');\nvar RouteData = require(\"./routedata\");\n// `RegExp` used to match route variables of the type '{name}'.\n// Any word character or a period is matched.\n\n\n\nvar removeBackslash = function (str) {\n\treturn str.replace(/\\\\/g, \"\");\n};\nvar wrapQuote = function (str) {\n\treturn (str + '')\n\t\t.replace(/([.?*+\\^$\\[\\]\\\\(){}|\\-])/g, \"\\\\$1\");\n};\n\nvar RouteRegistry = {\n    routes:  {},\n    register: function registerRoute(url, defaults) {\n    \t// if route ends with a / and url starts with a /, remove the leading / of the url\n    \tvar root = bindingProxy.call(\"root\");\n\n    \tif (root.lastIndexOf(\"/\") === root.length - 1 &&\n    \t\turl.indexOf(\"/\") === 0) {\n    \t\turl = url.substr(1);\n    \t}\n\n    \tdefaults = defaults || {};\n    \t// Extract the variable names and replace with `RegExp` that will match\n    \t// an atual URL with values.\n    \tvar names = [],\n    \t\tres,\n    \t\ttest = \"\",\n    \t\tmatcher,\n    \t\tlastIndex,\n    \t\tnext,\n    \t\tquerySeparator = bindingProxy.call(\"querySeparator\"),\n    \t\tmatchSlashes = bindingProxy.call(\"matchSlashes\");\n\n    \t// fall back to legacy `:foo` RegExp if necessary\n    \tif (regexps.colon.test(url)) {\n    \t\tmatcher = regexps.colon;\n\n    \t\t//!steal-remove-start\n    \t\tif(process.env.NODE_ENV !== 'production') {\n\t    \t\tdev.warn('update route \"' + url + '\" to \"' + url.replace(regexps.colon, function(name, key) {\n\t    \t\t\treturn '{' + key + '}';\n\t    \t\t}) + '\"');\n    \t\t}\n    \t\t//!steal-remove-end\n    \t} else {\n    \t\tmatcher = regexps.curlies;\n    \t}\n    \tlastIndex = matcher.lastIndex = 0;\n\n    \t// res will be something like [\"{foo}\",\"foo\"]\n    \twhile (res = matcher.exec(url)) {\n    \t\tnames.push(res[1]);\n    \t\ttest += removeBackslash(url.substring(lastIndex, matcher.lastIndex - res[0].length));\n    \t\t// if matchSlashes is false (the default) don't greedily match any slash in the string, assume its part of the URL\n    \t\tnext = \"\\\\\" + (removeBackslash(url.substr(matcher.lastIndex, 1)) || querySeparator+(matchSlashes? \"\": \"|/\"));\n    \t\t// a name without a default value HAS to have a value\n    \t\t// a name that has a default value can be empty\n    \t\t// The `\\\\` is for string-escaping giving single `\\` for `RegExp` escaping.\n    \t\ttest += \"([^\" + next + \"]\" + (defaults[res[1]] ? \"*\" : \"+\") + \")\";\n    \t\tlastIndex = matcher.lastIndex;\n    \t}\n    \ttest += url.substr(lastIndex)\n    \t\t.replace(\"\\\\\", \"\");\n\n    \t//!steal-remove-start\n    \tif(process.env.NODE_ENV !== 'production') {\n\t    \t// warn if new route uses same map properties as an existing route\n\t    \tcanReflect.eachKey(RouteRegistry.routes, function(r) {\n\t    \t\tvar existingKeys = r.names.concat(Object.keys(r.defaults)).sort();\n\t    \t\tvar keys = names.concat(Object.keys(defaults)).sort();\n\t    \t\tvar sameMapKeys = !diff(existingKeys, keys).length;\n\t    \t\tvar sameDefaultValues = !diffObject(r.defaults, defaults).length;\n\t    \t\t//the regex removes the trailing slash\n\t    \t\tvar matchingRoutesWithoutTrailingSlash = r.route.replace(/\\/$/, \"\") === url.replace(/\\/$/, \"\");\n\n\t    \t\tif (sameMapKeys && sameDefaultValues && !matchingRoutesWithoutTrailingSlash) {\n\t    \t\t\tdev.warn('two routes were registered with matching keys:\\n' +\n\t    \t\t\t\t'\\t(1) route.register(\"' + r.route + '\", ' + JSON.stringify(r.defaults) + ')\\n' +\n\t    \t\t\t\t'\\t(2) route.register(\"' + url + '\", ' + JSON.stringify(defaults) + ')\\n' +\n\t    \t\t\t\t'(1) will always be chosen since it was registered first');\n\t    \t\t}\n\t    \t});\n    \t}\n\n\t\t\t// Assign to the instance props\n\t\t\tif(this.data instanceof RouteData) {\n\t\t\t\tvar routeData = this.data;\n\t\t\t\tcanReflect.eachIndex(names, function(name) {\n\t\t\t\t\tvar type = \"string\";\n\t\t\t\t\tvar defaultValue = defaults[name];\n\t\t\t\t\tvar typeOf = typeof defaultValue;\n\n\t\t\t\t\tif(defaultValue != null) {\n\t\t\t\t\t\ttype = typeOf;\n\t\t\t\t\t}\n\n\t\t\t\t\tcanReflect.defineInstanceKey(routeData.constructor, name, {\n\t\t\t\t\t\ttype: type\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n    \t//!steal-remove-end\n    \t// Add route in a form that can be easily figured out.\n    \treturn RouteRegistry.routes[url] = {\n    \t\t// A regular expression that will match the route when variable values\n    \t\t// are present; i.e. for (`{page}/{type}`) the `RegExp` is `/([\\w\\.]*)/([\\w\\.]*)/` which\n    \t\t// will match for any value of `{page}` and `{type}` (word chars or period).\n    \t\ttest: new RegExp(\"^\" + test + \"($|\" + wrapQuote(querySeparator) + \")\"),\n    \t\t// The original URL, same as the index for this entry in routes.\n    \t\troute: url,\n    \t\t// An `array` of all the variable names in this route.\n    \t\tnames: names,\n    \t\t// Default values provided for the variables.\n    \t\tdefaults: defaults,\n    \t\t// The number of parts in the URL separated by `/`.\n    \t\tlength: url.split('/')\n    \t\t\t.length\n    \t};\n    }\n};\n\nmodule.exports = RouteRegistry;\n","\"use strict\";\nvar deparam = require('can-deparam');\nvar canReflect = require(\"can-reflect\");\n\nvar bindingProxy = require(\"./binding-proxy\");\nvar register = require(\"./register\");\n\nvar decode = function(str){\n\ttry {\n\t\treturn decodeURIComponent(str);\n\t} catch(ex) {\n\t\treturn unescape(str);\n\t}\n};\n\n// TODO: I'm not totally sure this belongs here. This might be shifted to can-route-pushstate.\nfunction toURLFragment(url){\n\tvar root =bindingProxy.call(\"root\");\n\t// if the root ends with `/` and the url starts with it, remove /\n    if (root.lastIndexOf(\"/\") === root.length - 1 && url.indexOf(\"/\") === 0) {\n        url = url.substr(1);\n    }\n\treturn url;\n}\n\nfunction canRoute_getRule(url){\n\n\turl = toURLFragment(url);\n    // See if the url matches any routes by testing it against the `route.test` `RegExp`.\n    // By comparing the URL length the most specialized route that matches is used.\n    var route = {\n        length: -1\n    };\n\n    canReflect.eachKey(register.routes, function (temp, name) {\n        if (temp.test.test(url) && temp.length > route.length) {\n            route = temp;\n        }\n    });\n    // If a route was matched.\n    if (route.length > -1) {\n\t\treturn route;\n\t}\n}\n\n/**\n * @function can-route.deparam deparam\n * @parent can-route.static\n * @description Extract data from a route path.\n * @signature `route.deparam(url)`\n *\n * Extract data from a url, creating an object representing its values.\n *\n * ```js\n * route.register(\"{page}\");\n *\n * const result = route.deparam(\"page=home\");\n * console.log(result.page); // -> \"home\"\n * ```\n *\n * @param {String} url A route fragment to extract data from.\n * @return {Object} An object containing the extracted data.\n *\n * @body\n *\n * Creates a data object based on the query string passed into it. This is\n * useful to create an object based on the `location.hash`.\n *\n * ```js\n * route.deparam(\"id=5&type=videos\");\n *   // -> { id: 5, type: \"videos\" }\n * ```\n *\n *\n * It's important to make sure the hash or exclamation point is not passed\n * to `route.deparam` otherwise it will be included in the first property's\n * name.\n *\n * ```js\n * route.data.id = 5 // location.hash -> #!id=5\n * route.data.type = \"videos\"\n *   // location.hash -> #!id=5&type=videos\n * route.deparam(location.hash);\n *   // -> { #!id: 5, type: \"videos\" }\n * ```\n *\n * `route.deparam` will try and find a matching route and, if it does,\n * will deconstruct the URL and parse out the key/value parameters into the\n * data object.\n *\n * ```js\n * route.register(\"{type}/{id}\");\n *\n * route.deparam(\"videos/5\");\n *   // -> { id: 5, route: \"{type}/{id}\", type: \"videos\" }\n * ```\n */\nfunction canRoute_deparam(url) {\n\n    var route = canRoute_getRule(url),\n\t\tquerySeparator =bindingProxy.call(\"querySeparator\"),\n\t\tparamsMatcher =bindingProxy.call(\"paramsMatcher\");\n\n\turl = toURLFragment(url);\n\n\t// If a route was matched.\n    if (route) {\n\n        var // Since `RegExp` backreferences are used in `route.test` (parens)\n        // the parts will contain the full matched string and each variable (back-referenced) value.\n        parts = url.match(route.test),\n            // Start will contain the full matched string; parts contain the variable values.\n            start = parts.shift(),\n            // The remainder will be the `&amp;key=value` list at the end of the URL.\n            remainder = url.substr(start.length - (parts[parts.length - 1] === querySeparator ? 1 : 0)),\n            // If there is a remainder and it contains a `&amp;key=value` list deparam it.\n            obj = (remainder && paramsMatcher.test(remainder)) ? deparam(remainder.slice(1)) : {};\n\n        // Add the default values for this route.\n        obj = canReflect.assignDeep(canReflect.assignDeep({}, route.defaults), obj);\n        // Overwrite each of the default values in `obj` with those in\n        // parts if that part is not empty.\n        parts.forEach(function (part, i) {\n            if (part && part !== querySeparator) {\n                obj[route.names[i]] = decode(part);\n            }\n        });\n        return obj;\n    }\n    // If no route was matched, it is parsed as a `&amp;key=value` list.\n    if (url.charAt(0) !== querySeparator) {\n        url = querySeparator + url;\n    }\n    return paramsMatcher.test(url) ? deparam(url.slice(1)) : {};\n}\n\ncanRoute_deparam.getRule = canRoute_getRule;\n\n\nmodule.exports = canRoute_deparam;\n","\"use strict\";\nvar canReflect = require(\"can-reflect\");\nvar param = require('can-param');\n\nvar register = require(\"./register\");\nvar regexps = require(\"./regexps\");\nvar bindingProxy = require(\"./binding-proxy\");\n\n// Checks if a route matches the data provided. If any route variable\n// is not present in the data, the route does not match. If all route\n// variables are present in the data, the number of matches is returned\n// to allow discerning between general and more specific routes.\nvar matchesData = function (route, data) {\n\tvar count = 0,\n\t\ti = 0,\n\t\tdefaults = {};\n\t// look at default values, if they match ...\n\tfor (var name in route.defaults) {\n\t\tif (route.defaults[name] === data[name]) {\n\t\t\t// mark as matched\n\t\t\tdefaults[name] = 1;\n\t\t\tcount++;\n\t\t}\n\t}\n\tfor (; i < route.names.length; i++) {\n\t\tif (!data.hasOwnProperty(route.names[i])) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!defaults[route.names[i]]) {\n\t\t\tcount++;\n\t\t}\n\n\t}\n\n\treturn count;\n};\n\nfunction getMatchedRoute(data, routeName) {\n\t// Check if the provided data keys match the names in any routes;\n    // Get the one with the most matches.\n    var route,\n        // Need to have at least 1 match.\n        matches = 0,\n        matchCount,\n        propCount = 0;\n\n    delete data.route;\n\n    canReflect.eachKey(data, function () {\n        propCount++;\n    });\n    // Otherwise find route.\n    canReflect.eachKey(register.routes, function (temp, name) {\n        // best route is the first with all defaults matching\n\n        matchCount = matchesData(temp, data);\n        if (matchCount > matches) {\n            route = temp;\n            matches = matchCount;\n        }\n        if (matchCount >= propCount) {\n            return false;\n        }\n    });\n    // If we have a route name in our `register` data, and it's\n    // just as good as what currently matches, use that\n    if (register.routes[routeName] && matchesData(register.routes[routeName], data) === matches) {\n        route = register.routes[routeName];\n    }\n    // If this is match...\n\treturn route;\n}\nfunction paramFromRoute(route, data) {\n\tvar cpy,\n\t\tres,\n\t\tafter,\n\t\tmatcher;\n\tif (route) {\n\n        cpy = canReflect.assignMap({}, data);\n        // fall back to legacy :foo RegExp if necessary\n        matcher = regexps.colon.test(route.route) ? regexps.colon : regexps.curlies;\n        // Create the url by replacing the var names with the provided data.\n        // If the default value is found an empty string is inserted.\n        res = route.route.replace(matcher, function (whole, name) {\n            delete cpy[name];\n            return data[name] === route.defaults[name] ? \"\" : encodeURIComponent(data[name]);\n        })\n        .replace(\"\\\\\", \"\");\n        // Remove matching default values\n        canReflect.eachKey(route.defaults, function (val, name) {\n            if (cpy[name] === val) {\n                delete cpy[name];\n            }\n        });\n        // The remaining elements of data are added as\n        // `&amp;` separated parameters to the url.\n        after = param(cpy);\n        // if we are paraming for setting the hash\n        // we also want to make sure the route value is updated\n        //if (_setRoute) {\n        //    register.matched(route.route);\n        //}\n        return res + (after ? bindingProxy.call(\"querySeparator\") + after : \"\");\n    }\n    // If no route was found, there is no hash URL, only paramters.\n    return canReflect.size(data) === 0 ? \"\" :bindingProxy.call(\"querySeparator\") + param(data);\n}\n\n\n/**\n * @function can-route.param param\n * @parent can-route.static\n * @description Get a route path from given data.\n * @signature `route.param(data)`\n * @param {data} object The data to populate the route with.\n * @param {String} [currentRouteName] The current route name.  If provided, this\n * can be used to \"stick\" the url to a previous route. By \"stick\", we mean that\n * if there are multiple registered routes that match the `object`, the\n * the `currentRouteName` will be used.\n * @return {String} The route, with the data populated in it.\n *\n * @body\n * Parameterizes the raw JS object representation provided in data.\n *\n * ```js\n * route.param({ type: \"video\", id: 5 });\n *   // -> \"type=video&id=5\"\n * ```\n *\n * If a route matching the provided data is found, that URL is built\n * from the data. Any remaining data is added at the end of the\n * URL as &amp; separated key/value parameters.\n *\n * ```js\n * route.register(\"{type}/{id}\");\n *\n * route.param({ type: \"video\", id: 5 }) // -> \"video/5\"\n * route.param({ type: \"video\", id: 5, isNew: false })\n *   // -> \"video/5&isNew=false\"\n * ```\n */\nfunction canRoute_param(data, currentRouteName) {\n \treturn paramFromRoute(getMatchedRoute(data, currentRouteName), data);\n}\nmodule.exports = canRoute_param;\ncanRoute_param.paramFromRoute = paramFromRoute;\ncanRoute_param.getMatchedRoute = getMatchedRoute;\n","\"use strict\";\nvar bindingProxy = require(\"./binding-proxy\");\nvar routeDeparam = require(\"./deparam\");\nvar routeParam = require(\"./param\");\nvar canReflect = require(\"can-reflect\");\nvar string = require('can-string');\n\n\nvar makeProps = function (props) {\n\tvar tags = [];\n\tcanReflect.eachKey(props, function (val, name) {\n\t\ttags.push((name === 'className' ? 'class' : name) + '=\"' +\n\t\t\t(name === \"href\" ? val : string.esc(val)) + '\"');\n\t});\n\treturn tags.join(\" \");\n};\nvar matchCheck = function(source, matcher){\n\t/*jshint eqeqeq:false*/\n\tfor(var prop in source) {\n\t\tvar s = source[prop],\n\t\t\tm = matcher[prop];\n\t\tif(s && m && typeof s === \"object\" && typeof matcher === \"object\") {\n\t\t\treturn matchCheck(s, m);\n\t\t}\n\t\tif(s != m) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\nfunction canRoute_url(options, merge) {\n\n    if (merge) {\n        var baseOptions = routeDeparam(bindingProxy.call(\"can.getValue\"));\n        options = canReflect.assignMap(canReflect.assignMap({}, baseOptions), options);\n    }\n    return bindingProxy.call(\"root\") +routeParam(options);\n}\nmodule.exports = {\n    /**\n     * @function can-route.url url\n     * @parent can-route.static\n     * @description Creates a URL fragment based on registered routes given a set of data.\n     * @signature `route.url(data [, merge])`\n     *\n     * Make a URL fragment that when set to window.location.hash will update can-route's properties\n     * to match those in `data`.\n     *\n     * ```js\n     * route.url({ page: \"home\" });\n     * // -> \"#!page=home\"\n     * ```\n     *\n     * @param {Object} data The data to populate the route with.\n     * @param {Boolean} [merge] Whether the given options should be merged into\n     * the current state of the route.\n     * @return {String} The route URL and query string.\n     *\n     * @body\n     * Similar to [can-route.link], but instead of creating an anchor tag,\n     * `route.url` creates only the URL based on the route options passed into it.\n     *\n     * ```js\n     * route.url( { type: \"videos\", id: 5 } );\n     *   // -> \"#!type=videos&id=5\"\n     * ```\n     *\n     * If a route matching the provided data is found the URL is built from the\n     * data. Any remaining data is added at the end of the URL as & separated\n     * key/value parameters.\n     *\n     * ```js\n     * route.register(\"{type}/{id}\");\n     *\n     * route.url( { type: \"videos\", id: 5 } ) // -> \"#!videos/5\"\n     * route.url( { type: \"video\", id: 5, isNew: false } )\n     *   // -> \"#!video/5&isNew=false\"\n     * ```\n     */\n    url: canRoute_url,\n    /**\n     * @function can-route.link link\n     * @parent can-route.static\n     * @description Creates a string representation of an anchor link using\n     * data and the registered routes.\n     * @signature `route.link(innerText, data, props [, merge])`\n     *\n     * Make an anchor tag (`<a>`) that when clicked on will update can-route's\n     * properties to match those in `data`.\n     *\n     * @param {Object} innerText The text inside the link.\n     * @param {Object} data The data to populate the route with.\n     * @param {Object} props Properties for the anchor other than `href`.\n     * @param {Boolean} [merge] Whether the given options should be merged into the current state of the route.\n     * @return {String} A string with an anchor tag that points to the populated route.\n     *\n     * @body\n     * Creates and returns an anchor tag with an href of the route\n     * attributes passed into it, as well as any properties desired\n     * for the tag.\n     *\n     * ```js\n     * route.link( \"My videos\", { type: \"videos\" }, {}, false )\n     *   // -> <a href=\"#!type=videos\">My videos</a>\n     * ```\n     *\n     * Other attributes besides href can be added to the anchor tag\n     * by passing in a data object with the attributes desired.\n     *\n     * ```js\n     * route.link( \"My videos\", { type: \"videos\" },\n     *   { className: \"new\" }, false )\n     *     // -> <a href=\"#!type=videos\" class=\"new\">My Videos</a>\n     * ```\n     *\n     * It is possible to utilize the current route options when making anchor\n     * tags in order to make your code more reusable. If merge is set to true,\n     * the route options passed into `canRoute.link` will be passed into the\n     * current ones.\n     *\n     * ```js\n     * location.hash = \"#!type=videos\"\n     * route.link( \"The zoo\", { id: 5 }, true )\n     *   // -> <a href=\"#!type=videos&id=5\">The zoo</true>\n     *\n     * location.hash = \"#!type=pictures\"\n     * route.link( \"The zoo\", { id: 5 }, true )\n     *   // -> <a href=\"#!type=pictures&id=5\">The zoo</true>\n     * ```\n     */\n    link: function canRoute_link(name, options, props, merge) {\n        return \"<a \" + makeProps(\n            canReflect.assignMap({\n                href: canRoute_url(options, merge)\n            }, props)) + \">\" + name + \"</a>\";\n    },\n    /**\n     * @function can-route.isCurrent isCurrent\n     * @parent can-route.static\n     *\n     * Check if data represents the current route.\n     *\n     * @signature `route.isCurrent(data [,subsetMatch] )`\n     *\n     * Compares `data` to the current route. Used to verify if an object is\n     * representative of the current route.\n     *\n     * ```js\n     * route.data.set({page: \"recipes\", id: '5'});\n     *\n     * route.isCurrent({page: \"recipes\"});       //-> false\n     * route.isCurrent({page: \"recipes\"}, true); //-> true\n     * ```\n     *\n     *   @param {Object} data Data to check agains the current route.\n     *   @param {Boolean} [subsetMatch] If true, `route.current` will return true\n     *   if every value in `data` matches the current route data, even if\n     *   the route data has additional properties that are not matched.  Defaults to `false`\n     *   where every property needs to be present.\n     *   @return {Boolean} Whether the data matches the current URL.\n     *\n     * @body\n     *\n     * ## Use\n     *\n     * Checks the page's current URL to see if the route represents the options\n     * passed into the function.\n     *\n     * Returns true if the options represent the current URL.\n     *\n     * ```js\n     * route.data.id = 5; // location.hash -> \"#!id=5\"\n     * route.isCurrent({ id: 5 }); // -> true\n     * route.isCurrent({ id: 5, type: 'videos' }); // -> false\n     *\n     * route.data.type = 'videos';\n     *   // location.hash -> #!id=5&type=videos\n     * route.isCurrent({ id: 5, type: 'videos' }); // -> true\n     * ```\n     */\n    isCurrent: function canRoute_isCurrent(options, subsetMatch) {\n\t\tif(subsetMatch) {\n\t\t\t// everything in options shouhld be in baseOptions\n\t\t\tvar baseOptions = routeDeparam( bindingProxy.call(\"can.getValue\") );\n\t\t\treturn matchCheck(options, baseOptions);\n\t\t} else {\n\t\t\treturn bindingProxy.call(\"can.getValue\") === routeParam(options);\n\t\t}\n\t}\n};\n","'use strict';\n\nvar globals = require('can-globals/can-globals-instance');\n\n/* globals WorkerGlobalScope */\n// A bit of weirdness to avoid complaining linters\nvar funcConstructor = Function;\n\n\n/**\n * @module {function} can-globals/is-browser-window/is-web-worker is-web-worker\n * @parent can-globals/modules\n * @signature `isWebWorker()`\n *\n * Returns `true` if the code is running within a [web worker](https://developer.mozilla.org/en-US/docs/Web/API/Worker).\n *\n * ```js\n * var isWebWorker = require(\"can-globals/is-web-worker/is-web-worker\");\n * var GLOBAL = require(\"can-globals/global/global\");\n *\n * if(isWebWorker()) {\n *   ...\n * }\n * ```\n *\n * @return {Boolean} True if the environment is a web worker.\n */\n\nglobals.define('isWebWorker', function(){\n    var global = funcConstructor('return this')();\n    return typeof WorkerGlobalScope !== \"undefined\" &&\n        (global instanceof WorkerGlobalScope);\n});\n\nmodule.exports = globals.makeExport('isWebWorker');\n","\"use strict\";\n/*jshint -W079 */\nvar Bind = require(\"can-bind\");\nvar queues = require(\"can-queues\");\nvar Observation = require('can-observation');\n\nvar namespace = require('can-namespace');\nvar devLog = require('can-log/dev/dev');\nvar canReflect = require('can-reflect');\nvar canSymbol = require('can-symbol');\nvar makeCompute = require(\"can-simple-observable/make-compute/make-compute\");\nvar RouteData = require(\"./src/routedata\");\nvar stringCoercingMapDecorator = require(\"./src/string-coercion\").stringCoercingMapDecorator;\n\nvar registerRoute = require(\"./src/register\");\nvar urlHelpers = require(\"./src/url-helpers\");\nvar routeParam = require(\"./src/param\");\nvar routeDeparam = require(\"./src/deparam\");\nvar bindingProxy = require(\"./src/binding-proxy\");\nvar Hashchange = require(\"can-route-hash\");\n\nvar isWebWorker =  require('can-globals/is-web-worker/is-web-worker');\nvar isBrowserWindow =  require('can-globals/is-browser-window/is-browser-window');\n\nvar hashchangeObservable = new Hashchange();\nbindingProxy.bindings.hashchange = hashchangeObservable;\nbindingProxy.defaultBinding = \"hashchange\";\nbindingProxy.urlDataObservable.value = hashchangeObservable;\n\n\n// ## route.js\n// `can-route`\n// _Helps manage browser history (and client state) by synchronizing the\n// `window.location.hash` with a `Map`._\n\nfunction canRoute(url, defaults){\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tdevLog.warn('Call route.register(url,defaults) instead of calling route(url, defaults)');\n\t}\n\t//!steal-remove-end\n\tregisterRoute.register(url, defaults);\n\treturn canRoute;\n}\n\n\n// Helper methods used for matching routes.\n\n\n// A ~~throttled~~ debounced function called multiple times will only fire once the\n// timer runs down. Each call resets the timer.\nvar timer;\n// A dummy events object used to dispatch url change events on.\nvar currentRuleObservable = new Observation(function canRoute_matchedRoute(){\n\tvar url = bindingProxy.call(\"can.getValue\");\n\treturn canRoute.rule(url);\n});\n\n\n// If the `route.data` changes, update the hash.\n// Using `.serialize()` retrieves the raw data contained in the `observable`.\n// This function is ~~throttled~~ debounced so it only updates once even if multiple values changed.\n// This might be able to use batchNum and avoid this.\nfunction updateUrl(serializedData) {\n\t// collect attributes that are changing\n\tclearTimeout(timer);\n\ttimer = setTimeout(function () {\n\t\t// indicate that the hash is set to look like the data\n\t\tvar serialized = canReflect.serialize( canRoute.data ),\n\t\t\tcurrentRouteName = currentRuleObservable.get(),\n\t\t\troute = routeParam.getMatchedRoute(serialized, currentRouteName),\n\t\t\tpath = routeParam.paramFromRoute(route, serialized);\n\n\t\tbindingProxy.call(\"can.setValue\", path);\n\t\tvar onStartComplete = canRoute._onStartComplete;\n\t\tif (onStartComplete) {\n\t\t\tcanRoute._onStartComplete = undefined;\n\t\t\tonStartComplete();\n\t\t}\n\t}, 10);\n}\n\n// Deparameterizes the portion of the hash of interest and assign the\n// values to the `route.data` removing existing values no longer in the hash.\n// updateRouteData is called typically by hashchange which fires asynchronously\n// So it’s possible that someone started changing the data before the\n// hashchange event fired.  For this reason, it will not set the route data\n// if the data is changing or the hash already matches the hash that was set.\nfunction updateRouteData() {\n\tvar hash = bindingProxy.call(\"can.getValue\");\n\t// if the hash data is currently changing, or\n\t// the hash is what we set it to anyway, do NOT change the hash\n\n\tqueues.batch.start();\n\n\tvar state = canRoute.deparam(hash);\n\tdelete state.route;\n\tcanReflect.update(canRoute.data,state);\n\tqueues.batch.stop();\n\n}\n\n\n/**\n * @static\n */\nObject.defineProperty(canRoute,\"routes\",{\n\t/**\n\t * @property {Object} routes\n\t * @hide\n\t *\n\t * A list of routes recognized by the router indixed by the url used to add it.\n\t * Each route is an object with these members:\n\t *\n\t *  - test - A regular expression that will match the route when variable values\n\t *    are present; i.e. for {page}/{type} the `RegExp` is /([\\w\\.]*)/([\\w\\.]*)/ which\n\t *    will match for any value of {page} and {type} (word chars or period).\n\t *\n\t *  - route - The original URL, same as the index for this entry in routes.\n\t *\n\t *  - names - An array of all the variable names in this route\n\t *\n\t *  - defaults - Default values provided for the variables or an empty object.\n\t *\n\t *  - length - The number of parts in the URL separated by '/'.\n\t */\n \tget: function() {\n \t\treturn registerRoute.routes;\n \t},\n\tset: function(newVal) {\n\t\treturn registerRoute.routes = newVal;\n\t}\n});\nObject.defineProperty(canRoute,\"defaultBinding\",{\n \tget: function(){\n\t\treturn bindingProxy.defaultBinding;\n\t},\n\tset: function(newVal){\n\t\tbindingProxy.defaultBinding = newVal;\n\t\tvar observable = bindingProxy.bindings[bindingProxy.defaultBinding];\n\t\tif(observable) {\n\t\t\tbindingProxy.urlDataObservable.value = observable;\n\t\t}\n\t}\n});\nObject.defineProperty(canRoute,\"urlData\",{\n \tget: function(){\n\t\treturn bindingProxy.urlDataObservable.value;\n\t},\n\tset: function(newVal){\n\t\tcanRoute._teardown();\n\t\tbindingProxy.urlDataObservable.value = newVal;\n\t}\n});\n\ncanReflect.assignMap(canRoute, {\n\tparam: routeParam,\n\tdeparam: routeDeparam,\n\tmap: function(data){\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tdevLog.warn('Set route.data directly instead of calling route.map');\n\t\t}\n\t\t//!steal-remove-end\n\t\tcanRoute.data = data;\n\t},\n\n\n\tstart: function (val) {\n\t\tif (val !== true) {\n\t\t\tcanRoute._setup();\n\t\t\tif(isBrowserWindow() || isWebWorker()) {\n\t\t\t\t// We can't use updateRouteData because we want to merge the route data\n\t\t\t\t// into .data\n\t\t\t\tvar hash = bindingProxy.call(\"can.getValue\");\n\t\t\t\tqueues.batch.start();\n\t\t\t\t// get teh data\n\t\t\t\tvar state = canRoute.deparam(hash);\n\t\t\t\tdelete state.route;\n\n\t\t\t\tcanReflect.assign(canRoute.data,state);\n\t\t\t\tqueues.batch.stop();\n\t\t\t\tupdateUrl();\n\t\t\t}\n\t\t}\n\t\treturn canRoute;\n\t},\n\turl: urlHelpers.url,\n\tlink: urlHelpers.link,\n\tisCurrent: urlHelpers.isCurrent,\n\tbindings: bindingProxy.bindings,\n\n\t// ready calls setup\n\t// setup binds and listens to data changes\n\t// bind listens to whatever you should be listening to\n\t// data changes tries to set the path\n\n\t// we need to be able to\n\t// easily kick off calling updateRouteData\n\t// \tteardown whatever is there\n\t//  turn on a particular binding\n\n\t// called when the route is ready\n\t_setup: function () {\n\t\tif (!canRoute._canBinding) {\n\n\t\t\tvar bindingOptions = {\n\n\t\t\t\t// The parent is the hashchange observable\n\t\t\t\tparent: bindingProxy.urlDataObservable.value,\n\t\t\t\tsetParent: updateUrl,\n\n\t\t\t\t// The child is route.data\n\t\t\t\tchild: canRoute.serializedObservation,\n\t\t\t\tsetChild: updateRouteData,\n\n\t\t\t\t// On init, we do not want the child set to the parent’s value; this is\n\t\t\t\t// handled by start() for reasons mentioned there.\n\t\t\t\tonInitDoNotUpdateChild: true,\n\n\t\t\t\t// Cycles are allowed because updateUrl is async; if another change\n\t\t\t\t// happens during its setTimeout, then without cycles the change would\n\t\t\t\t// be ignored :( TODO: Can this be removed if updateUrl stops using\n\t\t\t\t// setTimeout in a major version?\n\t\t\t\tcycles: 1,\n\n\t\t\t\t// Listen for changes in the notify queue\n\t\t\t\tqueue: \"notify\"\n\n\t\t\t};\n\n\t\t\t// For debugging: the names that will be assigned to the updateChild and\n\t\t\t// updateParent functions within can-bind\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tbindingOptions.updateChildName = \"can-route.updateRouteData\";\n\t\t\t\tbindingOptions.updateParentName = \"can-route.updateUrl\";\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\t// Create a new binding with can-bind\n\t\t\tcanRoute._canBinding = new Bind(bindingOptions);\n\n\t\t\t// …and turn it on!\n\t\t\tcanRoute._canBinding.start();\n\n\t\t}\n\t},\n\t_teardown: function () {\n\t\tif (canRoute._canBinding) {\n\t\t\tcanRoute._canBinding.stop();\n\t\t\tcanRoute._canBinding = null;\n\t\t}\n\t\tclearTimeout(timer);\n\t},\n\n\tstop: function() {\n\t\tthis._teardown();\n\t\treturn canRoute;\n\t},\n\n\tcurrentRule: makeCompute( currentRuleObservable ),\n\tregister: registerRoute.register,\n\trule: function(url){\n\t\tvar rule = routeDeparam.getRule(url);\n\t\tif(rule) {\n\t\t\treturn rule.route;\n\t\t}\n\t}\n});\n\n// The functions in the following list applied to `canRoute` (e.g. `canRoute.attr('...')`) will\n// instead act on the `canRoute.data` observe.\n\nvar bindToCanRouteData = function(name, args) {\n\tif (!canRoute.data[name]) {\n\t\treturn canRoute.data.addEventListener.apply(canRoute.data, args);\n\t}\n\treturn canRoute.data[name].apply(canRoute.data, args);\n};\n\n['addEventListener','removeEventListener','bind', 'unbind', 'on', 'off'].forEach(function(name) {\n\t// exposing all internal eventQueue evt’s to canRoute\n\tcanRoute[name] = function(eventName, handler) {\n\t\tif (eventName === '__url') {\n\t\t\treturn bindingProxy.call(\"can.onValue\", handler );\n\t\t}\n\t\treturn bindToCanRouteData(name, arguments);\n\t};\n});\n\n['delegate', 'undelegate', 'removeAttr', 'compute', '_get', '___get', 'each'].forEach(function (name) {\n\tcanRoute[name] = function () {\n\t\t// `delegate` and `undelegate` require\n\t\t// the `can/map/delegate` plugin\n\t\treturn bindToCanRouteData(name, arguments);\n\t};\n});\n\n\nvar routeData;\nvar setRouteData = function(data){\n\trouteData = data;\n\treturn routeData;\n};\nvar serializedObservation;\nvar serializedCompute;\n\nObject.defineProperty(canRoute,\"serializedObservation\", {\n\tget: function(){\n\t\tif(!serializedObservation) {\n\t\t\tserializedObservation = new Observation(function canRoute_data_serialized(){\n\t\t\t\treturn canReflect.serialize( canRoute.data );\n\t\t\t});\n\t\t}\n\t\treturn serializedObservation;\n\t}\n});\nObject.defineProperty(canRoute,\"serializedCompute\", {\n\tget: function(){\n\t\tif(!serializedCompute) {\n\t\t\tserializedCompute = makeCompute(canRoute.serializedObservation);\n\t\t}\n\t\treturn serializedCompute;\n\t}\n});\n\nvar viewModelSymbol = canSymbol.for(\"can.viewModel\");\nObject.defineProperty(canRoute,\"data\", {\n\tget: function(){\n\t\tif(routeData) {\n\t\t\treturn routeData;\n\t\t} else {\n\t\t\treturn setRouteData(new RouteData());\n\t\t}\n\t},\n\tset: function(data) {\n\t\tif( canReflect.isConstructorLike(data) ){\n\t\t\tdata = new data();\n\t\t}\n\t\tif(data && data[viewModelSymbol] !== undefined) {\n\t\t\tdata = data[viewModelSymbol];\n\t\t}\n\t\t// if it’s a map, we make it always set strings for backwards compat\n\t\tif( \"attr\" in data ) {\n\t\t\tsetRouteData( stringCoercingMapDecorator(data) );\n\t\t} else {\n\t\t\tsetRouteData(data);\n\t\t}\n\t}\n});\n\ncanRoute.attr = function(prop, value){\n\tconsole.warn(\"can-route: can-route.attr is deprecated. Use methods on can-route.data instead.\");\n\tif(\"attr\" in canRoute.data) {\n\t\treturn canRoute.data.attr.apply(canRoute.data, arguments);\n\t} else {\n\t\tif(arguments.length > 1) {\n\t\t\tcanReflect.setKeyValue(canRoute.data, prop, value);\n\t\t\treturn canRoute.data;\n\t\t} else if(typeof prop === 'object') {\n\t\t\tcanReflect.assignDeep(canRoute.data,prop);\n\t\t\treturn canRoute.data;\n\t\t} else if(arguments.length === 1){\n\t\t\treturn canReflect.getKeyValue(canRoute.data, prop);\n\t\t} else {\n\t\t\treturn canReflect.unwrap(canRoute.data);\n\t\t}\n\t}\n};\n\n\ncanReflect.setKeyValue(canRoute, canSymbol.for(\"can.isFunctionLike\"), false);\n\n// LEGACY\ncanRoute.matched = canRoute.currentRule;\ncanRoute.current = canRoute.isCurrent;\n\nmodule.exports = namespace.route = canRoute;\n"],"names":["Compute","newVal","arguments","length","canReflect","setValue","this","getValue","translationHelpers","WeakMap","observable","compute","bind","on","addEventListener","event","handler","translationHandler","get","oldVal","call","type","process","env","NODE_ENV","Object","defineProperty","value","getName","set","onValue","off","unbind","removeEventListener","offValue","assignSymbols","can.getValue","can.setValue","can.onValue","queue","can.offValue","can.valueHasDependencies","valueHasDependencies","can.getPriority","getPriority","can.setPriority","newPriority","setPriority","can.isValueLike","can.isFunctionLike","isComputed","stringify","obj","serialize","slice","assign","eachKey","val","prop","toString","stringCoercingMapDecorator","map","sym","canSymbol","for","attr","attrSuper","args","undefined","define","Array","apply","setKeyValue","require$$0","DefineMap","extend","seal","*","urlDataObservable","SimpleObservable","setName","bindingProxy","defaultBinding","bindings","toArray","shift","binding","Error","method","indexOf","curlies","colon","removeBackslash","str","replace","wrapQuote","RouteRegistry","routes","register","url","defaults","root","lastIndexOf","substr","res","matcher","lastIndex","names","test","querySeparator","matchSlashes","regexps","dev","warn","name","key","exec","push","substring","r","existingKeys","concat","keys","sort","sameMapKeys","diff","sameDefaultValues","diffObject","matchingRoutesWithoutTrailingSlash","route","JSON","data","RouteData","routeData","eachIndex","defaultValue","defineInstanceKey","constructor","RegExp","split","decode","decodeURIComponent","ex","unescape","toURLFragment","canRoute_getRule","temp","canRoute_deparam","paramsMatcher","parts","match","start","remainder","deparam","assignDeep","forEach","part","i","charAt","getRule","matchesData","count","hasOwnProperty","getMatchedRoute","routeName","matchCount","matches","propCount","paramFromRoute","cpy","after","assignMap","whole","encodeURIComponent","param","size","canRoute_param","currentRouteName","makeProps","props","tags","string","esc","join","matchCheck","source","s","m","canRoute_url","options","merge","baseOptions","routeDeparam","routeParam","link","href","isCurrent","subsetMatch","funcConstructor","Function","globals","global","WorkerGlobalScope","timer","makeExport","hashchangeObservable","Hashchange","canRoute","devLog","registerRoute","hashchange","currentRuleObservable","Observation","rule","updateUrl","serializedData","clearTimeout","setTimeout","serialized","path","onStartComplete","_onStartComplete","updateRouteData","hash","queues","batch","state","update","stop","_teardown","_setup","isBrowserWindow","isWebWorker","urlHelpers","_canBinding","bindingOptions","parent","setParent","child","serializedObservation","setChild","onInitDoNotUpdateChild","cycles","updateChildName","updateParentName","Bind","currentRule","makeCompute","bindToCanRouteData","eventName","serializedCompute","setRouteData","viewModelSymbol","isConstructorLike","console","getKeyValue","unwrap","matched","current","namespace"],"mappings":"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"}