{"version":3,"file":"can-component.js","sources":["../node_modules/can-component/control/control.js","../node_modules/can-component/can-component.js"],"sourcesContent":["\"use strict\";\nvar Control = require(\"can-control\");\nvar canReflect = require(\"can-reflect\");\n\n// ## Helpers\n// Attribute names to ignore for setting viewModel values.\nvar paramReplacer = /\\{([^\\}]+)\\}/g;\n\nvar ComponentControl = Control.extend({\n\t\t// the lookup path - where templated keys will be looked up\n\t\t// change lookup to first look in the viewModel\n\t\t_lookup: function(options) {\n\t\t\treturn [options.scope, options, window];\n\t\t},\n\t\t// strip strings that represent delegates from the key\n\t\t// viewModel.foo -> foo\n\t\t_removeDelegateFromKey: function (key) {\n\t\t\treturn key.replace(/^(scope|^viewModel)\\./, \"\");\n\t\t},\n\t\t// return whether the key is a delegate\n\t\t_isDelegate: function(options, key) {\n\t\t\treturn key === 'scope' || key === 'viewModel';\n\t\t},\n\t\t// return the delegate object for a given key\n\t\t_getDelegate: function(options, key) {\n\t\t\treturn options[key];\n\t\t},\n\t\t_action: function(methodName, options, controlInstance) {\n\t\t\tvar hasObjectLookup;\n\n\t\t\tparamReplacer.lastIndex = 0;\n\n\t\t\thasObjectLookup = paramReplacer.test(methodName);\n\n\t\t\t// If we don't have options (a `control` instance), we'll run this later.\n\t\t\tif (!controlInstance && hasObjectLookup) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\treturn Control._action.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t},\n\t// Extend `events` with a setup method that listens to changes in `viewModel` and\n\t// rebinds all templated event handlers.\n\t{\n\t\tsetup: function(el, options) {\n\t\t\tthis.scope = options.scope;\n\t\t\tthis.viewModel = options.viewModel;\n\t\t\treturn Control.prototype.setup.call(this, el, options);\n\t\t},\n\t\toff: function() {\n\t\t\t// If `this._bindings` exists we need to go through it's `readyComputes` and manually\n\t\t\t// unbind `change` event listeners set by the controller.\n\t\t\tif (this._bindings) {\n\t\t\t\tcanReflect.eachKey(this._bindings.readyComputes || {}, function(value) {\n\t\t\t\t\tcanReflect.offValue(value.compute, value.handler);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Call `Control.prototype.off` function on this instance to cleanup the bindings.\n\t\t\tControl.prototype.off.apply(this, arguments);\n\t\t\tthis._bindings.readyComputes = {};\n\t\t},\n\t\tdestroy: function() {\n\t\t\tControl.prototype.destroy.apply(this, arguments);\n\t\t\tif (typeof this.options.destroy === 'function') {\n\t\t\t\tthis.options.destroy.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t});\n\nmodule.exports = ComponentControl;\n","\"use strict\";\n/* jshint -W079 */\n// # can/component/component.js\n//\n// This implements the `Component` which allows you to create widgets\n// that use a view, a view-model, and custom tags.\n//\n// `Component` implements most of it's functionality in the `Component.setup`\n// and the `Component.prototype.setup` functions.\n//\n// `Component.setup` prepares everything needed by the `Component.prototype.setup`\n// to hookup the component.\nvar ComponentControl = require(\"./control/control\");\nvar namespace = require('can-namespace');\n\nvar Bind = require(\"can-bind\");\nvar Construct = require(\"can-construct\");\nvar stache = require(\"can-stache\");\nvar stacheBindings = require(\"can-stache-bindings\");\nvar Scope = require(\"can-view-scope\");\nvar viewCallbacks = require(\"can-view-callbacks\");\nvar nodeLists = require(\"can-view-nodelist\");\nvar canReflect = require(\"can-reflect\");\nvar observeReader = require(\"can-stache-key\");\nvar SettableObservable = require(\"can-simple-observable/setter/setter\");\nvar SimpleObservable = require(\"can-simple-observable\");\nvar SimpleMap = require(\"can-simple-map\");\nvar DefineMap = require(\"can-define/map/map\");\nvar canLog = require('can-log');\nvar canDev = require('can-log/dev/dev');\nvar assign = require('can-assign');\nvar ObservationRecorder = require(\"can-observation-recorder\");\nrequire('can-view-model');\n\n// DefineList must be imported so Arrays on the ViewModel\n// will be converted to DefineLists automatically\nrequire(\"can-define/list/list\");\n\nvar domData = require('can-dom-data-state');\nvar getChildNodes = require('can-child-nodes');\nvar string = require(\"can-string\");\nvar domEvents = require('can-dom-events');\nvar domMutate = require('can-dom-mutate');\nvar domMutateNode = require('can-dom-mutate/node');\nvar canSymbol = require('can-symbol');\nvar DOCUMENT = require('can-globals/document/document');\n\n// Symbols\nvar createdByCanComponentSymbol = canSymbol(\"can.createdByCanComponent\");\nvar getValueSymbol = canSymbol.for(\"can.getValue\");\nvar setValueSymbol = canSymbol.for(\"can.setValue\");\nvar viewInsertSymbol = canSymbol.for(\"can.viewInsert\");\nvar viewModelSymbol = canSymbol.for('can.viewModel');\n\nstache.addBindings(stacheBindings);\n\n// For insertion elements like <can-slot> and <context>, this will add\n// a compute viewModel to the top of the context if\n// a binding like {this}=\"value\" is present.\n// - el - the insertion element\n// - tagData - the tagData the insertion element will be rendered with\n// - insertionElementTagData - the tagData found at the insertion element\n// `returns` - the tagData the template should be rendered with.\nfunction addContext(el, tagData, insertionElementTagData) {\n\tvar vm;\n\n\tdomData.set.call(el, \"preventDataBindings\", true);\n\n\t// insertionElementTagData is where the <content> element is in the shadow dom\n\t// it should be used for bindings\n\tvar teardown = stacheBindings.behaviors.viewModel(el, insertionElementTagData, function(initialData, hasDataBinding, bindingState) {\n\t\t// Create a compute responsible for keeping the vm up-to-date\n\t\tif(bindingState && bindingState.isSettingOnViewModel === true) {\n\t\t\treturn vm = new SimpleMap(initialData);\n\t\t} else {\n\t\t\treturn vm = new SimpleObservable(initialData);\n\t\t}\n\t}, undefined, true);\n\n\n\tif(!teardown) {\n\t\t// if no teardown, there's no bindings, no need to change the scope\n\t\treturn tagData;\n\t} else {\n\t\treturn assign( assign({}, tagData), {\n\t\t\tteardown: teardown,\n\t\t\tscope: tagData.scope.add(vm)\n\t\t});\n\t}\n\n}\n\n// Returns a hookupFuction that gets the proper tagData in a template, renders it, and adds it to nodeLists\nfunction makeInsertionTagCallback(tagName, componentTagData, shadowTagData, leakScope, getPrimaryTemplate) {\n\tvar options = shadowTagData.options;\n\n\treturn function hookupFunction(el, insertionElementTagData) {\n\t\tvar template = getPrimaryTemplate(el) || insertionElementTagData.subtemplate,\n\t\t\trenderingLightContent = template !== insertionElementTagData.subtemplate;\n\n\t\tif (template) {\n\t\t\t// However, `_tags.[tagName]` is going to point to this current content callback.  We need to\n\t\t\t// remove that so it will walk up the chain\n\t\t\tdelete options.tags[tagName];\n\n\t\t\t// By default, light dom scoping is\n\t\t\t// dynamic. This means that any `{{foo}}`\n\t\t\t// bindings inside the \"light dom\" content of\n\t\t\t// the component will have access to the\n\t\t\t// internal viewModel. This can be overridden to be\n\t\t\t// lexical with the leakScope option.\n\t\t\tvar tagData;\n\n\t\t\tif( renderingLightContent ) {\n\n\t\t\t\tif(leakScope.toLightContent) {\n\t\t\t\t\t// render with the component's viewModel mixed in, however\n\t\t\t\t\t// we still want the outer refs to be used, NOT the component's refs\n\t\t\t\t\t// <component> {{some value }} </component>\n\t\t\t\t\t// To fix this, we\n\t\t\t\t\t// walk down the scope to the component's ref, clone scopes from that point up\n\t\t\t\t\t// use that as the new scope.\n\t\t\t\t\ttagData = addContext(el, {\n\t\t\t\t\t\tscope: insertionElementTagData.scope.cloneFromRef(),\n\t\t\t\t\t\toptions: insertionElementTagData.options\n\t\t\t\t\t}, insertionElementTagData);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// render with the same scope the component was found within.\n\t\t\t\t\ttagData = addContext(el, componentTagData, insertionElementTagData);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// we are rendering default content so this content should\n\t\t\t\t// use the same scope as the <content> tag was found within.\n\t\t\t\ttagData = addContext(el, insertionElementTagData, insertionElementTagData);\n\t\t\t}\n\n\n\t\t\t// the `el` is part of some parent node list\n\n\t\t\tvar nodeList = nodeLists.register([el], function() {\n\t\t\t\tif(tagData.teardown) {\n\t\t\t\t\ttagData.teardown();\n\t\t\t\t}\n\t\t\t}, insertionElementTagData.parentNodeList || true, insertionElementTagData.directlyNested);\n\t\t\tnodeList.expression = \"<can-slot name='\"+el.getAttribute('name')+\"'/>\";\n\n\t\t\tvar frag = template(tagData.scope, tagData.options, nodeList);\n\t\t\tvar newNodes = canReflect.toArray( getChildNodes(frag) );\n\t\t\tvar oldNodes = nodeLists.update(nodeList, newNodes);\n\t\t\tnodeLists.replace(oldNodes, frag);\n\n\n\t\t\t// Restore the proper tag function so it could potentially be used again (as in lists)\n\t\t\toptions.tags[tagName] = hookupFunction;\n\t\t}\n\t};\n}\n\n// Helper function for taking a viewModel passed into a component’s constructor\n// function and returning a function that can be used to set up the bindings\nfunction getSetupFunctionForComponentVM(componentInitVM) {\n\t// componentInitVM is the viewModel in `new ComponentConstructor({ viewModel: {...} })`\n\treturn ObservationRecorder.ignore(function(el, makeViewModel, initialVMData) {\n\t\tvar onCompleteBindings = [];\n\t\tvar onTeardowns = [];\n\t\tvar viewModel;// This will be created after getting all the initial values\n\n\t\t// Loop through all the props to create the new binding and get the initial\n\t\t// values (so the viewModel can be created with the initial values)\n\t\tcanReflect.eachKey(componentInitVM, function(parent, propName) {\n\t\t\tvar canGetParentValue = parent != null && !!parent[getValueSymbol];\n\t\t\tvar canSetParentValue = parent != null && !!parent[setValueSymbol];\n\n\t\t\t// If we can get or set the value, then we’ll create a binding\n\t\t\tif (canGetParentValue === true || canSetParentValue) {\n\n\t\t\t\t// Create an observable for reading/writing the viewModel\n\t\t\t\tvar keysToRead = observeReader.reads(propName);\n\t\t\t\tvar child = new SettableObservable(\n\t\t\t\t\tfunction() {\n\t\t\t\t\t\treturn observeReader.read(viewModel, keysToRead).value;\n\t\t\t\t\t},\n\t\t\t\t\tfunction(newValue) {\n\t\t\t\t\t\tcanReflect.setKeyValue(viewModel, propName, newValue);\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Create the binding similar to what’s in can-stache-bindings\n\t\t\t\tvar canBinding = new Bind({\n\t\t\t\t\tchild: child,\n\t\t\t\t\tparent: parent,\n\t\t\t\t\tqueue: \"domUI\",\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t// For debugging: the names that will be assigned to the updateChild\n\t\t\t\t\t// and updateParent functions within can-bind\n\t\t\t\t\tupdateChildName: \"update viewModel.\" + propName + \" of <\" + el.nodeName.toLowerCase() + \">\",\n\t\t\t\t\tupdateParentName: \"update \" + canReflect.getName(parent) + \" of <\" + el.nodeName.toLowerCase() + \">\"\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t});\n\n\t\t\t\t// Immediately bind to the parent\n\t\t\t\tcanBinding.startParent();\n\n\t\t\t\t// If we can get the value, we want to instantiate the viewModel with it\n\t\t\t\tif (canGetParentValue === true) {\n\t\t\t\t\tinitialVMData[propName] = canBinding.parentValue;\n\t\t\t\t}\n\n\t\t\t\t// Like can-stache-bindings, delay starting the rest of the binding\n\t\t\t\tonCompleteBindings.push(canBinding.start.bind(canBinding));\n\n\t\t\t\t// We’ll want to turn off the bindings when the component is destroyed\n\t\t\t\tonTeardowns.push(canBinding.stop.bind(canBinding));\n\n\t\t\t} else {\n\t\t\t\t// Can’t get or set the value, so assume it’s not an observable\n\t\t\t\tinitialVMData[propName] = parent;\n\t\t\t}\n\t\t});\n\n\t\t// Now that we have all the initial values, create the component’s viewModel\n\t\tviewModel = makeViewModel(initialVMData);\n\n\t\t// Call start() on all the bindings\n\t\tfor (var i = 0, len = onCompleteBindings.length; i < len; i++) {\n\t\t\tonCompleteBindings[i]();\n\t\t}\n\n\t\t// Return a teardown function\n\t\treturn function() {\n\t\t\tonTeardowns.forEach(function(onTeardown) {\n\t\t\t\tonTeardown();\n\t\t\t});\n\t\t};\n\t});\n}\n\nvar Component = Construct.extend(\n\n\t// ## Static\n\t{\n\t\t// ### setup\n\t\t//\n\t\t// When a component is extended, this sets up the component's internal constructor\n\t\t// functions and views for later fast initialization.\n\t\t// jshint maxdepth:6\n\t\tsetup: function() {\n\t\t\tConstruct.setup.apply(this, arguments);\n\n\t\t\t// When `Component.setup` function is ran for the first time, `Component` doesn't exist yet\n\t\t\t// which ensures that the following code is ran only in constructors that extend `Component`.\n\t\t\tif (Component) {\n\t\t\t\tvar self = this;\n\n\t\t\t\t// Define a control using the `events` prototype property.\n\t\t\t\tif(this.prototype.events !== undefined && canReflect.size(this.prototype.events) !== 0) {\n\t\t\t\t\tthis.Control = ComponentControl.extend(this.prototype.events);\n\t\t\t\t}\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t// If a constructor is assigned to the viewModel, give a warning\n\t\t\t\t\tif (this.prototype.viewModel && canReflect.isConstructorLike(this.prototype.viewModel)) {\n\t\t\t\t\t\tcanDev.warn(\"can-component: Assigning a DefineMap or constructor type to the viewModel property may not be what you intended. Did you mean ViewModel instead? More info: https://canjs.com/doc/can-component.prototype.ViewModel.html\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\t// Look at viewModel, scope, and ViewModel properties and set one of:\n\t\t\t\t//  - this.viewModelHandler\n\t\t\t\t//  - this.ViewModel\n\t\t\t\t//  - this.viewModelInstance\n\t\t\t\tvar protoViewModel = this.prototype.viewModel || this.prototype.scope;\n\n\t\t\t\tif(protoViewModel && this.prototype.ViewModel) {\n\t\t\t\t\tthrow new Error(\"Cannot provide both a ViewModel and a viewModel property\");\n\t\t\t\t}\n\t\t\t\tvar vmName = string.capitalize( string.camelize(this.prototype.tag) )+\"VM\";\n\t\t\t\tif(this.prototype.ViewModel) {\n\t\t\t\t\tif(typeof this.prototype.ViewModel === \"function\") {\n\t\t\t\t\t\tthis.ViewModel = this.prototype.ViewModel;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.ViewModel = DefineMap.extend(vmName, {}, this.prototype.ViewModel);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif(protoViewModel) {\n\t\t\t\t\t\tif(typeof protoViewModel === \"function\") {\n\t\t\t\t\t\t\tif(canReflect.isObservableLike(protoViewModel.prototype) && canReflect.isMapLike(protoViewModel.prototype)) {\n\t\t\t\t\t\t\t\tthis.ViewModel = protoViewModel;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.viewModelHandler = protoViewModel;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(canReflect.isObservableLike(protoViewModel) && canReflect.isMapLike(protoViewModel)) {\n\t\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t\t\t\tcanLog.warn(\"can-component: \"+this.prototype.tag+\" is sharing a single map across all component instances\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\t\t\tthis.viewModelInstance = protoViewModel;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcanLog.warn(\"can-component: \"+this.prototype.tag+\" is extending the viewModel into a can-simple-map\");\n\t\t\t\t\t\t\t\tthis.ViewModel = SimpleMap.extend(vmName,{},protoViewModel);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.ViewModel = SimpleMap.extend(vmName,{},{});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Convert the template into a renderer function.\n\t\t\t\tif (this.prototype.template) {\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\tcanLog.warn('can-component.prototype.template: is deprecated and will be removed in a future release. Use can-component.prototype.view');\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tthis.renderer = this.prototype.template;\n\t\t\t\t}\n\t\t\t\tif (this.prototype.view) {\n\t\t\t\t\tthis.renderer = this.prototype.view;\n\t\t\t\t}\n\n\t\t\t\t// default to stache if renderer is a string\n\t\t\t\tif (typeof this.renderer === \"string\") {\n\t\t\t\t\tvar viewName = string.capitalize( string.camelize(this.prototype.tag) )+\"View\";\n\t\t\t\t\tthis.renderer = stache(viewName, this.renderer);\n\t\t\t\t}\n\n\t\t\t\t// Register this component to be created when its `tag` is found.\n\t\t\t\tviewCallbacks.tag(this.prototype.tag, function(el, tagData) {\n\t\t\t\t\t// Check if a symbol already exists on the element; if it does, then\n\t\t\t\t\t// a new instance of the component has already been created\n\t\t\t\t\tif (el[createdByCanComponentSymbol] === undefined) {\n\t\t\t\t\t\tnew self(el, tagData);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}, {\n\t\t// ## Prototype\n\t\t// ### setup\n\t\t// When a new component instance is created, setup bindings, render the view, etc.\n\t\tsetup: function(el, componentTagData) {\n\t\t\tthis._initialArgs = [el,componentTagData];\n\t\t\tvar component = this;\n\t\t\tvar options = {\n\t\t\t\thelpers: {},\n\t\t\t\ttags: {}\n\t\t\t};\n\t\t\t// If a view is not provided, we fall back to\n\t\t\t// dynamic scoping regardless of settings.\n\n\t\t\t// If componentTagData isn’t defined, check for el and use it if it’s defined;\n\t\t\t// otherwise, an empty object is needed for componentTagData.\n\t\t\tif (componentTagData === undefined) {\n\t\t\t\tif (el === undefined) {\n\t\t\t\t\tcomponentTagData = {};\n\t\t\t\t} else {\n\t\t\t\t\tcomponentTagData = el;\n\t\t\t\t\tel = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create an element if it doesn’t exist and make it available outside of this\n\t\t\tif (el === undefined) {\n\t\t\t\tel = DOCUMENT().createElement(this.tag);\n\t\t\t\tel[createdByCanComponentSymbol] = true;\n\t\t\t}\n\t\t\tthis.element = el;\n\n\t\t\t// Hook up any <content> with which the component was instantiated\n\t\t\tvar componentContent = componentTagData.content;\n\t\t\tif (componentContent !== undefined) {\n\t\t\t\t// Check if it’s already a renderer function or\n\t\t\t\t// a string that needs to be parsed by stache\n\t\t\t\tif (typeof componentContent === \"function\") {\n\t\t\t\t\tcomponentTagData.subtemplate = componentContent;\n\t\t\t\t} else if (typeof componentContent === \"string\") {\n\t\t\t\t\tcomponentTagData.subtemplate = stache(componentContent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for the component being instantiated with a scope\n\t\t\tvar componentScope = componentTagData.scope;\n\t\t\tif (componentScope !== undefined && componentScope instanceof Scope === false) {\n\t\t\t\tcomponentTagData.scope = new Scope(componentScope);\n\t\t\t}\n\n\t\t\t// Hook up any templates with which the component was instantiated\n\t\t\tvar componentTemplates = componentTagData.templates;\n\t\t\tif (componentTemplates !== undefined) {\n\t\t\t\tcanReflect.eachKey(componentTemplates, function(template, name) {\n\t\t\t\t\t// Check if it’s a string that needs to be parsed by stache\n\t\t\t\t\tif (typeof template === \"string\") {\n\t\t\t\t\t\tvar debugName = name + \" template\";\n\t\t\t\t\t\tcomponentTemplates[name] = stache(debugName, template);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// an array of teardown stuff that should happen when the element is removed\n\t\t\tvar teardownFunctions = [];\n\t\t\tvar initialViewModelData = {};\n\t\t\tvar callTeardownFunctions = function() {\n\t\t\t\t\tfor (var i = 0, len = teardownFunctions.length; i < len; i++) {\n\t\t\t\t\t\tteardownFunctions[i]();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\tvar preventDataBindings = domData.get.call(el, \"preventDataBindings\");\n\t\t\tvar viewModel, frag;\n\n\t\t\t// ## Scope\n\t\t\tvar teardownBindings;\n\t\t\tif (preventDataBindings) {\n\t\t\t\tviewModel = el[viewModelSymbol];\n\t\t\t} else {// Set up the bindings\n\t\t\t\tvar setupFn;\n\t\t\t\tif (componentTagData.setupBindings) {\n\t\t\t\t\tsetupFn = componentTagData.setupBindings;\n\t\t\t\t} else if (componentTagData.viewModel) {\n\t\t\t\t\t// Component is being instantiated with a viewModel\n\t\t\t\t\tsetupFn = getSetupFunctionForComponentVM(componentTagData.viewModel);\n\t\t\t\t} else {\n\t\t\t\t\tsetupFn = function(el, callback, data) {\n\t\t\t\t\t\treturn stacheBindings.behaviors.viewModel(el, componentTagData, callback, data);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tteardownBindings = setupFn(el, function(initialViewModelData) {\n\n\t\t\t\t\tvar ViewModel = component.constructor.ViewModel,\n\t\t\t\t\t\tviewModelHandler = component.constructor.viewModelHandler,\n\t\t\t\t\t\tviewModelInstance = component.constructor.viewModelInstance;\n\n\t\t\t\t\tif(viewModelHandler) {\n\t\t\t\t\t\tvar scopeResult = viewModelHandler.call(component, initialViewModelData, componentTagData.scope, el);\n\t\t\t\t\t\tif (canReflect.isObservableLike(scopeResult) && canReflect.isMapLike(scopeResult) ) {\n\t\t\t\t\t\t\t// If the function returns a can.Map, use that as the viewModel\n\t\t\t\t\t\t\tviewModelInstance = scopeResult;\n\t\t\t\t\t\t} else if (canReflect.isObservableLike(scopeResult.prototype) && canReflect.isMapLike(scopeResult.prototype)) {\n\t\t\t\t\t\t\t// If `scopeResult` is of a `can.Map` type, use it to wrap the `initialViewModelData`\n\t\t\t\t\t\t\tViewModel = scopeResult;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise extend `SimpleMap` with the `scopeResult` and initialize it with the `initialViewModelData`\n\t\t\t\t\t\t\tViewModel = SimpleMap.extend(scopeResult);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(ViewModel) {\n\t\t\t\t\t\tviewModelInstance = new component.constructor.ViewModel(initialViewModelData);\n\t\t\t\t\t}\n\t\t\t\t\tviewModel = viewModelInstance;\n\t\t\t\t\treturn viewModelInstance;\n\t\t\t\t}, initialViewModelData);\n\t\t\t}\n\n\t\t\t// Set `viewModel` to `this.viewModel` and set it to the element's `data` object as a `viewModel` property\n\t\t\tthis.viewModel = viewModel;\n\n\t\t\tel[viewModelSymbol] = viewModel;\n\t\t\tel.viewModel = viewModel;\n\t\t\tdomData.set.call(el, \"preventDataBindings\", true);\n\n\t\t\t// ## Helpers\n\n\t\t\t// Setup helpers to callback with `this` as the component\n\t\t\tif(this.helpers !== undefined) {\n\t\t\t\tcanReflect.eachKey(this.helpers, function(val, prop) {\n\t\t\t\t\tif (typeof val === \"function\") {\n\t\t\t\t\t\toptions.helpers[prop] = val.bind(viewModel);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\n\t\t\t// ## `events` control\n\n\t\t\t// Create a control to listen to events\n\t\t\tif(this.constructor.Control) {\n\t\t\t\tthis._control = new this.constructor.Control(el, {\n\t\t\t\t\t// Pass the viewModel to the control so we can listen to it's changes from the controller.\n\t\t\t\t\tscope: this.viewModel,\n\t\t\t\t\tviewModel: this.viewModel,\n\t\t\t\t\tdestroy: callTeardownFunctions\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tvar removalDisposal = domMutate.onNodeRemoval(el, function () {\n\t\t\t\t\tvar doc = el.ownerDocument;\n\t\t\t\t\tvar rootNode = doc.contains ? doc : doc.documentElement;\n\t\t\t\t\tif (!rootNode.contains(el)) {\n\t\t\t\t\t\tremovalDisposal();\n\t\t\t\t\t\tcallTeardownFunctions();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// ## Rendering\n\n\t\t\tvar leakScope = {\n\t\t\t\ttoLightContent: this.leakScope === true,\n\t\t\t\tintoShadowContent: this.leakScope === true\n\t\t\t};\n\n\t\t\tvar hasShadowTemplate = !!(this.constructor.renderer);\n\n\t\t\t// Get what we should render between the component tags\n\t\t\t// and the data for it.\n\t\t\tvar betweenTagsRenderer;\n\t\t\tvar betweenTagsTagData;\n\t\t\tif( hasShadowTemplate ) {\n\t\t\t\tvar shadowTagData;\n\t\t\t\tif (leakScope.intoShadowContent) {\n\t\t\t\t\t// Give access to the component's data and the VM\n\t\t\t\t\tshadowTagData = {\n\t\t\t\t\t\tscope: componentTagData.scope.add(this.viewModel, { viewModel: true }),\n\t\t\t\t\t\toptions: options\n\t\t\t\t\t};\n\n\t\t\t\t} else { // lexical\n\t\t\t\t\t// only give access to the VM\n\t\t\t\t\tshadowTagData = {\n\t\t\t\t\t\tscope: new Scope(this.viewModel, null, { viewModel: true }),\n\t\t\t\t\t\toptions: options\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Add a hookup for each <can-slot>\n\t\t\t\toptions.tags['can-slot'] = makeInsertionTagCallback('can-slot', componentTagData, shadowTagData, leakScope, function(el) {\n\t\t\t\t\tvar templates = componentTagData.templates;\n\t\t\t\t\tif (templates) {// This is undefined if the component is <self-closing/>\n\t\t\t\t\t\treturn templates[el.getAttribute(\"name\")];\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Add a hookup for <content>\n\t\t\t\toptions.tags.content = makeInsertionTagCallback('content',  componentTagData, shadowTagData, leakScope, function() {\n\t\t\t\t\treturn componentTagData.subtemplate;\n\t\t\t\t});\n\n\t\t\t\tbetweenTagsRenderer = this.constructor.renderer;\n\t\t\t\tbetweenTagsTagData = shadowTagData;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// No shadow template.\n\t\t\t\t// Render light template with viewModel on top\n\t\t\t\tvar lightTemplateTagData = {\n\t\t\t\t\tscope: componentTagData.scope.add(this.viewModel, {\n\t\t\t\t\t\tviewModel: true\n\t\t\t\t\t}),\n\t\t\t\t\toptions: options\n\t\t\t\t};\n\t\t\t\tbetweenTagsTagData = lightTemplateTagData;\n\t\t\t\tbetweenTagsRenderer = componentTagData.subtemplate || el.ownerDocument.createDocumentFragment.bind(el.ownerDocument);\n\t\t\t}\n\t\t\tvar disconnectedCallback,\n\t\t\t\tcomponentInPage;\n\n\t\t\t// Keep a nodeList so we can kill any directly nested nodeLists within this component\n\t\t\tvar nodeList = nodeLists.register([], function() {\n\t\t\t\tcomponent._torndown = true;\n\t\t\t\tdomEvents.dispatch(el, \"beforeremove\", false);\n\t\t\t\tif(teardownBindings) {\n\t\t\t\t\tteardownBindings();\n\t\t\t\t}\n\t\t\t\tif(disconnectedCallback) {\n\t\t\t\t\tdisconnectedCallback(el);\n\t\t\t\t} else if(typeof viewModel.stopListening === \"function\"){\n\t\t\t\t\tviewModel.stopListening();\n\t\t\t\t}\n\t\t\t}, componentTagData.parentNodeList || true, false);\n\t\t\tnodeList.expression = \"<\" + this.tag + \">\";\n\t\t\tteardownFunctions.push(function() {\n\t\t\t\tnodeLists.unregister(nodeList);\n\t\t\t});\n\t\t\tthis.nodeList = nodeList;\n\n\t\t\tfrag = betweenTagsRenderer(betweenTagsTagData.scope, betweenTagsTagData.options, nodeList);\n\n\t\t\t// Append the resulting document fragment to the element\n\t\t\tdomMutateNode.appendChild.call(el, frag);\n\n\t\t\t// update the nodeList with the new children so the mapping gets applied\n\t\t\tnodeLists.update(nodeList, getChildNodes(el));\n\n\t\t\tif(viewModel && viewModel.connectedCallback) {\n\t\t\t\tcomponentInPage = DOCUMENT().body.contains(el);\n\n\t\t\t\tif(componentInPage) {\n\t\t\t\t\tdisconnectedCallback = viewModel.connectedCallback(el);\n\t\t\t\t} else {\n\t\t\t\t\tvar insertionDisposal = domMutate.onNodeInsertion(el, function () {\n\t\t\t\t\t\tinsertionDisposal();\n\t\t\t\t\t\tdisconnectedCallback = viewModel.connectedCallback(el);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tcomponent._torndown = false;\n\t\t}\n\t});\n\n// This adds support for components being rendered as values in stache templates\nComponent.prototype[viewInsertSymbol] = function(viewData) {\n\tif(this._torndown) {\n\t\tthis.setup.apply(this,this._initialArgs);\n\t}\n\tviewData.nodeList.newDeepChildren.push(this.nodeList);\n\treturn this.element;\n};\n\nmodule.exports = namespace.Component = Component;\n"],"names":["paramReplacer","ComponentControl","Control","extend","_lookup","options","scope","window","_removeDelegateFromKey","key","replace","_isDelegate","_getDelegate","_action","methodName","controlInstance","hasObjectLookup","lastIndex","test","apply","this","arguments","setup","el","viewModel","prototype","call","off","_bindings","canReflect","eachKey","readyComputes","value","offValue","compute","handler","destroy","createdByCanComponentSymbol","canSymbol","getValueSymbol","for","setValueSymbol","viewInsertSymbol","viewModelSymbol","addContext","tagData","insertionElementTagData","vm","domData","set","teardown","stacheBindings","behaviors","initialData","hasDataBinding","bindingState","isSettingOnViewModel","SimpleMap","SimpleObservable","undefined","assign","add","makeInsertionTagCallback","tagName","componentTagData","shadowTagData","leakScope","getPrimaryTemplate","hookupFunction","template","subtemplate","renderingLightContent","tags","toLightContent","cloneFromRef","nodeList","nodeLists","register","parentNodeList","directlyNested","expression","getAttribute","frag","newNodes","toArray","getChildNodes","oldNodes","update","getSetupFunctionForComponentVM","componentInitVM","ObservationRecorder","ignore","makeViewModel","initialVMData","onCompleteBindings","onTeardowns","parent","propName","canGetParentValue","canSetParentValue","keysToRead","observeReader","reads","child","SettableObservable","read","newValue","setKeyValue","canBinding","Bind","queue","updateChildName","nodeName","toLowerCase","updateParentName","getName","startParent","parentValue","push","start","bind","stop","i","len","length","forEach","onTeardown","stache","addBindings","Component","Construct","self","events","size","process","env","NODE_ENV","isConstructorLike","canDev","warn","protoViewModel","ViewModel","Error","vmName","string","capitalize","camelize","tag","DefineMap","isObservableLike","isMapLike","viewModelHandler","canLog","viewModelInstance","renderer","view","viewName","viewCallbacks","_initialArgs","component","helpers","DOCUMENT","createElement","element","componentContent","content","componentScope","Scope","componentTemplates","templates","name","debugName","teardownBindings","setupFn","teardownFunctions","callTeardownFunctions","get","setupBindings","callback","data","initialViewModelData","constructor","scopeResult","val","prop","_control","removalDisposal","domMutate","onNodeRemoval","doc","ownerDocument","contains","documentElement","betweenTagsRenderer","betweenTagsTagData","disconnectedCallback","intoShadowContent","createDocumentFragment","_torndown","domEvents","dispatch","stopListening","unregister","domMutateNode","appendChild","connectedCallback","body","insertionDisposal","onNodeInsertion","viewData","newDeepChildren","namespace"],"mappings":"q+FAMA,IAAIA,cAAgB,gBAEhBC,iBAAmBC,WAAQC,OAAO,CAGpCC,QAAS,SAASC,GACjB,MAAO,CAACA,EAAQC,MAAOD,EAASE,SAIjCC,uBAAwB,SAAUC,GACjC,OAAOA,EAAIC,QAAQ,wBAAyB,KAG7CC,YAAa,SAASN,EAASI,GAC9B,MAAe,UAARA,GAA2B,cAARA,GAG3BG,aAAc,SAASP,EAASI,GAC/B,OAAOJ,EAAQI,IAEhBI,QAAS,SAASC,EAAYT,EAASU,GACtC,IAAIC,EAOJ,OALAhB,cAAciB,UAAY,EAE1BD,EAAkBhB,cAAckB,KAAKJ,IAGhCC,GAAmBC,OACvB,EAEOd,WAAQW,QAAQM,MAAMC,KAAMC,aAMtC,CACCC,MAAO,SAASC,EAAIlB,GAGnB,OAFAe,KAAKd,MAAQD,EAAQC,MACrBc,KAAKI,UAAYnB,EAAQmB,UAClBtB,WAAQuB,UAAUH,MAAMI,KAAKN,KAAMG,EAAIlB,IAE/CsB,IAAK,WAGAP,KAAKQ,WACRC,WAAWC,QAAQV,KAAKQ,UAAUG,eAAiB,GAAI,SAASC,GAC/DH,WAAWI,SAASD,EAAME,QAASF,EAAMG,WAI3CjC,WAAQuB,UAAUE,IAAIR,MAAMC,KAAMC,WAClCD,KAAKQ,UAAUG,cAAgB,IAEhCK,QAAS,WACRlC,WAAQuB,UAAUW,QAAQjB,MAAMC,KAAMC,WACF,mBAAzBD,KAAKf,QAAQ+B,SACvBhB,KAAKf,QAAQ+B,QAAQjB,MAAMC,KAAMC,sBAKpBpB,iBCtBboC,4BAA8BC,UAAU,6BACxCC,eAAiBD,UAAUE,IAAI,gBAC/BC,eAAiBH,UAAUE,IAAI,gBAC/BE,iBAAmBJ,UAAUE,IAAI,kBACjCG,gBAAkBL,UAAUE,IAAI,iBAWpC,SAASI,WAAWrB,EAAIsB,EAASC,GAChC,IAAIC,EAEJC,QAAQC,IAAIvB,KAAKH,EAAI,uBAAuB,GAI5C,IAAI2B,EAAWC,eAAeC,UAAU5B,UAAUD,EAAIuB,EAAyB,SAASO,EAAaC,EAAgBC,GAEpH,OACQR,EADLQ,IAAsD,IAAtCA,EAAaC,qBACnB,IAAIC,UAAUJ,GAEd,IAAIK,iBAAiBL,SAEhCM,GAAW,GAGd,OAAIT,EAIIU,OAAQA,OAAO,GAAIf,GAAU,CACnCK,SAAUA,EACV5C,MAAOuC,EAAQvC,MAAMuD,IAAId,KAJnBF,EAWT,SAASiB,yBAAyBC,EAASC,EAAkBC,EAAeC,EAAWC,GACtF,IAAI9D,EAAU4D,EAAc5D,QAE5B,OAAO,SAAS+D,EAAe7C,EAAIuB,GAClC,IAAIuB,EAAWF,EAAmB5C,IAAOuB,EAAwBwB,YAChEC,EAAwBF,IAAavB,EAAwBwB,YAE9D,GAAID,EAAU,CAWb,IAAIxB,SARGxC,EAAQmE,KAAKT,GAmBlBlB,EATE0B,EAEAL,EAAUO,eAOF7B,WAAWrB,EAAI,CACxBjB,MAAOwC,EAAwBxC,MAAMoE,eACrCrE,QAASyC,EAAwBzC,SAC/ByC,GAIOF,WAAWrB,EAAIyC,EAAkBlB,GAKlCF,WAAWrB,EAAIuB,EAAyBA,GAMnD,IAAI6B,EAAWC,UAAUC,SAAS,CAACtD,GAAK,WACpCsB,EAAQK,UACVL,EAAQK,YAEPJ,EAAwBgC,iBAAkB,EAAMhC,EAAwBiC,gBAC3EJ,EAASK,WAAa,mBAAmBzD,EAAG0D,aAAa,QAAQ,MAEjE,IAAIC,EAAOb,EAASxB,EAAQvC,MAAOuC,EAAQxC,QAASsE,GAChDQ,EAAWtD,WAAWuD,QAASC,WAAcH,IAC7CI,EAAWV,UAAUW,OAAOZ,EAAUQ,GAC1CP,UAAUlE,QAAQ4E,EAAUJ,GAI5B7E,EAAQmE,KAAKT,GAAWK,IAO3B,SAASoB,+BAA+BC,GAEvC,OAAOC,oBAAoBC,OAAO,SAASpE,EAAIqE,EAAeC,GAC7D,IAEIrE,EAFAsE,EAAqB,GACrBC,EAAc,GAKlBlE,WAAWC,QAAQ2D,EAAiB,SAASO,EAAQC,GACpD,IAAIC,EAA8B,MAAVF,KAAoBA,EAAOzD,gBAC/C4D,EAA8B,MAAVH,KAAoBA,EAAOvD,gBAGnD,IAA0B,IAAtByD,GAA8BC,EAAmB,CAGpD,IAAIC,EAAaC,cAAcC,MAAML,GACjCM,EAAQ,IAAIC,iBACf,WACC,OAAOH,cAAcI,KAAKjF,EAAW4E,GAAYpE,OAElD,SAAS0E,GACR7E,WAAW8E,YAAYnF,EAAWyE,EAAUS,KAK1CE,EAAa,IAAIC,KAAK,CACzBN,MAAOA,EACPP,OAAQA,EACRc,MAAO,QAKPC,gBAAiB,oBAAsBd,EAAW,QAAU1E,EAAGyF,SAASC,cAAgB,IACxFC,iBAAkB,UAAYrF,WAAWsF,QAAQnB,GAAU,QAAUzE,EAAGyF,SAASC,cAAgB,MAKlGL,EAAWQ,eAGe,IAAtBlB,IACHL,EAAcI,GAAYW,EAAWS,aAItCvB,EAAmBwB,KAAKV,EAAWW,MAAMC,KAAKZ,IAG9Cb,EAAYuB,KAAKV,EAAWa,KAAKD,KAAKZ,SAItCf,EAAcI,GAAYD,IAK5BxE,EAAYoE,EAAcC,GAG1B,IAAK,IAAI6B,EAAI,EAAGC,EAAM7B,EAAmB8B,OAAQF,EAAIC,EAAKD,IACzD5B,EAAmB4B,KAIpB,OAAO,WACN3B,EAAY8B,QAAQ,SAASC,GAC5BA,SAnLJC,OAAOC,YAAY7E,gBAyLnB,IAAI8E,UAAYC,UAAU/H,OAGzB,CAMCmB,MAAO,WAKN,GAJA4G,UAAU5G,MAAMH,MAAMC,KAAMC,WAIxB4G,UAAW,CACd,IAAIE,EAAO/G,UAGkBuC,IAA1BvC,KAAKK,UAAU2G,QAAmE,IAA3CvG,WAAWwG,KAAKjH,KAAKK,UAAU2G,UACxEhH,KAAKlB,QAAUD,QAAiBE,OAAOiB,KAAKK,UAAU2G,SAI1B,eAAzBE,UAAQC,IAAIC,UAEXpH,KAAKK,UAAUD,WAAaK,WAAW4G,kBAAkBrH,KAAKK,UAAUD,YAC3EkH,IAAOC,KAAK,4NASd,IAAIC,EAAiBxH,KAAKK,UAAUD,WAAaJ,KAAKK,UAAUnB,MAEhE,GAAGsI,GAAkBxH,KAAKK,UAAUoH,UACnC,MAAM,IAAIC,MAAM,4DAEjB,IAAIC,EAASC,WAAOC,WAAYD,WAAOE,SAAS9H,KAAKK,UAAU0H,MAAO,KAgDtE,GA/CG/H,KAAKK,UAAUoH,UACsB,mBAA7BzH,KAAKK,UAAUoH,UACxBzH,KAAKyH,UAAYzH,KAAKK,UAAUoH,UAEhCzH,KAAKyH,UAAYO,UAAUjJ,OAAO4I,EAAQ,GAAI3H,KAAKK,UAAUoH,WAI3DD,EAC2B,mBAAnBA,EACN/G,WAAWwH,iBAAiBT,EAAenH,YAAcI,WAAWyH,UAAUV,EAAenH,WAC/FL,KAAKyH,UAAYD,EAEjBxH,KAAKmI,iBAAmBX,EAGtB/G,WAAWwH,iBAAiBT,IAAmB/G,WAAWyH,UAAUV,IAEzC,eAAzBN,UAAQC,IAAIC,UACfgB,OAAOb,KAAK,kBAAkBvH,KAAKK,UAAU0H,IAAI,2DAGlD/H,KAAKqI,kBAAoBb,IAEzBY,OAAOb,KAAK,kBAAkBvH,KAAKK,UAAU0H,IAAI,qDACjD/H,KAAKyH,UAAYpF,UAAUtD,OAAO4I,EAAO,GAAGH,IAI9CxH,KAAKyH,UAAYpF,UAAUtD,OAAO4I,EAAO,GAAG,IAK1C3H,KAAKK,UAAU4C,WAEW,eAAzBiE,UAAQC,IAAIC,UACfgB,OAAOb,KAAK,6HAGbvH,KAAKsI,SAAWtI,KAAKK,UAAU4C,UAE5BjD,KAAKK,UAAUkI,OAClBvI,KAAKsI,SAAWtI,KAAKK,UAAUkI,MAIH,iBAAlBvI,KAAKsI,SAAuB,CACtC,IAAIE,EAAWZ,WAAOC,WAAYD,WAAOE,SAAS9H,KAAKK,UAAU0H,MAAO,OACxE/H,KAAKsI,SAAW3B,OAAO6B,EAAUxI,KAAKsI,UAIvCG,cAAcV,IAAI/H,KAAKK,UAAU0H,IAAK,SAAS5H,EAAIsB,QAGVc,IAApCpC,EAAGc,8BACN,IAAI8F,EAAK5G,EAAIsB,QAKf,CAIFvB,MAAO,SAASC,EAAIyC,GACnB5C,KAAK0I,aAAe,CAACvI,EAAGyC,GACxB,IAAI+F,EAAY3I,KACZf,EAAU,CACb2J,QAAS,GACTxF,KAAM,SAOkBb,IAArBK,SACQL,IAAPpC,EACHyC,EAAmB,IAEnBA,EAAmBzC,EACnBA,OAAKoC,SAKIA,IAAPpC,KACHA,EAAK0I,cAAWC,cAAc9I,KAAK+H,MAChC9G,8BAA+B,GAEnCjB,KAAK+I,QAAU5I,EAGf,IAAI6I,EAAmBpG,EAAiBqG,aACf1G,IAArByG,IAG6B,mBAArBA,EACVpG,EAAiBM,YAAc8F,EACO,iBAArBA,IACjBpG,EAAiBM,YAAcyD,OAAOqC,KAKxC,IAAIE,EAAiBtG,EAAiB1D,WACfqD,IAAnB2G,GAAgCA,aAA0BC,QAAU,IACvEvG,EAAiB1D,MAAQ,IAAIiK,MAAMD,IAIpC,IAAIE,EAAqBxG,EAAiByG,eACf9G,IAAvB6G,GACH3I,WAAWC,QAAQ0I,EAAoB,SAASnG,EAAUqG,GAEzD,GAAwB,iBAAbrG,EAAuB,CACjC,IAAIsG,EAAYD,EAAO,YACvBF,EAAmBE,GAAQ3C,OAAO4C,EAAWtG,MAMhD,IAQI7C,EAAW0D,EAGX0F,EAICC,EAfDC,EAAoB,GAEpBC,EAAwB,WAC1B,IAAK,IAAIrD,EAAI,EAAGC,EAAMmD,EAAkBlD,OAAQF,EAAIC,EAAKD,IACxDoD,EAAkBpD,MAGK1E,QAAQgI,IAAItJ,KAAKH,EAAI,uBAM9CC,EAAYD,EAAGoB,kBAIdkI,EADG7G,EAAiBiH,cACVjH,EAAiBiH,cACjBjH,EAAiBxC,UAEjBgE,+BAA+BxB,EAAiBxC,WAEhD,SAASD,EAAI2J,EAAUC,GAChC,OAAOhI,eAAeC,UAAU5B,UAAUD,EAAIyC,EAAkBkH,EAAUC,IAG5EP,EAAmBC,EAAQtJ,EAAI,SAAS6J,GAEvC,IAAIvC,EAAYkB,EAAUsB,YAAYxC,UACrCU,EAAmBQ,EAAUsB,YAAY9B,iBACzCE,EAAoBM,EAAUsB,YAAY5B,kBAE3C,GAAGF,EAAkB,CACpB,IAAI+B,EAAc/B,EAAiB7H,KAAKqI,EAAWqB,EAAsBpH,EAAiB1D,MAAOiB,GAC7FM,WAAWwH,iBAAiBiC,IAAgBzJ,WAAWyH,UAAUgC,GAEpE7B,EAAoB6B,EAGpBzC,EAFUhH,WAAWwH,iBAAiBiC,EAAY7J,YAAcI,WAAWyH,UAAUgC,EAAY7J,WAErF6J,EAGA7H,UAAUtD,OAAOmL,GAQ/B,OAJGzC,IACFY,EAAoB,IAAIM,EAAUsB,YAAYxC,UAAUuC,IAEzD5J,EAAYiI,EACLA,GAjDkB,KA2E3B,GArBArI,KAAKI,UAAYA,EAEjBD,EAAGoB,iBAAmBnB,EACtBD,EAAGC,UAAYA,EACfwB,QAAQC,IAAIvB,KAAKH,EAAI,uBAAuB,QAKxBoC,IAAjBvC,KAAK4I,SACPnI,WAAWC,QAAQV,KAAK4I,QAAS,SAASuB,EAAKC,GAC3B,mBAARD,IACVlL,EAAQ2J,QAAQwB,GAAQD,EAAI/D,KAAKhG,MASjCJ,KAAKiK,YAAYnL,QACnBkB,KAAKqK,SAAW,IAAIrK,KAAKiK,YAAYnL,QAAQqB,EAAI,CAEhDjB,MAAOc,KAAKI,UACZA,UAAWJ,KAAKI,UAChBY,QAAS2I,SAGV,IAAIW,EAAkBC,UAAUC,cAAcrK,EAAI,WACjD,IAAIsK,EAAMtK,EAAGuK,eACED,EAAIE,SAAWF,EAAMA,EAAIG,iBAC1BD,SAASxK,KACtBmK,IACAX,OAOH,IASIkB,EACAC,EAECjI,EA4CDkI,EAxDAjI,EAAY,CACfO,gBAAmC,IAAnBrD,KAAK8C,UACrBkI,mBAAsC,IAAnBhL,KAAK8C,YAGE9C,KAAKiK,YAAoB,UAgDnDa,EAN2B,CAC1B5L,MAAO0D,EAAiB1D,MAAMuD,IAAIzC,KAAKI,UAAW,CACjDA,WAAW,IAEZnB,QAASA,GAGV4L,EAAsBjI,EAAiBM,aAAe/C,EAAGuK,cAAcO,uBAAuB7E,KAAKjG,EAAGuK,iBAvCrG7H,EAFGC,EAAUkI,kBAEG,CACf9L,MAAO0D,EAAiB1D,MAAMuD,IAAIzC,KAAKI,UAAW,CAAEA,WAAW,IAC/DnB,QAASA,GAKM,CACfC,MAAO,IAAIiK,MAAMnJ,KAAKI,UAAW,KAAM,CAAEA,WAAW,IACpDnB,QAASA,GAKXA,EAAQmE,KAAK,YAAcV,yBAAyB,WAAYE,EAAkBC,EAAeC,EAAW,SAAS3C,GACpH,IAAIkJ,EAAYzG,EAAiByG,UACjC,GAAIA,EACH,OAAOA,EAAUlJ,EAAG0D,aAAa,WAKnC5E,EAAQmE,KAAK6F,QAAUvG,yBAAyB,UAAYE,EAAkBC,EAAeC,EAAW,WACvG,OAAOF,EAAiBM,cAGzB2H,EAAsB7K,KAAKiK,YAAY3B,SACvCwC,EAAqBjI,GAkBtB,IAAIU,EAAWC,UAAUC,SAAS,GAAI,WACrCkF,EAAUuC,WAAY,EACtBC,UAAUC,SAASjL,EAAI,gBAAgB,GACpCqJ,GACFA,IAEEuB,EACFA,EAAqB5K,GACuB,mBAA5BC,EAAUiL,eAC1BjL,EAAUiL,iBAETzI,EAAiBc,iBAAkB,GAAM,GAe5C,GAdAH,EAASK,WAAa,IAAM5D,KAAK+H,IAAM,IACvC2B,EAAkBxD,KAAK,WACtB1C,UAAU8H,WAAW/H,KAEtBvD,KAAKuD,SAAWA,EAEhBO,EAAO+G,EAAoBC,EAAmB5L,MAAO4L,EAAmB7L,QAASsE,GAGjFgI,cAAcC,YAAYlL,KAAKH,EAAI2D,GAGnCN,UAAUW,OAAOZ,EAAUU,WAAc9D,IAEtCC,GAAaA,EAAUqL,kBAGzB,GAFkB5C,cAAW6C,KAAKf,SAASxK,GAG1C4K,EAAuB3K,EAAUqL,kBAAkBtL,QAEnD,IAAIwL,EAAoBpB,UAAUqB,gBAAgBzL,EAAI,WACrDwL,IACAZ,EAAuB3K,EAAUqL,kBAAkBtL,KAKtDwI,EAAUuC,WAAY,KAKzBrE,UAAUxG,UAAUiB,kBAAoB,SAASuK,GAKhD,OAJG7L,KAAKkL,WACPlL,KAAKE,MAAMH,MAAMC,KAAKA,KAAK0I,cAE5BmD,EAAStI,SAASuI,gBAAgB5F,KAAKlG,KAAKuD,UACrCvD,KAAK+I,SAGb,iBAAiBgD,UAAUlF,UAAYA"}