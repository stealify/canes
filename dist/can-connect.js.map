{"version":3,"file":"can-connect.js","sources":["../node_modules/can-connect/cache-requests/cache-requests.js","../node_modules/can-connect/data/memory-cache/memory-cache.js","../node_modules/can-connect/can/super-map/super-map.js","../node_modules/can-connect/can/base-map/base-map.js","../node_modules/can-connect/all.js"],"sourcesContent":["var connect = require(\"../can-connect\");\nvar getItems = require(\"../helpers/get-items\");\nvar forEach = Array.prototype.forEach;\n\n\n/**\n * @module can-connect/cache-requests/cache-requests cache-requests\n * @parent can-connect.behaviors\n * @group can-connect/cache-requests/cache-requests.data data interface\n * @group can-connect/cache-requests/cache-requests.queryLogic queryLogic\n *\n * Cache response data and use it to prevent unnecessary future requests or make future requests smaller.\n *\n * @signature `cacheRequests( baseConnection )`\n *\n *   Provide an implementation of [can-connect/cache-requests/cache-requests.getListData] that uses [can-connect/base/base.queryLogic] to\n *   determine what data is already in the [can-connect/base/base.cacheConnection cache] and what data needs to be\n *   loaded from the base connection.\n *\n *   It then gets data from the cache and the base connection (if needed), merges it, and returns it. Any data returned\n *   from the base connection is added to the cache.\n *\n *   @param {{}} baseConnection `can-connect` connection object that is having the `cache-requests` behavior added\n *   on to it. Should already contain the behaviors that provide the [can-connect/DataInterface]\n *   (e.g [can-connect/data/url/url]). If the `connect` helper is used to build the connection, the behaviors will\n *   automatically be ordered as required.\n *\n *   @return {Object} A `can-connect` connection containing the methods provided by `cache-requests`.\n *\n *\n * @body\n *\n * ## Use\n *\n * Use `cache-requests` in combination with a cache like [can-connect/data/memory-cache/memory-cache] or\n * [can-connect/data/localstorage-cache/localstorage-cache].  For example, to make it so response data is cached\n * in memory:\n *\n * ```js\n * var memoryStore = require(\"can-memory-store\");\n * var dataUrl = require(\"can-connect/data/url/url\");\n * var cacheRequests = require(\"can-connect/cache-requests/cache-requests\");\n * var queryLogic = require(\"can-query-logic\");\n *\n * var todoQueryLogic = new QueryLogic({});\n *\n * var cacheConnection = memoryStore({queryLogic: todoQueryLogic});\n * var todoConnection = connect([dataUrl, cacheRequests],{\n *   cacheConnection: cacheConnection,\n *   url: \"/todos\",\n *   queryLogic: todoQueryLogic\n * });\n * ```\n *\n * Now if today's todos are loaded:\n *\n * ```js\n * todoConnection.getListData({filter: {due: \"today\"}});\n * ```\n *\n * And later, a subset of those todos are loaded:\n *\n * ```js\n * todoConnection.getListData({filter: {due: \"today\", status: \"critical\"}});\n * ```\n *\n * The second request will be created from the original request's data.\n *\n * ## QueryLogic Usage\n *\n * `cache-requests` will \"fill-in\" the `cacheConnection` using [can-query-logic queryLogic].\n *\n * For example, if you requested paginated data like:\n *\n * ```\n * todoConnection.getListData({filter: {status: \"critical\"}})\n * ```\n *\n * And then later requested:\n *\n * ```\n * todoConnection.getListData({})\n * ```\n *\n * `cache-requests` will only request `{filter: {status: [\"low\",\"medium\"]}}`, merging\n * that response with the data already present in the cache.\n *\n * That configuration looks like:\n *\n * ```js\n * var memoryStore = require(\"can-memory-store\");\n * var dataUrl = require(\"can-connect/data/url/url\");\n * var cacheRequests = require(\"can-connect/cache-requests/cache-requests\");\n * var queryLogic = require(\"can-query-logic\");\n *\n * var todoQueryLogic = new QueryLogic({\n *   keys: {\n *     status: QueryLogic.makeEnum([\"low\",\"medium\",\"critical\"])\n *   }\n * });\n *\n * var cacheConnection = memoryStore({queryLogic: todoQueryLogic});\n * var todoConnection = connect([dataUrl, cacheRequests], {\n *   cacheConnection: cacheConnection,\n *   url: \"/todos\",\n *   queryLogic: todoQueryLogic\n * })\n * ```\n *\n * **Note:** `cacheConnection` shares the same queryLogic configuration as the primary connection.\n */\nvar cacheRequestsBehaviour = connect.behavior(\"cache-requests\",function(baseConnection){\n\n\treturn {\n\n\t\t/**\n\t\t * @function can-connect/cache-requests/cache-requests.getDiff getDiff\n\t\t * @parent can-connect/cache-requests/cache-requests.queryLogic\n\t\t *\n\t\t * Compares the cached queries to the requested query and returns a description of what subset can be loaded from the\n\t\t * cache and what subset must be loaded from the base connection.\n\t\t *\n\t\t * @signature `connection.getDiff( query, availableQueries )`\n\t\t *\n\t\t *   This determines the minimal amount of data that must be loaded from the base connection by going through each\n\t\t *   cached query (`availableQueries`) and doing a [can-query-logic.prototype.isSubset isSubset] check and a\n\t\t *   [can-query-logic.prototype.difference query difference] with the requested query (`query`).\n\t\t *\n\t\t *   If `query` is a subset of an `availableSet`, `{cached: query}` will be returned.\n\t\t *\n\t\t *   If `query` is neither a subset of, nor intersects with any `availableQueries`, `{needed: query}` is returned.\n\t\t *\n\t\t *   If `query` has an intersection with one or more `availableQueries`, a description of the difference that has the fewest\n\t\t *   missing elements will be returned. An example diff description looks like:\n\t\t *\n\t\t *   ```\n\t\t *   {\n\t\t *     needed: {start: 50, end: 99}, // the difference, the query that is not cached\n\t\t *     cached: {start: 0, end: 49}, // the intersection, the query that is cached\n\t\t *     count: 49 // the size of the needed query\n\t\t *   }\n\t\t *   ```\n\t\t *\n\t\t *   @param {can-query-logic/query} query The query that is being requested.\n\t\t *   @param {Array<can-query-logic/query>} availableQueries An array of [can-connect/connection.getSets available queries] in the\n\t\t *     [can-connect/base/base.cacheConnection cache].\n\t\t *   @return {Promise<{needed: can-query-logic/query, cached: can-query-logic/query, count: Integer}>} a difference description object. Described above.\n\t\t *\n\t\t */\n\t\tgetDiff: function( params, availableQueries ){\n\n\t\t\tvar minSets,\n\t\t\t\tself = this;\n\n\t\t\tforEach.call(availableQueries, function(query){\n\t\t\t\tvar curSets;\n\t\t\t\tvar difference = self.queryLogic.difference(params, query );\n\t\t\t\tif( self.queryLogic.isDefinedAndHasMembers(difference) ) {\n\t\t\t\t\tvar intersection = self.queryLogic.intersection(params, query);\n\t\t\t\t\tcurSets = {\n\t\t\t\t\t\tneeded: difference,\n\t\t\t\t\t\tcached: self.queryLogic.isDefinedAndHasMembers(intersection) ? intersection : false,\n\t\t\t\t\t\tcount: self.queryLogic.count(difference)\n\t\t\t\t\t};\n\t\t\t\t} else if( self.queryLogic.isSubset(params, query) ){\n\t\t\t\t\tcurSets = {\n\t\t\t\t\t\tcached: params,\n\t\t\t\t\t\tcount: 0\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif(curSets) {\n\t\t\t\t\tif(!minSets || curSets.count < minSets.count) {\n\t\t\t\t\t\tminSets = curSets;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif(!minSets) {\n\t\t\t\treturn {\n\t\t\t\t\tneeded: params\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tneeded: minSets.needed,\n\t\t\t\t\tcached: minSets.cached\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/cache-requests/cache-requests.unionMembers unionMembers\n\t\t * @parent can-connect/cache-requests/cache-requests.queryLogic\n\t\t *\n\t\t * Create the requested data set, a union of the cached and un-cached data.\n\t\t *\n\t\t * @signature `connection.unionMembers(set, diff, neededData, cachedData)`\n\t\t *\n\t\t *   Uses [can-query-logic.prototype.unionMembers] to merge the two queries of data (`neededData` & `cachedData`).\n\t\t *\n\t\t * @param {can-query-logic/query} query The parameters of the data set requested.\n\t\t * @param {Object} diff The result of [can-connect/cache-requests/cache-requests.getDiff].\n\t\t * @param {can-connect.listData} neededData The data loaded from the base connection.\n\t\t * @param {can-connect.listData} cachedData The data loaded from the [can-connect/base/base.cacheConnection].\n\t\t *\n\t\t * @return {can-connect.listData} A merged [can-connect.listData] representation of the the cached and requested data.\n\t\t */\n\t\tunionMembers: function(params, diff, neededItems, cachedItems){\n\t\t\t// using the diff, re-construct everything\n\t\t\treturn {data: this.queryLogic.unionMembers(diff.needed, diff.cached, getItems(neededItems), getItems(cachedItems))};\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/cache-requests/cache-requests.getListData getListData\n\t\t * @parent can-connect/cache-requests/cache-requests.data\n\t\t *\n\t\t * Only request data that isn't already present in the [can-connect/base/base.cacheConnection cache].\n\t\t *\n\t\t * @signature `connection.getListData(set)`\n\t\t *\n\t\t *   Overwrites a base connection's `getListData` to use data in the [can-connect/base/base.cacheConnection cache]\n\t\t *   whenever possible.  This works by [can-connect/connection.getSets getting the stored queries]\n\t\t *   from the [can-connect/base/base.cacheConnection cache] and\n\t\t *   doing a [can-connect/cache-requests/cache-requests.getDiff diff] to see what needs to be loaded from the base\n\t\t *   connection and what can be loaded from the [can-connect/base/base.cacheConnection cache].\n\t\t *\n\t\t *   With that information, this `getListData` requests data from the cache or the base connection as needed.\n\t\t *   Data loaded from different sources is combined via [can-connect/cache-requests/cache-requests.unionMembers].\n\t\t *\n\t\t * @param {can-query-logic/query} query the parameters of the list that is being requested.\n\t\t * @return {Promise<can-connect.listData>} a promise that returns an object conforming to the [can-connect.listData] format.\n\t\t */\n\t\tgetListData: function(set){\n\t\t\tset = set || {};\n\t\t\tvar self = this;\n\n\t\t\treturn this.cacheConnection.getSets(set).then(function(queries){\n\n\t\t\t\tvar diff = self.getDiff(set, queries);\n\n\t\t\t\tif(!diff.needed) {\n\t\t\t\t\treturn self.cacheConnection.getListData(diff.cached);\n\t\t\t\t} else if(!diff.cached) {\n\t\t\t\t\treturn baseConnection.getListData(diff.needed).then(function(data){\n\n\t\t\t\t\t\treturn self.cacheConnection.updateListData(getItems(data), diff.needed ).then(function(){\n\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tvar cachedPromise = self.cacheConnection.getListData(diff.cached);\n\t\t\t\t\tvar needsPromise = baseConnection.getListData(diff.needed);\n\n\t\t\t\t\tvar savedPromise = needsPromise.then(function(data){\n\t\t\t\t\t\treturn self.cacheConnection.updateListData(  getItems(data), diff.needed ).then(function(){\n\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\t// start the combine while we might be saving param and adding to cache\n\t\t\t\t\tvar combinedPromise = Promise.all([\n\t\t\t\t\t\tcachedPromise,\n\t\t\t\t\t\tneedsPromise\n\t\t\t\t\t]).then(function(result){\n\t\t\t\t\t\tvar cached = result[0],\n\t\t\t\t\t\t\tneeded = result[1];\n\t\t\t\t\t\treturn self.unionMembers( set, diff, needed, cached);\n\t\t\t\t\t});\n\n\t\t\t\t\treturn Promise.all([combinedPromise, savedPromise]).then(function(data){\n\t\t\t\t\t\treturn data[0];\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t};\n\n});\n\nmodule.exports = cacheRequestsBehaviour;\n\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\tvar validate = require(\"../helpers/validate\");\n}\nmodule.exports = validate(cacheRequestsBehaviour, ['getListData', 'cacheConnection']);\n//!steal-remove-end\n","\"use strict\";\n/**\n * @module can-connect/data/memory-cache/memory-cache memory-cache\n * @parent can-connect.deprecated\n * @group can-connect/data/memory-cache/memory-cache.data-methods data methods\n *\n * Saves raw data in JavaScript memory that disappears when the page refreshes.\n *\n * @deprecated {5.0} Use [can-memory-store] instead.\n *\n * @signature `memoryCache( baseConnection )`\n *\n *   Creates a cache of instances and a cache of sets of instances that is\n *   accessible to read via [can-connect/data/memory-cache/memory-cache.getSets],\n *   [can-connect/data/memory-cache/memory-cache.getData], and [can-connect/data/memory-cache/memory-cache.getListData].\n *   The caches are updated via [can-connect/data/memory-cache/memory-cache.createData],\n *   [can-connect/data/memory-cache/memory-cache.updateData], [can-connect/data/memory-cache/memory-cache.destroyData],\n *   and [can-connect/data/memory-cache/memory-cache.updateListData].\n *\n *   [can-connect/data/memory-cache/memory-cache.createData],\n *   [can-connect/data/memory-cache/memory-cache.updateData],\n *   [can-connect/data/memory-cache/memory-cache.destroyData] are able to move items in and out\n *   of sets.\n *\n * @body\n *\n * ## Use\n *\n * `data/memory-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n * [can-connect/cache-requests/cache-requests].\n *\n * ```js\n * var cacheConnection = connect([\n *   require(\"can-connect/data/memory-cache/memory-cache\")\n * ],{});\n *\n * var todoConnection = connect([\n *   require(\"can-connect/data/url/url\"),\n *   require(\"can-connect/fall-through-cache/fall-through-cache\")\n * ],\n * {\n *   url: \"/services/todos\",\n *   cacheConnection: cacheConnection\n * });\n * ```\n */\nvar memoryStore = require(\"can-memory-store\");\n\nmodule.exports = memoryStore;\n","\"use strict\";\nvar connect = require(\"../../can-connect\");\n\nvar constructor = require(\"../../constructor/constructor\");\nvar canMap = require(\"../map/map\");\nvar canRef = require(\"../ref/ref\");\nvar constructorStore = require(\"../../constructor/store/store\");\nvar dataCallbacks = require(\"../../data/callbacks/callbacks\");\nvar callbacksCache = require(\"../../data/callbacks-cache/callbacks-cache\");\nvar combineRequests = require(\"../../data/combine-requests/combine-requests\");\nvar localCache = require(\"../../data/localstorage-cache/localstorage-cache\");\nvar dataParse = require(\"../../data/parse/parse\");\nvar dataUrl = require(\"../../data/url/url\");\nvar fallThroughCache = require(\"../../fall-through-cache/fall-through-cache\");\nvar realTime = require(\"../../real-time/real-time\");\nvar callbacksOnce = require(\"../../constructor/callbacks-once/callbacks-once\");\nvar GLOBAL = require(\"can-globals/global/global\");\n\nvar $ = GLOBAL().$;\n\nconnect.superMap = function(options){\n\n\tvar behaviors = [\n\t\tconstructor,\n\t\tcanMap,\n\t\tcanRef,\n\t\tconstructorStore,\n\t\tdataCallbacks,\n\t\tcombineRequests,\n\t\tdataParse,\n\t\tdataUrl,\n\t\trealTime,\n\t\tcallbacksOnce];\n\n\tif(typeof localStorage !== \"undefined\") {\n\t\tif(!options.cacheConnection) {\n\t\t\toptions.cacheConnection = connect([localCache],{\n\t\t\t\tname: options.name+\"Cache\",\n\t\t\t\tidProp: options.idProp,\n\t\t\t\tqueryLogic: options.queryLogic\n\t\t\t});\n\t\t}\n\t\tbehaviors.push(callbacksCache,fallThroughCache);\n\t}\n\t// Handles if jQuery isn't provided.\n\tif($ && $.ajax) {\n\t\toptions.ajax = $.ajax;\n\t}\n\treturn connect(behaviors,options);\n};\n\nmodule.exports = connect.superMap;\n","var connect = require(\"../../can-connect\");\n\nvar constructor = require(\"../../constructor/constructor\");\nvar canMap = require(\"../map/map\");\nvar canRef = require(\"../ref/ref\");\nvar constructorStore = require(\"../../constructor/store/store\");\nvar dataCallbacks = require(\"../../data/callbacks/callbacks\");\nvar callbacksCache = require(\"../../data/callbacks-cache/callbacks-cache\");\nvar dataParse = require(\"../../data/parse/parse\");\nvar dataUrl = require(\"../../data/url/url\");\nvar realTime = require(\"../../real-time/real-time\");\nvar callbacksOnce = require(\"../../constructor/callbacks-once/callbacks-once\");\nvar GLOBAL = require(\"can-globals/global/global\");\n\n\nvar $ = GLOBAL().$;\n\nconnect.baseMap = function(options){\n\n\tvar behaviors = [\n\t\tconstructor,\n\t\tcanMap,\n\t\tcanRef,\n\t\tconstructorStore,\n\t\tdataCallbacks,\n\t\tdataParse,\n\t\tdataUrl,\n\t\trealTime,\n\t\tcallbacksOnce\n\t];\n\n\t// Handles if jQuery isn't provided.\n\tif($ && $.ajax) {\n\t\toptions.ajax = $.ajax;\n\t}\n\n\treturn connect(behaviors,options);\n};\n\nmodule.exports = connect.baseMap;\n","\"use strict\";\nvar connect = require(\"./can-connect\");\n\nconnect.cacheRequests = require(\"./cache-requests/cache-requests\");\n\nconnect.constructor = require(\"./constructor/constructor\");\nconnect.constructorCallbacksOnce = require(\"./constructor/callbacks-once/callbacks-once\");\nconnect.constructorStore = require(\"./constructor/store/store\");\nconnect.dataCallbacks = require(\"./data/callbacks/callbacks\");\nconnect.dataCallbacksCache = require(\"./data/callbacks-cache/callbacks-cache\");\nconnect.dataCombineRequests = require(\"./data/combine-requests/combine-requests\");\nconnect.dataLocalStorageCache = require(\"./data/localstorage-cache/localstorage-cache\");\nconnect.dataMemoryCache = require(\"./data/memory-cache/memory-cache\");\nconnect.dataParse = require(\"./data/parse/parse\");\nconnect.dataUrl = require(\"./data/url/url\");\nconnect.fallThroughCache = require(\"./fall-through-cache/fall-through-cache\");\nconnect.realTime = require(\"./real-time/real-time\");\n\nconnect.superMap = require(\"./can/super-map/super-map\");\nconnect.baseMap = require('./can/base-map/base-map');\n\nmodule.exports = connect;\n"],"names":["forEach","Array","prototype","cacheRequestsBehaviour","connect","behavior","baseConnection","getDiff","params","availableQueries","minSets","self","this","call","query","curSets","difference","queryLogic","isDefinedAndHasMembers","intersection","needed","cached","count","isSubset","unionMembers","diff","neededItems","cachedItems","data","getItems","getListData","set","cacheConnection","getSets","then","queries","cachedPromise","needsPromise","savedPromise","updateListData","combinedPromise","Promise","all","result","process","env","NODE_ENV","validate","require$$0","memoryStore","$","GLOBAL","superMap","options","behaviors","constructor","canMap","canRef","constructorStore","dataCallbacks","combineRequests","dataParse","dataUrl","realTime","callbacksOnce","localStorage","localCache","name","idProp","push","callbacksCache","fallThroughCache","ajax","baseMap","cacheRequests","require$$1","constructorCallbacksOnce","require$$2","require$$3","require$$4","dataCallbacksCache","require$$5","dataCombineRequests","require$$6","dataLocalStorageCache","require$$7","dataMemoryCache","require$$8","require$$9","require$$10","require$$11","require$$12","require$$13","require$$14"],"mappings":"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"}