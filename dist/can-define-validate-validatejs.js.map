{"version":3,"file":"can-define-validate-validatejs.js","sources":["../node_modules/can-define-validate-validatejs/node_modules/can-validate-validatejs/can-validate-validatejs.js","../node_modules/can-define-validate-validatejs/can-define-validate-validatejs.js"],"sourcesContent":["var canReflect = require(\"can-reflect\");\nvar validatejs = require(\"validate.js\");\n\nvar makeValidator = function(constraints) {\n\treturn function(value) {\n\t\t// Returns an array or undefined\n\t\treturn validatejs.single(value, constraints);\n\t};\n};\n\nmakeValidator.many = function(constraints) {\n\treturn function(values) {\n\t\tvar rawErrors = validatejs(values, constraints, {\n\t\t\tformat: \"detailed\",\n\t\t\tfullMessages: false\n\t\t});\n\t\tvar errors;\n\n\t\tif (rawErrors) {\n\t\t\terrors = [];\n\t\t\tcanReflect.eachIndex(rawErrors, function(error) {\n\t\t\t\terrors.push({\n\t\t\t\t\tmessage: error.options.message || error.error,\n\t\t\t\t\trelated: [error.attribute]\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\treturn errors;\n\t};\n};\n\nmakeValidator.validatejs = validatejs;\n\nmodule.exports = makeValidator;\n","\"use strict\";\nvar validate = require(\"can-validate-validatejs\");\nvar define = require(\"can-define\");\nvar assign = require(\"can-assign\");\nvar canReflect = require(\"can-reflect\");\nvar formatErrors = require(\"can-validate\").formatErrors;\n\nvar getMapConstraints = function(Map) {\n\tvar constraints = {};\n\tcanReflect.eachKey(Map.prototype._define.definitions, function(prop, key) {\n\t\tif (prop.validate && canReflect.size(prop.validate)!== 0) {\n\t\t\tconstraints[key] = prop.validate;\n\t\t}\n\t});\n\treturn constraints;\n};\n\nvar validateMap = function(Map, validator) {\n\tvar mapDefinition = Map.prototype._define;\n\n\tMap.prototype.testSet = function() {\n\t\tvar values = {};\n\t\tvar useNewObject = false;\n\t\tif (arguments.length) {\n\t\t\t// Check if testing many values or just one\n\t\t\tif (typeof arguments[0] === \"object\" && Boolean(arguments[0])) {\n\t\t\t\tvalues = arguments[0];\n\t\t\t\tuseNewObject = Boolean(arguments[1]);\n\t\t\t}\n\n\t\t\t// Check if testing single value\n\t\t\tif (typeof arguments[0] === \"string\") {\n\t\t\t\tvalues[arguments[0]] = arguments[1];\n\t\t\t}\n\n\t\t\t// Merge values with existing map or with a new map\n\t\t\tif (useNewObject) {\n\t\t\t\tvalues = new Map(values);\n\t\t\t} else {\n\t\t\t\tvar mapClone = this.serialize();\n\t\t\t\tassign(mapClone, values);\n\t\t\t\tvalues = mapClone;\n\t\t\t}\n\t\t\treturn validator(values);\n\t\t} else {\n\t\t\treturn this.errors();\n\t\t}\n\t};\n\n\tMap.prototype.errors = function() {\n\t\tvar _errors = this._errors;\n\t\tvar errors;\n\t\tif (arguments.length) {\n\t\t\tvar errorsObj = formatErrors(_errors, \"errors-object\");\n\t\t\terrors = [];\n\n\t\t\tcanReflect.eachIndex(arguments, function(key) {\n\t\t\t\t[].push.apply(errors, errorsObj ? errorsObj[key] : []);\n\t\t\t});\n\t\t\terrors = errors.length > 0 ? errors : undefined;\n\t\t} else {\n\t\t\terrors = _errors;\n\t\t}\n\t\treturn errors;\n\t};\n\n\tdefine.property(\n\t\tMap.prototype,\n\t\t\"_errors\",\n\t\t{\n\t\t\tget: function() {\n\t\t\t\tvar errors = validator(this);\n\t\t\t\treturn errors;\n\t\t\t}\n\t\t},\n\t\tmapDefinition.dataInitializers,\n\t\tmapDefinition.computedInitializers\n\t);\n};\n\nvar decorator = function(Map) {\n\tvar constraints = getMapConstraints(Map);\n\tvar validator = validate.many(constraints);\n\n\tvalidateMap(Map, function(map) {\n\t\tvar errors = validator(map);\n\t\treturn formatErrors(errors, \"errors\");\n\t});\n};\n\ndecorator.validatejs = validate.validatejs;\n\nmodule.exports = decorator;\n"],"names":["makeValidator","constraints","value","validatejs","single","many","values","errors","rawErrors","format","fullMessages","canReflect","eachIndex","error","push","message","options","related","attribute","formatErrors","require$$0","getMapConstraints","Map","eachKey","prototype","_define","definitions","prop","key","validate","size","validateMap","validator","mapDefinition","testSet","useNewObject","arguments","length","Boolean","mapClone","this","serialize","assign","_errors","errorsObj","apply","undefined","define","property","get","dataInitializers","computedInitializers","decorator","map"],"mappings":"8tCAGA,IAAIA,cAAgB,SAASC,GAC5B,OAAO,SAASC,GAEf,OAAOC,WAAWC,OAAOF,EAAOD,KAIlCD,cAAcK,KAAO,SAASJ,GAC7B,OAAO,SAASK,GACf,IAIIC,EAJAC,EAAYL,WAAWG,EAAQL,EAAa,CAC/CQ,OAAQ,WACRC,cAAc,IAaf,OATIF,IACHD,EAAS,GACTI,WAAWC,UAAUJ,EAAW,SAASK,GACxCN,EAAOO,KAAK,CACXC,QAASF,EAAMG,QAAQD,SAAWF,EAAMA,MACxCI,QAAS,CAACJ,EAAMK,gBAIZX,IAITP,cAAcG,WAAaA,WAE3B,0BAAiBH,cC5BbmB,aAAeC,YAAwBD,aAEvCE,kBAAoB,SAASC,GAChC,IAAIrB,EAAc,GAMlB,OALAU,WAAWY,QAAQD,EAAIE,UAAUC,QAAQC,YAAa,SAASC,EAAMC,GAChED,EAAKE,UAA8C,IAAlClB,WAAWmB,KAAKH,EAAKE,YACzC5B,EAAY2B,GAAOD,EAAKE,YAGnB5B,GAGJ8B,YAAc,SAAST,EAAKU,GAC/B,IAAIC,EAAgBX,EAAIE,UAAUC,QAElCH,EAAIE,UAAUU,QAAU,WACvB,IAAI5B,EAAS,GACT6B,GAAe,EACnB,GAAIC,UAAUC,OAAQ,CAarB,GAX4B,iBAAjBD,UAAU,IAAmBE,QAAQF,UAAU,MACzD9B,EAAS8B,UAAU,GACnBD,EAAeG,QAAQF,UAAU,KAIN,iBAAjBA,UAAU,KACpB9B,EAAO8B,UAAU,IAAMA,UAAU,IAI9BD,EACH7B,EAAS,IAAIgB,EAAIhB,OACX,CACN,IAAIiC,EAAWC,KAAKC,YACpBC,OAAOH,EAAUjC,GACjBA,EAASiC,EAEV,OAAOP,EAAU1B,GAEjB,OAAOkC,KAAKjC,UAIde,EAAIE,UAAUjB,OAAS,WACtB,IACIA,EADAoC,EAAUH,KAAKG,QAEnB,GAAIP,UAAUC,OAAQ,CACrB,IAAIO,EAAYzB,aAAawB,EAAS,iBACtCpC,EAAS,GAETI,WAAWC,UAAUwB,UAAW,SAASR,GACxC,GAAGd,KAAK+B,MAAMtC,EAAQqC,EAAYA,EAAUhB,GAAO,MAEpDrB,EAASA,EAAO8B,OAAS,EAAI9B,OAASuC,OAEtCvC,EAASoC,EAEV,OAAOpC,GAGRwC,OAAOC,SACN1B,EAAIE,UACJ,UACA,CACCyB,IAAK,WAEJ,OADajB,EAAUQ,QAIzBP,EAAciB,iBACdjB,EAAckB,uBAIZC,UAAY,SAAS9B,GACxB,IAAIrB,EAAcoB,kBAAkBC,GAChCU,EAAYH,sBAASxB,KAAKJ,GAE9B8B,YAAYT,EAAK,SAAS+B,GACzB,IAAI9C,EAASyB,EAAUqB,GACvB,OAAOlC,aAAaZ,EAAQ,aAI9B6C,UAAUjD,WAAa0B,sBAAS1B,WAEhC,gCAAiBiD"}