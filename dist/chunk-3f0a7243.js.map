{"version":3,"file":"chunk-3f0a7243.js","sources":["../node_modules/can-diff/list/list.js"],"sourcesContent":["'use strict';\n\nvar canReflect = require(\"can-reflect\");\n\nvar slice = [].slice;\n// a b c\n// a b c d\n// [[2,0, d]]\n\n\nfunction defaultIdentity(a, b){\n    return a === b;\n}\n\nfunction makeIdentityFromMapSchema(typeSchema) {\n    if(typeSchema.identity && typeSchema.identity.length) {\n        return function identityCheck(a, b) {\n            var aId = canReflect.getIdentity(a, typeSchema),\n                bId = canReflect.getIdentity(b, typeSchema);\n            return aId === bId;\n        };\n    } else {\n        return defaultIdentity;\n    }\n}\n\nfunction makeIdentityFromListSchema(listSchema) {\n    return listSchema.values != null ?\n        makeIdentityFromMapSchema( canReflect.getSchema(listSchema.values) ) :\n        defaultIdentity;\n}\n\nfunction makeIdentity(oldList, oldListLength) {\n    var listSchema = canReflect.getSchema(oldList),\n        typeSchema;\n    if(listSchema != null) {\n        if(listSchema.values != null) {\n            typeSchema = canReflect.getSchema(listSchema.values);\n        } else {\n            return defaultIdentity;\n        }\n    }\n    if(typeSchema == null && oldListLength > 0) {\n        typeSchema = canReflect.getSchema( canReflect.getKeyValue(oldList, 0) );\n    }\n    if(typeSchema) {\n        return makeIdentityFromMapSchema(typeSchema);\n    } else {\n        return defaultIdentity;\n    }\n}\n\n\n\nfunction reverseDiff(oldDiffStopIndex, newDiffStopIndex, oldList, newList, identity) {\n\tvar oldIndex = oldList.length - 1,\n\t\tnewIndex =  newList.length - 1;\n\n\twhile( oldIndex > oldDiffStopIndex && newIndex > newDiffStopIndex) {\n\t\tvar oldItem = oldList[oldIndex],\n\t\t\tnewItem = newList[newIndex];\n\n\t\tif( identity( oldItem, newItem, oldIndex ) ) {\n\t\t\toldIndex--;\n\t\t\tnewIndex--;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t// use newIndex because it reflects any deletions\n\t\t\treturn [{\n                type: \"splice\",\n\t\t\t\tindex: newDiffStopIndex,\n\t\t\t \tdeleteCount: (oldIndex-oldDiffStopIndex+1),\n\t\t\t \tinsert: slice.call(newList, newDiffStopIndex,newIndex+1)\n\t\t\t}];\n\t\t}\n\t}\n\t// if we've reached of either the new or old list\n\t// we simply return\n\treturn [{\n        type: \"splice\",\n\t\tindex: newDiffStopIndex,\n\t\tdeleteCount: (oldIndex-oldDiffStopIndex+1),\n\t\tinsert: slice.call(newList, newDiffStopIndex,newIndex+1)\n\t}];\n\n}\n\n/**\n * @module {function} can-diff/list/list\n * @parent can-diff\n *\n * @description Return a difference of two lists.\n *\n * @signature `diffList( oldList, newList, [identity] )`\n *\n * Compares two lists and produces a sequence of patches that can be applied to make `oldList` take\n * the shape of `newList`.\n *\n * ```js\n * var diffList = require(\"can-diff/list/list\");\n *\n * console.log(diff([1], [1, 2])); // -> [{type: \"splice\", index: 1, deleteCount: 0, insert: [2]}]\n * console.log(diff([1, 2], [1])); // -> [{type: \"splice\", index: 1, deleteCount: 1, insert: []}]\n *\n * // with an optional identity function:\n * diffList(\n *     [{id:1},{id:2}],\n *     [{id:1},{id:3}],\n *     (a,b) => a.id === b.id\n * ); // -> [{type: \"splice\", index: 1, deleteCount: 1, insert: [{id:3}]}]\n * ```\n *\n * The patch algorithm is linear with respect to the length of the lists and therefore does not produce a\n * [perfect edit distance](https://en.wikipedia.org/wiki/Edit_distance) (which would be at least quadratic).\n *\n * It is designed to work with most common list change scenarios, when items are inserted or removed\n * to a list (as opposed to moved with in the last).\n *\n * For example, it is able to produce the following patches:\n *\n * ```js\n * diffList(\n *     [\"a\",\"b\",\"c\",\"d\"],\n *     [\"a\",\"b\",\"X\",\"Y\",\"c\",\"d\"]\n * ); // -> [{type: \"splice\", index: 2, deleteCount: 0, insert: [\"X\",\"Y\"]}]\n * ```\n *\n * @param  {ArrayLike} oldList The source array or list to diff from.\n * @param  {ArrayLike} newList The array or list to diff to.\n * @param  {function|can-reflect.getSchema} schemaOrIdentity An optional identity function or a schema with\n * an identity property for comparing elements.  If a `schemaOrIdentity` is not provided, the schema of\n * the `oldList` will be used.  If a schema can not be found, items a default identity function will be created\n * that checks if the two values are strictly equal `===`.\n * @return {Array} An array of [can-symbol/types/Patch] objects representing the differences\n *\n * Returns the difference between two ArrayLike objects (that have nonnegative\n * integer keys and the `length` property) as an array of patch objects.\n *\n * A patch object returned by this function has the following properties:\n * - **type**: the type of patch (`\"splice\"`).\n * - **index**:  the index of newList where the patch begins\n * - **deleteCount**: the number of items deleted from that index in newList\n * - **insert**: an Array of items newly inserted at that index in newList\n *\n * Patches should be applied in the order they are returned.\n */\n\nmodule.exports = function(oldList, newList, schemaOrIdentity){\n    var oldIndex = 0,\n\t\tnewIndex =  0,\n\t\toldLength = canReflect.size( oldList ),\n\t\tnewLength = canReflect.size( newList ),\n\t\tpatches = [];\n\n    var schemaType = typeof schemaOrIdentity,\n        identity;\n    if(schemaType === \"function\") {\n        identity = schemaOrIdentity;\n    } else if(schemaOrIdentity != null) {\n        if(schemaOrIdentity.type === \"map\") {\n            identity = makeIdentityFromMapSchema(schemaOrIdentity);\n        } else {\n            identity = makeIdentityFromListSchema(schemaOrIdentity);\n        }\n    } else {\n        identity = makeIdentity(oldList, oldLength);\n    }\n\n\n\n\twhile(oldIndex < oldLength && newIndex < newLength) {\n\t\tvar oldItem = oldList[oldIndex],\n\t\t\tnewItem = newList[newIndex];\n\n\t\tif( identity( oldItem, newItem, oldIndex ) ) {\n\t\t\toldIndex++;\n\t\t\tnewIndex++;\n\t\t\tcontinue;\n\t\t}\n\t\t// look for single insert, does the next newList item equal the current oldList.\n\t\t// 1 2 3\n\t\t// 1 2 4 3\n\t\tif(  newIndex+1 < newLength && identity( oldItem, newList[newIndex+1], oldIndex ) ) {\n\t\t\tpatches.push({index: newIndex, deleteCount: 0, insert: [ newList[newIndex] ], type: \"splice\"});\n\t\t\toldIndex++;\n\t\t\tnewIndex += 2;\n\t\t\tcontinue;\n\t\t}\n\t\t// look for single removal, does the next item in the oldList equal the current newList item.\n\t\t// 1 2 3\n\t\t// 1 3\n\t\telse if( oldIndex+1 < oldLength  && identity( oldList[oldIndex+1], newItem, oldIndex+1 ) ) {\n\t\t\tpatches.push({index: newIndex, deleteCount: 1, insert: [], type: \"splice\"});\n\t\t\toldIndex += 2;\n\t\t\tnewIndex++;\n\t\t\tcontinue;\n\t\t}\n\t\t// just clean up the rest and exit\n\t\t// 1 2 3\n\t\t// 1 2 5 6 7\n\t\telse {\n\t\t\t// iterate backwards to `newIndex`\n\t\t\t// \"a\", \"b\", \"c\", \"d\", \"e\"\n\t\t\t// \"a\", \"x\", \"y\", \"z\", \"e\"\n\t\t\t// -> {}\n\t\t\tpatches.push.apply(patches, reverseDiff(oldIndex, newIndex , oldList, newList, identity) );\n\n\n\t\t\treturn patches;\n\t\t}\n\t}\n\tif( (newIndex === newLength) && (oldIndex === oldLength) ) {\n\t\treturn patches;\n\t}\n\t// a b\n\t// a b c d e\n\tpatches.push(\n\t\t\t\t{type: \"splice\", index: newIndex,\n\t\t\t\t deleteCount: oldLength-oldIndex,\n\t\t\t\t insert: slice.call(newList, newIndex) } );\n\n\treturn patches;\n};\n\n\n\n\n// a b c\n// a d e b c\n"],"names":["slice","defaultIdentity","a","b","makeIdentityFromMapSchema","typeSchema","identity","length","canReflect","getIdentity","makeIdentityFromListSchema","listSchema","values","getSchema","makeIdentity","oldList","oldListLength","getKeyValue","reverseDiff","oldDiffStopIndex","newDiffStopIndex","newList","oldIndex","newIndex","type","index","deleteCount","insert","call","schemaOrIdentity","oldLength","size","newLength","patches","oldItem","newItem","push","apply"],"mappings":"6EAIA,IAAIA,MAAQ,GAAGA,MAMf,SAASC,gBAAgBC,EAAGC,GACxB,OAAOD,IAAMC,EAGjB,SAASC,0BAA0BC,GAC/B,OAAGA,EAAWC,UAAYD,EAAWC,SAASC,OACnC,SAAuBL,EAAGC,GAG7B,OAFUK,WAAWC,YAAYP,EAAGG,KAC1BG,WAAWC,YAAYN,EAAGE,IAIjCJ,gBAIf,SAASS,2BAA2BC,GAChC,OAA4B,MAArBA,EAAWC,OACdR,0BAA2BI,WAAWK,UAAUF,EAAWC,SAC3DX,gBAGR,SAASa,aAAaC,EAASC,GAC3B,IACIX,EADAM,EAAaH,WAAWK,UAAUE,GAEtC,GAAiB,MAAdJ,EAAoB,CACnB,GAAwB,MAArBA,EAAWC,OAGV,OAAOX,gBAFPI,EAAaG,WAAWK,UAAUF,EAAWC,QAQrD,OAHiB,MAAdP,GAAsBW,EAAgB,IACrCX,EAAaG,WAAWK,UAAWL,WAAWS,YAAYF,EAAS,KAEpEV,EACQD,0BAA0BC,GAE1BJ,gBAMf,SAASiB,YAAYC,EAAkBC,EAAkBL,EAASM,EAASf,GAI1E,IAHA,IAAIgB,EAAWP,EAAQR,OAAS,EAC/BgB,EAAYF,EAAQd,OAAS,EAEvBe,EAAWH,GAAoBI,EAAWH,GAAkB,CAIlE,IAAId,EAHUS,EAAQO,GACXD,EAAQE,GAEaD,GAM/B,MAAO,CAAC,CACKE,KAAM,SAClBC,MAAOL,EACNM,YAAcJ,EAASH,EAAiB,EACxCQ,OAAQ3B,MAAM4B,KAAKP,EAASD,EAAiBG,EAAS,KATxDD,IACAC,IAcF,MAAO,CAAC,CACDC,KAAM,SACZC,MAAOL,EACPM,YAAcJ,EAASH,EAAiB,EACxCQ,OAAQ3B,MAAM4B,KAAKP,EAASD,EAAiBG,EAAS,KAiExD,SAAiB,SAASR,EAASM,EAASQ,GACxC,IAOIvB,EAPAgB,EAAW,EACjBC,EAAY,EACZO,EAAYtB,WAAWuB,KAAMhB,GAC7BiB,EAAYxB,WAAWuB,KAAMV,GAC7BY,EAAU,GAkBX,IAbO3B,EADc,oBAFMuB,EAGTA,EACe,MAApBA,EACuB,QAA1BA,EAAiBL,KACLpB,0BAA0ByB,GAE1BnB,2BAA2BmB,GAG/Bf,aAAaC,EAASe,GAKlCR,EAAWQ,GAAaP,EAAWS,GAAW,CACnD,IAAIE,EAAUnB,EAAQO,GACrBa,EAAUd,EAAQE,GAEnB,GAAIjB,EAAU4B,EAASC,EAASb,GAC/BA,IACAC,SAMD,GAAKA,EAAS,EAAIS,GAAa1B,EAAU4B,EAASb,EAAQE,EAAS,GAAID,GACtEW,EAAQG,KAAK,CAACX,MAAOF,EAAUG,YAAa,EAAGC,OAAQ,CAAEN,EAAQE,IAAaC,KAAM,WACpFF,IACAC,GAAY,MAHb,CASK,KAAID,EAAS,EAAIQ,GAAcxB,EAAUS,EAAQO,EAAS,GAAIa,EAASb,EAAS,IAiBpF,OAHAW,EAAQG,KAAKC,MAAMJ,EAASf,YAAYI,EAAUC,EAAWR,EAASM,EAASf,IAGxE2B,EAhBPA,EAAQG,KAAK,CAACX,MAAOF,EAAUG,YAAa,EAAGC,OAAQ,GAAIH,KAAM,WACjEF,GAAY,EACZC,KAiBF,OAAKA,IAAaS,GAAeV,IAAaQ,EACtCG,GAIRA,EAAQG,KACL,CAACZ,KAAM,SAAUC,MAAOF,EACvBG,YAAaI,EAAUR,EACvBK,OAAQ3B,MAAM4B,KAAKP,EAASE,KAEzBU"}