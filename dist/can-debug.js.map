{"version":3,"file":"can-debug.js","sources":["../node_modules/can-debug/src/proxy-namespace.js","../node_modules/can-debug/src/temporarily-bind.js","../node_modules/can-debug/src/graph/graph.js","../node_modules/can-debug/src/get-graph/make-node.js","../node_modules/can-debug/src/get-graph/get-graph.js","../node_modules/can-debug/src/format-graph/format-graph.js","../node_modules/can-debug/src/log-data/log-data.js","../node_modules/can-debug/src/label-cycles/label-cycles.js","../node_modules/can-debug/src/get-data/get-data.js","../node_modules/can-debug/src/what-i-change/what-i-change.js","../node_modules/can-debug/src/what-changes-me/what-changes-me.js","../node_modules/can-debug/src/get-what-i-change/get-what-i-change.js","../node_modules/can-debug/src/get-what-changes-me/get-what-changes-me.js","../node_modules/can-debug/can-debug.js"],"sourcesContent":["\"use strict\";\nvar warned = false;\n\nmodule.exports = function proxyNamespace(namespace) {\n\treturn new Proxy(namespace, {\n\t\tget: function get(target, name) {\n\t\t\tif (!warned) {\n\t\t\t\tconsole.warn(\"Warning: use of 'can' global should be for debugging purposes only.\");\n\t\t\t\twarned = true;\n\t\t\t}\n\t\t\treturn target[name];\n\t\t}\n\t});\n};\n","\"use strict\";\nvar canSymbol = require(\"can-symbol\");\nvar canReflect = require(\"can-reflect\");\n\nvar onValueSymbol = canSymbol.for(\"can.onValue\");\nvar offValueSymbol = canSymbol.for(\"can.offValue\");\nvar onKeyValueSymbol = canSymbol.for(\"can.onKeyValue\");\nvar offKeyValueSymbol = canSymbol.for(\"can.offKeyValue\");\n\nvar noop = function noop() {};\n\nfunction isFunction(value) {\n\treturn typeof value === \"function\";\n}\n\nfunction withKey(obj, key, fn) {\n\tvar result;\n\n\tif (isFunction(obj[onKeyValueSymbol])) {\n\t\tcanReflect.onKeyValue(obj, key, noop);\n\t}\n\n\tresult = fn(obj, key);\n\n\tif (isFunction(obj[offKeyValueSymbol])) {\n\t\tcanReflect.offKeyValue(obj, key, noop);\n\t}\n\n\treturn result;\n}\n\nfunction withoutKey(obj, fn) {\n\tvar result;\n\n\tif (isFunction(obj[onValueSymbol])) {\n\t\tcanReflect.onValue(obj, noop);\n\t}\n\n\tresult = fn(obj);\n\n\tif (isFunction(obj[offValueSymbol])) {\n\t\tcanReflect.offValue(obj, noop);\n\t}\n\n\treturn result;\n}\n\n// Takes a function with signature `fn(obj, [key])`\n// Makes sure that the argument is bound before calling \n// the function and unbinds it after the call is done.\nmodule.exports = function temporarilyBind(fn) {\n\treturn function(obj, key) {\n\t\tvar gotKey = arguments.length === 2;\n\t\treturn gotKey ? withKey(obj, key, fn) : withoutKey(obj, fn);\n\t};\n};\n","\"use strict\";\nfunction Graph() {\n\tthis.nodes = [];\n\tthis.arrows = new Map();\n\tthis.arrowsMeta = new Map();\n}\n\n// Adds the node, but it does not check if the node exists, callers will have\n// to check that through [findNode]\nGraph.prototype.addNode = function addNode(node) {\n\tthis.nodes.push(node);\n\tthis.arrows.set(node, new Set());\n};\n\n// Adds an arrow from head to tail with optional metadata\n// The method does not check whether head and tail are already\n// nodes in the graph, this should be done by the caller.\nGraph.prototype.addArrow = function addArrow(head, tail, meta) {\n\tvar graph = this;\n\n\tgraph.arrows.get(head).add(tail);\n\n\t// optional\n\tif (meta) {\n\t\taddArrowMeta(graph, head, tail, meta);\n\t}\n};\n\n// Tests whether there is an arrow from head to tail\nGraph.prototype.hasArrow = function hasArrow(head, tail) {\n\treturn this.getNeighbors(head).has(tail);\n};\n\n// Returns the metadata associated to the head -> tail arrow\nGraph.prototype.getArrowMeta = function getArrowMeta(head, tail) {\n\treturn this.arrowsMeta.get(head) && this.arrowsMeta.get(head).get(tail);\n};\n\n// Sets metadata about the arrow from head to tail\n// Merges the passed object into existing metadata\nGraph.prototype.setArrowMeta = function setArrowMeta(head, tail, meta) {\n\taddArrowMeta(this, head, tail, meta);\n};\n\n// Returns a Set of all nodes 'y' such that there is an arrow\n// from the node 'x' to the node 'y'.\nGraph.prototype.getNeighbors = function getNeighbors(node) {\n\treturn this.arrows.get(node);\n};\n\n// Returns the first node that satisfies the provided testing function.\n// The Graph is traversed using depth first search\nGraph.prototype.findNode = function findNode(cb) {\n\tvar found = null;\n\tvar graph = this;\n\n\tfor (var node of graph.nodes) {\n\t\tif (cb(node)) {\n\t\t\tfound = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n};\n\nGraph.prototype.bfs = function bfs(visit) {\n\tvar graph = this;\n\n\tvar node = graph.nodes[0];\n\tvar queue = [node];\n\tvar visited = new Map([[node, true]]);\n\n\twhile (queue.length) {\n\t\tnode = queue.shift();\n\n\t\tvisit(node);\n\n\t\tgraph.arrows.get(node).forEach(function(adj) {\n\t\t\tif (!visited.has(adj)) {\n\t\t\t\tqueue.push(adj);\n\t\t\t\tvisited.set(adj, true);\n\t\t\t}\n\t\t});\n\t}\n};\n\nGraph.prototype.dfs = function dfs(visit) {\n\tvar graph = this;\n\n\tvar node = graph.nodes[0];\n\tvar stack = [node];\n\tvar visited = new Map();\n\n\twhile (stack.length) {\n\t\tnode = stack.pop();\n\n\t\tvisit(node);\n\n\t\tif (!visited.has(node)) {\n\t\t\tvisited.set(node, true);\n\t\t\tgraph.arrows.get(node).forEach(function(adj) {\n\t\t\t\tstack.push(adj);\n\t\t\t});\n\t\t}\n\t}\n};\n\n// Returns a new graph where the arrows point to the opposite direction, that is:\n// For each arrow (u, v) in [this], there will be a (v, u) in the returned graph\n// This is also called Transpose or Converse a graph\nGraph.prototype.reverse = function reverse() {\n\tvar graph = this;\n\tvar reversed = new Graph();\n\n\t// copy over the nodes\n\tgraph.nodes.forEach(reversed.addNode.bind(reversed));\n\n\tgraph.nodes.forEach(function(node) {\n\t\tgraph.getNeighbors(node).forEach(function(adj) {\n\t\t\t// add the arrow in the opposite direction, copy over metadata\n\t\t\tvar meta = graph.getArrowMeta(node, adj);\n\t\t\treversed.addArrow(adj, node, meta);\n\t\t});\n\t});\n\n\treturn reversed;\n};\n\n// Helpers\nfunction addArrowMeta(graph, head, tail, meta) {\n\tvar entry = graph.arrowsMeta.get(head);\n\n\tif (entry) {\n\t\tvar arrowMeta = entry.get(tail);\n\t\tif (!arrowMeta) {\n\t\t\tarrowMeta = {};\n\t\t}\n\t\tentry.set(tail, Object.assign(arrowMeta, meta));\n\t} else {\n\t\tentry = new Map([[tail, meta]]);\n\t\tgraph.arrowsMeta.set(head, entry);\n\t}\n}\n\nmodule.exports = Graph;\n","\"use strict\";\nvar canReflect = require(\"can-reflect\");\n\nmodule.exports = function makeNode(obj, key) {\n\tvar gotKey = arguments.length === 2;\n\n\tvar node = {\n\t\tobj: obj,\n\t\tname: canReflect.getName(obj),\n\t\tvalue: gotKey ? canReflect.getKeyValue(obj, key) : canReflect.getValue(obj)\n\t};\n\n\tif (gotKey) {\n\t\tnode.key = key;\n\t}\n\n\treturn node;\n};\n","\"use strict\";\nvar Graph = require(\"../graph/graph\");\nvar makeNode = require(\"./make-node\");\nvar canReflect = require(\"can-reflect\");\nvar mutateDeps = require(\"can-reflect-dependencies\");\n\n// Returns a directed graph of the dependencies of obj (key is optional)\n//\n// Signature:\n//\tgetDirectedGraph(obj)\n//\tgetDirectedGraph(obj, key)\nmodule.exports = function getGraph(obj, key) {\n\tvar order = 0;\n\tvar graph = new Graph();\n\tvar gotKey = arguments.length === 2;\n\n\tvar addArrow = function addArrow(direction, parent, child, meta) {\n\t\tswitch (direction) {\n\t\t\tcase \"whatIChange\":\n\t\t\t\tgraph.addArrow(parent, child, meta); break;\n\t\t\tcase \"whatChangesMe\":\n\t\t\t\tgraph.addArrow(child, parent, meta); break;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unknown direction value: \", meta.direction);\n\t\t}\n\t};\n\n\t// keyDependencies :: Map<obj, Set<key>>\n\tvar visitKeyDependencies = function visitKeyDependencies(source, meta, cb) {\n\t\tcanReflect.eachKey(source.keyDependencies || {}, function(keys, obj) {\n\t\t\tcanReflect.each(keys, function(key) {\n\t\t\t\tcb(obj, meta, key);\n\t\t\t});\n\t\t});\n\t};\n\n\t// valueDependencies :: Set<obj>\n\tvar visitValueDependencies = function visitValueDependencies(source, meta, cb) {\n\t\tcanReflect.eachIndex(source.valueDependencies || [], function(obj) {\n\t\t\tcb(obj, meta);\n\t\t});\n\t};\n\n\tvar visit = function visit(obj, meta, key) {\n\t\tvar gotKey = arguments.length === 3;\n\n\t\tvar node = graph.findNode(function(node) {\n\t\t\treturn gotKey ?\n\t\t\t\tnode.obj === obj && node.key === key :\n\t\t\t\tnode.obj === obj;\n\t\t});\n\n\t\t// if there is a node already in the graph, add the arrow and prevent\n\t\t// infinite calls to `visit` by returning early\n\t\tif (node) {\n\t\t\tif (meta.parent) {\n\t\t\t\taddArrow(meta.direction, meta.parent, node, {\n\t\t\t\t\tkind: meta.kind,\n\t\t\t\t\tdirection: meta.direction\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn graph;\n\t\t}\n\n\t\t// create and add a node to the graph\n\t\torder += 1;\n\t\tnode = gotKey ? makeNode(obj, key) : makeNode(obj);\n\t\tnode.order = order;\n\t\tgraph.addNode(node);\n\n\t\t// if there is a known parent node, add the arrow in the given direction\n\t\tif (meta.parent) {\n\t\t\taddArrow(meta.direction, meta.parent, node, {\n\t\t\t\tkind: meta.kind,\n\t\t\t\tdirection: meta.direction\n\t\t\t});\n\t\t}\n\n\t\t// get the dependencies of the new node and recursively visit those\n\t\tvar nextMeta;\n\t\tvar data = gotKey ?\n\t\t\tmutateDeps.getDependencyDataOf(obj, key) :\n\t\t\tmutateDeps.getDependencyDataOf(obj);\n\n\t\tif (data && data.whatIChange) {\n\t\t\tnextMeta = { direction: \"whatIChange\", parent: node };\n\n\t\t\t// kind :: derive | mutate\n\t\t\tcanReflect.eachKey(data.whatIChange, function(dependencyRecord, kind) {\n\t\t\t\tnextMeta.kind = kind;\n\t\t\t\tvisitKeyDependencies(dependencyRecord, nextMeta, visit);\n\t\t\t\tvisitValueDependencies(dependencyRecord, nextMeta, visit);\n\t\t\t});\n\t\t}\n\n\t\tif (data && data.whatChangesMe) {\n\t\t\tnextMeta = { direction: \"whatChangesMe\", parent: node };\n\n\t\t\t// kind :: derive | mutate\n\t\t\tcanReflect.eachKey(data.whatChangesMe, function(dependencyRecord, kind) {\n\t\t\t\tnextMeta.kind = kind;\n\t\t\t\tvisitKeyDependencies(dependencyRecord, nextMeta, visit);\n\t\t\t\tvisitValueDependencies(dependencyRecord, nextMeta, visit);\n\t\t\t});\n\t\t}\n\n\t\treturn graph;\n\t};\n\n\treturn gotKey ? visit(obj, {}, key) : visit(obj, {});\n};\n","\"use strict\";\nvar canReflect = require(\"can-reflect\");\n\n// Converts the graph into a data structure that vis.js requires to draw the graph\nmodule.exports = function formatGraph(graph) {\n\t// { [node]: Number }\n\tvar nodeIdMap = new Map(\n\t\tgraph.nodes.map(function(node, index) {\n\t\t\treturn [node, index + 1];\n\t\t})\n\t);\n\n\t// collects nodes in the shape of { id: Number, label: String }\n\tvar nodesDataSet = graph.nodes.map(function(node) {\n\t\treturn {\n\t\t\tshape: \"box\",\n\t\t\tid: nodeIdMap.get(node),\n\t\t\tlabel:\n\t\t\t\tcanReflect.getName(node.obj) +\n\t\t\t\t(node.key ? \".\" + node.key : \"\")\n\t\t};\n\t});\n\n\tvar getArrowData = function getArrowData(meta) {\n\t\tvar regular = { arrows: \"to\" };\n\t\tvar withDashes = { arrows: \"to\", dashes: true };\n\n\t\tvar map = {\n\t\t\tderive: regular,\n\t\t\tmutate: withDashes\n\t\t};\n\n\t\treturn map[meta.kind];\n\t};\n\n\t// collect edges in the shape of { from: Id, to: Id }\n\tvar visited = new Map();\n\tvar arrowsDataSet = [];\n\tgraph.nodes.forEach(function(node) {\n\t\tvar visit = function(node) {\n\t\t\tif (!visited.has(node)) {\n\t\t\t\tvisited.set(node, true);\n\t\t\t\tvar arrows = graph.arrows.get(node);\n\t\t\t\tvar headId = nodeIdMap.get(node);\n\n\t\t\t\tarrows.forEach(function(neighbor) {\n\t\t\t\t\tvar tailId = nodeIdMap.get(neighbor);\n\t\t\t\t\tvar meta = graph.arrowsMeta.get(node).get(neighbor);\n\n\t\t\t\t\tarrowsDataSet.push(\n\t\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t\t{ from: headId, to: tailId },\n\t\t\t\t\t\t\tgetArrowData(meta)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\tvisit(neighbor);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tvisit(node);\n\t});\n\t\n\treturn {\n\t\tnodes: nodesDataSet,\n\t\tedges: arrowsDataSet\n\t};\n};\n","\"use strict\";\nvar canReflect = require(\"can-reflect\");\n\nvar quoteString = function quoteString(x) {\n\treturn typeof x === \"string\" ? JSON.stringify(x) : x;\n};\n\nmodule.exports = function log(data) {\n\tvar node = data.node;\n\tvar nameParts = [node.name, \"key\" in node ? \".\" + node.key : \"\"];\n\n\tconsole.group(nameParts.join(\"\"));\n\tconsole.log(\"value  \", quoteString(node.value));\n\tconsole.log(\"object \", node.obj);\n\n\tif (data.derive.length) {\n\t\tconsole.group(\"DERIVED FROM\");\n\t\tcanReflect.eachIndex(data.derive, log);\n\t\tconsole.groupEnd();\n\t}\n\n\tif (data.mutations.length) {\n\t\tconsole.group(\"MUTATED BY\");\n\t\tcanReflect.eachIndex(data.mutations, log);\n\t\tconsole.groupEnd();\n\t}\n\n\tif (data.twoWay.length) {\n\t\tconsole.group(\"TWO WAY\");\n\t\tcanReflect.eachIndex(data.twoWay, log);\n\t\tconsole.groupEnd();\n\t}\n\n\tconsole.groupEnd();\n};\n","\"use strict\";\nvar Graph = require(\"../graph/graph\");\n\n// Returns a new graph with all the arrows not involved in a circuit\nmodule.exports = function labelCycles(graph) {\n\tvar visited = new Map();\n\tvar result = new Graph();\n\n\t// copy over all nodes\n\tgraph.nodes.forEach(function(node) {\n\t\tresult.addNode(node);\n\t});\n\n\tvar visit = function visit(node) {\n\t\tvisited.set(node, true);\n\n\t\tgraph.getNeighbors(node).forEach(function(adj) {\n\t\t\t// back arrow found\n\t\t\tif (visited.has(adj)) {\n\t\t\t\t// if isTwoWay is false it means the cycle involves more than 2 nodes,\n\t\t\t\t// e.g: A -> B -> C -> A\n\t\t\t\t// what to do in these cases? (currently ignoring these)\n\t\t\t\tvar isTwoWay = graph.hasArrow(node, adj);\n\n\t\t\t\tif (isTwoWay) {\n\t\t\t\t\tresult.addArrow(adj, node, { kind: \"twoWay\" });\n\t\t\t\t}\n\t\t\t// copy over arrows not involved in a cycle\n\t\t\t} else {\n\t\t\t\tresult.addArrow(node, adj, graph.getArrowMeta(node, adj));\n\t\t\t\tvisit(adj);\n\t\t\t}\n\t\t});\n\t};\n\n\tvisit(graph.nodes[0]);\n\treturn result;\n};\n","\"use strict\";\nvar labelCycles = require(\"../label-cycles/label-cycles\");\n\nvar isDisconnected = function isDisconnected(data) {\n\treturn (\n\t\t!data.derive.length &&\n\t\t!data.mutations.length &&\n\t\t!data.twoWay.length\n\t);\n};\n\n// Returns a deeply nested object from the graph\nmodule.exports = function getDebugData(inputGraph, direction) {\n\tvar visited = new Map();\n\n\tvar graph = labelCycles(\n\t\tdirection === \"whatChangesMe\" ? inputGraph.reverse() : inputGraph\n\t);\n\n\tvar visit = function visit(node) {\n\t\tvar data = { node: node, derive: [], mutations: [], twoWay: [] };\n\n\t\tvisited.set(node, true);\n\n\t\tgraph.getNeighbors(node).forEach(function(adj) {\n\t\t\tvar meta = graph.getArrowMeta(node, adj);\n\n\t\t\tif (!visited.has(adj)) {\n\t\t\t\tswitch (meta.kind) {\n\t\t\t\t\tcase \"twoWay\":\n\t\t\t\t\t\tdata.twoWay.push(visit(adj));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"derive\":\n\t\t\t\t\t\tdata.derive.push(visit(adj));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"mutate\":\n\t\t\t\t\t\tdata.mutations.push(visit(adj));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"Unknow meta.kind value: \", meta.kind);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn data;\n\t};\n\n\t// discard data if there are no arrows registered, this happens when\n\t// [direction] is passed in and no arrow metadada matches its value\n\tvar result = visit(graph.nodes[0]);\n\treturn isDisconnected(result) ? null : result;\n};\n","\"use strict\";\nvar log = require(\"../log-data/log-data\");\nvar getData = require(\"../get-data/get-data\");\nvar getGraph = require(\"../get-graph/get-graph\");\n\n// key :: string | number | null | undefined\nmodule.exports = function logWhatIChange(obj, key) {\n\tvar gotKey = arguments.length === 2;\n\n\tvar data = getData(\n\t\tgotKey ? getGraph(obj, key) : getGraph(obj),\n\t\t\"whatIChange\"\n\t);\n\n\tif (data) {\n\t\tlog(data);\n\t}\n};\n","\"use strict\";\nvar log = require(\"../log-data/log-data\");\nvar getData = require(\"../get-data/get-data\");\nvar getGraph = require(\"../get-graph/get-graph\");\n\n// key :: string | number | null | undefined\nmodule.exports = function logWhatChangesMe(obj, key) {\n\tvar gotKey = arguments.length === 2;\n\n\tvar data = getData(\n\t\tgotKey ? getGraph(obj, key) : getGraph(obj),\n\t\t\"whatChangesMe\"\n\t);\n\n\tif (data) {\n\t\tlog(data);\n\t}\n};\n","\"use strict\";\nvar getData = require(\"../get-data/get-data\");\nvar getGraph = require(\"../get-graph/get-graph\");\n\nmodule.exports = function getWhatChangesMe(obj, key) {\n\tvar gotKey = arguments.length === 2;\n\n\treturn getData(\n\t\tgotKey ? getGraph(obj, key) : getGraph(obj),\n\t\t\"whatIChange\"\n\t);\n};\n","\"use strict\";\nvar getData = require(\"../get-data/get-data\");\nvar getGraph = require(\"../get-graph/get-graph\");\n\nmodule.exports = function getWhatChangesMe(obj, key) {\n\tvar gotKey = arguments.length === 2;\n\n\treturn getData(\n\t\tgotKey ? getGraph(obj, key) : getGraph(obj),\n\t\t\"whatChangesMe\"\n\t);\n};\n","\"use strict\";\nvar namespace = require(\"can-namespace\");\nvar globals = require(\"can-globals\");\nvar proxyNamespace = require(\"./src/proxy-namespace\");\nvar temporarilyBind = require(\"./src/temporarily-bind\");\n\nvar getGraph = require(\"./src/get-graph/get-graph\");\nvar formatGraph = require(\"./src/format-graph/format-graph\");\nvar logWhatIChange = require(\"./src/what-i-change/what-i-change\");\nvar logWhatChangesMe = require(\"./src/what-changes-me/what-changes-me\");\nvar getWhatIChange = require(\"./src/get-what-i-change/get-what-i-change\");\nvar getWhatChangesMe = require(\"./src/get-what-changes-me/get-what-changes-me\");\n\nvar canSymbol = require(\"can-symbol\");\nvar canReflect = require(\"can-reflect\");\nvar canQueues = require(\"can-queues\");\nvar mergeDeep = require(\"can-diff/merge-deep/merge-deep\");\n\nvar global = globals.getKeyValue(\"global\");\n\nvar devtoolsRegistrationComplete = false;\nfunction registerWithDevtools() {\n\tif (devtoolsRegistrationComplete) {\n\t\treturn;\n\t}\n\n\tvar devtoolsGlobalName =  \"__CANJS_DEVTOOLS__\";\n\tvar devtoolsCanModules = {\n\t\tSymbol: canSymbol,\n\t\tReflect: canReflect,\n\t\tqueues: canQueues,\n\t\tgetGraph: namespace.debug.getGraph,\n\t\tformatGraph: namespace.debug.formatGraph,\n\t\tmergeDeep: mergeDeep\n\t};\n\n\tif (global[devtoolsGlobalName]) {\n\t\tglobal[devtoolsGlobalName].register(devtoolsCanModules);\n\t} else {\n\t\tObject.defineProperty(global, devtoolsGlobalName, {\n\t\t\tset: function(devtoolsGlobal) {\n\t\t\t\tObject.defineProperty(global, devtoolsGlobalName, {\n\t\t\t\t\tvalue: devtoolsGlobal\n\t\t\t\t});\n\n\t\t\t\tdevtoolsGlobal.register(devtoolsCanModules);\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\t}\n\n\tdevtoolsRegistrationComplete = true;\n}\n\nmodule.exports = function() {\n\tnamespace.debug = {\n\t\tgetGraph: temporarilyBind(getGraph),\n\t\tformatGraph: temporarilyBind(formatGraph),\n\t\tgetWhatIChange: temporarilyBind(getWhatIChange),\n\t\tgetWhatChangesMe: temporarilyBind(getWhatChangesMe),\n\t\tlogWhatIChange: temporarilyBind(logWhatIChange),\n\t\tlogWhatChangesMe: temporarilyBind(logWhatChangesMe)\n\t};\n\n\tregisterWithDevtools();\n\n\tglobal.can = typeof Proxy !== \"undefined\" ? proxyNamespace(namespace) : namespace;\n\n\treturn namespace.debug;\n};\n"],"names":["warned","namespace","Proxy","get","target","name","console","warn","onValueSymbol","canSymbol","for","offValueSymbol","onKeyValueSymbol","offKeyValueSymbol","noop","isFunction","value","withKey","obj","key","fn","result","canReflect","onKeyValue","offKeyValue","withoutKey","onValue","offValue","arguments","length","Graph","this","nodes","arrows","Map","arrowsMeta","addArrowMeta","graph","head","tail","meta","entry","arrowMeta","set","Object","assign","prototype","addNode","node","push","Set","addArrow","add","hasArrow","getNeighbors","has","getArrowMeta","setArrowMeta","findNode","cb","found","bfs","visit","queue","visited","shift","forEach","adj","dfs","stack","pop","reverse","reversed","bind","gotKey","getName","getKeyValue","getValue","order","direction","parent","child","Error","visitKeyDependencies","source","eachKey","keyDependencies","keys","each","visitValueDependencies","eachIndex","valueDependencies","nextMeta","kind","makeNode","data","mutateDeps","getDependencyDataOf","whatIChange","dependencyRecord","whatChangesMe","nodeIdMap","map","index","nodesDataSet","shape","id","label","arrowsDataSet","headId","neighbor","tailId","from","to","derive","mutate","dashes","getArrowData","edges","quoteString","x","JSON","stringify","log","nameParts","group","join","groupEnd","mutations","twoWay","isDisconnected","inputGraph","labelCycles","getData","getGraph","global","globals","devtoolsRegistrationComplete","registerWithDevtools","devtoolsCanModules","Symbol","Reflect","queues","canQueues","debug","formatGraph","mergeDeep","register","defineProperty","devtoolsGlobal","configurable","temporarilyBind","getWhatIChange","getWhatChangesMe","logWhatIChange","logWhatChangesMe","can","proxyNamespace"],"mappings":"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"}