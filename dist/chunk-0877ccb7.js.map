{"version":3,"file":"chunk-0877ccb7.js","sources":["../node_modules/can-stache-key/can-stache-key.js"],"sourcesContent":["\"use strict\";\nvar ObservationRecorder = require('can-observation-recorder');\nvar dev = require('can-log/dev/dev');\nvar canSymbol = require(\"can-symbol\");\nvar canReflect = require(\"can-reflect\");\nvar canReflectPromise = require(\"can-reflect-promise\");\n\nvar getValueSymbol = canSymbol.for(\"can.getValue\");\nvar setValueSymbol = canSymbol.for(\"can.setValue\");\n\nvar isValueLikeSymbol = canSymbol.for(\"can.isValueLike\");\nvar peek = ObservationRecorder.ignore(canReflect.getKeyValue.bind(canReflect));\nvar observeReader;\n\nvar bindName = Function.prototype.bind;\n//!steal-remove-start\nif (process.env.NODE_ENV !== 'production') {\n\tbindName = function(source){\n\t\tvar fn = Function.prototype.bind.call(this, source);\n\t\tObject.defineProperty(fn, \"name\", {\n\t\t\tvalue: canReflect.getName(source) + \".\"+canReflect.getName(this)\n\t\t});\n\t\treturn fn;\n\t};\n}\n//!steal-remove-end\n\nvar isAt = function(index, reads) {\n\tvar prevRead = reads[index-1];\n\treturn prevRead && prevRead.at;\n};\n\nvar readValue = function(value, index, reads, options, state, prev){\n\t// if the previous read is AT false ... we shouldn't be doing this;\n\tvar usedValueReader;\n\tdo {\n\n\t\tusedValueReader = false;\n\t\tfor(var i =0, len = observeReader.valueReaders.length; i < len; i++){\n\t\t\tif( observeReader.valueReaders[i].test(value, index, reads, options) ) {\n\t\t\t\tvalue = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);\n\t\t\t\t//usedValueReader = true;\n\t\t\t}\n\t\t}\n\t} while(usedValueReader);\n\n\treturn value;\n};\n\nvar specialRead = {index: true, key: true, event: true, element: true, viewModel: true};\n\nvar checkForObservableAndNotify = function(options, state, getObserves, value, index){\n\tif(options.foundObservable && !state.foundObservable) {\n\t\tif(ObservationRecorder.trapsCount()) {\n\t\t\tObservationRecorder.addMany( getObserves() );\n\t\t\toptions.foundObservable(value, index);\n\t\t\tstate.foundObservable = true;\n\t\t}\n\t}\n};\n\nvar objHasKeyAtIndex = function(obj, reads, index) {\n\treturn !!(\n\t\treads && reads.length &&\n\t\tcanReflect.hasKey(obj, reads[index].key)\n\t);\n};\n\nobserveReader = {\n\t// there are things that you need to evaluate when you get them back as a property read\n\t// for example a compute or a function you might need to call to get the next value to\n\t// actually check\n\t// - readCompute - can be set to `false` to prevent reading an ending compute.  This is used by component to get a\n\t//   compute as a delegate.  In 3.0, this should be removed and force people to write \"{@prop} change\"\n\t// - callMethodsOnObservables - this is an overwrite ... so normal methods won't be called, but observable ones will.\n\t// - executeAnonymousFunctions - call a function if it's found, defaults to true\n\t// - proxyMethods - if the last read is a method, return a function so `this` will be correct.\n\t// - args - arguments to call functions with.\n\t//\n\t// Callbacks\n\t// - earlyExit - called if a value could not be found\n\t// - foundObservable - called when an observable value is found\n\tread: function (parent, reads, options) {\n\t\toptions = options || {};\n\t\tvar state = {\n\t\t\tfoundObservable: false\n\t\t};\n\t\tvar getObserves;\n\t\tif(options.foundObservable) {\n\t\t\tgetObserves = ObservationRecorder.trap();\n\t\t}\n\n\t\t// `cur` is the current value.\n\t\tvar cur = readValue(parent, 0, reads, options, state),\n\t\t\ttype,\n\t\t\t// `prev` is the object we are reading from.\n\t\t\tprev,\n\t\t\t// `foundObs` did we find an observable.\n\t\t\treadLength = reads.length,\n\t\t\ti = 0,\n\t\t\tlast,\n\t\t\tparentHasKey;\n\n\t\tcheckForObservableAndNotify(options, state, getObserves, parent, 0);\n\n\t\twhile( i < readLength ) {\n\t\t\tprev = cur;\n\t\t\t// try to read the property\n\t\t\tfor(var r=0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {\n\t\t\t\tvar reader = observeReader.propertyReaders[r];\n\t\t\t\tif(reader.test(cur)) {\n\t\t\t\t\tcur = reader.read(cur, reads[i], i, options, state);\n\t\t\t\t\tbreak; // there can be only one reading of a property\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckForObservableAndNotify(options, state, getObserves, prev, i);\n\t\t\tlast = cur;\n\t\t\ti = i+1;\n\t\t\t// read the value if it is a compute or function\n\t\t\tcur = readValue(cur, i, reads, options, state, prev);\n\n\t\t\tcheckForObservableAndNotify(options, state, getObserves, prev, i-1);\n\n\t\t\ttype = typeof cur;\n\t\t\t// early exit if need be\n\t\t\tif (i < reads.length && (cur === null || cur === undefined )) {\n\t\t\t\tparentHasKey = objHasKeyAtIndex(prev, reads, i - 1);\n\t\t\t\tif (options.earlyExit && !parentHasKey) {\n\t\t\t\t\toptions.earlyExit(prev, i - 1, cur);\n\t\t\t\t}\n\t\t\t\t// return undefined so we know this isn't the right value\n\t\t\t\treturn {\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t\tparent: prev,\n\t\t\t\t\tparentHasKey: parentHasKey,\n\t\t\t\t\tfoundLastParent: false\n\t\t\t\t};\n\t\t\t}\n\n\t\t}\n\n\t\tparentHasKey = objHasKeyAtIndex(prev, reads, reads.length - 1);\n\t\t// if we don't have a value, exit early.\n\t\tif (cur === undefined && !parentHasKey) {\n\t\t\tif (options.earlyExit) {\n\t\t\t\toptions.earlyExit(prev, i - 1);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tvalue: cur,\n\t\t\tparent: prev,\n\t\t\tparentHasKey: parentHasKey,\n\t\t\tfoundLastParent: true\n\t\t};\n\t},\n\tget: function(parent, reads, options){\n\t\treturn observeReader.read(parent, observeReader.reads(reads), options || {}).value;\n\t},\n\tvalueReadersMap: {},\n\t// an array of types that might have a value inside them like functions\n\t// value readers check the current value\n\t// and get a new value from it\n\t// ideally they would keep calling until\n\t// none of these passed\n\tvalueReaders: [\n\t\t{\n\t\t\tname: \"function\",\n\t\t\t// if this is a function before the last read and its not a constructor function\n\t\t\ttest: function(value){\n\t\t\t\treturn value && canReflect.isFunctionLike(value) && !canReflect.isConstructorLike(value);\n\t\t\t},\n\t\t\tread: function(value, i, reads, options, state, prev){\n\t\t\t\tif(options.callMethodsOnObservables && canReflect.isObservableLike(prev) && canReflect.isMapLike(prev)) {\n\t\t\t\t\tdev.warn(\"can-stache-key: read() called with `callMethodsOnObservables: true`.\");\n\n\t\t\t\t\treturn value.apply(prev, options.args || []);\n\t\t\t\t}\n\n\t\t\t\treturn options.proxyMethods !== false ? bindName.call(value, prev) : value;\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tname: \"isValueLike\",\n\t\t\t// compute value reader\n\t\t\ttest: function(value, i, reads, options) {\n\t\t\t\treturn value && value[getValueSymbol] && value[isValueLikeSymbol] !== false && (options.foundAt || !isAt(i, reads) );\n\t\t\t},\n\t\t\tread: function(value, i, reads, options){\n\t\t\t\tif(options.readCompute === false && i === reads.length ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\treturn canReflect.getValue(value);\n\t\t\t},\n\t\t\twrite: function(base, newVal){\n\t\t\t\tif(base[setValueSymbol]) {\n\t\t\t\t\tbase[setValueSymbol](newVal);\n\t\t\t\t} else if(base.set) {\n\t\t\t\t\tbase.set(newVal);\n\t\t\t\t} else {\n\t\t\t\t\tbase(newVal);\n\t\t\t\t}\n\t\t\t}\n\t\t}],\n\tpropertyReadersMap: {},\n\t// an array of things that might have a property\n\tpropertyReaders: [\n\t\t{\n\t\t\tname: \"map\",\n\t\t\ttest: function(value){\n\t\t\t\t// the first time we try reading from a promise, set it up for\n\t\t\t\t//  special reflections.\n\t\t\t\tif(canReflect.isPromise(value) || typeof value === \"object\" && value && typeof value.then === \"function\") {\n\t\t\t\t\tcanReflectPromise(value);\n\t\t\t\t}\n\n\t\t\t\treturn canReflect.isObservableLike(value) && canReflect.isMapLike(value);\n\t\t\t},\n\t\t\tread: function(value, prop){\n\t\t\t\tvar res = canReflect.getKeyValue(value, prop.key);\n\t\t\t\tif(res !== undefined) {\n\t\t\t\t\treturn res;\n\t\t\t\t} else {\n\t\t\t\t\treturn value[prop.key];\n\t\t\t\t}\n\t\t\t},\n\t\t\twrite: canReflect.setKeyValue\n\t\t},\n\n\t\t// read a normal object\n\t\t{\n\t\t\tname: \"object\",\n\t\t\t// this is the default\n\t\t\ttest: function(){return true;},\n\t\t\tread: function(value, prop, i, options){\n\t\t\t\tif(value == null) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\tif(typeof value === \"object\") {\n\t\t\t\t\t\tif(prop.key in value) {\n\t\t\t\t\t\t\treturn value[prop.key];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: remove in 5.0.\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t\tif( prop.at && specialRead[prop.key] && ( (\"@\"+prop.key) in value)) {\n\t\t\t\t\t\t\t\toptions.foundAt = true;\n\t\t\t\t\t\t\t\tdev.warn(\"Use %\"+prop.key+\" in place of @\"+prop.key+\".\");\n\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn value[prop.key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\twrite: function(base, prop, newVal){\n\t\t\t\tvar propValue = base[prop];\n\t\t\t\t// if newVal is observable object, lets try to update\n\t\t\t\tif(newVal != null && typeof newVal === \"object\" && canReflect.isMapLike(propValue) ) {\n\t\t\t\t\tdev.warn(\"can-stache-key: Merging data into \\\"\" + prop + \"\\\" because its parent is non-observable\");\n\t\t\t\t\tcanReflect.update(propValue, newVal);\n\t\t\t\t} else if(propValue != null && propValue[setValueSymbol] !== undefined){\n\t\t\t\t\tcanReflect.setValue(propValue, newVal);\n\t\t\t\t} else {\n\t\t\t\t\tbase[prop] = newVal;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t],\n\treads: function(keyArg) {\n\t\tvar key = \"\"+keyArg;\n\t\tvar keys = [];\n\t\tvar last = 0;\n\t\tvar at = false;\n\t\tif( key.charAt(0) === \"@\" ) {\n\t\t\tlast = 1;\n\t\t\tat = true;\n\t\t}\n\t\tvar keyToAdd = \"\";\n\t\tfor(var i = last; i < key.length; i++) {\n\t\t\tvar character = key.charAt(i);\n\t\t\tif(character === \".\" || character === \"@\") {\n\t\t\t\tif( key.charAt(i -1) !== \"\\\\\" ) {\n\t\t\t\t\tkeys.push({\n\t\t\t\t\t\tkey: keyToAdd,\n\t\t\t\t\t\tat: at\n\t\t\t\t\t});\n\t\t\t\t\tat = character === \"@\";\n\t\t\t\t\tkeyToAdd = \"\";\n\t\t\t\t} else {\n\t\t\t\t\tkeyToAdd = keyToAdd.substr(0,keyToAdd.length - 1) + \".\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeyToAdd += character;\n\t\t\t}\n\t\t}\n\t\tkeys.push({\n\t\t\tkey: keyToAdd,\n\t\t\tat: at\n\t\t});\n\n\t\treturn keys;\n\t},\n\t// This should be able to set a property similar to how read works.\n\twrite: function(parent, key, value, options) {\n\t\tvar keys = typeof key === \"string\" ? observeReader.reads(key) : key;\n\t\tvar last;\n\n\t\toptions = options || {};\n\t\tif(keys.length > 1) {\n\t\t\tlast = keys.pop();\n\t\t\tparent = observeReader.read(parent, keys, options).value;\n\t\t\tkeys.push(last);\n\t\t} else {\n\t\t\tlast = keys[0];\n\t\t}\n\t\tif(!parent) {\n\t\t\treturn;\n\t\t}\n\t\tvar keyValue = peek(parent, last.key);\n\t\t// here's where we need to figure out the best way to write\n\n\t\t// if property being set points at a compute, set the compute\n\t\tif( observeReader.valueReadersMap.isValueLike.test(keyValue, keys.length - 1, keys, options) ) {\n\t\t\tobserveReader.valueReadersMap.isValueLike.write(keyValue, value, options);\n\t\t} else {\n\t\t\tif(observeReader.valueReadersMap.isValueLike.test(parent, keys.length - 1, keys, options) ) {\n\t\t\t\tparent = parent[getValueSymbol]();\n\t\t\t}\n\t\t\tif(observeReader.propertyReadersMap.map.test(parent)) {\n\t\t\t\tobserveReader.propertyReadersMap.map.write(parent, last.key, value, options);\n\t\t\t}\n\t\t\telse if(observeReader.propertyReadersMap.object.test(parent)) {\n\t\t\t\tobserveReader.propertyReadersMap.object.write(parent, last.key, value, options);\n\t\t\t\tif(options.observation) {\n\t\t\t\t\toptions.observation.update();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nobserveReader.propertyReaders.forEach(function(reader){\n\tobserveReader.propertyReadersMap[reader.name] = reader;\n});\nobserveReader.valueReaders.forEach(function(reader){\n\tobserveReader.valueReadersMap[reader.name] = reader;\n});\nobserveReader.set = observeReader.write;\n\nmodule.exports = observeReader;\n"],"names":["observeReader","getValueSymbol","canSymbol","for","setValueSymbol","isValueLikeSymbol","peek","ObservationRecorder","ignore","canReflect","getKeyValue","bind","bindName","Function","prototype","process","env","NODE_ENV","source","fn","call","this","Object","defineProperty","value","getName","isAt","index","reads","prevRead","at","readValue","options","state","prev","i","len","valueReaders","length","test","read","specialRead","key","event","element","viewModel","checkForObservableAndNotify","getObserves","foundObservable","trapsCount","addMany","objHasKeyAtIndex","obj","hasKey","parent","trap","parentHasKey","cur","readLength","r","readersLength","propertyReaders","reader","earlyExit","undefined","foundLastParent","get","valueReadersMap","name","isFunctionLike","isConstructorLike","callMethodsOnObservables","isObservableLike","isMapLike","dev","warn","apply","args","proxyMethods","foundAt","readCompute","getValue","write","base","newVal","set","propertyReadersMap","isPromise","then","canReflectPromise","prop","res","setKeyValue","propValue","update","setValue","keyArg","keys","last","charAt","keyToAdd","character","push","substr","pop","keyValue","isValueLike","map","object","observation","forEach"],"mappings":"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"}