{"version":3,"file":"chunk-8f9d5c6d.js","sources":["../node_modules/can-simple-observable/async/async.js","../node_modules/can-simple-observable/resolver/resolver.js"],"sourcesContent":["\"use strict\";\nvar SimpleObservable = require(\"../can-simple-observable\");\nvar Observation = require(\"can-observation\");\nvar queues = require(\"can-queues\");\nvar SettableObservable = require(\"../settable/settable\");\nvar canReflect = require(\"can-reflect\");\nvar ObservationRecorder = require(\"can-observation-recorder\");\nvar valueEventBindings = require(\"can-event-queue/value/value\");\n\n// This is an observable that is like `settable`, but passed a `resolve`\n// function that can resolve the value of this observable late.\nfunction AsyncObservable(fn, context, initialValue) {\n\tthis.resolve = this.resolve.bind(this);\n\tthis.lastSetValue = new SimpleObservable(initialValue);\n\tthis.handler = this.handler.bind(this);\n\n\tfunction observe() {\n\t\tthis.resolveCalled = false;\n\n\t\t// set inGetter flag to avoid calling `resolve` redundantly if it is called\n\t\t// synchronously in the getter\n\t\tthis.inGetter = true;\n\t\tvar newVal = fn.call(\n\t\t\tcontext,\n\t\t\tthis.lastSetValue.get(),\n\t\t\tthis.bound === true ? this.resolve : undefined\n\t\t);\n\t\tthis.inGetter = false;\n\n\t\t// if the getter returned a value, resolve with the value\n\t\tif (newVal !== undefined) {\n\t\t\tthis.resolve(newVal);\n\t\t}\n\t\t// otherwise, if `resolve` was called synchronously in the getter,\n\t\t// resolve with the value passed to `resolve`\n\t\telse if (this.resolveCalled) {\n\t\t\tthis.resolve(this._value);\n\t\t}\n\n\t\t// if bound, the handlers will be called by `resolve`\n\t\t// returning here would cause a duplicate event\n\t\tif (this.bound !== true) {\n\t\t\treturn newVal;\n\t\t}\n\t}\n\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor) +\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(fn) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.handler, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".handler\"\n\t\t});\n\t\tObject.defineProperty(observe, \"name\", {\n\t\t\tvalue: canReflect.getName(fn) + \"::\" + canReflect.getName(this.constructor)\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tthis.observation = new Observation(observe, this);\n}\nAsyncObservable.prototype = Object.create(SettableObservable.prototype);\nAsyncObservable.prototype.constructor = AsyncObservable;\n\nAsyncObservable.prototype.handler = function(newVal) {\n\tif (newVal !== undefined) {\n\t\tSettableObservable.prototype.handler.apply(this, arguments);\n\t}\n};\n\nvar peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));\nAsyncObservable.prototype.activate = function() {\n\tcanReflect.onValue(this.observation, this.handler, \"notify\");\n\tif (!this.resolveCalled) {\n\t\tthis._value = peek(this.observation);\n\t}\n};\n\nAsyncObservable.prototype.resolve = function resolve(newVal) {\n\tthis.resolveCalled = true;\n\tvar old = this._value;\n\tthis._value = newVal;\n\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tif (typeof this._log === \"function\") {\n\t\t\tthis._log(old, newVal);\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// if resolve was called synchronously from the getter, do not enqueue changes\n\t// the observation will handle calling resolve again if required\n\tif (!this.inGetter) {\n\t\tvar queuesArgs = [\n\t\tthis.handlers.getNode([]),\n\t\t\tthis,\n\t\t\t[newVal, old],\n\t\t\tnull\n\t\t];\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tqueuesArgs = [\n\t\t\t\tthis.handlers.getNode([]),\n\t\t\t\tthis,\n\t\t\t\t[newVal, old],\n\t\t\t\tnull\n\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\t, [canReflect.getName(this), \"resolved with\", newVal]\n\t\t\t\t/* jshint laxcomma: false */\n\t\t\t];\n\t\t}\n\t\t//!steal-remove-end\n\t\t// adds callback handlers to be called w/i their respective queue.\n\t\tqueues.enqueueByQueue.apply(queues, queuesArgs);\n\t}\n};\n\nmodule.exports = AsyncObservable;\n","\"use strict\";\nvar canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\nvar ObservationRecorder = require(\"can-observation-recorder\");\nvar Observation = require(\"can-observation\");\nvar queues = require(\"can-queues\");\nvar mapEventBindings = require(\"can-event-queue/map/map\");\nvar SettableObservable = require(\"../settable/settable\");\nvar SimpleObservable = require(\"../can-simple-observable\");\n\nvar getChangesSymbol = canSymbol.for(\"can.getChangesDependencyRecord\");\n\nfunction ResolverObservable(resolver, context, initialValue) {\n\t// we don't want reads leaking out.  We should be binding to all of this ourselves.\n\tthis.resolver = ObservationRecorder.ignore(resolver);\n\tthis.context = context;\n\tthis._valueOptions = {\n\t\tresolve: this.resolve.bind(this),\n\t\tlistenTo: this.listenTo.bind(this),\n\t\tstopListening: this.stopListening.bind(this),\n\t\tlastSet: new SimpleObservable(initialValue)\n\t};\n\n\tthis.update = this.update.bind(this);\n\n\tthis.contextHandlers = new WeakMap();\n\tthis.teardown = null;\n\t// a place holder for remembering where we bind\n\tthis.binder = {};\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor) +\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(resolver) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.update, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".update\"\n\t\t});\n\n\t\tcanReflect.assignSymbols(this._valueOptions.lastSet, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor)  +\"::lastSet\"+\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(resolver) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\t//!steal-remove-end\n}\nResolverObservable.prototype = Object.create(SettableObservable.prototype);\n\nfunction deleteHandler(bindTarget, event, queue, handler){\n\tmapEventBindings.off.call(bindTarget, event, handler, queue);\n}\n\ncanReflect.assignMap(ResolverObservable.prototype, {\n\tconstructor: ResolverObservable,\n\tlistenTo: function(bindTarget, event, handler, queueName) {\n\t\t//Object.defineProperty(this.handler, \"name\", {\n\t\t//\tvalue: canReflect.getName(this) + \".handler\"\n\t\t//});\n\t\tif(canReflect.isPrimitive(bindTarget)) {\n\t\t\thandler = event;\n\t\t\tevent = bindTarget;\n\t\t\tbindTarget = this.context;\n\t\t}\n\t\tif(typeof event === \"function\") {\n\t\t\thandler = event;\n\t\t\tevent = undefined;\n\t\t}\n\n\t\tvar resolverInstance = this;\n\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tif(!handler.name) {\n\t\t\t\tObject.defineProperty(handler, \"name\", {\n\t\t\t\t\tvalue:\n\t\t\t\t\t\t(bindTarget ?\n\t\t\t\t\t\t\t canReflect.getName(bindTarget) : \"\")+\n\t\t\t\t\t\t (event ? \".on('\"+event+\"',handler)\" : \".on(handler)\")+\n\t\t\t\t\t\t \"::\"+canReflect.getName(this)\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tvar contextHandler = handler.bind(this.context);\n\t\tcontextHandler[getChangesSymbol] = function getChangesDependencyRecord() {\n\t\t\tvar s = new Set();\n\t\t\ts.add(resolverInstance);\n\t\t\treturn {\n\t\t\t\tvalueDependencies: s\n\t\t\t};\n\t\t};\n\n\t\tthis.contextHandlers.set(handler, contextHandler);\n\t\tmapEventBindings.listenTo.call(this.binder, bindTarget, event, contextHandler, queueName || \"notify\");\n\t},\n\tstopListening: function(){\n\n\t\tvar meta = this.binder[canSymbol.for(\"can.meta\")];\n\t\tvar listenHandlers = meta && meta.listenHandlers;\n\t\tif(listenHandlers) {\n\t\t\tvar keys = mapEventBindings.stopListeningArgumentsToKeys.call({context: this.context, defaultQueue: \"notify\"});\n\n\t\t\tlistenHandlers.delete(keys, deleteHandler);\n\t\t}\n\t\treturn this;\n\t},\n\tresolve: function(newVal) {\n\t\tthis._value = newVal;\n\t\t// if we are setting up the initial binding and we get a resolved value\n\t\t// do not emit events for it.\n\n\t\tif(this.isBinding) {\n\t\t\tthis.lastValue = this._value;\n\t\t\treturn newVal;\n\t\t}\n\n\t\tif(this._value !== this.lastValue) {\n\t\t\tvar enqueueMeta  = {};\n\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t/* jshint laxcomma: true */\n\t\t\t\tenqueueMeta = {\n\t\t\t\t\tlog: [canReflect.getName(this.update)],\n\t\t\t\t\treasonLog: [canReflect.getName(this), \"resolved with\", newVal]\n\t\t\t\t};\n\t\t\t\t/* jshint laxcomma: false */\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tqueues.batch.start();\n\t\t\tqueues.deriveQueue.enqueue(\n\t\t\t\tthis.update,\n\t\t\t\tthis,\n\t\t\t\t[],\n\t\t\t\tenqueueMeta\n\t\t\t);\n\t\t\tqueues.batch.stop();\n\t\t}\n\t\treturn newVal;\n\t},\n\tupdate: function(){\n\n\t\tif(this.lastValue !== this._value) {\n\n\t\t\tvar old = this.lastValue;\n\t\t\tthis.lastValue = this._value;\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tif (typeof this._log === \"function\") {\n\t\t\t\t\tthis._log(old, this._value);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\t// adds callback handlers to be called w/i their respective queue.\n\t\t\tqueues.enqueueByQueue(\n\t\t\t\tthis.handlers.getNode([]),\n\t\t\t\tthis,\n\t\t\t\t[this._value, old]\n\t\t\t);\n\t\t}\n\t},\n\tactivate: function() {\n\t\tthis.isBinding = true;\n\t\tthis.teardown = this.resolver.call(this.context, this._valueOptions);\n\t\tthis.isBinding = false;\n\t},\n\tonUnbound: function() {\n\t\tthis.bound = false;\n\t\tmapEventBindings.stopListening.call(this.binder);\n\t\tif(this.teardown != null) {\n\t\t\tthis.teardown();\n\t\t\tthis.teardown = null;\n\t\t}\n\t},\n\tset: function(value) {\n\t\tthis._valueOptions.lastSet.set(value);\n\n\t\t/*if (newVal !== this.lastSetValue.get()) {\n\t\t\tthis.lastSetValue.set(newVal);\n\t\t}*/\n\t},\n\tget: function() {\n\t\tif (ObservationRecorder.isRecording()) {\n\t\t\tObservationRecorder.add(this);\n\t\t\tif (!this.bound) {\n\t\t\t\tthis.onBound();\n\t\t\t}\n\t\t}\n\n\t\tif (this.bound === true) {\n\t\t\treturn this._value;\n\t\t} else {\n\t\t\tvar handler = function(){};\n\t\t\tthis.on(handler);\n\t\t\tvar val = this._value;\n\t\t\tthis.off(handler);\n\t\t\treturn val;\n\t\t}\n\t},\n\thasDependencies: function hasDependencies() {\n\t\tvar hasDependencies = false;\n\n\t\tif (this.bound) {\n\t\t\tvar meta = this.binder[canSymbol.for(\"can.meta\")];\n\t\t\tvar listenHandlers = meta && meta.listenHandlers;\n\t\t\thasDependencies = !!listenHandlers.size();\n\t\t}\n\n\t\treturn hasDependencies;\n\t},\n\tgetValueDependencies: function getValueDependencies() {\n\t\tif (this.bound) {\n\t\t\tvar meta = this.binder[canSymbol.for(\"can.meta\")];\n\t\t\tvar listenHandlers = meta && meta.listenHandlers;\n\n\t\t\tvar keyDeps = new Map();\n\t\t\tvar valueDeps = new Set();\n\n\t\t\tif (listenHandlers) {\n\t\t\t\tcanReflect.each(listenHandlers.root, function(events, obj) {\n\t\t\t\t\tcanReflect.each(events, function(queues, eventName) {\n\t\t\t\t\t\tif (eventName === undefined) {\n\t\t\t\t\t\t\tvalueDeps.add(obj);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar entry = keyDeps.get(obj);\n\t\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\t\tentry = new Set();\n\t\t\t\t\t\t\t\tkeyDeps.set(obj, entry);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry.add(eventName);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tif (valueDeps.size || keyDeps.size) {\n\t\t\t\t\tvar result = {};\n\n\t\t\t\t\tif (keyDeps.size) {\n\t\t\t\t\t\tresult.keyDependencies = keyDeps;\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDeps.size) {\n\t\t\t\t\t\tresult.valueDependencies = valueDeps;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\ncanReflect.assignSymbols(ResolverObservable.prototype, {\n\t\"can.getValue\": ResolverObservable.prototype.get,\n\t\"can.setValue\": ResolverObservable.prototype.set,\n\t\"can.isMapLike\": false,\n\t\"can.getPriority\": function() {\n\t\t// TODO: the priority should come from any underlying values\n\t\treturn this.priority || 0;\n\t},\n\t\"can.setPriority\": function(newPriority) {\n\t\tthis.priority = newPriority;\n\t},\n\t\"can.valueHasDependencies\": ResolverObservable.prototype.hasDependencies,\n\t\"can.getValueDependencies\": ResolverObservable.prototype.getValueDependencies\n});\n\n\nmodule.exports = ResolverObservable;\n"],"names":["AsyncObservable","fn","context","initialValue","observe","this","resolveCalled","inGetter","newVal","call","lastSetValue","get","bound","resolve","undefined","_value","bind","SimpleObservable","handler","process","env","NODE_ENV","canReflect","assignSymbols","can.getName","getName","constructor","Object","defineProperty","value","observation","Observation","prototype","create","SettableObservable","apply","arguments","peek","ObservationRecorder","ignore","getValue","activate","onValue","old","_log","queuesArgs","handlers","getNode","queues","enqueueByQueue","getChangesSymbol","canSymbol","for","ResolverObservable","resolver","_valueOptions","listenTo","stopListening","lastSet","update","contextHandlers","WeakMap","teardown","binder","deleteHandler","bindTarget","event","queue","mapEventBindings","off","assignMap","queueName","isPrimitive","resolverInstance","name","contextHandler","s","Set","add","valueDependencies","set","meta","listenHandlers","keys","stopListeningArgumentsToKeys","defaultQueue","delete","isBinding","lastValue","enqueueMeta","log","reasonLog","batch","start","deriveQueue","enqueue","stop","onUnbound","isRecording","onBound","on","val","hasDependencies","size","getValueDependencies","keyDeps","Map","valueDeps","each","root","events","obj","eventName","entry","result","keyDependencies","can.getValue","can.setValue","can.isMapLike","can.getPriority","priority","can.setPriority","newPriority","can.valueHasDependencies","can.getValueDependencies"],"mappings":"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"}