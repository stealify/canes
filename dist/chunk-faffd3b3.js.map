{"version":3,"file":"chunk-faffd3b3.js","sources":["../node_modules/can-attribute-encoder/can-attribute-encoder.js"],"sourcesContent":["\"use strict\";\nvar namespace = require('can-namespace');\nvar dev = require('can-log/dev/dev');\n\n/**\n * @module {{}} can-attribute-encoder can-attribute-encoder\n * @parent can-dom-utilities\n * @collection can-infrastructure\n * @package ./package.json\n *\n * Encode and decode attribute names.\n *\n * @option {Object} An object with the methods:\n * [can-attribute-encoder.encode] and [can-attribute-encoder.decode].\n *\n */\n\n\nfunction each(items, callback){\n\tfor ( var i = 0; i < items.length; i++ ) {\n\t\tcallback(items[i], i);\n\t}\n}\n\nfunction makeMap(str){\n\tvar obj = {}, items = str.split(\",\");\n\teach(items, function(name){\n\t\tobj[name] = true;\n\t});\n\treturn obj;\n}\n\n// Attributes for which the case matters - shouldnâ€™t be lowercased.\nvar caseMattersAttributes = makeMap(\"allowReorder,attributeName,attributeType,autoReverse,baseFrequency,baseProfile,calcMode,clipPathUnits,contentScriptType,contentStyleType,diffuseConstant,edgeMode,externalResourcesRequired,filterRes,filterUnits,glyphRef,gradientTransform,gradientUnits,kernelMatrix,kernelUnitLength,keyPoints,keySplines,keyTimes,lengthAdjust,limitingConeAngle,markerHeight,markerUnits,markerWidth,maskContentUnits,maskUnits,patternContentUnits,patternTransform,patternUnits,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,repeatCount,repeatDur,requiredExtensions,requiredFeatures,specularConstant,specularExponent,spreadMethod,startOffset,stdDeviation,stitchTiles,surfaceScale,systemLanguage,tableValues,textLength,viewBox,viewTarget,xChannelSelector,yChannelSelector\");\n\nfunction camelCaseToSpinalCase(match, lowerCaseChar, upperCaseChar) {\n\treturn lowerCaseChar + \"-\" + upperCaseChar.toLowerCase();\n}\n\nfunction startsWith(allOfIt, startsWith) {\n\treturn allOfIt.indexOf(startsWith) === 0;\n}\n\nfunction endsWith(allOfIt, endsWith) {\n\treturn (allOfIt.length - allOfIt.indexOf(endsWith)) === endsWith.length;\n}\n\nvar regexes = {\n\tleftParens: /\\(/g,\n\trightParens: /\\)/g,\n\tleftBrace: /\\{/g,\n\trightBrace: /\\}/g,\n\tcamelCase: /([a-z]|^)([A-Z])/g,\n\tforwardSlash: /\\//g,\n\tspace: /\\s/g,\n\tuppercase: /[A-Z]/g,\n\tuppercaseDelimiterThenChar: /:u:([a-z])/g,\n\tcaret: /\\^/g,\n\tdollar: /\\$/g,\n\tat: /@/g\n};\n\nvar delimiters = {\n\tprependUppercase: ':u:',\n\treplaceSpace: ':s:',\n\treplaceForwardSlash: ':f:',\n\treplaceLeftParens: ':lp:',\n\treplaceRightParens: ':rp:',\n\treplaceLeftBrace: ':lb:',\n\treplaceRightBrace: ':rb:',\n\treplaceCaret: ':c:',\n\treplaceDollar: ':d:',\n\treplaceAt: ':at:'\n};\n\nvar encoder = {};\n\n/**\n * @function can-attribute-encoder.encode encode\n * @parent can-attribute-encoder\n * @description Encode an attribute name\n *\n * @signature `encoder.encode(attributeName)`\n *\n * Note: specific encoding may change, but encoded attributes\n * can always be decoded using [can-attribute-encoder.decode].\n *\n * @body\n *\n * ```js\n * var encodedAttributeName = encoder.encode(\"{(^$foo/bar baz)}\");\n * div.setAttribute(encodedAttributeName, \"attribute value\");\n * ```\n *\n * @param {String} attributeName The attribute name.\n * @return {String} The encoded attribute name.\n *\n */\nencoder.encode = function(name) {\n\tvar encoded = name;\n\n\t// encode or convert camelCase attributes unless in list of attributes\n\t// where case matters\n\tif (!caseMattersAttributes[encoded] && encoded.match(regexes.camelCase)) {\n\t\t// encode uppercase characters in new bindings\n\t\t// - on:fooBar, fooBar:to, fooBar:from, fooBar:bind\n\t\tif (\n\t\t\tstartsWith(encoded, 'on:') ||\n\t\t\tendsWith(encoded, ':to') ||\n\t\t\tendsWith(encoded, ':from') ||\n\t\t\tendsWith(encoded, ':bind') ||\n\t\t\tendsWith(encoded, ':raw')\n\t\t) {\n\t\t\tencoded = encoded\n\t\t\t\t.replace(regexes.uppercase, function(char) {\n\t\t\t\t\treturn delimiters.prependUppercase + char.toLowerCase();\n\t\t\t\t});\n\t\t} else if(startsWith(encoded, '(') || startsWith(encoded, '{')) {\n\t\t\t// convert uppercase characters in older bindings to kebab-case\n\t\t\t// - {fooBar}, (fooBar), {(fooBar)}\n\t\t\tencoded = encoded.replace(regexes.camelCase, camelCaseToSpinalCase);\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tdev.warn(\"can-attribute-encoder: Found attribute with name: \" + name + \". Converting to: \" + encoded + '.');\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t}\n\t}\n\n\t//encode spaces\n\tencoded = encoded.replace(regexes.space, delimiters.replaceSpace)\n\t\t//encode forward slashes\n\t\t.replace(regexes.forwardSlash, delimiters.replaceForwardSlash)\n\t\t// encode left parentheses\n\t\t.replace(regexes.leftParens, delimiters.replaceLeftParens)\n\t\t// encode right parentheses\n\t\t.replace(regexes.rightParens, delimiters.replaceRightParens)\n\t\t// encode left braces\n\t\t.replace(regexes.leftBrace, delimiters.replaceLeftBrace)\n\t\t// encode left braces\n\t\t.replace(regexes.rightBrace, delimiters.replaceRightBrace)\n\t\t// encode ^\n\t\t.replace(regexes.caret, delimiters.replaceCaret)\n\t\t// encode $\n\t\t.replace(regexes.dollar, delimiters.replaceDollar)\n\t\t// encode @\n\t\t.replace(regexes.at, delimiters.replaceAt);\n\n\treturn encoded;\n};\n\n/**\n * @function can-attribute-encoder.decode decode\n * @parent can-attribute-encoder\n * @description Decode an attribute name encoded by [can-attribute-encoder.encode]\n * @signature `encoder.decode(attributeName)`\n *\n * @body\n *\n * ```js\n * encoder.decode(attributeName); // -> \"{(^$foo/bar baz)}\"\n *\n * ```\n *\n * @param {String} attributeName The encoded attribute name.\n * @return {String} The decoded attribute name.\n *\n */\nencoder.decode = function(name) {\n\tvar decoded = name;\n\n\t// decode uppercase characters in new bindings\n\tif (!caseMattersAttributes[decoded] && decoded.match(regexes.uppercaseDelimiterThenChar)) {\n\t\tif (\n\t\t\tstartsWith(decoded, 'on:') ||\n\t\t\tendsWith(decoded, ':to') ||\n\t\t\tendsWith(decoded, ':from') ||\n\t\t\tendsWith(decoded, ':bind') ||\n\t\t\tendsWith(decoded, ':raw')\n\t\t) {\n\t\t\tdecoded = decoded\n\t\t\t\t.replace(regexes.uppercaseDelimiterThenChar, function(match, char) {\n\t\t\t\t\treturn char.toUpperCase();\n\t\t\t\t});\n\t\t}\n\t}\n\n\t// decode left parentheses\n\tdecoded = decoded.replace(delimiters.replaceLeftParens, '(')\n\t\t// decode right parentheses\n\t\t.replace(delimiters.replaceRightParens, ')')\n\t\t// decode left braces\n\t\t.replace(delimiters.replaceLeftBrace, '{')\n\t\t// decode left braces\n\t\t.replace(delimiters.replaceRightBrace, '}')\n\t\t// decode forward slashes\n\t\t.replace(delimiters.replaceForwardSlash, '/')\n\t\t// decode spaces\n\t\t.replace(delimiters.replaceSpace, ' ')\n\t\t// decode ^\n\t\t.replace(delimiters.replaceCaret, '^')\n\t\t//decode $\n\t\t.replace(delimiters.replaceDollar, '$')\n\t\t//decode @\n\t\t.replace(delimiters.replaceAt, '@');\n\n\treturn decoded;\n};\n\nif (namespace.encoder) {\n\tthrow new Error(\"You can't have two versions of can-attribute-encoder, check your dependencies\");\n} \nmodule.exports = namespace.encoder = encoder;\n"],"names":["each","items","callback","i","length","makeMap","str","obj","split","name","caseMattersAttributes","camelCaseToSpinalCase","match","lowerCaseChar","upperCaseChar","toLowerCase","startsWith","allOfIt","indexOf","endsWith","regexes","leftParens","rightParens","leftBrace","rightBrace","camelCase","forwardSlash","space","uppercase","uppercaseDelimiterThenChar","caret","dollar","at","delimiters","prependUppercase","replaceSpace","replaceForwardSlash","replaceLeftParens","replaceRightParens","replaceLeftBrace","replaceRightBrace","replaceCaret","replaceDollar","replaceAt","encoder","encode","encoded","replace","char","process","env","NODE_ENV","dev","warn","decode","decoded","toUpperCase","namespace","Error"],"mappings":"sKAkBA,SAASA,KAAKC,EAAOC,GACpB,IAAM,IAAIC,EAAI,EAAGA,EAAIF,EAAMG,OAAQD,IAClCD,EAASD,EAAME,GAAIA,GAIrB,SAASE,QAAQC,GAChB,IAAIC,EAAM,GAIV,OAHAP,KADsBM,EAAIE,MAAM,KACpB,SAASC,GACpBF,EAAIE,IAAQ,IAENF,EAIR,IAAIG,sBAAwBL,QAAQ,gxBAEpC,SAASM,sBAAsBC,EAAOC,EAAeC,GACpD,OAAOD,EAAgB,IAAMC,EAAcC,cAG5C,SAASC,WAAWC,EAASD,GAC5B,OAAuC,IAAhCC,EAAQC,QAAQF,GAGxB,SAASG,SAASF,EAASE,GAC1B,OAAQF,EAAQb,OAASa,EAAQC,QAAQC,KAAeA,EAASf,OAGlE,IAAIgB,QAAU,CACbC,WAAY,MACZC,YAAa,MACbC,UAAW,MACXC,WAAY,MACZC,UAAW,oBACXC,aAAc,MACdC,MAAO,MACPC,UAAW,SACXC,2BAA4B,cAC5BC,MAAO,MACPC,OAAQ,MACRC,GAAI,MAGDC,WAAa,CAChBC,iBAAkB,MAClBC,aAAc,MACdC,oBAAqB,MACrBC,kBAAmB,OACnBC,mBAAoB,OACpBC,iBAAkB,OAClBC,kBAAmB,OACnBC,aAAc,MACdC,cAAe,MACfC,UAAW,QAGRC,QAAU,CAuBdC,OAAiB,SAASpC,GACzB,IAAIqC,EAAUrC,EAiDd,OA7CKC,sBAAsBoC,IAAYA,EAAQlC,MAAMQ,QAAQK,aAI3DT,WAAW8B,EAAS,QACpB3B,SAAS2B,EAAS,QAClB3B,SAAS2B,EAAS,UAClB3B,SAAS2B,EAAS,UAClB3B,SAAS2B,EAAS,QAElBA,EAAUA,EACRC,QAAQ3B,QAAQQ,UAAW,SAASoB,GACpC,OAAOf,WAAWC,iBAAmBc,EAAKjC,iBAEnCC,WAAW8B,EAAS,MAAQ9B,WAAW8B,EAAS,QAGzDA,EAAUA,EAAQC,QAAQ3B,QAAQK,UAAWd,uBAEjB,eAAzBsC,UAAQC,IAAIC,UACdC,IAAIC,KAAK,qDAAuD5C,EAAO,oBAAsBqC,EAAU,OAO1GA,EAAUA,EAAQC,QAAQ3B,QAAQO,MAAOM,WAAWE,cAElDY,QAAQ3B,QAAQM,aAAcO,WAAWG,qBAEzCW,QAAQ3B,QAAQC,WAAYY,WAAWI,mBAEvCU,QAAQ3B,QAAQE,YAAaW,WAAWK,oBAExCS,QAAQ3B,QAAQG,UAAWU,WAAWM,kBAEtCQ,QAAQ3B,QAAQI,WAAYS,WAAWO,mBAEvCO,QAAQ3B,QAAQU,MAAOG,WAAWQ,cAElCM,QAAQ3B,QAAQW,OAAQE,WAAWS,eAEnCK,QAAQ3B,QAAQY,GAAIC,WAAWU,YAsBlCW,OAAiB,SAAS7C,GACzB,IAAI8C,EAAU9C,EAqCd,OAlCKC,sBAAsB6C,IAAYA,EAAQ3C,MAAMQ,QAAQS,8BAE3Db,WAAWuC,EAAS,QACpBpC,SAASoC,EAAS,QAClBpC,SAASoC,EAAS,UAClBpC,SAASoC,EAAS,UAClBpC,SAASoC,EAAS,WAElBA,EAAUA,EACRR,QAAQ3B,QAAQS,2BAA4B,SAASjB,EAAOoC,GAC5D,OAAOA,EAAKQ,iBAMhBD,EAAUA,EAAQR,QAAQd,WAAWI,kBAAmB,KAEtDU,QAAQd,WAAWK,mBAAoB,KAEvCS,QAAQd,WAAWM,iBAAkB,KAErCQ,QAAQd,WAAWO,kBAAmB,KAEtCO,QAAQd,WAAWG,oBAAqB,KAExCW,QAAQd,WAAWE,aAAc,KAEjCY,QAAQd,WAAWQ,aAAc,KAEjCM,QAAQd,WAAWS,cAAe,KAElCK,QAAQd,WAAWU,UAAW,OAKjC,GAAIc,UAAUb,QACb,MAAM,IAAIc,MAAM,yGAEAD,UAAUb,QAAUA"}