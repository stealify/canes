{"version":3,"file":"can-observe.js","sources":["../node_modules/can-observe/src/-symbols.js","../node_modules/can-observe/src/-observable-store.js","../node_modules/can-observe/src/-helpers.js","../node_modules/can-observe/src/-computed-helpers.js","../node_modules/can-observe/src/-make-object.js","../node_modules/can-observe/src/-make-array.js","../node_modules/can-observe/src/-make-observe.js","../node_modules/can-observe/src/-make-function.js","../node_modules/can-observe/src/-type-helpers.js","../node_modules/can-observe/object/object.js","../node_modules/can-observe/array/array.js","../node_modules/can-observe/decorators/decorators.js","../node_modules/can-observe/can-observe.js"],"sourcesContent":["\"use strict\";\nvar canSymbol = require(\"can-symbol\");\n\nmodule.exports = {\n\tmetaSymbol: canSymbol.for(\"can.meta\"),\n\t// not an actual symbol. This is so it can be enumerable\n\t// by default. We could create a KeyTree with a type where symbols are\n\t// enumerable.\n\tpatchesSymbol: \"can.patches\",\n\tkeysSymbol: \"can.keys\"\n};\n","\"use strict\";\nmodule.exports = {\n\tproxiedObjects: new WeakMap(),\n\tproxies: new WeakSet()\n};","\n\"use strict\";\nvar canSymbol = require(\"can-symbol\");\nvar metaSymbol = canSymbol.for(\"can.meta\");\nvar classTest = /^\\s*class\\s+/;\n\nvar helpers = {\n\tassignEverything: function(d, s) {\n\t\tObject.getOwnPropertyNames(s).concat(Object.getOwnPropertySymbols(s)).forEach(function(key) {\n\t\t\tObject.defineProperty(d,key, Object.getOwnPropertyDescriptor(s,key));\n\t\t});\n\t\treturn d;\n\t},\n\tisBuiltInButNotArrayOrPlainObject: function(obj) {\n\t\tif (Array.isArray(obj)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof obj === \"function\") {\n\t\t\tvar fnCode = obj.toString();\n\t\t\tif (fnCode.indexOf(\"[native code]\") > 0) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tvar toString = Object.prototype.toString.call(obj);\n\t\t\treturn toString !== '[object Object]' && toString.indexOf('[object ') !== -1;\n\t\t}\n\n\t},\n\tinheritsFromArray: function(obj) {\n\t\tvar cur = obj;\n\t\tdo {\n\t\t\tif (Array.isArray(cur)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcur = Object.getPrototypeOf(cur);\n\t\t} while (cur);\n\t\treturn false;\n\t},\n\tisClass: function(obj) {\n\t\treturn typeof obj === 'function' && classTest.test(obj.toString());\n\t},\n\tsupportsClass: (function() {\n\t\ttry {\n\t\t\teval('\"use strict\"; class A{};');\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t})(),\n\tmakeSimpleExtender: function(BaseType){\n\t\treturn function extend(name, staticProps, prototypeProps){\n\t\t    var Type = function(){\n\t\t        var source = this;\n\t\t\t\tvar instance = BaseType.apply(this, arguments);\n\t\t        if(source.init) {\n\t\t            // makes sure nothing can leak out\n\t\t            instance[metaSymbol].preventSideEffects++;\n\t\t            source.init.apply(instance, arguments);\n\t\t            instance[metaSymbol].preventSideEffects--;\n\t\t        }\n\t\t        return instance;\n\t\t\t};\n\n\n\t\t\thelpers.assignEverything(Type,BaseType);\n\t\t\thelpers.assignEverything(Type, staticProps || {});\n\t\t\tType.extend = helpers.makeSimpleExtender(Type);\n\t\t\tType.prototype = Object.create( BaseType.prototype );\n\t\t\thelpers.assignEverything(Type.prototype, prototypeProps || {});\n\t\t\tType.prototype.constructor = Type;\n\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tObject.defineProperty(Type, \"name\", {\n\t\t\t\t\tvalue: name\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn Type;\n\t\t};\n\t},\n\tassignNonEnumerable: function(obj, key, value){\n\t\treturn Object.defineProperty(obj,key,{\n\t\t    enumerable: false,\n\t\t    writable: true,\n\t\t    configurable: true,\n\t\t    value: value\n\t\t});\n\t}\n};\n\n\nmodule.exports = helpers;\n","\"use strict\";\nvar Observation = require(\"can-observation\");\nvar ObservationRecorder = require(\"can-observation-recorder\");\nvar mapBindings = require(\"can-event-queue/map/map\");\n\nvar canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\nvar canMeta = canSymbol.for(\"can.meta\");\nvar computedPropertyDefinitionSymbol = canSymbol.for(\"can.computedPropertyDefinitions\");\nvar onKeyValueSymbol = canSymbol.for(\"can.onKeyValue\");\nvar offKeyValueSymbol = canSymbol.for(\"can.offKeyValue\");\n// var getKeyDependenciesSymbol = canSymbol.for(\"can.getKeyDependencies\");\n\n// ## ComputedObjectObservationData\n// Instances of this are created to wrap the observation.\n// The `.bind` and `.unbind` methods should be called when the\n// instance's prop is bound or unbound.\nfunction ComputedObjectObservationData(instance, prop, observation){\n\tthis.instance = instance;\n    this.prop = prop;\n    this.observation = observation;\n\tthis.forward = this.forward.bind(this);\n}\n\nComputedObjectObservationData.prototype.bind = function(){\n    this.bindingCount++;\n    if(this.bindingCount === 1) {\n        this.observation.on(this.forward, \"notify\");\n    }\n};\n\nComputedObjectObservationData.prototype.unbind = function(){\n    this.bindingCount--;\n    if(this.bindingCount === 0) {\n        this.observation.off(this.forward, \"notify\");\n    }\n};\n\nComputedObjectObservationData.prototype.forward = function(newValue, oldValue){\n\tmapBindings.dispatch.call(this.instance, {\n\t\ttype: this.prop,\n\t\ttarget: this.instance\n\n\t\t// patches: [{\n\t\t// \tkey: this.prop,\n\t\t// \ttype: \"set\",\n\t\t// \tvalue: newValue\n\t\t// }]\n\t\t// keyChanged: undefined\n\t}, [newValue, oldValue]);\n};\n\nComputedObjectObservationData.prototype.bindingCount = 0;\n\nfunction findComputed(instance, key) {\n\tvar meta = instance[canMeta];\n\tvar target = meta.target;\n\n\tvar computedPropertyDefinitions = target[computedPropertyDefinitionSymbol];\n\tif (computedPropertyDefinitions === undefined) {\n\t\treturn;\n\t}\n\tvar computedPropertyDefinition = computedPropertyDefinitions[key];\n\tif (computedPropertyDefinition === undefined) {\n\t\treturn;\n\t}\n\n\tif (meta.computedKeys[key] === undefined) {\n\t\tmeta.computedKeys[key] = new ComputedObjectObservationData(\n\t\t\tinstance, key,\n\t\t\tcomputedPropertyDefinition(instance, key)\n\t\t);\n\t}\n\n\treturn meta.computedKeys[key];\n}\n\nvar computedHelpers = module.exports = {\n\tget: function(instance, key) {\n\t\tvar computedObj = findComputed(instance, key);\n\t\tif (computedObj === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tObservationRecorder.add(instance, key.toString());\n\t\tif(computedObj.bindingCount === 0 && ObservationRecorder.isRecording()) {\n\t\t\tObservation.temporarilyBind(computedObj.observation);\n\t\t}\n\n\t\treturn {\n\t\t\tvalue: canReflect.getValue(computedObj.observation),\n\t\t};\n\t},\n\tset: function(instance, key, value) {\n\t\tvar computedObj = findComputed(instance, key);\n\t\tif (computedObj === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tif (computedObj.observation[canSymbol.for(\"can.setValue\")] === undefined) {\n\t\t\t\tthrow new Error(\"Cannot set \\\"\" + key + \"\\\" on \" + canReflect.getName(instance));\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tcanReflect.setValue(computedObj.observation, value);\n\t\treturn true;\n\t},\n\tbind: function(instance, key) {\n\t\tvar computedObj = findComputed(instance, key);\n\t\tif (computedObj === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tcomputedObj.bind();\n\t},\n\tunbind: function(instance, key) {\n\t\tvar computedObj = findComputed(instance, key);\n\t\tif (computedObj === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tcomputedObj.unbind();\n\t},\n\taddKeyDependencies: function(proxyKeys) {\n\t\tvar onKeyValue = proxyKeys[onKeyValueSymbol];\n\t\tvar offKeyValue = proxyKeys[offKeyValueSymbol];\n\t\t// var getKeyDependencies = proxyKeys[getKeyDependenciesSymbol];\n\n\t\tcanReflect.assignSymbols(proxyKeys, {\n\t\t\t\"can.onKeyValue\": function(key, handler, queue) {\n\t\t\t\tcomputedHelpers.bind(this, key);\n\n\t\t\t\t// var handlers = this[canMeta].handlers;\n\t\t\t\t// handlers.add([ key, \"onKeyValue\", queue || \"notify\", handler ]);\n\n\t\t\t\treturn onKeyValue.apply(this, arguments);\n\t\t\t},\n\t\t\t\"can.offKeyValue\": function(key, handler, queue) {\n\t\t\t\tcomputedHelpers.unbind(this, key);\n\n\t\t\t\t// var handlers = this[canMeta].handlers;\n\t\t\t\t// handlers.delete([ key, \"onKeyValue\", queue || \"notify\", handler ]);\n\n\t\t\t\treturn offKeyValue.apply(this, arguments);\n\t\t\t},\n\t\t\t\"can.getKeyDependencies\": function(key) {\n\t\t\t\tvar computedObj = findComputed(this, key);\n\t\t\t\tif (computedObj === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: new Set([ computedObj.observation ])\n\t\t\t\t};\n\t\t\t},\n\t\t});\n\t},\n\taddMethodsAndSymbols: function(Type) {\n\t\tType.prototype.addEventListener = function(key, handler, queue) {\n\t\t\tcomputedHelpers.bind(this, key);\n\t\t\treturn mapBindings.addEventListener.call(this, key, handler, queue);\n\t\t};\n\n\t\tType.prototype.removeEventListener = function(key, handler, queue) {\n\t\t\tcomputedHelpers.unbind(this, key);\n\t\t\treturn mapBindings.removeEventListener.call(this, key, handler, queue);\n\t\t};\n\t},\n\tensureDefinition: function(prototype) {\n\t\tif (!prototype.hasOwnProperty(computedPropertyDefinitionSymbol)) {\n\t\t\tvar parent = prototype[computedPropertyDefinitionSymbol];\n\t\t\tvar definitions = prototype[computedPropertyDefinitionSymbol] = Object.create(parent || null);\n\n\t\t\tObject.getOwnPropertyNames(prototype).forEach(function(prop) {\n\t\t\t\tif (prop === \"constructor\") {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// auto-binding for getters\n\t\t\t\tvar descriptor = Object.getOwnPropertyDescriptor(prototype, prop);\n\t\t\t\tif(descriptor.get !== undefined) {\n\t\t\t\t\tvar getter = descriptor.get;\n\t\t\t\t\tdefinitions[prop] = function(instance, property) {\n\t\t\t\t\t\treturn new Observation(getter, instance);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn prototype[computedPropertyDefinitionSymbol];\n\t},\n};\n","\"use strict\";\n// # -make-object.js\n// This module's `.observable` method proxies an object to make it observable.\n// The other exports are used by other make-TYPE modules.\nvar canReflect = require(\"can-reflect\");\nvar ObservationRecorder = require(\"can-observation-recorder\");\nvar mapBindings = require(\"can-event-queue/map/map\");\n\nvar symbols = require(\"./-symbols\");\nvar observableStore = require(\"./-observable-store\");\nvar helpers = require(\"./-helpers\");\nvar computedHelpers = require(\"./-computed-helpers\");\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar isSymbolLike = canReflect.isSymbolLike;\n\n// These are the \"overwrites\" for the proxy.\n// Copy the symbols from the map bindings mixin.\nvar proxyKeys = Object.create(null);\nObject.getOwnPropertySymbols(mapBindings).forEach(function(symbol){\n\thelpers.assignNonEnumerable(proxyKeys, symbol, mapBindings[symbol]);\n});\n\ncomputedHelpers.addKeyDependencies(proxyKeys);\n\nvar makeObject = {\n\t// Returns a proxied version of the object.\n\t// - `object` - An object to proxy.\n\t// - `options` - Configurable behaviors.\n\t//   - `proxyKeys` - Keys that will override any keys on `object`. Defaults to `makeObject.proxyKeys`.\n\t//   - `observe(nonObservable)` - A function that converts a nested value to an observable.\n\t//   - `shouldRecordObservation(keyInfo, meta)` - Returns if `ObservationRecorder`\n\t//     should be called.  Defaults to `makeObject.shouldRecordObservationOnOwnAndMissingKeys`.\n\tobservable: function(object, options) {\n\t\tif(options.shouldRecordObservation === undefined) {\n\t\t\toptions.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;\n\t\t}\n\n\t\tvar meta = {\n\t\t\ttarget: object,\n\t\t\tproxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(makeObject.proxyKeys()),\n\t\t\tcomputedKeys: Object.create(null),\n\t\t\toptions: options,\n\t\t\t// `preventSideEffects` is a counter used to \"turn off\" the proxy.  This is incremented when some\n\t\t\t// function (like `Array.splice`) wants to handle event dispatching and/or calling\n\t\t\t// `ObservationRecorder` itself for performance reasons.\n\t\t\tpreventSideEffects: 0\n\t\t};\n\n\t\thelpers.assignNonEnumerable(meta.proxyKeys, symbols.metaSymbol, meta);\n\n\t\t// We `bind` so the `meta` is immediately available as `this`.\n\t\tvar traps = {\n\t\t\tget: makeObject.get.bind(meta),\n\t\t\tset: makeObject.set.bind(meta),\n\t\t\townKeys: makeObject.ownKeys.bind(meta),\n\t\t\tdeleteProperty: makeObject.deleteProperty.bind(meta),\n\t\t\tgetOwnPropertyDescriptor: makeObject.getOwnPropertyDescriptor.bind(meta),\n\t\t\tmeta: meta\n\t\t};\n\n\t\tif(options.getPrototypeOf) {\n\t\t\ttraps.getPrototypeOf = options.getPrototypeOf;\n\t\t}\n\n\t\tmeta.proxy = new Proxy(object, traps);\n\t\tmapBindings.addHandlers(meta.proxy, meta);\n\t\treturn meta.proxy;\n\t},\n\tproxyKeys: function() {\n\t\treturn proxyKeys;\n\t},\n\t// `get` checks the target for un-proxied objects.\n\t// If it finds an un-proxied object:\n\t//   - it creates one (which registers itself in the observableStore) and\n\t//   - returns the proxied value without modifying the underlying target\n\tget: function(target, key, receiver) {\n\t\t// If getting a key for the proxy, return that value.\n\t\tvar proxyKey = this.proxyKeys[key];\n\t\tif (proxyKey !== undefined) {\n\t\t\treturn proxyKey;\n\t\t}\n\n\t\t// Symbols are not observable and their values are not made observable.\n\t\tif (isSymbolLike(key)) {\n\t\t\treturn target[key];\n\t\t}\n\n\t\t// If it has a defined property definiition\n\t\tvar computedValue = computedHelpers.get(receiver, key);\n\t\tif(computedValue !== undefined ) {\n\t\t\treturn computedValue.value;\n\t\t}\n\n\t\t// Gets information about the key on `target` or on `target`'s prototype.\n\t\tvar keyInfo = makeObject.getKeyInfo(target, key, receiver, this);\n\t\tvar value = keyInfo.targetValue;\n\n\t\t// If the return value can be changed ...\n\t\tif (!keyInfo.valueIsInvariant) {\n\t\t\t// Convert the value into an observable\n\t\t\t// or get it if already converted from the store.\n\t\t\tvalue = makeObject.getValueFromStore(key, value, this);\n\t\t}\n\n\t\tif (this.options.shouldRecordObservation(keyInfo, this)) {\n\t\t\tObservationRecorder.add(this.proxy, key.toString());\n\t\t}\n\n\t\t// if the parent object is observable, we need to observe there too.\n\t\tif (keyInfo.parentObservableGetCalledOn) {\n\t\t\tObservationRecorder.add(keyInfo.parentObservableGetCalledOn, key.toString());\n\t\t}\n\t\treturn value;\n\t},\n\t// `set` is called when a property is set on the proxy or an object\n\t// that has the proxy on its prototype.\n\tset: function(target, key, value, receiver) {\n\t\t// If the receiver is not this observable (the observable might be on the proto chain),\n\t\t// set the key on the reciever.\n\t\tif (receiver !== this.proxy) {\n\t\t\treturn makeObject.setKey(receiver, key, value, this);\n\t\t}\n\n\t\t// If it has a defined property definiition\n\t\tvar computedValue = computedHelpers.set(receiver, key, value);\n\t\tif(computedValue === true ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Gets the observable value to set.\n\t\tvalue = makeObject.getValueToSet(key, value, this);\n\n\t\t// Sets the value on the target.  If there\n\t\t// is a change, calls the callback.\n\t\tmakeObject.setValueAndOnChange(key, value, this, function(key, value, meta, hadOwn, old) {\n\n\t\t\t//!steal-remove-start\n\t\t\tvar reasonLog = [canReflect.getName(meta.proxy)+\" set\", key,\"to\", value];\n\t\t\t//!steal-remove-end\n\n\t\t\tvar dispatchArgs = {\n\t\t\t\ttype: key,\n\t\t\t\tpatches: [{\n\t\t\t\t\tkey: key,\n\t\t\t\t\ttype: hadOwn ? \"set\" : \"add\",\n\t\t\t\t\tvalue: value\n\t\t\t\t}],\n\t\t\t\tkeyChanged: !hadOwn ? key : undefined\n\t\t\t};\n\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tdispatchArgs.reasonLog = reasonLog;\n\t\t\t}\t\t\t\t\n\t\t\t//!steal-remove-end\n\n\t\t\t// Fire event handlers for this key change.\n\t\t\tmapBindings.dispatch.call( meta.proxy, dispatchArgs,[value, old]);\n\n\t\t});\n\n\t\treturn true;\n\t},\n\t// `deleteProperty` is called when a property is deleted on the proxy.\n\tdeleteProperty: function(target, key) {\n\n\t\tvar old = this.target[key],\n\t\t\tdeleteSuccessful = delete this.target[key];\n\n\t\t// Fire event handlers if we were able to delete and the value changed.\n\t\tif (deleteSuccessful && this.preventSideEffects === 0 && old !== undefined) {\n\t\t\t//!steal-remove-start\n\t\t\tvar reasonLog = [canReflect.getName(this.proxy)+\" deleted\", key];\n\t\t\t//!steal-remove-end\n\t\t\t// wrapping in process.env.NODE_ENV !== 'production' causes out of scope error\n\t\t\tvar dispatchArgs = {\n\t\t\t\ttype: key,\n\t\t\t\tpatches: [{\n\t\t\t\t\tkey: key,\n\t\t\t\t\ttype: \"delete\"\n\t\t\t\t}],\n\t\t\t\tkeyChanged: key\n\t\t\t};\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tdispatchArgs.reasonLog = reasonLog;\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tmapBindings.dispatch.call( this.proxy, dispatchArgs,[undefined, old]);\n\n\t\t}\n\t\treturn deleteSuccessful;\n\t},\n\t// `ownKeys` returns the proxies keys.\n\t// Proxies should return the keys and symbols from proxyOnly\n\t// as well as from the target, so operators like `in` and\n\t// functions like `hasOwnProperty` can be used to determine\n\t// that the Proxy is observable.\n\townKeys: function(target, key) {\n\t\tObservationRecorder.add(this.proxy, symbols.keysSymbol);\n\n\t\treturn Object.getOwnPropertyNames(this.target)\n\t\t\t.concat(Object.getOwnPropertySymbols(this.target))\n\t\t\t.concat(Object.getOwnPropertySymbols(this.proxyKeys));\n\t},\n\tgetOwnPropertyDescriptor: function(target, key) {\n\t\tvar desc = Object.getOwnPropertyDescriptor(target, key);\n\n\t\tif(!desc && (key in this.proxyKeys)) {\n\t\t\treturn Object.getOwnPropertyDescriptor(this.proxyKeys, key);\n\t\t}\n\n\t\treturn desc;\n\t},\n\t// Returns a `keyInfo` object with useful information about the key\n\t// and its value.  This function is _heavily_ optimized.\n\tgetKeyInfo: function(target, key, receiver, meta) {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(target, key);\n\t\tvar propertyInfo = {\n\t\t\t// The key being read.\n\t\t\tkey: key,\n\t\t\t// The property descriptor.\n\t\t\tdescriptor: descriptor,\n\t\t\t// If the `target` has the key.\n\t\t\ttargetHasOwnKey: Boolean(descriptor),\n\t\t\t// If the proxy is on the proto chain.\n\t\t\tgetCalledOnParent: receiver !== meta.proxy,\n\t\t\t// If the prototype of the target has this key.\n\t\t\tprotoHasKey: false,\n\t\t\t// If the property is sealed or not.\n\t\t\tvalueIsInvariant: false,\n\t\t\t// The value of the key wherever it is found.\n\t\t\ttargetValue: undefined,\n\t\t\t// If reading the key went through a getter.\n\t\t\tisAccessor: false\n\t\t};\n\t\tif (propertyInfo.getCalledOnParent === true) {\n\t\t\tpropertyInfo.parentObservableGetCalledOn = observableStore.proxiedObjects.get(receiver);\n\t\t}\n\t\tif (descriptor !== undefined) {\n\t\t\tpropertyInfo.valueIsInvariant = descriptor.writable === false;\n\t\t\tif (descriptor.get !== undefined) {\n\t\t\t\tpropertyInfo.targetValue = descriptor.get.call( propertyInfo.parentObservableGetCalledOn || receiver);\n\t\t\t\tpropertyInfo.isAccessor = true;\n\t\t\t} else {\n\t\t\t\tpropertyInfo.targetValue = descriptor.value;\n\t\t\t}\n\t\t} else {\n\t\t\tpropertyInfo.targetValue = meta.target[key];\n\t\t\tpropertyInfo.protoHasKey = propertyInfo.targetValue !== undefined ? true : (key in target);\n\t\t}\n\n\t\treturn propertyInfo;\n\t},\n\t// Returns `true` if `ObservationRecorder.add` should be called.\n\t// This is the default `options.shouldRecordObservation` behavior.\n\t// `observe.Object` changes this to record all keys except functions on the\n\t// proto chain.\n\tshouldRecordObservationOnOwnAndMissingKeys: function(keyInfo, meta) {\n\t\treturn meta.preventSideEffects === 0 &&\n\t\t\t// The read is not a getter AND ...\n\t\t\t!keyInfo.isAccessor &&\n\t\t\t(\n\t\t\t\t// (the read is on the proxy OR\n\t\t\t\t(// it's not on the proto chain and we are not sealed).\n                keyInfo.targetHasOwnKey || !keyInfo.protoHasKey && !Object.isSealed(meta.target))\n\t\t\t);\n\t},\n\t// `setKey` sets a value on an object. Use `Object.defineProperty`\n\t// because it won't try setting up the proto chain.\n\tsetKey: function(receiver, key, value) {\n\t\tObject.defineProperty(receiver, key, {\n\t\t\tvalue: value,\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\twritable: true\n\t\t});\n\t\treturn true;\n\t},\n\t// `getValueToSet` gets the value we will set on the object.  It only\n\t// converts set values to observables if we have actually bound.\n\tgetValueToSet: function(key, value, meta) {\n\t\tif (!canReflect.isSymbolLike(key) && meta.handlers.getNode([key])) {\n\t\t\treturn makeObject.getValueFromStore(key, value, meta);\n\t\t}\n\t\treturn value;\n\t},\n\t// Get a value from the store if we can.\n\tgetValueFromStore: function(key, value, meta) {\n\t\t// We never convert primitives or things that are already observable.\n\t\t// However, there are some builtIns that we premptively convert, namely\n\t\t// Array.prototype methods.\n\t\tif (!canReflect.isPrimitive(value) &&\n\t\t\t!canReflect.isObservableLike(value) &&\n\t\t\t// Do nothing if the value is already a converted proxy.\n\t\t\t!observableStore.proxies.has(value)) {\n\n\t\t\t// If the `value` already been made into a proxy, use the value.\n\t\t\tif (observableStore.proxiedObjects.has(value)) {\n\t\t\t\tvalue = observableStore.proxiedObjects.get(value);\n\t\t\t}\n\t\t\telse if (!helpers.isBuiltInButNotArrayOrPlainObject(value)) {\n\t\t\t\tvalue = meta.options.observe(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t},\n\n\t// `setValueAndOnChange` sets the value.  If the value changed,\n\t// calls the `onChange` callback.\n\tsetValueAndOnChange: function(key, value, data, onChange) {\n\t\tvar old, change;\n\t\tvar hadOwn = hasOwn.call(data.target, key);\n\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(data.target, key);\n\t\t// call the setter on the Proxy to properly do any side-effect sets (and run corresponding handlers)\n\t\t// -- setters do not return values, so it is unnecessary to check for changes.\n\t\tif (descriptor && descriptor.set) {\n\t\t\tdescriptor.set.call(data.proxy, value);\n\t\t} else {\n\t\t\t// otherwise check for a changed value\n\t\t\told = data.target[key];\n\t\t\tchange = old !== value;\n\t\t\tif (change) {\n\t\t\t\tdata.target[key] = value;\n\t\t\t\tif (data.preventSideEffects === 0) {\n\t\t\t\t\tonChange(key, value, data, hadOwn, old);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nmodule.exports = makeObject;\n","\"use strict\";\n// # -make-array.js\n// This module's `.observable` method proxies an Array to make it observable.\n// The other exports are not used elsewhere.\n// `.set` is the only proxy method that differs from `make-object`'s.\nvar ObservationRecorder = require(\"can-observation-recorder\");\nvar mapBindings = require(\"can-event-queue/map/map\");\nvar canReflect = require(\"can-reflect\");\n\nvar makeObject = require(\"./-make-object\");\nvar symbols = require(\"./-symbols\");\nvar observableStore = require(\"./-observable-store\");\nvar helpers = require(\"./-helpers\");\nvar computedHelpers = require(\"./-computed-helpers\");\n\nvar isSymbolLike = canReflect.isSymbolLike;\n\n// Returns if prop is an integer\nvar isInteger = Number.isInteger || function(value) {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\n// Returns `true` if the length was set and it deleted indexed\n// properties.\nfunction didLengthChangeCauseDeletions(key, value, old) {\n\treturn key === \"length\" && value < old;\n}\n\n\n// ## Rewrite array methods\n// The following rewrites array methods to generate events and\n// for performance reasons.\n//\n// Array's methods that mutate are rewritten to generate patch events.\n// Other methods on array are rewritten to:\n// - Avoid calling `ObservationRecorder.add` on every property.\n// - Make the returned result observable.\n//\n// ### Rewrite mutating methods\n// The following defines a relationship between an array\n// mutation method and the patch events that should be dispatched\n// for that mutation.\nvar mutateMethods = {\n\t\"push\": function(arr, args) {\n\t\treturn [{\n\t\t\tindex: arr.length - args.length,\n\t\t\tdeleteCount: 0,\n\t\t\tinsert: args,\n\t\t\ttype: \"splice\"\n\t\t}];\n\t},\n\t\"pop\": function(arr) {\n\t\treturn [{\n\t\t\tindex: arr.length,\n\t\t\tdeleteCount: 1,\n\t\t\tinsert: [],\n\t\t\ttype: \"splice\"\n\t\t}];\n\t},\n\t\"shift\": function() {\n\t\treturn [{\n\t\t\tindex: 0,\n\t\t\tdeleteCount: 1,\n\t\t\tinsert: [],\n\t\t\ttype: \"splice\"\n\t\t}];\n\t},\n\t\"unshift\": function(arr, args) {\n\t\treturn [{\n\t\t\tindex: 0,\n\t\t\tdeleteCount: 0,\n\t\t\tinsert: args,\n\t\t\ttype: \"splice\"\n\t\t}];\n\t},\n\t\"splice\": function(arr, args) {\n\t\treturn [{\n\t\t\tindex: args[0],\n\t\t\tdeleteCount: args[1],\n\t\t\tinsert: args.slice(2),\n\t\t\ttype: \"splice\"\n\t\t}];\n\t},\n\t\"sort\": function(arr) {\n\t\t// The array replaced everything.\n\t\treturn [{\n\t\t\tindex: 0,\n\t\t\tdeleteCount: arr.length,\n\t\t\tinsert: arr,\n\t\t\ttype: \"splice\"\n\t\t}];\n\t},\n\t\"reverse\": function(arr, args, old) {\n\t\t// The array replaced everything.\n\t\treturn [{\n\t\t\tindex: 0,\n\t\t\tdeleteCount: arr.length,\n\t\t\tinsert: arr,\n\t\t\ttype: \"splice\"\n\t\t}];\n\t}\n};\n// Overwrite Array's methods that mutate to:\n// - prevent other events from being fired off (index events and length events.)\n// - dispatch patches events.\ncanReflect.eachKey(mutateMethods, function(makePatches, prop){\n\tvar protoFn = Array.prototype[prop];\n\tvar mutateMethod = function() {\n\t\tvar meta = this[symbols.metaSymbol],\n\t\t\t// Capture if this function should be making sideEffects\n\t\t\tmakeSideEffects = meta.preventSideEffects === 0,\n\t\t\toldLength = meta.target.length;\n\n\t\t// Prevent proxy from calling ObservationRecorder and sending events.\n\t\tmeta.preventSideEffects++;\n\n\t\t// Call the function -- note that *this* is the Proxy here, so\n\t\t// accesses in the function still go through `get()` and `set()`.\n\t\tvar ret = protoFn.apply(meta.target, arguments);\n\t\tvar patches = makePatches(meta.target, Array.from(arguments), oldLength);\n\n\t\tif (makeSideEffects === true) {\n\t\t\t//!steal-remove-start\n\t\t\tvar reasonLog = [canReflect.getName(meta.proxy)+\".\"+prop+\" called with\", arguments];\n\t\t\t//!steal-remove-end\n\t\t\tvar dispatchArgs = {\n\t\t\t\ttype: \"length\",\n\t\t\t\tpatches: patches\n\t\t\t};\n\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tdispatchArgs.reasonLog = reasonLog;\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tmapBindings.dispatch.call( meta.proxy, dispatchArgs , [meta.target.length, oldLength]);\n\t\t}\n\n\t\tmeta.preventSideEffects--;\n\t\treturn ret;\n\t};\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tObject.defineProperty(mutateMethod, \"name\", {\n\t\t\tvalue: prop\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\t// Store the proxied method so it will be used instead of the\n\t// prototype method.\n\tobservableStore.proxiedObjects.set(protoFn, mutateMethod);\n\tobservableStore.proxies.add(mutateMethod);\n});\n\n// ### Rewrite non-mutating methods\n// The following rewrites the Array methods to signal\n// to `ObservationRecorder` to bind on patches events.\n// It also prevents the proxy handlers calling `ObservationRecorder`\n// themselves.\nObject.getOwnPropertyNames(Array.prototype).forEach(function(prop) {\n\tvar protoFn = Array.prototype[prop];\n\tif (observableStore.proxiedObjects.has(protoFn)) {\n\t\treturn;\n\t}\n\n\tif (prop !== \"constructor\" && typeof protoFn === \"function\") {\n\t\tvar arrayMethod = function() {\n\t\t\tObservationRecorder.add(this, symbols.patchesSymbol);\n\t\t\tvar meta = this[symbols.metaSymbol];\n\t\t\tmeta.preventSideEffects++;\n\t\t\tvar ret = protoFn.apply(this, arguments);\n\t\t\tmeta.preventSideEffects--;\n\t\t\treturn meta.options.observe(ret);\n\t\t};\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tObject.defineProperty(arrayMethod, \"name\", {\n\t\t\t\tvalue: prop\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\t\tobservableStore.proxiedObjects.set(protoFn, arrayMethod);\n\t\tobservableStore.proxies.add(arrayMethod);\n\t}\n});\n\n\n// Array's have the same proxy keys as objects.\nvar proxyKeys = helpers.assignEverything(Object.create(null), makeObject.proxyKeys());\n\n\nvar makeArray = {\n\t// Returns a proxied version of the array.\n\t// - `array` - An array to proxy.\n\t// - `options` - Configurable behaviors.\n\t//   - `proxyKeys` - Keys that will override any keys on `array`. Defaults to `makeObject.proxyKeys`.\n\t//   - `observe(nonObservable)` - A function that converts a nested value to an observable.\n\t//   - `shouldRecordObservation(keyInfo, meta)` - Returns if `ObservationRecorder`\n\t//     should be called.  Defaults to `makeObject.shouldRecordObservationOnOwnAndMissingKeys`.\n\tobservable: function(array, options) {\n\t\tif(options.shouldRecordObservation === undefined) {\n\t\t\toptions.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;\n\t\t}\n\t\tvar meta = {\n\t\t\ttarget: array,\n\t\t\tproxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(makeArray.proxyKeys()),\n\t\t\tcomputedKeys: Object.create(null),\n\t\t\toptions: options,\n\t\t\t// `preventSideEffects` is a counter used to \"turn off\" the proxy.  This is incremented when some\n\t\t\t// function (like `Array.splice`) wants to handle event dispatching and/or calling\n\t\t\t// `ObservationRecorder` itself for performance reasons.\n\t\t\tpreventSideEffects: 0\n\t\t};\n\t\tmeta.proxyKeys[symbols.metaSymbol] = meta;\n\t\tmeta.proxy = new Proxy(array, {\n\t\t\tget: makeObject.get.bind(meta),\n\t\t\tset: makeArray.set.bind(meta),\n\t\t\townKeys: makeObject.ownKeys.bind(meta),\n\t\t\tdeleteProperty: makeObject.deleteProperty.bind(meta),\n\t\t\tmeta: meta\n\t\t});\n\t\tmapBindings.addHandlers(meta.proxy, meta);\n\t\treturn meta.proxy;\n\t},\n\tproxyKeys: function() {\n\t\treturn proxyKeys;\n\t},\n\t// `set` is called when a property is set on the proxy or an object\n\t// that has the proxy on its prototype.\n\tset: function(target, key, value, receiver) {\n\t\t// If the receiver is not this observable (the observable might be on the proto chain),\n\t\t// set the key on the reciever.\n\t\tif (receiver !== this.proxy) {\n\t\t\treturn makeObject.setKey(receiver, key, value, this);\n\t\t}\n\n\t\t// If it has a defined property definiition\n\t\tvar computedValue = computedHelpers.set(receiver, key, value);\n\t\tif(computedValue === true ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Gets the observable value to set.\n\t\tvalue = makeObject.getValueToSet(key, value, this);\n\t\tvar startingLength = target.length;\n\n\t\t// Sets the value on the target.  If there\n\t\t// is a change, calls the callback.\n\t\tmakeObject.setValueAndOnChange(key, value, this, function(key, value, meta, hadOwn, old) {\n\n\t\t\t// Determine the patches this change should dispatch\n\t\t\tvar patches = [{\n\t\t\t\tkey: key,\n\t\t\t\ttype: hadOwn ? \"set\" : \"add\",\n\t\t\t\tvalue: value\n\t\t\t}];\n\n\t\t\tvar numberKey = !isSymbolLike(key) && +key;\n\n\t\t\t// If we are adding an indexed value like `arr[5] =value` ...\n\t\t\tif ( isInteger(numberKey) ) {\n\t\t\t\t// If we set an enumerable property after the length ...\n\t\t\t\tif (!hadOwn && numberKey > startingLength) {\n\t\t\t\t\t// ... add patches for those values.\n\t\t\t\t\tpatches.push({\n\t\t\t\t\t\tindex: startingLength,\n\t\t\t\t\t\tdeleteCount: 0,\n\t\t\t\t\t\tinsert: target.slice(startingLength),\n\t\t\t\t\t\ttype: \"splice\"\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, splice the value into the array.\n\t\t\t\t\tpatches.push.apply(patches, mutateMethods.splice(target, [numberKey, 1, value]));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// In the case of deleting items by setting the length of the array,\n\t\t\t// add patches that splice the items removed.\n\t\t\t// (deleting individual items from an array doesn't change the length; it just creates holes)\n\t\t\tif (didLengthChangeCauseDeletions(key, value, old, meta)) {\n\t\t\t\tpatches.push({\n\t\t\t\t\tindex: value,\n\t\t\t\t\tdeleteCount: old - value,\n\t\t\t\t\tinsert: [],\n\t\t\t\t\ttype: \"splice\"\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-start\n\t\t\tvar reasonLog = [canReflect.getName(meta.proxy)+\" set\", key,\"to\", value];\n\t\t\t//!steal-remove-end\n\n\t\t\tvar dispatchArgs = {\n\t\t\t\ttype: key,\n\t\t\t\tpatches: patches,\n\t\t\t\tkeyChanged: !hadOwn ? key : undefined\n\t\t\t};\n\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tdispatchArgs.reasonLog = reasonLog;\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\tmapBindings.dispatch.call( meta.proxy, dispatchArgs, [value, old]);\n\n\t\t});\n\n\t\treturn true;\n\t}\n};\n\n\nmodule.exports = makeArray;\n","\"use strict\";\nvar canReflect = require(\"can-reflect\");\nvar observables = require(\"./-observable-store\");\nvar helpers = require(\"./-helpers\");\n\nvar makeObserve = {\n\tobserve: function(value) {\n\t\tif (canReflect.isPrimitive(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tvar observable = observables.proxiedObjects.get(value);\n\t\tif (observable) {\n\t\t\treturn observable;\n\t\t}\n\t\tif (observables.proxies.has(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tif (helpers.isBuiltInButNotArrayOrPlainObject(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tif (typeof value === \"function\") {\n\t\t\tobservable = makeObserve.function(value);\n\t\t} else if (helpers.inheritsFromArray(value)) {\n\t\t\tobservable = makeObserve.array(value);\n\t\t} else {\n\t\t\tobservable = makeObserve.object(value);\n\t\t}\n\t\tobservables.proxiedObjects.set(value, observable);\n\t\tobservables.proxies.add(observable);\n\t\treturn observable;\n\t},\n\t// Set to a function that converts non-observable\n\t// objects to observable objects\n\t\"object\": null,\n\t// Set to a function that converts non-observable\n\t// arrays to observable arrays\n\t\"array\": null,\n\t// Set to a function that converts non-observable\n\t// functions to observable functions\n\t\"function\": null\n};\n\nmodule.exports = makeObserve;\n","\"use strict\";\n// # -make-function.js\n// This module's `.observable` method proxies an function to make it an any instances\n// created by it observable.\nvar canReflect = require(\"can-reflect\");\nvar makeObject = require(\"./-make-object\");\nvar makeObserve = require(\"./-make-observe\");\nvar symbols = require(\"./-symbols\");\nvar observableStore = require(\"./-observable-store\");\nvar mapBindings = require(\"can-event-queue/map/map\");\nvar typeBindings = require(\"can-event-queue/type/type\");\nvar helpers = require(\"./-helpers\");\n\n// ## proxyKeys\n// A function's proxyKeys is a combination of:\n// - object's symbols (`.onKeyValue`)\n// - type event symbols (`.onInstancePatches`, `.onInstanceBound`)\n// - type definition symbols (`.defineInstanceKey`)\nvar proxyKeys = helpers.assignEverything(Object.create(null), makeObject.proxyKeys());\ntypeBindings(proxyKeys);\ncanReflect.assignSymbols(proxyKeys, {\n\t\"can.defineInstanceKey\": function(prop, value) {\n\t\tthis[symbols.metaSymbol].definitions[prop] = value;\n\t}\n});\n\nvar makeFunction = {\n\n\tobservable: function(object, options) {\n\n\t\tif(options.shouldRecordObservation === undefined) {\n\t\t\toptions.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;\n\t\t}\n\t\tvar proxyKeys = Object.create(makeFunction.proxyKeys());\n\n\t\tvar meta = {\n\t\t\ttarget: object,\n\t\t\tproxyKeys: proxyKeys,\n\t\t\tcomputedKeys: Object.create(null),\n\t\t\toptions: options,\n\t\t\tdefinitions: {},\n\t\t\tisClass: helpers.isClass(object),\n\t\t\tpreventSideEffects: 0\n\t\t};\n\n\t\tproxyKeys[symbols.metaSymbol] = meta;\n\t\tmeta.proxy = new Proxy(object, {\n\t\t\tget: makeObject.get.bind(meta),\n\t\t\tset: makeObject.set.bind(meta),\n\t\t\townKeys: makeObject.ownKeys.bind(meta),\n\t\t\tdeleteProperty: makeObject.deleteProperty.bind(meta),\n\t\t\tconstruct: makeFunction.construct.bind(meta),\n\t\t\tapply: makeFunction.apply.bind(meta),\n\t\t\tmeta: meta\n\t\t});\n\n\t\tmapBindings.addHandlers(meta.proxy, meta);\n\t\ttypeBindings.addHandlers(meta.proxy, meta);\n\n\t\t// Store the function and its proxy now, before we\n\t\t// convert the prototype and its constructor to proxies.\n\t\tobservableStore.proxiedObjects.set(object, meta.proxy);\n\t\tobservableStore.proxies.add(meta.proxy);\n\n\t\t// Change prototype and its constructor\n\t\tif (meta.target.prototype && meta.target.prototype.constructor === meta.target) {\n\t\t\tvar newPrototype = makeObject.observable(meta.target.prototype, {\n\t\t\t\tgetPrototypeOf: function(){\n\t\t\t\t\treturn meta.target.prototype;\n\t\t\t\t},\n\t\t\t\tobserve: makeObserve.observe\n\t\t\t});\n\n\t\t\tobservableStore.proxiedObjects.set(meta.target.prototype, newPrototype);\n\t\t\tobservableStore.proxies.add(newPrototype);\n\n\t\t\tvar prototype = meta.proxy.prototype;\n\t\t\tprototype.constructor = meta.proxy;\n\t\t}\n\n\t\treturn meta.proxy;\n\t},\n\t// `construct` is called when the `new` operator is used.\n\t// It needs to return an observable instance.\n\tconstruct: function(target, argumentsList, newTarget) {\n\t\tvar instanceTarget, key;\n\t\tif (this.isClass) {\n\t\t\t// If the `target` a class, we can't call the function without new. We\n\t\t\t// can create the instance with `Reflect.construct`.\n\t\t\tinstanceTarget = Reflect.construct(target, argumentsList, newTarget);\n\t\t\t// Support `can.defineInstanceKey`.\n\t\t\tfor (key in this.definitions) {\n\t\t\t\tObject.defineProperty(instanceTarget, key, this.definitions[key]);\n\t\t\t}\n\t\t\treturn this.options.observe(instanceTarget);\n\t\t} else {\n\t\t\t// Create an empty object that inherits from the constructor function.\n\t\t\tinstanceTarget = Object.create(this.proxy.prototype);\n\t\t\t// Support `can.defineInstanceKey`.\n\t\t\tfor (key in this.definitions) {\n\t\t\t\tObject.defineProperty(instanceTarget, key, this.definitions[key]);\n\t\t\t}\n\t\t\tvar instance = this.options.observe(instanceTarget);\n\t\t\tinstance[symbols.metaSymbol].preventSideEffects++;\n\t\t\tvar res = target.apply(instance, argumentsList);\n\t\t\tinstance[symbols.metaSymbol].preventSideEffects--;\n\t\t\tif (res) {\n\t\t\t\treturn res;\n\t\t\t} else {\n\t\t\t\treturn instance;\n\t\t\t}\n\t\t}\n\t},\n\t// `apply` makes sure the function returns an observable.\n\tapply: function(target, thisArg, argumentsList) {\n\t\tvar ret = this.target.apply(thisArg, argumentsList);\n\t\treturn this.options.observe(ret);\n\t},\n\tproxyKeys: function() {\n\t\treturn proxyKeys;\n\t}\n};\n\nmodule.exports = makeFunction;\n","\"use strict\";\nvar queues = require(\"can-queues\");\nvar canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\nvar canMeta = canSymbol.for(\"can.meta\");\nvar typeDefinitionsSymbol = canSymbol.for(\"can.typeDefinitions\");\n\nvar helpers = module.exports = {\n\tensureDefinition: function(prototype) {\n\t\tvar typeDefs = prototype[typeDefinitionsSymbol];\n\t\tif (!typeDefs) {\n\t\t\tvar parent = prototype[typeDefinitionsSymbol];\n\t\t\ttypeDefs = prototype[typeDefinitionsSymbol] = Object.create(parent || null);\n\t\t}\n\n\t\treturn typeDefs;\n\t},\n\taddMethodsAndSymbols: function(Type) {\n\t\tcanReflect.assignSymbols(Type, {\n\t\t\t\"can.defineInstanceKey\": function(prop, value) {\n\t\t\t\thelpers.ensureDefinition(this.prototype)[prop] = value;\n\t\t\t},\n\t\t\t\"can.dispatchInstanceBoundChange\": function(obj, isBound) {\n\t\t\t\tvar meta = this[canMeta];\n\t\t\t\tif (meta) {\n\t\t\t\t\tvar lifecycleHandlers = meta.lifecycleHandlers;\n\t\t\t\t\tif (lifecycleHandlers) {\n\t\t\t\t\t\tqueues.enqueueByQueue(lifecycleHandlers.getNode([]), this, [obj, isBound]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\tshouldRecordObservationOnAllKeysExceptFunctionsOnProto: function(keyInfo, meta){\n\t\treturn meta.preventSideEffects === 0 && !keyInfo.isAccessor && (\n\t\t\t// it's on us\n\t\t\t(// it's on our proto, but not a function\n            (keyInfo.targetHasOwnKey ) ||\n\t\t\t// it's \"missing\", and we are not sealed\n\t\t\t(!keyInfo.protoHasKey && !Object.isSealed(meta.target)) || keyInfo.protoHasKey && (typeof targetValue !== \"function\"))\n\t\t);\n\t},\n};\n","\"use strict\";\nvar canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\nvar makeObserve = require(\"../src/-make-observe\");\nvar eventMixin = require(\"can-event-queue/map/map\");\nvar typeEventMixin = require(\"can-event-queue/type/type\");\nvar helpers = require(\"../src/-helpers\");\nvar makeObject = require(\"../src/-make-object\");\nvar observableStore = require(\"../src/-observable-store\");\nvar definitionsSymbol = canSymbol.for(\"can.typeDefinitions\");\nvar computedHelpers = require(\"../src/-computed-helpers\");\nvar typeHelpers = require(\"../src/-type-helpers\");\n\n// Setup proxyKeys to look for observations when doing onKeyValue and offKeyValue\nvar proxyKeys = helpers.assignEverything({},makeObject.proxyKeys());\ncomputedHelpers.addKeyDependencies(proxyKeys);\n\n// ## ObserveObject constructor function\n// Works by returning the proxy-wrapped instance.\nvar ObserveObject = function(props) {\n    var prototype = Object.getPrototypeOf(this);\n\n    computedHelpers.ensureDefinition(prototype);\n    typeHelpers.ensureDefinition(prototype);\n\n    // Define expando properties from `can.defineInstanceProperty`\n    var sourceInstance = this;\n    var definitions = prototype[definitionsSymbol] || {};\n    for (var key in definitions) {\n        Object.defineProperty(sourceInstance, key, definitions[key]);\n    }\n    // Add properties passed to the constructor.\n    if (props !== undefined) {\n        canReflect.assign(sourceInstance, props);\n    }\n    // Create a copy of the proxy keys\n    var localProxyKeys = Object.create(proxyKeys);\n\n    // Make sure that the .constructor property isn't proxied.  If it was,\n    // `this.constructor` would not be the type.\n    localProxyKeys.constructor = this.constructor;\n\n    // Wrap the sourceInstance\n    var observable = makeObject.observable(sourceInstance, {\n        observe: makeObserve.observe,\n        proxyKeys: localProxyKeys,\n        shouldRecordObservation: typeHelpers.shouldRecordObservationOnAllKeysExceptFunctionsOnProto\n    });\n    // Add the proxy to the stores.\n    observableStore.proxiedObjects.set(sourceInstance, observable);\n    observableStore.proxies.add(observable);\n    return observable;\n};\n\neventMixin(ObserveObject.prototype);\ntypeEventMixin(ObserveObject);\ncomputedHelpers.addMethodsAndSymbols(ObserveObject);\ntypeHelpers.addMethodsAndSymbols(ObserveObject);\n\n// Allows this to be extended w/o `class`\nObserveObject.extend = helpers.makeSimpleExtender(ObserveObject);\n\n\n\nmodule.exports = ObserveObject;\n","\"use strict\";\n// ## can-observe/array/array\n//\nvar canSymbol = require(\"can-symbol\");\nvar makeArray = require(\"../src/-make-array\");\nvar makeObserve = require(\"../src/-make-observe\");\nvar eventMixin = require(\"can-event-queue/map/map\");\nvar typeEventMixin = require(\"can-event-queue/type/type\");\nvar helpers = require(\"../src/-helpers\");\nvar observableStore = require(\"../src/-observable-store\");\nvar computedHelpers = require(\"../src/-computed-helpers\");\nvar typeHelpers = require(\"../src/-type-helpers\");\n\nvar definitionsSymbol = canSymbol.for(\"can.typeDefinitions\");\n\n// Setup proxyKeys to look for observations when doing onKeyValue and offKeyValue\nvar proxyKeys = helpers.assignEverything({},makeArray.proxyKeys());\n\nvar ObserveArray;\nif ( /*helpers.supportsClass*/ false) {\n    /*ObserveArray = class ObserveArray extends Array {\n        constructor(items) {\n            super();\n            var prototype = Object.getPrototypeOf(this);\n            var constructor = this.constructor;\n            var instance = this;\n            var definitions = prototype[definitionsSymbol] || {};\n            for (var key in definitions) {\n                Object.defineProperty(instance, key, definitions[key]);\n            }\n            this.push.apply(this, items);\n\n            return makeArray.observable(instance, {\n                observe: makeObserve.observe,\n                proxyKeys: {\n                    constructor: constructor\n                }\n            });\n        }\n    };*/\n} else {\n\n    var ObserveArray = function(items) {\n        var prototype = Object.getPrototypeOf(this);\n\n        computedHelpers.ensureDefinition(prototype);\n        typeHelpers.ensureDefinition(prototype);\n\n        var instance = this;\n        var definitions = prototype[definitionsSymbol] || {};\n        for (var key in definitions) {\n            Object.defineProperty(instance, key, definitions[key]);\n        }\n        this.push.apply(this, items || []);\n\n        var localProxyKeys = Object.create(proxyKeys);\n        localProxyKeys.constructor = this.constructor;\n\n        var observable = makeArray.observable(instance, {\n            observe: makeObserve.observe,\n            proxyKeys: localProxyKeys,\n            shouldRecordObservation: typeHelpers.shouldRecordObservationOnAllKeysExceptFunctionsOnProto\n        });\n        observableStore.proxiedObjects.set(instance, observable);\n        observableStore.proxies.add(observable);\n        return observable;\n    };\n    ObserveArray.prototype = Object.create(Array.prototype);\n}\n\neventMixin(ObserveArray.prototype);\ntypeEventMixin(ObserveArray);\ncomputedHelpers.addMethodsAndSymbols(ObserveArray);\ntypeHelpers.addMethodsAndSymbols(ObserveArray);\n\nObserveArray.extend = helpers.makeSimpleExtender(ObserveArray);\n\n\n\nmodule.exports = ObserveArray;\n","\"use strict\";\n\nvar canReflect = require(\"can-reflect\");\nvar AsyncObservable = require(\"can-simple-observable/async/async\");\nvar ResolverObservable = require(\"can-simple-observable/resolver/resolver\");\n\nvar computedHelpers = require(\"../src/-computed-helpers\");\nfunction defineProperty(prototype, prop, makeObservable) {\n\tcomputedHelpers.ensureDefinition(prototype)[prop] = makeObservable;\n}\n\nfunction asyncBase(config) {\n\treturn function(target, key, descriptor) {\n\t\tif (descriptor.get !== undefined) {\n\t\t\tvar getter = descriptor.get;\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tif (getter.length !== 0) {\n\t\t\t\t\tthrow new Error(\"async decorated \" + key + \" on \" + canReflect.getName(target) + \": getters should take no arguments.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn defineProperty(target, key, function(instance, property) {\n\t\t\t\tfunction fn(lastSet, resolve) {\n\t\t\t\t\tif (!resolve) {\n\t\t\t\t\t\treturn config.default;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar promise = getter.call(this, true);\n\t\t\t\t\tif (canReflect.isPromise(promise)) {\n\t\t\t\t\t\tpromise.then(resolve);\n\t\t\t\t\t\treturn config.default;\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\telse if (promise !== undefined) {\n\t\t\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t\tthrow new Error(\"async decorated \" + key + \" on \" + canReflect.getName(target) + \": getters must return undefined or a promise.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t}\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tcanReflect.assignSymbols(fn, {\n\t\t\t\t\t\t\"can.getName\": function() {\n\t\t\t\t\t\t\treturn canReflect.getName(getter); + \" getter\";\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\treturn new AsyncObservable(fn, instance, config.default);\n\t\t\t});\n\t\t}\n\n\t\tif (descriptor.value !== undefined) {\n\t\t\tvar method = descriptor.value;\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tif (method.length !== 1) {\n\t\t\t\t\tthrow new Error(\"async decorated \" + key + \" on \" + canReflect.getName(target) + \": methods should take 1 argument (resolve).\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn defineProperty(target, key, function(instance, property) {\n\t\t\t\treturn new AsyncObservable(function(lastSet, resolve) {\n\t\t\t\t\treturn method.call(this, resolve);\n\t\t\t\t}, instance, config.default);\n\t\t\t});\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tthrow new Error(\"async decorated \" + key + \" on \" + canReflect.getName(target) + \": Unrecognized descriptor.\");\n\t\t}\n\t\t//!steal-remove-end\n\t};\n}\n\nfunction resolverBase(config) {\n\treturn function(target, key, descriptor) {\n\t\tif (descriptor.value !== undefined) {\n\t\t\tvar method = descriptor.value;\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tif (method.length !== 1) {\n\t\t\t\t\tthrow new Error(\"resolver decorated \" + key + \" on \" + canReflect.getName(target) + \": methods should take 1 argument (value).\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn defineProperty(target, key, function(instance, property) {\n\t\t\t\treturn new ResolverObservable(method, instance);\n\t\t\t});\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tthrow new Error(\"resolver decorated \" + key + \" on \" + canReflect.getName(target) + \": Unrecognized descriptor.\");\n\t\t}\n\t\t//!steal-remove-end\n\t};\n}\n\nfunction optionalConfig(decorator) {\n\tfunction wrapper(config) {\n\t\tif (arguments.length === 3) {\n\t\t\treturn decorator({}).apply(null, arguments);\n\t\t}\n\n\t\treturn decorator(config);\n\t}\n\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tObject.defineProperty(wrapper, \"name\", {\n\t\t\tvalue: canReflect.getName(decorator.name)\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\treturn wrapper;\n}\n\nmodule.exports = {\n\tasync: optionalConfig(asyncBase),\n\tresolver: optionalConfig(resolverBase),\n};\n","\"use strict\";\n// # can-observe.js\n// Assembles the final observe export.\nvar makeObject = require(\"./src/-make-object\");\nvar makeArray = require(\"./src/-make-array\");\nvar makeFunction = require(\"./src/-make-function\");\nvar makeObserve = require(\"./src/-make-observe\");\nvar ObserveObject = require(\"./object/object\");\nvar ObserveArray = require(\"./array/array\");\n\nvar computedHelpers = require(\"./src/-computed-helpers\");\nvar decorators = require(\"./decorators/decorators\");\n\nmakeObserve.object = function(object) {\n\treturn makeObject.observable(object, makeObserve);\n};\nmakeObserve.array = function(array) {\n\treturn makeArray.observable(array, makeObserve);\n};\nmakeObserve.function = function(array) {\n\treturn makeFunction.observable(array, makeObserve);\n};\nmakeObserve.observe.Object = ObserveObject;\nmakeObserve.observe.Array = ObserveArray;\n\nmodule.exports = makeObserve.observe;\n\nmodule.exports.defineProperty = function(prototype, prop, makeObservable) {\n\tcomputedHelpers.ensureDefinition(prototype)[prop] = makeObservable;\n};\n\nfor (var key in decorators) {\n\tmodule.exports[key] = decorators[key];\n}\n"],"names":["metaSymbol","canSymbol","for","patchesSymbol","keysSymbol","proxiedObjects","WeakMap","proxies","WeakSet","classTest","helpers","assignEverything","d","s","Object","getOwnPropertyNames","concat","getOwnPropertySymbols","forEach","key","defineProperty","getOwnPropertyDescriptor","isBuiltInButNotArrayOrPlainObject","obj","Array","isArray","toString","indexOf","prototype","call","inheritsFromArray","cur","getPrototypeOf","isClass","test","supportsClass","eval","e","makeSimpleExtender","BaseType","name","staticProps","prototypeProps","Type","instance","apply","this","arguments","init","preventSideEffects","extend","create","constructor","process","env","NODE_ENV","value","assignNonEnumerable","enumerable","writable","configurable","canMeta","computedPropertyDefinitionSymbol","onKeyValueSymbol","offKeyValueSymbol","ComputedObjectObservationData","prop","observation","forward","bind","findComputed","meta","computedPropertyDefinitions","target","undefined","computedPropertyDefinition","computedKeys","bindingCount","on","unbind","off","newValue","oldValue","mapBindings","dispatch","type","computedHelpers","module","get","computedObj","ObservationRecorder","add","isRecording","Observation","temporarilyBind","canReflect","getValue","set","Error","getName","setValue","addKeyDependencies","proxyKeys","onKeyValue","offKeyValue","assignSymbols","can.onKeyValue","handler","queue","can.offKeyValue","can.getKeyDependencies","valueDependencies","Set","addMethodsAndSymbols","addEventListener","removeEventListener","ensureDefinition","hasOwnProperty","parent","definitions","descriptor","getter","property","hasOwn","isSymbolLike","symbol","makeObject","observable","object","options","shouldRecordObservation","shouldRecordObservationOnOwnAndMissingKeys","symbols","traps","ownKeys","deleteProperty","proxy","Proxy","addHandlers","receiver","proxyKey","computedValue","keyInfo","getKeyInfo","targetValue","valueIsInvariant","getValueFromStore","parentObservableGetCalledOn","setKey","getValueToSet","setValueAndOnChange","hadOwn","old","reasonLog","dispatchArgs","patches","keyChanged","deleteSuccessful","desc","propertyInfo","targetHasOwnKey","Boolean","getCalledOnParent","protoHasKey","isAccessor","observableStore","isSealed","handlers","getNode","isPrimitive","isObservableLike","has","observe","data","onChange","isInteger","Number","isFinite","Math","floor","didLengthChangeCauseDeletions","mutateMethods","push","arr","args","index","length","deleteCount","insert","pop","shift","unshift","splice","slice","sort","reverse","eachKey","makePatches","protoFn","mutateMethod","makeSideEffects","oldLength","ret","from","arrayMethod","makeArray","array","startingLength","numberKey","makeObserve","observables","function","typeBindings","can.defineInstanceKey","makeFunction","construct","newPrototype","argumentsList","newTarget","instanceTarget","Reflect","res","thisArg","typeDefinitionsSymbol","typeDefs","can.dispatchInstanceBoundChange","isBound","lifecycleHandlers","queues","enqueueByQueue","shouldRecordObservationOnAllKeysExceptFunctionsOnProto","definitionsSymbol","ObserveObject","props","typeHelpers","assign","localProxyKeys","eventMixin","typeEventMixin","ObserveArray","items","makeObservable","asyncBase","config","fn","lastSet","resolve","default","promise","isPromise","then","can.getName","AsyncObservable","method","resolverBase","ResolverObservable","optionalConfig","decorator","wrapper","async","resolver","decorators","exports"],"mappings":"sxCAGA,YAAiB,CAChBA,WAAYC,UAAUC,IAAI,YAI1BC,cAAe,cACfC,WAAY,4BCRI,CAChBC,eAAgB,IAAIC,QACpBC,QAAS,IAAIC,SCAVR,WAAaC,UAAUC,IAAI,YAC3BO,UAAY,eAEZC,QAAU,CACbC,iBAAkB,SAASC,EAAGC,GAI7B,OAHAC,OAAOC,oBAAoBF,GAAGG,OAAOF,OAAOG,sBAAsBJ,IAAIK,QAAQ,SAASC,GACtFL,OAAOM,eAAeR,EAAEO,EAAKL,OAAOO,yBAAyBR,EAAEM,MAEzDP,GAERU,kCAAmC,SAASC,GAC3C,GAAIC,MAAMC,QAAQF,GACjB,OAAO,EAER,GAAmB,mBAARA,EAEV,OADaA,EAAIG,WACNC,QAAQ,iBAAmB,EAMtC,IAAID,EAAWZ,OAAOc,UAAUF,SAASG,KAAKN,GAC9C,MAAoB,oBAAbG,IAAoE,IAAlCA,EAASC,QAAQ,aAI5DG,kBAAmB,SAASP,GAC3B,IAAIQ,EAAMR,EACV,EAAG,CACF,GAAIC,MAAMC,QAAQM,GACjB,OAAO,EAERA,EAAMjB,OAAOkB,eAAeD,SACpBA,GACT,OAAO,GAERE,QAAS,SAASV,GACjB,MAAsB,mBAARA,GAAsBd,UAAUyB,KAAKX,EAAIG,aAExDS,cAAe,WACd,IAEC,OADAC,KAAK,6BACE,EACN,MAAOC,GACR,OAAO,GALM,GAQfC,mBAAoB,SAASC,GAC5B,OAAO,SAAgBC,EAAMC,EAAaC,GACtC,IAAIC,EAAO,WACP,IACFC,EAAWL,EAASM,MAAMC,KAAMC,WAO9B,OARaD,KAEHE,OAENJ,EAAS5C,YAAYiD,qBAJZH,KAKFE,KAAKH,MAAMD,EAAUG,WAC5BH,EAAS5C,YAAYiD,sBAElBL,GAmBd,OAfAlC,QAAQC,iBAAiBgC,EAAKJ,GAC9B7B,QAAQC,iBAAiBgC,EAAMF,GAAe,IAC9CE,EAAKO,OAASxC,QAAQ4B,mBAAmBK,GACzCA,EAAKf,UAAYd,OAAOqC,OAAQZ,EAASX,WACzClB,QAAQC,iBAAiBgC,EAAKf,UAAWc,GAAkB,IAC3DC,EAAKf,UAAUwB,YAAcT,EAGD,eAAzBU,UAAQC,IAAIC,UACdzC,OAAOM,eAAeuB,EAAM,OAAQ,CACnCa,MAAOhB,IAKFG,IAGTc,oBAAqB,SAASlC,EAAKJ,EAAKqC,GACvC,OAAO1C,OAAOM,eAAeG,EAAIJ,EAAI,CACjCuC,YAAY,EACZC,UAAU,EACVC,cAAc,EACdJ,MAAOA,cAMI9C,yDCxFjB,IAAImD,EAAU5D,UAAUC,IAAI,YACxB4D,EAAmC7D,UAAUC,IAAI,mCACjD6D,EAAmB9D,UAAUC,IAAI,kBACjC8D,EAAoB/D,UAAUC,IAAI,mBAOtC,SAAS+D,EAA8BrB,EAAUsB,EAAMC,GACtDrB,KAAKF,SAAWA,EACbE,KAAKoB,KAAOA,EACZpB,KAAKqB,YAAcA,EACtBrB,KAAKsB,QAAUtB,KAAKsB,QAAQC,KAAKvB,MAiClC,SAASwB,EAAa1B,EAAUzB,GAC/B,IAAIoD,EAAO3B,EAASiB,GAGhBW,EAFSD,EAAKE,OAEuBX,GACzC,QAAoCY,IAAhCF,EAAJ,CAGA,IAAIG,EAA6BH,EAA4BrD,GAC7D,QAAmCuD,IAA/BC,EAWJ,YAP+BD,IAA3BH,EAAKK,aAAazD,KACrBoD,EAAKK,aAAazD,GAAO,IAAI8C,EAC5BrB,EAAUzB,EACVwD,EAA2B/B,EAAUzB,KAIhCoD,EAAKK,aAAazD,IAlD1B8C,EAA8BrC,UAAUyC,KAAO,WAC3CvB,KAAK+B,eACoB,IAAtB/B,KAAK+B,cACJ/B,KAAKqB,YAAYW,GAAGhC,KAAKsB,QAAS,WAI1CH,EAA8BrC,UAAUmD,OAAS,WAC7CjC,KAAK+B,eACoB,IAAtB/B,KAAK+B,cACJ/B,KAAKqB,YAAYa,IAAIlC,KAAKsB,QAAS,WAI3CH,EAA8BrC,UAAUwC,QAAU,SAASa,EAAUC,GACpEC,iBAAYC,SAASvD,KAAKiB,KAAKF,SAAU,CACxCyC,KAAMvC,KAAKoB,KACXO,OAAQ3B,KAAKF,UAQX,CAACqC,EAAUC,KAGfjB,EAA8BrC,UAAUiD,aAAe,EAyBvD,IAAIS,EAAkBC,UAAiB,CACtCC,IAAK,SAAS5C,EAAUzB,GACvB,IAAIsE,EAAcnB,EAAa1B,EAAUzB,GACzC,QAAoBuD,IAAhBe,EASJ,OALAC,oBAAoBC,IAAI/C,EAAUzB,EAAIO,YACN,IAA7B+D,EAAYZ,cAAsBa,oBAAoBE,eACxDC,YAAYC,gBAAgBL,EAAYtB,aAGlC,CACNX,MAAOuC,WAAWC,SAASP,EAAYtB,eAGzC8B,IAAK,SAASrD,EAAUzB,EAAKqC,GAC5B,IAAIiC,EAAcnB,EAAa1B,EAAUzB,GACzC,QAAoBuD,IAAhBe,EACH,OAAO,EAIR,GAA4B,eAAzBpC,UAAQC,IAAIC,eACiDmB,IAA3De,EAAYtB,YAAYlE,UAAUC,IAAI,iBACzC,MAAM,IAAIgG,MAAM,eAAkB/E,EAAM,QAAW4E,WAAWI,QAAQvD,IAMxE,OADAmD,WAAWK,SAASX,EAAYtB,YAAaX,IACtC,GAERa,KAAM,SAASzB,EAAUzB,GACxB,IAAIsE,EAAcnB,EAAa1B,EAAUzB,QACrBuD,IAAhBe,GAIJA,EAAYpB,QAEbU,OAAQ,SAASnC,EAAUzB,GAC1B,IAAIsE,EAAcnB,EAAa1B,EAAUzB,QACrBuD,IAAhBe,GAIJA,EAAYV,UAEbsB,mBAAoB,SAASC,GAC5B,IAAIC,EAAaD,EAAUvC,GACvByC,EAAcF,EAAUtC,GAG5B+B,WAAWU,cAAcH,EAAW,CACnCI,iBAAkB,SAASvF,EAAKwF,EAASC,GAMxC,OALAtB,EAAgBjB,KAAKvB,KAAM3B,GAKpBoF,EAAW1D,MAAMC,KAAMC,YAE/B8D,kBAAmB,SAAS1F,EAAKwF,EAASC,GAMzC,OALAtB,EAAgBP,OAAOjC,KAAM3B,GAKtBqF,EAAY3D,MAAMC,KAAMC,YAEhC+D,yBAA0B,SAAS3F,GAClC,IAAIsE,EAAcnB,EAAaxB,KAAM3B,GACrC,QAAoBuD,IAAhBe,EAIJ,MAAO,CACNsB,kBAAmB,IAAIC,IAAI,CAAEvB,EAAYtB,mBAK7C8C,qBAAsB,SAAStE,GAC9BA,EAAKf,UAAUsF,iBAAmB,SAAS/F,EAAKwF,EAASC,GAExD,OADAtB,EAAgBjB,KAAKvB,KAAM3B,GACpBgE,iBAAY+B,iBAAiBrF,KAAKiB,KAAM3B,EAAKwF,EAASC,IAG9DjE,EAAKf,UAAUuF,oBAAsB,SAAShG,EAAKwF,EAASC,GAE3D,OADAtB,EAAgBP,OAAOjC,KAAM3B,GACtBgE,iBAAYgC,oBAAoBtF,KAAKiB,KAAM3B,EAAKwF,EAASC,KAGlEQ,iBAAkB,SAASxF,GAC1B,IAAKA,EAAUyF,eAAevD,GAAmC,CAChE,IAAIwD,EAAS1F,EAAUkC,GACnByD,EAAc3F,EAAUkC,GAAoChD,OAAOqC,OAAOmE,GAAU,MAExFxG,OAAOC,oBAAoBa,GAAWV,QAAQ,SAASgD,GACtD,GAAa,gBAATA,EAAJ,CAKA,IAAIsD,EAAa1G,OAAOO,yBAAyBO,EAAWsC,GAC5D,QAAsBQ,IAAnB8C,EAAWhC,IAAmB,CAChC,IAAIiC,EAASD,EAAWhC,IACxB+B,EAAYrD,GAAQ,SAAStB,EAAU8E,GACtC,OAAO,IAAI7B,YAAY4B,EAAQ7E,QAMnC,OAAOhB,EAAUkC,kUCnLf6D,OAAS7G,OAAOc,UAAUyF,eAC1BO,aAAe7B,WAAW6B,aAI1BtB,UAAYxF,OAAOqC,OAAO,MAC9BrC,OAAOG,sBAAsBkE,kBAAajE,QAAQ,SAAS2G,GAC1DnH,QAAQ+C,oBAAoB6C,UAAWuB,EAAQ1C,iBAAY0C,MAG5DvC,gBAAgBe,mBAAmBC,WAEnC,IAAIwB,WAAa,CAQhBC,WAAY,SAASC,EAAQC,QACWvD,IAApCuD,EAAQC,0BACVD,EAAQC,wBAA0BJ,WAAWK,4CAG9C,IAAI5D,EAAO,CACVE,OAAQuD,EACR1B,eAAiC5B,IAAtBuD,EAAQ3B,UAA0B2B,EAAQ3B,UAAYxF,OAAOqC,OAAO2E,WAAWxB,aAC1F1B,aAAc9D,OAAOqC,OAAO,MAC5B8E,QAASA,EAIThF,mBAAoB,GAGrBvC,QAAQ+C,oBAAoBc,EAAK+B,UAAW8B,QAAQpI,WAAYuE,GAGhE,IAAI8D,EAAQ,CACX7C,IAAKsC,WAAWtC,IAAInB,KAAKE,GACzB0B,IAAK6B,WAAW7B,IAAI5B,KAAKE,GACzB+D,QAASR,WAAWQ,QAAQjE,KAAKE,GACjCgE,eAAgBT,WAAWS,eAAelE,KAAKE,GAC/ClD,yBAA0ByG,WAAWzG,yBAAyBgD,KAAKE,GACnEA,KAAMA,GASP,OANG0D,EAAQjG,iBACVqG,EAAMrG,eAAiBiG,EAAQjG,gBAGhCuC,EAAKiE,MAAQ,IAAIC,MAAMT,EAAQK,GAC/BlD,iBAAYuD,YAAYnE,EAAKiE,MAAOjE,GAC7BA,EAAKiE,OAEblC,UAAW,WACV,OAAOA,WAMRd,IAAK,SAASf,EAAQtD,EAAKwH,GAE1B,IAAIC,EAAW9F,KAAKwD,UAAUnF,GAC9B,QAAiBuD,IAAbkE,EACH,OAAOA,EAIR,GAAIhB,aAAazG,GAChB,OAAOsD,EAAOtD,GAIf,IAAI0H,EAAgBvD,gBAAgBE,IAAImD,EAAUxH,GAClD,QAAqBuD,IAAlBmE,EACF,OAAOA,EAAcrF,MAItB,IAAIsF,EAAUhB,WAAWiB,WAAWtE,EAAQtD,EAAKwH,EAAU7F,MACvDU,EAAQsF,EAAQE,YAiBpB,OAdKF,EAAQG,mBAGZzF,EAAQsE,WAAWoB,kBAAkB/H,EAAKqC,EAAOV,OAG9CA,KAAKmF,QAAQC,wBAAwBY,EAAShG,OACjD4C,oBAAoBC,IAAI7C,KAAK0F,MAAOrH,EAAIO,YAIrCoH,EAAQK,6BACXzD,oBAAoBC,IAAImD,EAAQK,4BAA6BhI,EAAIO,YAE3D8B,GAIRyC,IAAK,SAASxB,EAAQtD,EAAKqC,EAAOmF,GAGjC,OAAIA,IAAa7F,KAAK0F,MACdV,WAAWsB,OAAOT,EAAUxH,EAAKqC,EAAOV,OAK3B,IADDwC,gBAAgBW,IAAI0C,EAAUxH,EAAKqC,KAMvDA,EAAQsE,WAAWuB,cAAclI,EAAKqC,EAAOV,MAI7CgF,WAAWwB,oBAAoBnI,EAAKqC,EAAOV,KAAM,SAAS3B,EAAKqC,EAAOe,EAAMgF,EAAQC,GAGnF,IAAIC,EAAY,CAAC1D,WAAWI,QAAQ5B,EAAKiE,OAAO,OAAQrH,EAAI,KAAMqC,GAG9DkG,EAAe,CAClBrE,KAAMlE,EACNwI,QAAS,CAAC,CACTxI,IAAKA,EACLkE,KAAMkE,EAAS,MAAQ,MACvB/F,MAAOA,IAERoG,WAAaL,OAAe7E,EAANvD,GAIK,eAAzBkC,UAAQC,IAAIC,WACdmG,EAAaD,UAAYA,GAK1BtE,iBAAYC,SAASvD,KAAM0C,EAAKiE,MAAOkB,EAAa,CAAClG,EAAOgG,OAItD,IAGRjB,eAAgB,SAAS9D,EAAQtD,GAEhC,IAAIqI,EAAM1G,KAAK2B,OAAOtD,GACrB0I,SAA0B/G,KAAK2B,OAAOtD,GAGvC,GAAI0I,GAAgD,IAA5B/G,KAAKG,yBAAoCyB,IAAR8E,EAAmB,CAE3E,IAAIC,EAAY,CAAC1D,WAAWI,QAAQrD,KAAK0F,OAAO,WAAYrH,GAGxDuI,EAAe,CAClBrE,KAAMlE,EACNwI,QAAS,CAAC,CACTxI,IAAKA,EACLkE,KAAM,WAEPuE,WAAYzI,GAGe,eAAzBkC,UAAQC,IAAIC,WACdmG,EAAaD,UAAYA,GAI1BtE,iBAAYC,SAASvD,KAAMiB,KAAK0F,MAAOkB,EAAa,MAAChF,EAAW8E,IAGjE,OAAOK,GAORvB,QAAS,SAAS7D,EAAQtD,GAGzB,OAFAuE,oBAAoBC,IAAI7C,KAAK0F,MAAOJ,QAAQhI,YAErCU,OAAOC,oBAAoB+B,KAAK2B,QACrCzD,OAAOF,OAAOG,sBAAsB6B,KAAK2B,SACzCzD,OAAOF,OAAOG,sBAAsB6B,KAAKwD,aAE5CjF,yBAA0B,SAASoD,EAAQtD,GAC1C,IAAI2I,EAAOhJ,OAAOO,yBAAyBoD,EAAQtD,GAEnD,OAAI2I,GAAS3I,KAAO2B,KAAKwD,UACjBxF,OAAOO,yBAAyByB,KAAKwD,UAAWnF,GAGjD2I,GAIRf,WAAY,SAAStE,EAAQtD,EAAKwH,EAAUpE,GAC3C,IAAIiD,EAAa1G,OAAOO,yBAAyBoD,EAAQtD,GACrD4I,EAAe,CAElB5I,IAAKA,EAELqG,WAAYA,EAEZwC,gBAAiBC,QAAQzC,GAEzB0C,kBAAmBvB,IAAapE,EAAKiE,MAErC2B,aAAa,EAEblB,kBAAkB,EAElBD,iBAAatE,EAEb0F,YAAY,GAkBb,OAhBuC,IAAnCL,EAAaG,oBAChBH,EAAaZ,4BAA8BkB,gBAAgBhK,eAAemF,IAAImD,SAE5DjE,IAAf8C,GACHuC,EAAad,kBAA2C,IAAxBzB,EAAW7D,cACpBe,IAAnB8C,EAAWhC,KACduE,EAAaf,YAAcxB,EAAWhC,IAAI3D,KAAMkI,EAAaZ,6BAA+BR,GAC5FoB,EAAaK,YAAa,GAE1BL,EAAaf,YAAcxB,EAAWhE,QAGvCuG,EAAaf,YAAczE,EAAKE,OAAOtD,GACvC4I,EAAaI,iBAA2CzF,IAA7BqF,EAAaf,aAAoC7H,KAAOsD,GAG7EsF,GAMR5B,2CAA4C,SAASW,EAASvE,GAC7D,OAAmC,IAA5BA,EAAKtB,qBAEV6F,EAAQsB,aAIItB,EAAQkB,kBAAoBlB,EAAQqB,cAAgBrJ,OAAOwJ,SAAS/F,EAAKE,UAKxF2E,OAAQ,SAAST,EAAUxH,EAAKqC,GAO/B,OANA1C,OAAOM,eAAeuH,EAAUxH,EAAK,CACpCqC,MAAOA,EACPI,cAAc,EACdF,YAAY,EACZC,UAAU,KAEJ,GAIR0F,cAAe,SAASlI,EAAKqC,EAAOe,GACnC,OAAKwB,WAAW6B,aAAazG,IAAQoD,EAAKgG,SAASC,QAAQ,CAACrJ,IACpD2G,WAAWoB,kBAAkB/H,EAAKqC,EAAOe,GAE1Cf,GAGR0F,kBAAmB,SAAS/H,EAAKqC,EAAOe,GAiBvC,OAbKwB,WAAW0E,YAAYjH,IAC1BuC,WAAW2E,iBAAiBlH,IAE5B6G,gBAAgB9J,QAAQoK,IAAInH,KAGzB6G,gBAAgBhK,eAAesK,IAAInH,GACtCA,EAAQ6G,gBAAgBhK,eAAemF,IAAIhC,GAElC9C,QAAQY,kCAAkCkC,KACnDA,EAAQe,EAAK0D,QAAQ2C,QAAQpH,KAGxBA,GAKR8F,oBAAqB,SAASnI,EAAKqC,EAAOqH,EAAMC,GAC/C,IAAItB,EACAD,EAAS5B,OAAO9F,KAAKgJ,EAAKpG,OAAQtD,GAElCqG,EAAa1G,OAAOO,yBAAyBwJ,EAAKpG,OAAQtD,GAG1DqG,GAAcA,EAAWvB,IAC5BuB,EAAWvB,IAAIpE,KAAKgJ,EAAKrC,MAAOhF,IAGhCgG,EAAMqB,EAAKpG,OAAOtD,MACDqC,IAEhBqH,EAAKpG,OAAOtD,GAAOqC,EACa,IAA5BqH,EAAK5H,oBACR6H,EAAS3J,EAAKqC,EAAOqH,EAAMtB,EAAQC,iBAQvB1B,WCjUbF,eAAe7B,WAAW6B,aAG1BmD,UAAYC,OAAOD,WAAa,SAASvH,GAC3C,MAAwB,iBAAVA,GACZyH,SAASzH,IACT0H,KAAKC,MAAM3H,KAAWA,GAK1B,SAAS4H,8BAA8BjK,EAAKqC,EAAOgG,GAClD,MAAe,WAARrI,GAAoBqC,EAAQgG,EAiBpC,IAAI6B,cAAgB,CACnBC,KAAQ,SAASC,EAAKC,GACrB,MAAO,CAAC,CACPC,MAAOF,EAAIG,OAASF,EAAKE,OACzBC,YAAa,EACbC,OAAQJ,EACRnG,KAAM,YAGRwG,IAAO,SAASN,GACf,MAAO,CAAC,CACPE,MAAOF,EAAIG,OACXC,YAAa,EACbC,OAAQ,GACRvG,KAAM,YAGRyG,MAAS,WACR,MAAO,CAAC,CACPL,MAAO,EACPE,YAAa,EACbC,OAAQ,GACRvG,KAAM,YAGR0G,QAAW,SAASR,EAAKC,GACxB,MAAO,CAAC,CACPC,MAAO,EACPE,YAAa,EACbC,OAAQJ,EACRnG,KAAM,YAGR2G,OAAU,SAAST,EAAKC,GACvB,MAAO,CAAC,CACPC,MAAOD,EAAK,GACZG,YAAaH,EAAK,GAClBI,OAAQJ,EAAKS,MAAM,GACnB5G,KAAM,YAGR6G,KAAQ,SAASX,GAEhB,MAAO,CAAC,CACPE,MAAO,EACPE,YAAaJ,EAAIG,OACjBE,OAAQL,EACRlG,KAAM,YAGR8G,QAAW,SAASZ,EAAKC,EAAMhC,GAE9B,MAAO,CAAC,CACPiC,MAAO,EACPE,YAAaJ,EAAIG,OACjBE,OAAQL,EACRlG,KAAM,aAOTU,WAAWqG,QAAQf,cAAe,SAASgB,EAAanI,GACvD,IAAIoI,EAAU9K,MAAMI,UAAUsC,GAC1BqI,EAAe,WAClB,IAAIhI,EAAOzB,KAAKsF,QAAQpI,YAEvBwM,EAA8C,IAA5BjI,EAAKtB,mBACvBwJ,EAAYlI,EAAKE,OAAOiH,OAGzBnH,EAAKtB,qBAIL,IAAIyJ,EAAMJ,EAAQzJ,MAAM0B,EAAKE,OAAQ1B,WACjC4G,EAAU0C,EAAY9H,EAAKE,OAAQjD,MAAMmL,KAAK5J,WAAY0J,GAE9D,IAAwB,IAApBD,EAA0B,CAE7B,IAAI/C,EAAY,CAAC1D,WAAWI,QAAQ5B,EAAKiE,OAAO,IAAItE,EAAK,eAAgBnB,WAErE2G,EAAe,CAClBrE,KAAM,SACNsE,QAASA,GAIkB,eAAzBtG,UAAQC,IAAIC,WACdmG,EAAaD,UAAYA,GAI1BtE,iBAAYC,SAASvD,KAAM0C,EAAKiE,MAAOkB,EAAe,CAACnF,EAAKE,OAAOiH,OAAQe,IAI5E,OADAlI,EAAKtB,qBACEyJ,GAGoB,eAAzBrJ,UAAQC,IAAIC,UACdzC,OAAOM,eAAemL,EAAc,OAAQ,CAC3C/I,MAAOU,IAOTmG,gBAAgBhK,eAAe4F,IAAIqG,EAASC,GAC5ClC,gBAAgB9J,QAAQoF,IAAI4G,KAQ7BzL,OAAOC,oBAAoBS,MAAMI,WAAWV,QAAQ,SAASgD,GAC5D,IAAIoI,EAAU9K,MAAMI,UAAUsC,GAC9B,IAAImG,gBAAgBhK,eAAesK,IAAI2B,IAI1B,gBAATpI,GAA6C,mBAAZoI,EAAwB,CAC5D,IAAIM,EAAc,WACjBlH,oBAAoBC,IAAI7C,KAAMsF,QAAQjI,eACtC,IAAIoE,EAAOzB,KAAKsF,QAAQpI,YACxBuE,EAAKtB,qBACL,IAAIyJ,EAAMJ,EAAQzJ,MAAMC,KAAMC,WAE9B,OADAwB,EAAKtB,qBACEsB,EAAK0D,QAAQ2C,QAAQ8B,IAGD,eAAzBrJ,UAAQC,IAAIC,UACdzC,OAAOM,eAAewL,EAAa,OAAQ,CAC1CpJ,MAAOU,IAITmG,gBAAgBhK,eAAe4F,IAAIqG,EAASM,GAC5CvC,gBAAgB9J,QAAQoF,IAAIiH,MAM9B,IAAItG,YAAY5F,QAAQC,iBAAiBG,OAAOqC,OAAO,MAAO2E,WAAWxB,aAGrEuG,UAAY,CAQf9E,WAAY,SAAS+E,EAAO7E,QACYvD,IAApCuD,EAAQC,0BACVD,EAAQC,wBAA0BJ,WAAWK,4CAE9C,IAAI5D,EAAO,CACVE,OAAQqI,EACRxG,eAAiC5B,IAAtBuD,EAAQ3B,UAA0B2B,EAAQ3B,UAAYxF,OAAOqC,OAAO0J,UAAUvG,aACzF1B,aAAc9D,OAAOqC,OAAO,MAC5B8E,QAASA,EAIThF,mBAAoB,GAWrB,OATAsB,EAAK+B,UAAU8B,QAAQpI,YAAcuE,EACrCA,EAAKiE,MAAQ,IAAIC,MAAMqE,EAAO,CAC7BtH,IAAKsC,WAAWtC,IAAInB,KAAKE,GACzB0B,IAAK4G,UAAU5G,IAAI5B,KAAKE,GACxB+D,QAASR,WAAWQ,QAAQjE,KAAKE,GACjCgE,eAAgBT,WAAWS,eAAelE,KAAKE,GAC/CA,KAAMA,IAEPY,iBAAYuD,YAAYnE,EAAKiE,MAAOjE,GAC7BA,EAAKiE,OAEblC,UAAW,WACV,OAAOA,aAIRL,IAAK,SAASxB,EAAQtD,EAAKqC,EAAOmF,GAGjC,GAAIA,IAAa7F,KAAK0F,MACrB,OAAOV,WAAWsB,OAAOT,EAAUxH,EAAKqC,EAAOV,MAKhD,IAAqB,IADDwC,gBAAgBW,IAAI0C,EAAUxH,EAAKqC,GAEtD,OAAO,EAIRA,EAAQsE,WAAWuB,cAAclI,EAAKqC,EAAOV,MAC7C,IAAIiK,EAAiBtI,EAAOiH,OA+D5B,OA3DA5D,WAAWwB,oBAAoBnI,EAAKqC,EAAOV,KAAM,SAAS3B,EAAKqC,EAAOe,EAAMgF,EAAQC,GAGnF,IAAIG,EAAU,CAAC,CACdxI,IAAKA,EACLkE,KAAMkE,EAAS,MAAQ,MACvB/F,MAAOA,IAGJwJ,GAAapF,eAAazG,KAASA,EAGlC4J,UAAUiC,MAETzD,GAAUyD,EAAYD,EAE1BpD,EAAQ2B,KAAK,CACZG,MAAOsB,EACPpB,YAAa,EACbC,OAAQnH,EAAOwH,MAAMc,GACrB1H,KAAM,WAIPsE,EAAQ2B,KAAKzI,MAAM8G,EAAS0B,cAAcW,OAAOvH,EAAQ,CAACuI,EAAW,EAAGxJ,MAOtE4H,8BAA8BjK,EAAKqC,EAAOgG,EAAKjF,IAClDoF,EAAQ2B,KAAK,CACZG,MAAOjI,EACPmI,YAAanC,EAAMhG,EACnBoI,OAAQ,GACRvG,KAAM,WAIR,IAAIoE,EAAY,CAAC1D,WAAWI,QAAQ5B,EAAKiE,OAAO,OAAQrH,EAAI,KAAMqC,GAG9DkG,EAAe,CAClBrE,KAAMlE,EACNwI,QAASA,EACTC,WAAaL,OAAe7E,EAANvD,GAIK,eAAzBkC,UAAQC,IAAIC,WACdmG,EAAaD,UAAYA,GAI1BtE,iBAAYC,SAASvD,KAAM0C,EAAKiE,MAAOkB,EAAc,CAAClG,EAAOgG,OAIvD,cAKQqD,UCvTbI,YAAc,CACjBrC,QAAS,SAASpH,GACjB,GAAIuC,WAAW0E,YAAYjH,GAC1B,OAAOA,EAER,IAAIuE,EAAamF,gBAAY7M,eAAemF,IAAIhC,GAChD,OAAIuE,IAGAmF,gBAAY3M,QAAQoK,IAAInH,GACpBA,EAEJ9C,QAAQY,kCAAkCkC,GACtCA,GAGPuE,EADoB,mBAAVvE,EACGyJ,YAAYE,SAAS3J,GACxB9C,QAAQoB,kBAAkB0B,GACvByJ,YAAYH,MAAMtJ,GAElByJ,YAAYjF,OAAOxE,GAEjC0J,gBAAY7M,eAAe4F,IAAIzC,EAAOuE,GACtCmF,gBAAY3M,QAAQoF,IAAIoC,GACjBA,KAIRC,OAAU,KAGV8E,MAAS,KAGTK,SAAY,kBAGIF,YCxBb3G,YAAY5F,QAAQC,iBAAiBG,OAAOqC,OAAO,MAAO2E,WAAWxB,aACzE8G,cAAa9G,aACbP,WAAWU,cAAcH,YAAW,CACnC+G,wBAAyB,SAASnJ,EAAMV,GACvCV,KAAKsF,QAAQpI,YAAYuH,YAAYrD,GAAQV,KAI/C,IAAI8J,aAAe,CAElBvF,WAAY,SAASC,EAAQC,QAEWvD,IAApCuD,EAAQC,0BACVD,EAAQC,wBAA0BJ,WAAWK,4CAE9C,IAAI7B,EAAYxF,OAAOqC,OAAOmK,aAAahH,aAEvC/B,EAAO,CACVE,OAAQuD,EACR1B,UAAWA,EACX1B,aAAc9D,OAAOqC,OAAO,MAC5B8E,QAASA,EACTV,YAAa,GACbtF,QAASvB,QAAQuB,QAAQ+F,GACzB/E,mBAAoB,GAuBrB,GApBAqD,EAAU8B,QAAQpI,YAAcuE,EAChCA,EAAKiE,MAAQ,IAAIC,MAAMT,EAAQ,CAC9BxC,IAAKsC,WAAWtC,IAAInB,KAAKE,GACzB0B,IAAK6B,WAAW7B,IAAI5B,KAAKE,GACzB+D,QAASR,WAAWQ,QAAQjE,KAAKE,GACjCgE,eAAgBT,WAAWS,eAAelE,KAAKE,GAC/CgJ,UAAWD,aAAaC,UAAUlJ,KAAKE,GACvC1B,MAAOyK,aAAazK,MAAMwB,KAAKE,GAC/BA,KAAMA,IAGPY,iBAAYuD,YAAYnE,EAAKiE,MAAOjE,GACpC6I,cAAa1E,YAAYnE,EAAKiE,MAAOjE,GAIrC8F,gBAAgBhK,eAAe4F,IAAI+B,EAAQzD,EAAKiE,OAChD6B,gBAAgB9J,QAAQoF,IAAIpB,EAAKiE,OAG7BjE,EAAKE,OAAO7C,WAAa2C,EAAKE,OAAO7C,UAAUwB,cAAgBmB,EAAKE,OAAQ,CAC/E,IAAI+I,EAAe1F,WAAWC,WAAWxD,EAAKE,OAAO7C,UAAW,CAC/DI,eAAgB,WACf,OAAOuC,EAAKE,OAAO7C,WAEpBgJ,QAASqC,YAAYrC,UAGtBP,gBAAgBhK,eAAe4F,IAAI1B,EAAKE,OAAO7C,UAAW4L,GAC1DnD,gBAAgB9J,QAAQoF,IAAI6H,GAEZjJ,EAAKiE,MAAM5G,UACjBwB,YAAcmB,EAAKiE,MAG9B,OAAOjE,EAAKiE,OAIb+E,UAAW,SAAS9I,EAAQgJ,EAAeC,GAC1C,IAAIC,EAAgBxM,EACpB,GAAI2B,KAAKb,QAAS,CAKjB,IAAKd,KAFLwM,EAAiBC,QAAQL,UAAU9I,EAAQgJ,EAAeC,GAE9C5K,KAAKyE,YAChBzG,OAAOM,eAAeuM,EAAgBxM,EAAK2B,KAAKyE,YAAYpG,IAE7D,OAAO2B,KAAKmF,QAAQ2C,QAAQ+C,GAK5B,IAAKxM,KAFLwM,EAAiB7M,OAAOqC,OAAOL,KAAK0F,MAAM5G,WAE9BkB,KAAKyE,YAChBzG,OAAOM,eAAeuM,EAAgBxM,EAAK2B,KAAKyE,YAAYpG,IAE7D,IAAIyB,EAAWE,KAAKmF,QAAQ2C,QAAQ+C,GACpC/K,EAASwF,QAAQpI,YAAYiD,qBAC7B,IAAI4K,EAAMpJ,EAAO5B,MAAMD,EAAU6K,GAEjC,OADA7K,EAASwF,QAAQpI,YAAYiD,qBACzB4K,GAGIjL,GAKVC,MAAO,SAAS4B,EAAQqJ,EAASL,GAChC,IAAIf,EAAM5J,KAAK2B,OAAO5B,MAAMiL,EAASL,GACrC,OAAO3K,KAAKmF,QAAQ2C,QAAQ8B,IAE7BpG,UAAW,WACV,OAAOA,2BAIQgH,0DCvHjB,IAAIzJ,EAAU5D,UAAUC,IAAI,YACxB6N,EAAwB9N,UAAUC,IAAI,uBAEtCQ,EAAU6E,UAAiB,CAC9B6B,iBAAkB,SAASxF,GAC1B,IAAIoM,EAAWpM,EAAUmM,GACzB,IAAKC,EAAU,CACd,IAAI1G,EAAS1F,EAAUmM,GACvBC,EAAWpM,EAAUmM,GAAyBjN,OAAOqC,OAAOmE,GAAU,MAGvE,OAAO0G,GAER/G,qBAAsB,SAAStE,GAC9BoD,WAAWU,cAAc9D,EAAM,CAC9B0K,wBAAyB,SAASnJ,EAAMV,GACvC9C,EAAQ0G,iBAAiBtE,KAAKlB,WAAWsC,GAAQV,GAElDyK,kCAAmC,SAAS1M,EAAK2M,GAChD,IAAI3J,EAAOzB,KAAKe,GAChB,GAAIU,EAAM,CACT,IAAI4J,EAAoB5J,EAAK4J,kBACzBA,GACHC,OAAOC,eAAeF,EAAkB3D,QAAQ,IAAK1H,KAAM,CAACvB,EAAK2M,SAMtEI,uDAAwD,SAASxF,EAASvE,GACzE,OAAmC,IAA5BA,EAAKtB,qBAA6B6F,EAAQsB,aAGtCtB,oBAERA,EAAQqB,cAAgBrJ,OAAOwJ,SAAS/F,EAAKE,SAAYqE,EAAQqB,aAAuC,mBAAhBnB,4LC9BzFuF,kBAAoBtO,UAAUC,IAAI,uBAKlCoG,YAAY5F,QAAQC,iBAAiB,GAAGmH,WAAWxB,aACvDhB,gBAAgBe,mBAAmBC,aAInC,IAAIkI,cAAgB,SAASC,GACzB,IAAI7M,EAAYd,OAAOkB,eAAec,MAEtCwC,gBAAgB8B,iBAAiBxF,GACjC8M,YAAYtH,iBAAiBxF,GAG7B,IACI2F,EAAc3F,EAAU2M,oBAAsB,GAClD,IAAK,IAAIpN,KAAOoG,EACZzG,OAAOM,eAHU0B,KAGqB3B,EAAKoG,EAAYpG,SAG7CuD,IAAV+J,GACA1I,WAAW4I,OAPM7L,KAOiB2L,GAGtC,IAAIG,EAAiB9N,OAAOqC,OAAOmD,aAInCsI,EAAexL,YAAcN,KAAKM,YAGlC,IAAI2E,EAAaD,WAAWC,WAjBPjF,KAiBkC,CACnD8H,QAASqC,YAAYrC,QACrBtE,UAAWsI,EACX1G,wBAAyBwG,YAAYJ,yDAKzC,OAFAjE,gBAAgBhK,eAAe4F,IAvBVnD,KAuB8BiF,GACnDsC,gBAAgB9J,QAAQoF,IAAIoC,GACrBA,GAGX8G,iBAAWL,cAAc5M,WACzBkN,cAAeN,eACflJ,gBAAgB2B,qBAAqBuH,eACrCE,YAAYzH,qBAAqBuH,eAGjCA,cAActL,OAASxC,QAAQ4B,mBAAmBkM,eAIlD,WAAiBA,cCnDbD,oBAAoBtO,UAAUC,IAAI,uBAGlCoG,YAAY5F,QAAQC,iBAAiB,GAAGkM,UAAUvG,aAElDyI,aAwBIA,aAAe,SAASC,GACxB,IAAIpN,EAAYd,OAAOkB,eAAec,MAEtCwC,gBAAgB8B,iBAAiBxF,GACjC8M,YAAYtH,iBAAiBxF,GAE7B,IACI2F,EAAc3F,EAAU2M,sBAAsB,GAClD,IAAK,IAAIpN,KAAOoG,EACZzG,OAAOM,eAHI0B,KAGqB3B,EAAKoG,EAAYpG,IAErD2B,KAAKwI,KAAKzI,MAAMC,KAAMkM,GAAS,IAE/B,IAAIJ,EAAiB9N,OAAOqC,OAAOmD,aACnCsI,EAAexL,YAAcN,KAAKM,YAElC,IAAI2E,EAAa8E,UAAU9E,WAVZjF,KAUiC,CAC5C8H,QAASqC,YAAYrC,QACrBtE,UAAWsI,EACX1G,wBAAyBwG,YAAYJ,yDAIzC,OAFAjE,gBAAgBhK,eAAe4F,IAfhBnD,KAe8BiF,GAC7CsC,gBAAgB9J,QAAQoF,IAAIoC,GACrBA,GAEXgH,aAAanN,UAAYd,OAAOqC,OAAO3B,MAAMI,WAGjDiN,iBAAWE,aAAanN,WACxBkN,cAAeC,cACfzJ,gBAAgB2B,qBAAqB8H,cACrCL,YAAYzH,qBAAqB8H,cAEjCA,aAAa7L,OAASxC,QAAQ4B,mBAAmByM,cAIjD,UAAiBA,aCxEjB,SAAS3N,eAAeQ,EAAWsC,EAAM+K,GACxC3J,gBAAgB8B,iBAAiBxF,GAAWsC,GAAQ+K,EAGrD,SAASC,UAAUC,GAClB,OAAO,SAAS1K,EAAQtD,EAAKqG,GAC5B,QAAuB9C,IAAnB8C,EAAWhC,IAAmB,CACjC,IAAIiC,EAASD,EAAWhC,IAExB,GAA4B,eAAzBnC,UAAQC,IAAIC,UACQ,IAAlBkE,EAAOiE,OACV,MAAM,IAAIxF,MAAM,mBAAqB/E,EAAM,OAAS4E,WAAWI,QAAQ1B,GAAU,uCAKnF,OAAOrD,eAAeqD,EAAQtD,EAAK,SAASyB,EAAU8E,GACrD,SAAS0H,EAAGC,EAASC,GACpB,IAAKA,EACJ,OAAOH,EAAOI,QAGf,IAAIC,EAAU/H,EAAO5F,KAAKiB,MAAM,GAChC,GAAIiD,WAAW0J,UAAUD,GAExB,OADAA,EAAQE,KAAKJ,GACNH,EAAOI,QAGV,QAAgB7K,IAAZ8K,GACoB,eAAzBnM,UAAQC,IAAIC,SACd,MAAM,IAAI2C,MAAM,mBAAqB/E,EAAM,OAAS4E,WAAWI,QAAQ1B,GAAU,iDAgBpF,MAT4B,eAAzBpB,UAAQC,IAAIC,UACdwC,WAAWU,cAAc2I,EAAI,CAC5BO,cAAe,WACd,OAAO5J,WAAWI,QAAQsB,MAMtB,IAAImI,gBAAgBR,EAAIxM,EAAUuM,EAAOI,WAIlD,QAAyB7K,IAArB8C,EAAWhE,MAAqB,CACnC,IAAIqM,EAASrI,EAAWhE,MAExB,GAA4B,eAAzBH,UAAQC,IAAIC,UACQ,IAAlBsM,EAAOnE,OACV,MAAM,IAAIxF,MAAM,mBAAqB/E,EAAM,OAAS4E,WAAWI,QAAQ1B,GAAU,+CAKnF,OAAOrD,eAAeqD,EAAQtD,EAAK,SAASyB,EAAU8E,GACrD,OAAO,IAAIkI,gBAAgB,SAASP,EAASC,GAC5C,OAAOO,EAAOhO,KAAKiB,KAAMwM,IACvB1M,EAAUuM,EAAOI,WAKtB,GAA4B,eAAzBlM,UAAQC,IAAIC,SACd,MAAM,IAAI2C,MAAM,mBAAqB/E,EAAM,OAAS4E,WAAWI,QAAQ1B,GAAU,+BAMpF,SAASqL,aAAaX,GACrB,OAAO,SAAS1K,EAAQtD,EAAKqG,GAC5B,QAAyB9C,IAArB8C,EAAWhE,MAAqB,CACnC,IAAIqM,EAASrI,EAAWhE,MAExB,GAA4B,eAAzBH,UAAQC,IAAIC,UACQ,IAAlBsM,EAAOnE,OACV,MAAM,IAAIxF,MAAM,sBAAwB/E,EAAM,OAAS4E,WAAWI,QAAQ1B,GAAU,6CAKtF,OAAOrD,eAAeqD,EAAQtD,EAAK,SAASyB,EAAU8E,GACrD,OAAO,IAAIqI,mBAAmBF,EAAQjN,KAKxC,GAA4B,eAAzBS,UAAQC,IAAIC,SACd,MAAM,IAAI2C,MAAM,sBAAwB/E,EAAM,OAAS4E,WAAWI,QAAQ1B,GAAU,+BAMvF,SAASuL,eAAeC,GACvB,SAASC,EAAQf,GAChB,OAAyB,IAArBpM,UAAU2I,OACNuE,EAAU,IAAIpN,MAAM,KAAME,WAG3BkN,EAAUd,GAWlB,MAP4B,eAAzB9L,UAAQC,IAAIC,UACdzC,OAAOM,eAAe8O,EAAS,OAAQ,CACtC1M,MAAOuC,WAAWI,QAAQ8J,EAAUzN,QAK/B0N,EAGR,eAAiB,CAChBC,MAAOH,eAAed,WACtBkB,SAAUJ,eAAeF,2DClG1B,IAAK,IAAI3O,KAlBT8L,YAAYjF,OAAS,SAASA,GAC7B,OAAOF,WAAWC,WAAWC,EAAQiF,cAEtCA,YAAYH,MAAQ,SAASA,GAC5B,OAAOD,UAAU9E,WAAW+E,EAAOG,cAEpCA,YAAYE,SAAW,SAASL,GAC/B,OAAOQ,aAAavF,WAAW+E,EAAOG,cAEvCA,YAAYrC,QAAQ9J,OAAS0N,OAC7BvB,YAAYrC,QAAQpJ,MAAQuN,MAE5BxJ,UAAiB0H,YAAYrC,QAE7BrF,yBAAgC,SAAS3D,EAAWsC,EAAM+K,GACzD3J,gBAAgB8B,iBAAiBxF,GAAWsC,GAAQ+K,GAGrCoB,WACf9K,EAAO+K,QAAQnP,GAAOkP,WAAWlP"}