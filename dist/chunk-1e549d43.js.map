{"version":3,"file":"chunk-1e549d43.js","sources":["../node_modules/can-diff/merge-deep/merge-deep.js"],"sourcesContent":["\"use strict\";\nvar canReflect = require(\"can-reflect\");\nvar diffList = require(\"../list/list\");\n\nfunction smartMerge(instance, props) {\n\n\tprops = canReflect.serialize(props);\n\n\tif (canReflect.isMoreListLikeThanMapLike(instance)) {\n\t\tmergeList(instance, props);\n\t} else {\n\t\tmergeMap(instance, props);\n\t}\n\treturn instance;\n}\n\n// date is expected to be mutable here\nfunction mergeMap(instance, data) {\n\n\t// for each key in\n\tcanReflect.eachKey(instance, function(value, prop) {\n\t\tif(!canReflect.hasKey(data, prop)) {\n\t\t\tcanReflect.deleteKeyValue(instance, prop);\n\t\t\treturn;\n\t\t}\n\t\tvar newValue = canReflect.getKeyValue(data, prop);\n\t\tcanReflect.deleteKeyValue(data, prop);\n\n\t\t// cases:\n\t\t// a. list\n\t\t// b. map\n\t\t// c. primitive\n\n\t\t// if the data is typed, we would just replace it\n\t\tif (canReflect.isPrimitive(value)) {\n\t\t\tcanReflect.setKeyValue(instance, prop, newValue);\n\t\t\treturn;\n\t\t}\n\n\n\t\tvar newValueIsList = Array.isArray(newValue),\n\t\t\tcurrentValueIsList = canReflect.isMoreListLikeThanMapLike(value);\n\n\t\tif (currentValueIsList && newValueIsList) {\n\n\t\t\tmergeList(value, newValue);\n\n\t\t} else if (!newValueIsList && !currentValueIsList && canReflect.isMapLike(value) && canReflect.isPlainObject(newValue)) {\n\n\t\t\t// TODO: the `TYPE` should probably be infered from the `_define` property definition.\n\t\t\tvar schema = canReflect.getSchema(value);\n\t\t\tif (schema && schema.identity && schema.identity.length) {\n\t\t\t\tvar id = canReflect.getIdentity(value, schema);\n\t\t\t\tif (id != null && id === canReflect.getIdentity(newValue, schema)) {\n\t\t\t\t\tmergeMap(value, newValue);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcanReflect.setKeyValue(instance, prop, canReflect.new(value.constructor, newValue));\n\t\t} else {\n\t\t\tcanReflect.setKeyValue(instance, prop, newValue);\n\t\t}\n\t});\n\tcanReflect.eachKey(data, function(value, prop) {\n\t\tcanReflect.setKeyValue(instance, prop, value);\n\t});\n}\n\nfunction mergeList(list, data) {\n\tvar ItemType, itemSchema;\n\tvar listSchema = canReflect.getSchema(list);\n\tif (listSchema) {\n\t\tItemType = listSchema.values;\n\t}\n\n\tif (ItemType) {\n\t\titemSchema = canReflect.getSchema(ItemType);\n\t}\n\tif (!itemSchema && canReflect.size(list) > 0) {\n\t\titemSchema = canReflect.getSchema(canReflect.getKeyValue(list, 0));\n\t}\n\n\tvar identity;\n\tif(itemSchema && itemSchema.identity && itemSchema.identity.length) {\n\t\tidentity = function(a, b) {\n\t\t   var aId = canReflect.getIdentity(a, itemSchema),\n\t\t\t   bId = canReflect.getIdentity(b, itemSchema);\n\t\t   var eq = aId === bId;\n\t\t   if (eq) {\n\t\t\t   // If id is the same we merge data in. Case #2\n\t\t\t   mergeMap(a, b);\n\t\t   }\n\t\t   return eq;\n\t   };\n   } else {\n\t   identity = function(a, b) {\n\t\t  var eq = a === b;\n\t\t  if (eq) {\n\t\t\t  // If id is the same we merge data in. Case #2\n\t\t\t  if(! canReflect.isPrimitive(a) ) {\n\t\t\t\t   mergeMap(a, b);\n\t\t\t  }\n\n\t\t  }\n\t\t  return eq;\n\t  }\n   }\n\n\n\tvar patches = diffList(list, data, identity);\n\n\n\n\tvar hydrate = ItemType ? canReflect.new.bind(canReflect, ItemType) : function(v) {\n\t\treturn v;\n\t};\n\n\n\t// If there are no patches then data contains only updates for all of the existing items, and we just leave.\n\tif (!patches.length) {\n\t\treturn list;\n\t}\n\n\t// Apply patches (add new, remove) #3. For any insertion use a hydrator.\n\tpatches.forEach(function(patch) {\n\t\tapplyPatch(list, patch, hydrate);\n\t});\n}\n\nfunction applyPatch(list, patch, makeInstance) {\n\t// Splice signature compared to patch:\n\t//   array.splice(start, deleteCount, item1, item2, ...)\n\t//   patch = {index: 1, deleteCount: 0, insert: [1.5]}\n\tvar insert = makeInstance && patch.insert.map(function(val){\n\t\treturn makeInstance(val);\n\t}) || patch.insert;\n\n\tvar args = [patch.index, patch.deleteCount].concat(insert);\n\tlist.splice.apply(list, args);\n\n\treturn list;\n}\n\nsmartMerge.applyPatch = applyPatch;\n\nmodule.exports = smartMerge;\n"],"names":["smartMerge","instance","props","canReflect","serialize","isMoreListLikeThanMapLike","mergeList","mergeMap","data","eachKey","value","prop","hasKey","newValue","getKeyValue","deleteKeyValue","isPrimitive","setKeyValue","newValueIsList","Array","isArray","currentValueIsList","isMapLike","isPlainObject","schema","getSchema","identity","length","id","getIdentity","new","constructor","list","ItemType","itemSchema","listSchema","values","size","a","b","eq","patches","diffList","hydrate","bind","v","forEach","patch","applyPatch","makeInstance","insert","map","val","args","index","deleteCount","concat","splice","apply"],"mappings":"wHAIA,SAASA,WAAWC,EAAUC,GAS7B,OAPAA,EAAQC,WAAWC,UAAUF,GAEzBC,WAAWE,0BAA0BJ,GACxCK,UAAUL,EAAUC,GAEpBK,SAASN,EAAUC,GAEbD,EAIR,SAASM,SAASN,EAAUO,GAG3BL,WAAWM,QAAQR,EAAU,SAASS,EAAOC,GAC5C,GAAIR,WAAWS,OAAOJ,EAAMG,GAA5B,CAIA,IAAIE,EAAWV,WAAWW,YAAYN,EAAMG,GAS5C,GARAR,WAAWY,eAAeP,EAAMG,GAQ5BR,WAAWa,YAAYN,GAC1BP,WAAWc,YAAYhB,EAAUU,EAAME,OADxC,CAMA,IAAIK,EAAiBC,MAAMC,QAAQP,GAClCQ,EAAqBlB,WAAWE,0BAA0BK,GAE3D,GAAIW,GAAsBH,EAEzBZ,UAAUI,EAAOG,QAEX,IAAKK,IAAmBG,GAAsBlB,WAAWmB,UAAUZ,IAAUP,WAAWoB,cAAcV,GAAW,CAGvH,IAAIW,EAASrB,WAAWsB,UAAUf,GAClC,GAAIc,GAAUA,EAAOE,UAAYF,EAAOE,SAASC,OAAQ,CACxD,IAAIC,EAAKzB,WAAW0B,YAAYnB,EAAOc,GACvC,GAAU,MAANI,GAAcA,IAAOzB,WAAW0B,YAAYhB,EAAUW,GAEzD,YADAjB,SAASG,EAAOG,GAIlBV,WAAWc,YAAYhB,EAAUU,EAAMR,WAAW2B,IAAIpB,EAAMqB,YAAalB,SAEzEV,WAAWc,YAAYhB,EAAUU,EAAME,SAtCvCV,WAAWY,eAAed,EAAUU,KAyCtCR,WAAWM,QAAQD,EAAM,SAASE,EAAOC,GACxCR,WAAWc,YAAYhB,EAAUU,EAAMD,KAIzC,SAASJ,UAAU0B,EAAMxB,GACxB,IAAIyB,EAAUC,EAaVR,EAZAS,EAAahC,WAAWsB,UAAUO,GAClCG,IACHF,EAAWE,EAAWC,QAGnBH,IACHC,EAAa/B,WAAWsB,UAAUQ,KAE9BC,GAAc/B,WAAWkC,KAAKL,GAAQ,IAC1CE,EAAa/B,WAAWsB,UAAUtB,WAAWW,YAAYkB,EAAM,KAK/DN,EADEQ,GAAcA,EAAWR,UAAYQ,EAAWR,SAASC,OAChD,SAASW,EAAGC,GACpB,IAEIC,EAFMrC,WAAW0B,YAAYS,EAAGJ,KAC7B/B,WAAW0B,YAAYU,EAAGL,GAMjC,OAJIM,GAEHjC,SAAS+B,EAAGC,GAENC,GAGG,SAASF,EAAGC,GACvB,IAAIC,EAAKF,IAAMC,EAQf,OAPIC,IAEErC,WAAWa,YAAYsB,IAC1B/B,SAAS+B,EAAGC,IAIRC,GAKV,IAAIC,EAAUC,KAASV,EAAMxB,EAAMkB,GAI/BiB,EAAUV,EAAW9B,WAAW2B,IAAIc,KAAKzC,WAAY8B,GAAY,SAASY,GAC7E,OAAOA,GAKR,IAAKJ,EAAQd,OACZ,OAAOK,EAIRS,EAAQK,QAAQ,SAASC,GACxBC,WAAWhB,EAAMe,EAAOJ,KAI1B,SAASK,WAAWhB,EAAMe,EAAOE,GAIhC,IAAIC,EAASD,GAAgBF,EAAMG,OAAOC,IAAI,SAASC,GACtD,OAAOH,EAAaG,MACfL,EAAMG,OAERG,EAAO,CAACN,EAAMO,MAAOP,EAAMQ,aAAaC,OAAON,GAGnD,OAFAlB,EAAKyB,OAAOC,MAAM1B,EAAMqB,GAEjBrB,EAGRhC,WAAWgD,WAAaA,WAExB,cAAiBhD"}