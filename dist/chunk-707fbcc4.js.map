{"version":3,"file":"chunk-707fbcc4.js","sources":["../node_modules/can-define/can-define.js"],"sourcesContent":["\"use strict\";\n\"format cjs\";\n\nvar ns = require(\"can-namespace\");\nvar canSymbol = require(\"can-symbol\");\nvar canReflect = require(\"can-reflect\");\n\nvar Observation = require(\"can-observation\");\nvar ObservationRecorder = require(\"can-observation-recorder\");\nvar AsyncObservable = require(\"can-simple-observable/async/async\");\nvar SettableObservable = require(\"can-simple-observable/settable/settable\");\nvar ResolverObservable = require(\"can-simple-observable/resolver/resolver\");\n\nvar eventQueue = require(\"can-event-queue/map/map\");\nvar addTypeEvents = require(\"can-event-queue/type/type\");\nvar queues = require(\"can-queues\");\n\nvar assign = require(\"can-assign\");\nvar canLogDev = require(\"can-log/dev/dev\");\n\nvar stringToAny = require(\"can-string-to-any\");\nvar defineLazyValue = require(\"can-define-lazy-value\");\n\nvar MaybeBoolean = require(\"can-data-types/maybe-boolean/maybe-boolean\"),\n    MaybeDate = require(\"can-data-types/maybe-date/maybe-date\"),\n    MaybeNumber = require(\"can-data-types/maybe-number/maybe-number\"),\n    MaybeString = require(\"can-data-types/maybe-string/maybe-string\");\n\nvar newSymbol = canSymbol.for(\"can.new\"),\n\tserializeSymbol = canSymbol.for(\"can.serialize\");\n\nvar eventsProto, define,\n\tmake, makeDefinition, getDefinitionsAndMethods, getDefinitionOrMethod;\n\n// UTILITIES\nfunction isDefineType(func){\n\treturn func && (func.canDefineType === true || func[newSymbol] );\n}\n\nvar peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));\n\nvar Object_defineNamedPrototypeProperty = Object.defineProperty;\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\tObject_defineNamedPrototypeProperty = function(obj, prop, definition) {\n\t\tif (definition.get) {\n\t\t\tObject.defineProperty(definition.get, \"name\", {\n\t\t\t\tvalue: \"get \"+canReflect.getName(obj) + \".\"+prop,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t\tif (definition.set) {\n\t\t\tObject.defineProperty(definition.set, \"name\", {\n\t\t\t\tvalue:  \"set \"+canReflect.getName(obj) + \".\"+prop,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t\treturn Object.defineProperty(obj, prop, definition);\n\t};\n}\n//!steal-remove-end\n\n\nfunction defineConfigurableAndNotEnumerable(obj, prop, value) {\n\tObject.defineProperty(obj, prop, {\n\t\tconfigurable: true,\n\t\tenumerable: false,\n\t\twritable: true,\n\t\tvalue: value\n\t});\n}\n\nfunction eachPropertyDescriptor(map, cb){\n\tfor(var prop in map) {\n\t\tif(map.hasOwnProperty(prop)) {\n\t\t\tcb.call(map, prop, Object.getOwnPropertyDescriptor(map,prop));\n\t\t}\n\t}\n}\n\nfunction getEveryPropertyAndSymbol(obj) {\n\tvar props = Object.getOwnPropertyNames(obj);\n\tvar symbols = (\"getOwnPropertySymbols\" in Object) ?\n\t  Object.getOwnPropertySymbols(obj) : [];\n\treturn props.concat(symbols);\n}\n\nfunction cleanUpDefinition(prop, definition, shouldWarn, typePrototype){\n\t// cleanup `value` -> `default`\n\tif(definition.value !== undefined && ( typeof definition.value !== \"function\" || definition.value.length === 0) ){\n\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tif(shouldWarn) {\n\t\t\t\tcanLogDev.warn(\n\t\t\t\t\t\"can-define: Change the 'value' definition for \" + canReflect.getName(typePrototype)+\".\"+prop + \" to 'default'.\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tdefinition.default = definition.value;\n\t\tdelete definition.value;\n\t}\n\t// cleanup `Value` -> `DEFAULT`\n\tif(definition.Value !== undefined  ){\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tif(shouldWarn) {\n\t\t\t\tcanLogDev.warn(\n\t\t\t\t\t\"can-define: Change the 'Value' definition for \" + canReflect.getName(typePrototype)+\".\"+prop + \" to 'Default'.\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t\tdefinition.Default = definition.Value;\n\t\tdelete definition.Value;\n\t}\n}\n\nfunction isValueResolver(definition) {\n\t// there's a function and it has one argument\n\treturn typeof definition.value === \"function\" && definition.value.length;\n}\n\nmodule.exports = define = ns.define = function(typePrototype, defines, baseDefine) {\n\t// default property definitions on _data\n\tvar prop,\n\t\tdataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null),\n\t\t// computed property definitions on _computed\n\t\tcomputedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null);\n\n\tvar result = getDefinitionsAndMethods(defines, baseDefine, typePrototype);\n\tresult.dataInitializers = dataInitializers;\n\tresult.computedInitializers = computedInitializers;\n\n\n\t// Goes through each property definition and creates\n\t// a `getter` and `setter` function for `Object.defineProperty`.\n\tcanReflect.eachKey(result.definitions, function(definition, property){\n\t\tdefine.property(typePrototype, property, definition, dataInitializers, computedInitializers, result.defaultDefinition);\n\t});\n\n\t// Places a `_data` on the prototype that when first called replaces itself\n\t// with a `_data` object local to the instance.  It also defines getters\n\t// for any value that has a default value.\n\tif(typePrototype.hasOwnProperty(\"_data\")) {\n\t\tfor (prop in dataInitializers) {\n\t\t\tdefineLazyValue(typePrototype._data, prop, dataInitializers[prop].bind(typePrototype), true);\n\t\t}\n\t} else {\n\t\tdefineLazyValue(typePrototype, \"_data\", function() {\n\t\t\tvar map = this;\n\t\t\tvar data = {};\n\t\t\tfor (var prop in dataInitializers) {\n\t\t\t\tdefineLazyValue(data, prop, dataInitializers[prop].bind(map), true);\n\t\t\t}\n\t\t\treturn data;\n\t\t});\n\t}\n\n\t// Places a `_computed` on the prototype that when first called replaces itself\n\t// with a `_computed` object local to the instance.  It also defines getters\n\t// that will create the property's compute when read.\n\tif(typePrototype.hasOwnProperty(\"_computed\")) {\n\t\tfor (prop in computedInitializers) {\n\t\t\tdefineLazyValue(typePrototype._computed, prop, computedInitializers[prop].bind(typePrototype));\n\t\t}\n\t} else {\n\t\tdefineLazyValue(typePrototype, \"_computed\", function() {\n\t\t\tvar map = this;\n\t\t\tvar data = Object.create(null);\n\t\t\tfor (var prop in computedInitializers) {\n\t\t\t\tdefineLazyValue(data, prop, computedInitializers[prop].bind(map));\n\t\t\t}\n\t\t\treturn data;\n\t\t});\n\t}\n\n\t// Add necessary event methods to this object.\n\tgetEveryPropertyAndSymbol(eventsProto).forEach(function(prop){\n\t\tObject.defineProperty(typePrototype, prop, {\n\t\t\tenumerable: false,\n\t\t\tvalue: eventsProto[prop],\n\t\t\tconfigurable: true,\n\t\t\twritable: true\n\t\t});\n\t});\n\t// also add any symbols\n\t// add so instance defs can be dynamically added\n\tObject.defineProperty(typePrototype,\"_define\",{\n\t\tenumerable: false,\n\t\tvalue: result,\n\t\tconfigurable: true,\n\t\twritable: true\n\t});\n\n\t// Places Symbol.iterator or @@iterator on the prototype\n\t// so that this can be iterated with for/of and canReflect.eachIndex\n\tvar iteratorSymbol = canSymbol.iterator || canSymbol.for(\"iterator\");\n\tif(!typePrototype[iteratorSymbol]) {\n\t\tdefineConfigurableAndNotEnumerable(typePrototype, iteratorSymbol, function(){\n\t\t\treturn new define.Iterator(this);\n\t\t});\n\t}\n\n\treturn result;\n};\n\nvar onlyType = function(obj){\n\tfor(var prop in obj) {\n\t\tif(prop !== \"type\") {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\ndefine.extensions = function () {};\n\n// typePrototype - the prototype of the type we are defining `prop` on.\n// `definition` - the user provided definition\ndefine.property = function(typePrototype, prop, definition, dataInitializers, computedInitializers, defaultDefinition) {\n\tvar propertyDefinition = define.extensions.apply(this, arguments);\n\n\tif (propertyDefinition) {\n\t\tdefinition = makeDefinition(prop, propertyDefinition, defaultDefinition || {}, typePrototype);\n\t}\n\n\tvar type = definition.type;\n\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tif (type && canReflect.isConstructorLike(type) && !isDefineType(type)) {\n\t\t\tcanLogDev.warn(\n\t\t\t\t\"can-define: the definition for \" + canReflect.getName(typePrototype) + \".\"+\n                prop +\n\t\t\t\t\" uses a constructor for \\\"type\\\". Did you mean \\\"Type\\\"?\"\n\t\t\t);\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// Special case definitions that have only `type: \"*\"`.\n\tif (type && onlyType(definition) && type === define.types[\"*\"]) {\n\t\tObject_defineNamedPrototypeProperty(typePrototype, prop, {\n\t\t\tget: make.get.data(prop),\n\t\t\tset: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true\n\t\t});\n\t\treturn;\n\t}\n\tdefinition.type = type;\n\n\t// Where the value is stored.  If there is a `get` the source of the value\n\t// will be a compute in `this._computed[prop]`.  If not, the source of the\n\t// value will be in `this._data[prop]`.\n\tvar dataProperty = definition.get || isValueResolver(definition) ? \"computed\" : \"data\",\n\n\t\t// simple functions that all read/get/set to the right place.\n\t\t// - reader - reads the value but does not observe.\n\t\t// - getter - reads the value and notifies observers.\n\t\t// - setter - sets the value.\n\t\treader = make.read[dataProperty](prop),\n\t\tgetter = make.get[dataProperty](prop),\n\t\tsetter = make.set[dataProperty](prop),\n\t\tgetInitialValue;\n\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tif (definition.get) {\n\t\t\tObject.defineProperty(definition.get, \"name\", {\n\t\t\t\tvalue: canReflect.getName(typePrototype) + \"'s \" + prop + \" getter\",\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t\tif (definition.set) {\n\t\t\tObject.defineProperty(definition.set, \"name\", {\n\t\t\t\tvalue: canReflect.getName(typePrototype) + \"'s \" + prop + \" setter\",\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t\tif(isValueResolver(definition)) {\n\t\t\tObject.defineProperty(definition.value, \"name\", {\n\t\t\t\tvalue: canReflect.getName(typePrototype) + \"'s \" + prop + \" value\",\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// Determine the type converter\n\tvar typeConvert = function(val) {\n\t\treturn val;\n\t};\n\n\tif (definition.Type) {\n\t\ttypeConvert = make.set.Type(prop, definition.Type, typeConvert);\n\t}\n\tif (type) {\n\t\ttypeConvert = make.set.type(prop, type, typeConvert);\n\t}\n\n\t// make a setter that's going to fire of events\n\tvar eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));\n\tif(isValueResolver(definition)) {\n\t\tcomputedInitializers[prop] = make.valueResolver(prop, definition, typeConvert);\n\t}\n\t// Determine a function that will provide the initial property value.\n\telse if ((definition.default !== undefined || definition.Default !== undefined)) {\n\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t// If value is an object or array, give a warning\n\t\t\tif (definition.default !== null && typeof definition.default === 'object') {\n\t\t\t\tcanLogDev.warn(\"can-define: The default value for \" + canReflect.getName(typePrototype)+\".\"+prop + \" is set to an object. This will be shared by all instances of the DefineMap. Use a function that returns the object instead.\");\n\t\t\t}\n\t\t\t// If value is a constructor, give a warning\n\t\t\tif (definition.default && canReflect.isConstructorLike(definition.default)) {\n\t\t\t\tcanLogDev.warn(\"can-define: The \\\"default\\\" for \" + canReflect.getName(typePrototype)+\".\"+prop + \" is set to a constructor. Did you mean \\\"Default\\\" instead?\");\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tgetInitialValue = ObservationRecorder.ignore(make.get.defaultValue(prop, definition, typeConvert, eventsSetter));\n\t}\n\n\t// If property has a getter, create the compute that stores its data.\n\tif (definition.get) {\n\t\tcomputedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);\n\t}\n\t// If the property isn't a getter, but has an initial value, setup a\n\t// default value on `this._data[prop]`.\n\telse if (getInitialValue) {\n\t\tdataInitializers[prop] = getInitialValue;\n\t}\n\n\n\t// Define setter behavior.\n\n\t// If there's a `get` and `set`, make the setter get the `lastSetValue` on the\n\t// `get`'s compute.\n\tif (definition.get && definition.set) {\n\t\t// the compute will set off events, so we can use the basic setter\n\t\tsetter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);\n\t}\n\t// If there's a `set` and no `get`,\n\telse if (definition.set) {\n\t\t// Add `set` functionality to the eventSetter.\n\t\tsetter = make.set.setter(prop, definition.set, reader, eventsSetter, false);\n\t}\n\t// If there's neither `set` or `get` or `value` (resolver)\n\telse if (dataProperty === \"data\") {\n\t\t// make a set that produces events.\n\t\tsetter = eventsSetter;\n\t}\n\t// If there's zero-arg `get` but not `set`, warn on all sets in dev mode\n\telse if (definition.get && definition.get.length < 1) {\n\t\tsetter = function() {\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tcanLogDev.warn(\"can-define: Set value for property \" +\n\t\t\t\t\tcanReflect.getName(typePrototype)+\".\"+ prop +\n\t\t\t\t\t\" ignored, as its definition has a zero-argument getter and no setter\");\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t};\n\t}\n\n\n\t// Add type behavior to the setter.\n\tif (type) {\n\t\tsetter = make.set.type(prop, type, setter);\n\t}\n\tif (definition.Type) {\n\t\tsetter = make.set.Type(prop, definition.Type, setter);\n\t}\n\n\t// Define the property.\n\tObject_defineNamedPrototypeProperty(typePrototype, prop, {\n\t\tget: getter,\n\t\tset: setter,\n\t\tenumerable: \"serialize\" in definition ? !!definition.serialize : !definition.get,\n\t\tconfigurable: true\n\t});\n};\ndefine.makeDefineInstanceKey = function(constructor) {\n\tconstructor[canSymbol.for(\"can.defineInstanceKey\")] = function(property, value) {\n\t\tvar defineResult = this.prototype._define;\n\t\tif(typeof value === \"object\") {\n\t\t\t// change `value` to default.\n\t\t\tcleanUpDefinition(property, value, false, this);\n\t\t}\n\t\tvar definition = getDefinitionOrMethod(property, value, defineResult.defaultDefinition, this);\n\t\tif(definition && typeof definition === \"object\") {\n\t\t\tdefine.property(constructor.prototype, property, definition, defineResult.dataInitializers, defineResult.computedInitializers, defineResult.defaultDefinition);\n\t\t\tdefineResult.definitions[property] = definition;\n\t\t} else {\n\t\t\tdefineResult.methods[property] = definition;\n\t\t}\n\n\t\tthis.prototype.dispatch({\n\t\t\ttype: \"can.keys\",\n\t\t\ttarget: this.prototype\n\t\t});\n\t};\n};\n\n// Makes a simple constructor function.\ndefine.Constructor = function(defines, sealed) {\n\tvar constructor = function DefineConstructor(props) {\n\t\tObject.defineProperty(this,\"__inSetup\",{\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: true,\n\t\t\twritable: true\n\t\t});\n\t\tdefine.setup.call(this, props, sealed);\n\t\tthis.__inSetup = false;\n\t};\n\tvar result = define(constructor.prototype, defines);\n\taddTypeEvents(constructor);\n\tdefine.makeDefineInstanceKey(constructor, result);\n\treturn constructor;\n};\n\n// A bunch of helper functions that are used to create various behaviors.\nmake = {\n\n\tcomputeObj: function(map, prop, observable) {\n\t\tvar computeObj = {\n\t\t\toldValue: undefined,\n\t\t\tcompute: observable,\n\t\t\tcount: 0,\n\t\t\thandler: function(newVal) {\n\t\t\t\tvar oldValue = computeObj.oldValue;\n\t\t\t\tcomputeObj.oldValue = newVal;\n\n\t\t\t\tmap.dispatch({\n\t\t\t\t\ttype: prop,\n\t\t\t\t\ttarget: map\n\t\t\t\t}, [newVal, oldValue]);\n\t\t\t}\n\t\t};\n\t\treturn computeObj;\n\t},\n\tvalueResolver: function(prop, definition, typeConvert) {\n\t\tvar getDefault = make.get.defaultValue(prop, definition, typeConvert);\n\t\treturn function(){\n\t\t\tvar map = this;\n\t\t\tvar defaultValue = getDefault.call(this);\n\t\t\tvar computeObj = make.computeObj(map, prop, new ResolverObservable(definition.value, map, defaultValue));\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tObject.defineProperty(computeObj.handler, \"name\", {\n\t\t\t\t\tvalue: canReflect.getName(definition.value).replace('value', 'event emitter')\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\treturn computeObj;\n\t\t};\n\t},\n\t// Returns a function that creates the `_computed` prop.\n\tcompute: function(prop, get, defaultValueFn) {\n\n\t\treturn function() {\n\t\t\tvar map = this,\n\t\t\t\tdefaultValue = defaultValueFn && defaultValueFn.call(this),\n\t\t\t\tobservable, computeObj;\n\n\t\t\tif(get.length === 0) {\n\t\t\t\tobservable = new Observation(get, map);\n\t\t\t} else if(get.length === 1) {\n\t\t\t\tobservable = new SettableObservable(get, map, defaultValue);\n\t\t\t} else {\n\t\t\t\tobservable = new AsyncObservable(get, map, defaultValue);\n\t\t\t}\n\n\t\t\tcomputeObj = make.computeObj(map, prop, observable);\n\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tObject.defineProperty(computeObj.handler, \"name\", {\n\t\t\t\t\tvalue: canReflect.getName(get).replace('getter', 'event emitter')\n\t\t\t\t});\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\t\t\treturn computeObj;\n\t\t};\n\t},\n\t// Set related helpers.\n\tset: {\n\t\tdata: function(prop) {\n\t\t\treturn function(newVal) {\n\t\t\t\tthis._data[prop] = newVal;\n\t\t\t};\n\t\t},\n\t\tcomputed: function(prop) {\n\t\t\treturn function(val) {\n\t\t\t\tcanReflect.setValue( this._computed[prop].compute, val );\n\t\t\t};\n\t\t},\n\t\tevents: function(prop, getCurrent, setData, eventType) {\n\t\t\treturn function(newVal) {\n\t\t\t\tif (this.__inSetup) {\n\t\t\t\t\tsetData.call(this, newVal);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar current = getCurrent.call(this);\n\t\t\t\t\tif (newVal !== current) {\n\t\t\t\t\t\tvar dispatched;\n\t\t\t\t\t\tsetData.call(this, newVal);\n\n\t\t\t\t\t\tdispatched = {\n\t\t\t\t\t\t\tpatches: [{type: \"set\", key: prop, value: newVal}],\n\t\t\t\t\t\t\ttype: prop,\n\t\t\t\t\t\t\ttarget: this\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t\tdispatched.reasonLog = [ canReflect.getName(this) + \"'s\", prop, \"changed to\", newVal, \"from\", current ];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\t\tthis.dispatch(dispatched, [newVal, current]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\tsetter: function(prop, setter, getCurrent, setEvents, hasGetter) {\n\t\t\treturn function(value) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tvar asyncTimer;\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\tvar self = this;\n\n\t\t\t\t// call the setter, if returned value is undefined,\n\t\t\t\t// this means the setter is async so we\n\t\t\t\t// do not call update property and return right away\n\n\t\t\t\tqueues.batch.start();\n\t\t\t\tvar setterCalled = false,\n\t\t\t\t\tcurrent = getCurrent.call(this),\n\t\t\t\t\tsetValue = setter.call(this, value, function(value) {\n\t\t\t\t\t\tsetEvents.call(self, value);\n\n\t\t\t\t\t\tsetterCalled = true;\n\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t\tclearTimeout(asyncTimer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t}, current);\n\n\t\t\t\tif (setterCalled) {\n\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t} else {\n\t\t\t\t\tif (hasGetter) {\n\t\t\t\t\t\t// we got a return value\n\t\t\t\t\t\tif (setValue !== undefined) {\n\t\t\t\t\t\t\t// if the current `set` value is returned, don't set\n\t\t\t\t\t\t\t// because current might be the `lastSetVal` of the internal compute.\n\t\t\t\t\t\t\tif (current !== setValue) {\n\t\t\t\t\t\t\t\tsetEvents.call(this, setValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// this is a side effect, it didn't take a value\n\t\t\t\t\t\t// so use the original set value\n\t\t\t\t\t\telse if (setter.length === 0) {\n\t\t\t\t\t\t\tsetEvents.call(this, value);\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// it took a value\n\t\t\t\t\t\telse if (setter.length === 1) {\n\t\t\t\t\t\t\t// if we have a getter, and undefined was returned,\n\t\t\t\t\t\t\t// we should assume this is setting the getters properties\n\t\t\t\t\t\t\t// and we shouldn't do anything.\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// we are expecting something\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t\t\tasyncTimer = setTimeout(function() {\n\t\t\t\t\t\t\t\t\tcanLogDev.warn('can-define: Setter \"' + canReflect.getName(self)+\".\"+prop + '\" did not return a value or call the setter callback.');\n\t\t\t\t\t\t\t\t}, canLogDev.warnTimeout);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// we got a return value\n\t\t\t\t\t\tif (setValue !== undefined) {\n\t\t\t\t\t\t\t// if the current `set` value is returned, don't set\n\t\t\t\t\t\t\t// because current might be the `lastSetVal` of the internal compute.\n\t\t\t\t\t\t\tsetEvents.call(this, setValue);\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// this is a side effect, it didn't take a value\n\t\t\t\t\t\t// so use the original set value\n\t\t\t\t\t\telse if (setter.length === 0) {\n\t\t\t\t\t\t\tsetEvents.call(this, value);\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// it took a value\n\t\t\t\t\t\telse if (setter.length === 1) {\n\t\t\t\t\t\t\t// if we don't have a getter, we should probably be setting the\n\t\t\t\t\t\t\t// value to undefined\n\t\t\t\t\t\t\tsetEvents.call(this, undefined);\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// we are expecting something\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t\t\tasyncTimer = setTimeout(function() {\n\t\t\t\t\t\t\t\t\tcanLogDev.warn('can/map/setter.js: Setter \"' + canReflect.getName(self)+\".\"+prop + '\" did not return a value or call the setter callback.');\n\t\t\t\t\t\t\t\t}, canLogDev.warnTimeout);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\t\t\tqueues.batch.stop();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\ttype: function(prop, type, set) {\n\t\t\tfunction setter(newValue) {\n\t\t\t\treturn set.call(this, type.call(this, newValue, prop));\n\t\t\t}\n\t\t\tif(isDefineType(type)) {\n\t\t\t\t// TODO: remove this `canDefineType` check in a future release.\n\t\t\t\tif(type.canDefineType) {\n\t\t\t\t\treturn setter;\n\t\t\t\t} else {\n\t\t\t\t\treturn function setter(newValue){\n\t\t\t\t\t\treturn set.call(this, canReflect.convert(newValue, type));\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If type is a nested object: `type: {foo: \"string\", bar: \"number\"}`\n\t\t\tif (typeof type === \"object\") {\n\t\t\t\treturn make.set.Type(prop, type, set);\n\t\t\t} else {\n\t\t\t\treturn setter;\n\t\t\t}\n\t\t},\n\t\tType: function(prop, Type, set) {\n\t\t\t// `type`: {foo: \"string\"}\n\t\t\tif(Array.isArray(Type) && define.DefineList) {\n\t\t\t\tType = define.DefineList.extend({\n\t\t\t\t\t\"#\": Type[0]\n\t\t\t\t});\n\t\t\t} else if (typeof Type === \"object\") {\n\t\t\t\tif(define.DefineMap) {\n\t\t\t\t\tType = define.DefineMap.extend(Type);\n\t\t\t\t} else {\n\t\t\t\t\tType = define.Constructor(Type);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn function(newValue) {\n\t\t\t\tif (newValue instanceof Type || newValue == null) {\n\t\t\t\t\treturn set.call(this, newValue);\n\t\t\t\t} else {\n\t\t\t\t\treturn set.call(this, new Type(newValue));\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\t// Helpes that indicate what the event type should be.  These probably aren't needed.\n\teventType: {\n\t\tdata: function(prop) {\n\t\t\treturn function(newVal, oldVal) {\n\t\t\t\treturn oldVal !== undefined || this._data.hasOwnProperty(prop) ? \"set\" : \"add\";\n\t\t\t};\n\t\t},\n\t\tcomputed: function() {\n\t\t\treturn function() {\n\t\t\t\treturn \"set\";\n\t\t\t};\n\t\t}\n\t},\n\t// Helpers that read the data in a non-observable way.\n\tread: {\n\t\tdata: function(prop) {\n\t\t\treturn function() {\n\t\t\t\treturn this._data[prop];\n\t\t\t};\n\t\t},\n\t\tcomputed: function(prop) {\n\t\t\t// might want to protect this\n\t\t\treturn function() {\n\t\t\t\treturn canReflect.getValue( this._computed[prop].compute );\n\t\t\t};\n\t\t},\n\t\tlastSet: function(prop) {\n\t\t\treturn function() {\n\t\t\t\tvar observable = this._computed[prop].compute;\n\t\t\t\tif(observable.lastSetValue) {\n\t\t\t\t\treturn canReflect.getValue(observable.lastSetValue);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t},\n\t// Helpers that read the data in an observable way.\n\tget: {\n\t\t// uses the default value\n\t\tdefaultValue: function(prop, definition, typeConvert, callSetter) {\n\t\t\treturn function() {\n\t\t\t\tvar value = definition.default;\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tif (typeof value === \"function\") {\n\t\t\t\t\t\tvalue = value.call(this);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = typeConvert.call(this, value);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar Default = definition.Default;\n\t\t\t\t\tif (Default) {\n\t\t\t\t\t\tvalue = typeConvert.call(this,new Default());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(definition.set) {\n\t\t\t\t\t// TODO: there's almost certainly a faster way of making this happen\n\t\t\t\t\t// But this is maintainable.\n\n\t\t\t\t\tvar VALUE;\n\t\t\t\t\tvar sync = true;\n\n\t\t\t\t\tvar setter = make.set.setter(prop, definition.set, function(){}, function(value){\n\t\t\t\t\t\tif(sync) {\n\t\t\t\t\t\t\tVALUE = value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallSetter.call(this, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, definition.get);\n\n\t\t\t\t\tsetter.call(this,value);\n\t\t\t\t\tsync= false;\n\n\t\t\t\t\t// VALUE will be undefined if the callback is never called.\n\t\t\t\t\treturn VALUE;\n\n\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t};\n\t\t},\n\t\tdata: function(prop) {\n\t\t\treturn function() {\n\t\t\t\tif (!this.__inSetup) {\n\t\t\t\t\tObservationRecorder.add(this, prop);\n\t\t\t\t}\n\n\t\t\t\treturn this._data[prop];\n\t\t\t};\n\t\t},\n\t\tcomputed: function(prop) {\n\t\t\treturn function(val) {\n\t\t\t\tvar compute = this._computed[prop].compute;\n\t\t\t\tif (ObservationRecorder.isRecording()) {\n\t\t\t\t\tObservationRecorder.add(this, prop);\n\t\t\t\t\tif (!canReflect.isBound(compute)) {\n\t\t\t\t\t\tObservation.temporarilyBind(compute);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn peek(compute);\n\t\t\t};\n\t\t}\n\t}\n};\n\ndefine.behaviors = [\"get\", \"set\", \"value\", \"Value\", \"type\", \"Type\", \"serialize\"];\n\n// This cleans up a particular behavior and adds it to the definition\nvar addBehaviorToDefinition = function(definition, behavior, value) {\n\tif(behavior === \"enumerable\") {\n\t\t// treat enumerable like serialize\n\t\tdefinition.serialize = !!value;\n\t}\n\telse if(behavior === \"type\") {\n\t\tvar behaviorDef = value;\n\t\tif(typeof behaviorDef === \"string\") {\n\t\t\tbehaviorDef = define.types[behaviorDef];\n\t\t\tif(typeof behaviorDef === \"object\" && !isDefineType(behaviorDef)) {\n\t\t\t\tassign(definition, behaviorDef);\n\t\t\t\tbehaviorDef = behaviorDef[behavior];\n\t\t\t}\n\t\t}\n\t\tif (typeof behaviorDef !== 'undefined') {\n\t\t\tdefinition[behavior] = behaviorDef;\n\t\t}\n\t}\n\telse {\n\t\tdefinition[behavior] = value;\n\t}\n};\n\n// This is called by `define.property` AND `getDefinitionOrMethod` (which is called by `define`)\n// Currently, this is adding default behavior\n// copying `type` over, and even cleaning up the final definition object\nmakeDefinition = function(prop, def, defaultDefinition, typePrototype) {\n\tvar definition = {};\n\n\tcanReflect.eachKey(def, function(value, behavior) {\n\t\taddBehaviorToDefinition(definition, behavior, value);\n\t});\n\t// only add default if it doesn't exist\n\tcanReflect.eachKey(defaultDefinition, function(value, prop){\n\t\tif(definition[prop] === undefined) {\n\t\t\tif(prop !== \"type\" && prop !== \"Type\") {\n\t\t\t\tdefinition[prop] = value;\n\t\t\t}\n\t\t}\n\t});\n\n\t// normalize Type that implements can.new\n\tif(def.Type) {\n\t\tvar value = def.Type;\n\n\t\tvar serialize = value[serializeSymbol];\n\t\tif(serialize) {\n\t\t\tdefinition.serialize = function(val){\n\t\t\t\treturn serialize.call(val);\n\t\t\t};\n\t\t}\n\t\tif(value[newSymbol]) {\n\t\t\tdefinition.type = value[newSymbol];\n\t\t\tdelete definition.Type;\n\t\t}\n\t}\n\n\t// We only want to add a defaultDefinition if def.type is not a string\n\t// if def.type is a string it is handled in addDefinition\n\tif(typeof def.type !== 'string') {\n\t\t// if there's no type definition, take it from the defaultDefinition\n\t\tif(!definition.type && !definition.Type) {\n            var defaultsCopy = canReflect.assignMap({},defaultDefinition);\n            definition = canReflect.assignMap(defaultsCopy, definition);\n\t\t}\n\n\t\tif( canReflect.size(definition) === 0 ) {\n\t\t\tdefinition.type = define.types[\"*\"];\n\t\t}\n\t}\n\tcleanUpDefinition(prop, definition, true, typePrototype);\n\treturn definition;\n};\n\n// called by `can.defineInstanceKey` and `getDefinitionsAndMethods`\n// returns the value or the definition object.\n// calls makeDefinition\n// This is dealing with a string value\ngetDefinitionOrMethod = function(prop, value, defaultDefinition, typePrototype){\n\t// Clean up the value to make it a definition-like object\n\tvar definition;\n\tif(typeof value === \"string\") {\n\t\tdefinition = {type: value};\n\t}\n    // copies a `Type`'s methods over\n\telse if(value && (value[serializeSymbol] || value[newSymbol]) ) {\n\t\tdefinition = { Type: value };\n\t}\n\telse if(typeof value === \"function\") {\n\t\tif(canReflect.isConstructorLike(value)) {\n\t\t\tdefinition = {Type: value};\n\t\t}\n\t\t// or leaves as a function\n\t} else if( Array.isArray(value) ) {\n\t\tdefinition = {Type: value};\n\t} else if( canReflect.isPlainObject(value) ){\n\t\tdefinition = value;\n\t}\n\n\tif(definition) {\n\t\treturn makeDefinition(prop, definition, defaultDefinition, typePrototype);\n\t}\n\telse {\n\t\treturn value;\n\t}\n};\n// called by can.define\ngetDefinitionsAndMethods = function(defines, baseDefines, typePrototype) {\n\t// make it so the definitions include base definitions on the proto\n\tvar definitions = Object.create(baseDefines ? baseDefines.definitions : null);\n\tvar methods = {};\n\t// first lets get a default if it exists\n\tvar defaults = defines[\"*\"],\n\t\tdefaultDefinition;\n\tif(defaults) {\n\t\tdelete defines[\"*\"];\n\t\tdefaultDefinition = getDefinitionOrMethod(\"*\", defaults, {});\n\t} else {\n\t\tdefaultDefinition = Object.create(null);\n\t}\n\n\teachPropertyDescriptor(defines, function( prop, propertyDescriptor ) {\n\n\t\tvar value;\n\t\tif(propertyDescriptor.get || propertyDescriptor.set) {\n\t\t\tvalue = {get: propertyDescriptor.get, set: propertyDescriptor.set};\n\t\t} else {\n\t\t\tvalue = propertyDescriptor.value;\n\t\t}\n\n\t\tif(prop === \"constructor\") {\n\t\t\tmethods[prop] = value;\n\t\t\treturn;\n\t\t} else {\n\t\t\tvar result = getDefinitionOrMethod(prop, value, defaultDefinition, typePrototype);\n\t\t\tif(result && typeof result === \"object\" && canReflect.size(result) > 0) {\n\t\t\t\tdefinitions[prop] = result;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Removed adding raw values that are not functions\n\t\t\t\tif (typeof result === 'function') {\n\t\t\t\t\tmethods[prop] = result;\n\t\t\t\t}\n\t\t\t\t//!steal-remove-start\n\t\t\t\telse if (typeof result !== 'undefined') {\n\t\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n                    \t// Ex: {prop: 0}\n\t\t\t\t\t\tcanLogDev.error(canReflect.getName(typePrototype)+\".\"+prop + \" does not match a supported propDefinition. See: https://canjs.com/doc/can-define.types.propDefinition.html\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t}\n\t\t}\n\t});\n\tif(defaults) {\n\t\t// we should move this property off the prototype.\n\t\tdefineConfigurableAndNotEnumerable(defines,\"*\", defaults);\n\t}\n\treturn {definitions: definitions, methods: methods, defaultDefinition: defaultDefinition};\n};\n\neventsProto = eventQueue({});\n\nfunction setupComputed(instance, eventName) {\n\tvar computedBinding = instance._computed && instance._computed[eventName];\n\tif (computedBinding && computedBinding.compute) {\n\t\tif (!computedBinding.count) {\n\t\t\tcomputedBinding.count = 1;\n\t\t\tcanReflect.onValue(computedBinding.compute, computedBinding.handler, \"notify\");\n\t\t\tcomputedBinding.oldValue = canReflect.getValue(computedBinding.compute);\n\t\t} else {\n\t\t\tcomputedBinding.count++;\n\t\t}\n\n\t}\n}\nfunction teardownComputed(instance, eventName){\n\tvar computedBinding = instance._computed && instance._computed[eventName];\n\tif (computedBinding) {\n\t\tif (computedBinding.count === 1) {\n\t\t\tcomputedBinding.count = 0;\n\t\t\tcanReflect.offValue(computedBinding.compute, computedBinding.handler,\"notify\");\n\t\t} else {\n\t\t\tcomputedBinding.count--;\n\t\t}\n\t}\n}\n\nvar canMetaSymbol = canSymbol.for(\"can.meta\");\nassign(eventsProto, {\n\t_eventSetup: function() {},\n\t_eventTeardown: function() {},\n\taddEventListener: function(eventName, handler, queue) {\n\t\tsetupComputed(this, eventName);\n\t\treturn eventQueue.addEventListener.apply(this, arguments);\n\t},\n\n\t// ### unbind\n\t// Stops listening to an event.\n\t// If this is the last listener of a computed property,\n\t// stop forwarding events of the computed property to this map.\n\tremoveEventListener: function(eventName, handler) {\n\t\tteardownComputed(this, eventName);\n\t\treturn eventQueue.removeEventListener.apply(this, arguments);\n\n\t}\n});\neventsProto.on = eventsProto.bind = eventsProto.addEventListener;\neventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;\n\n\nvar onKeyValueSymbol = canSymbol.for(\"can.onKeyValue\");\nvar offKeyValueSymbol = canSymbol.for(\"can.offKeyValue\");\n\ncanReflect.assignSymbols(eventsProto,{\n\t\"can.onKeyValue\": function(key){\n\t\tsetupComputed(this, key);\n\t\treturn eventQueue[onKeyValueSymbol].apply(this, arguments);\n\t},\n\t\"can.offKeyValue\": function(key){\n\t\tteardownComputed(this, key);\n\t\treturn eventQueue[offKeyValueSymbol].apply(this, arguments);\n\t}\n});\n\ndelete eventsProto.one;\n\ndefine.setup = function(props, sealed) {\n\tObject.defineProperty(this,\"constructor\", {value: this.constructor, enumerable: false, writable: false});\n\tObject.defineProperty(this,canMetaSymbol, {value: Object.create(null), enumerable: false, writable: false});\n\n\t/* jshint -W030 */\n\n\tvar definitions = this._define.definitions;\n\tvar instanceDefinitions = Object.create(null);\n\tvar map = this;\n\tcanReflect.eachKey(props, function(value, prop){\n\t\tif(definitions[prop] !== undefined) {\n\t\t\tmap[prop] = value;\n\t\t} else {\n\t\t\tdefine.expando(map, prop, value);\n\t\t}\n\t});\n\tif(canReflect.size(instanceDefinitions) > 0) {\n\t\tdefineConfigurableAndNotEnumerable(this, \"_instanceDefinitions\", instanceDefinitions);\n\t}\n\t// only seal in dev mode for performance reasons.\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tthis._data;\n\t\tthis._computed;\n\t\tif(sealed !== false) {\n\t\t\tObject.seal(this);\n\t\t}\n\t}\n\t//!steal-remove-end\n};\n\n\nvar returnFirstArg = function(arg){\n\treturn arg;\n};\n\ndefine.expando = function(map, prop, value) {\n\tif(define._specialKeys[prop]) {\n\t\t// ignores _data and _computed\n\t\treturn true;\n\t}\n\t// first check if it's already a constructor define\n\tvar constructorDefines = map._define.definitions;\n\tif(constructorDefines && constructorDefines[prop]) {\n\t\treturn;\n\t}\n\t// next if it's already on this instances\n\tvar instanceDefines = map._instanceDefinitions;\n\tif(!instanceDefines) {\n\t\tif(Object.isSealed(map)) {\n\t\t\treturn;\n\t\t}\n\t\tObject.defineProperty(map, \"_instanceDefinitions\", {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tvalue: {}\n\t\t});\n\t\tinstanceDefines = map._instanceDefinitions;\n\t}\n\tif(!instanceDefines[prop]) {\n\t\tvar defaultDefinition = map._define.defaultDefinition || {type: define.types.observable};\n\t\tdefine.property(map, prop, defaultDefinition, {},{});\n\t\t// possibly convert value to List or DefineMap\n\t\tif(defaultDefinition.type) {\n\t\t\tmap._data[prop] = define.make.set.type(prop, defaultDefinition.type, returnFirstArg).call(map, value);\n\t\t} else {\n\t\t\tmap._data[prop] = define.types.observable(value);\n\t\t}\n\n\t\tinstanceDefines[prop] = defaultDefinition;\n\t\tif(!map.__inSetup) {\n\t\t\tqueues.batch.start();\n\t\t\tmap.dispatch({\n\t\t\t\ttype: \"can.keys\",\n\t\t\t\ttarget: map\n\t\t\t});\n\t\t\tif(map._data[prop] !== undefined) {\n\t\t\t\tmap.dispatch({\n\t\t\t\t\ttype: prop,\n\t\t\t\t\ttarget: map,\n\t\t\t\t\tpatches: [{type: \"set\", key: prop, value: map._data[prop]}],\n\t\t\t\t},[map._data[prop], undefined]);\n\t\t\t}\n\t\t\tqueues.batch.stop();\n\t\t}\n\t\treturn true;\n\t}\n};\ndefine.replaceWith = defineLazyValue;\ndefine.eventsProto = eventsProto;\ndefine.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;\ndefine.make = make;\ndefine.getDefinitionOrMethod = getDefinitionOrMethod;\ndefine._specialKeys = {_data: true, _computed: true};\nvar simpleGetterSetters = {};\ndefine.makeSimpleGetterSetter = function(prop){\n\tif(simpleGetterSetters[prop] === undefined) {\n\n\t\tvar setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop) );\n\n\t\tsimpleGetterSetters[prop] = {\n\t\t\tget: make.get.data(prop),\n\t\t\tset: function(newVal){\n\t\t\t\treturn setter.call(this, define.types.observable(newVal));\n\t\t\t},\n\t\t\tenumerable: true,\n            configurable: true\n\t\t};\n\t}\n\treturn simpleGetterSetters[prop];\n};\n\ndefine.Iterator = function(obj){\n\tthis.obj = obj;\n\tthis.definitions = Object.keys(obj._define.definitions);\n\tthis.instanceDefinitions = obj._instanceDefinitions ?\n\t\tObject.keys(obj._instanceDefinitions) :\n\t\tObject.keys(obj);\n\tthis.hasGet = typeof obj.get === \"function\";\n};\n\ndefine.Iterator.prototype.next = function(){\n\tvar key;\n\tif(this.definitions.length) {\n\t\tkey = this.definitions.shift();\n\n\t\t// Getters should not be enumerable\n\t\tvar def = this.obj._define.definitions[key];\n\t\tif(def.get) {\n\t\t\treturn this.next();\n\t\t}\n\t} else if(this.instanceDefinitions.length) {\n\t\tkey = this.instanceDefinitions.shift();\n\t} else {\n\t\treturn {\n\t\t\tvalue: undefined,\n\t\t\tdone: true\n\t\t};\n\t}\n\n\treturn {\n\t\tvalue: [\n\t\t\tkey,\n\t\t\tthis.hasGet ? this.obj.get(key) : this.obj[key]\n\t\t],\n\t\tdone: false\n\t};\n};\n\n\n\nfunction isObservableValue(obj){\n\treturn canReflect.isValueLike(obj) && canReflect.isObservableLike(obj);\n}\n\ndefine.types = {\n\t// To be made into a type ... this is both lazy {time: '123-456'}\n\t'date': MaybeDate,\n\t'number': MaybeNumber,\n\t'boolean': MaybeBoolean,\n\t'observable': function(newVal) {\n\t\t\tif(Array.isArray(newVal) && define.DefineList) {\n\t\t\t\t\tnewVal = new define.DefineList(newVal);\n\t\t\t}\n\t\t\telse if(canReflect.isPlainObject(newVal) &&  define.DefineMap) {\n\t\t\t\t\tnewVal = new define.DefineMap(newVal);\n\t\t\t}\n\t\t\treturn newVal;\n\t},\n\t'stringOrObservable': function(newVal) {\n\t\tif(Array.isArray(newVal)) {\n\t\t\treturn new define.DefaultList(newVal);\n\t\t}\n\t\telse if(canReflect.isPlainObject(newVal)) {\n\t\t\treturn new define.DefaultMap(newVal);\n\t\t}\n\t\telse {\n\t\t\treturn canReflect.convert( newVal, define.types.string);\n\t\t}\n\t},\n\t/**\n\t * Implements HTML-style boolean logic for attribute strings, where\n\t * any string, including \"\", is truthy.\n\t */\n\t'htmlbool': function(val) {\n\t\tif (val === '') {\n\t\t\treturn true;\n\t\t}\n\t\treturn !!stringToAny(val);\n\t},\n\t'*': function(val) {\n\t\treturn val;\n\t},\n\t'any': function(val) {\n\t\treturn val;\n\t},\n\t'string': MaybeString,\n\n\t'compute': {\n\t\tset: function(newValue, setVal, setErr, oldValue) {\n\t\t\tif (isObservableValue(newValue) ) {\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t\tif (isObservableValue(oldValue)) {\n\t\t\t\tcanReflect.setValue(oldValue,newValue);\n\t\t\t\treturn oldValue;\n\t\t\t}\n\t\t\treturn newValue;\n\t\t},\n\t\tget: function(value) {\n\t\t\treturn isObservableValue(value) ? canReflect.getValue(value) : value;\n\t\t}\n\t}\n};\n\ndefine.updateSchemaKeys = function(schema, definitions) {\n\tfor(var prop in definitions) {\n\t\tvar definition = definitions[prop];\n\t\tif(definition.serialize !== false ) {\n\t\t\tif(definition.type) {\n\t\t\t\tschema.keys[prop] = definition.type;\n\t\t\t} else {\n\t\t\t\tschema.keys[prop] = function(val){ return val; };\n\t\t\t}\n\t\t\t // some unknown type\n\t\t\tif(definitions[prop].identity === true) {\n\t\t\t\tschema.identity.push(prop);\n\t\t\t}\n\t\t}\n\t}\n\treturn schema;\n};\n"],"names":["eventsProto","define","make","makeDefinition","getDefinitionsAndMethods","getDefinitionOrMethod","newSymbol","canSymbol","for","serializeSymbol","isDefineType","func","canDefineType","peek","ObservationRecorder","ignore","canReflect","getValue","bind","Object_defineNamedPrototypeProperty","Object","defineProperty","defineConfigurableAndNotEnumerable","obj","prop","value","configurable","enumerable","writable","eachPropertyDescriptor","map","cb","hasOwnProperty","call","getOwnPropertyDescriptor","getEveryPropertyAndSymbol","props","getOwnPropertyNames","symbols","getOwnPropertySymbols","concat","cleanUpDefinition","definition","shouldWarn","typePrototype","undefined","length","process","env","NODE_ENV","canLogDev","warn","getName","default","Value","Default","isValueResolver","get","set","ns","defines","baseDefine","dataInitializers","create","computedInitializers","result","eachKey","definitions","property","defaultDefinition","defineLazyValue","_data","data","this","_computed","forEach","iteratorSymbol","iterator","Iterator","onlyType","extensions","propertyDefinition","apply","arguments","type","isConstructorLike","types","events","eventType","getInitialValue","dataProperty","reader","read","getter","setter","typeConvert","val","Type","eventsSetter","valueResolver","defaultValue","compute","lastSet","serialize","makeDefineInstanceKey","constructor","defineResult","prototype","_define","methods","dispatch","target","Constructor","sealed","setup","__inSetup","addTypeEvents","computeObj","observable","oldValue","count","handler","newVal","getDefault","ResolverObservable","replace","defaultValueFn","Observation","SettableObservable","AsyncObservable","computed","setValue","getCurrent","setData","dispatched","current","patches","key","reasonLog","setEvents","hasGetter","asyncTimer","self","queues","batch","start","setterCalled","clearTimeout","stop","setTimeout","warnTimeout","newValue","convert","Array","isArray","DefineList","extend","#","DefineMap","oldVal","lastSetValue","callSetter","VALUE","sync","add","isRecording","isBound","temporarilyBind","behaviors","addBehaviorToDefinition","behavior","behaviorDef","assign","setupComputed","instance","eventName","computedBinding","onValue","teardownComputed","offValue","def","defaultsCopy","assignMap","size","isPlainObject","baseDefines","defaults","propertyDescriptor","error","eventQueue","canMetaSymbol","_eventSetup","_eventTeardown","addEventListener","queue","removeEventListener","on","off","unbind","onKeyValueSymbol","offKeyValueSymbol","assignSymbols","can.onKeyValue","can.offKeyValue","one","instanceDefinitions","expando","seal","returnFirstArg","arg","_specialKeys","constructorDefines","instanceDefines","_instanceDefinitions","isSealed","replaceWith","simpleGetterSetters","isObservableValue","isValueLike","isObservableLike","makeSimpleGetterSetter","keys","hasGet","next","shift","done","date","MaybeDate","number","MaybeNumber","boolean","MaybeBoolean","stringOrObservable","DefaultList","DefaultMap","string","htmlbool","stringToAny","*","any","MaybeString","setVal","setErr","updateSchemaKeys","schema","identity","push"],"mappings":"2mCA4BA,IAGIA,YAAaC,OAChBC,KAAMC,eAAgBC,yBAA0BC,sBAJ7CC,UAAYC,UAAUC,IAAI,WAC7BC,gBAAkBF,UAAUC,IAAI,iBAMjC,SAASE,aAAaC,GACrB,OAAOA,KAAgC,IAAvBA,EAAKC,eAA0BD,EAAKL,YAGrD,IAAIO,KAAOC,oBAAoBC,OAAOC,WAAWC,SAASC,KAAKF,aAE3DG,oCAAsCC,OAAOC,eAuBjD,SAASC,mCAAmCC,EAAKC,EAAMC,GACtDL,OAAOC,eAAeE,EAAKC,EAAM,CAChCE,cAAc,EACdC,YAAY,EACZC,UAAU,EACVH,MAAOA,IAIT,SAASI,uBAAuBC,EAAKC,GACpC,IAAI,IAAIP,KAAQM,EACZA,EAAIE,eAAeR,IACrBO,EAAGE,KAAKH,EAAKN,EAAMJ,OAAOc,yBAAyBJ,EAAIN,IAK1D,SAASW,0BAA0BZ,GAClC,IAAIa,EAAQhB,OAAOiB,oBAAoBd,GACnCe,EAAW,0BAA2BlB,OACxCA,OAAOmB,sBAAsBhB,GAAO,GACtC,OAAOa,EAAMI,OAAOF,GAGrB,SAASG,kBAAkBjB,EAAMkB,EAAYC,EAAYC,QAEhCC,IAArBH,EAAWjB,OAAqD,mBAArBiB,EAAWjB,OAAoD,IAA5BiB,EAAWjB,MAAMqB,SAGrE,eAAzBC,UAAQC,IAAIC,UACXN,GACFO,IAAUC,KACT,iDAAmDnC,WAAWoC,QAAQR,GAAe,IAAIpB,EAAO,kBAMnGkB,EAAWW,QAAUX,EAAWjB,aACzBiB,EAAWjB,YAGKoB,IAArBH,EAAWY,QAEe,eAAzBP,UAAQC,IAAIC,UACXN,GACFO,IAAUC,KACT,iDAAmDnC,WAAWoC,QAAQR,GAAe,IAAIpB,EAAO,kBAKnGkB,EAAWa,QAAUb,EAAWY,aACzBZ,EAAWY,OAIpB,SAASE,gBAAgBd,GAExB,MAAmC,mBAArBA,EAAWjB,OAAwBiB,EAAWjB,MAAMqB,OAhFvC,eAAzBC,UAAQC,IAAIC,WACd9B,oCAAsC,SAASI,EAAKC,EAAMkB,GAczD,OAbIA,EAAWe,KACdrC,OAAOC,eAAeqB,EAAWe,IAAK,OAAQ,CAC7ChC,MAAO,OAAOT,WAAWoC,QAAQ7B,GAAO,IAAIC,EAC5CI,UAAU,EACVF,cAAc,IAGZgB,EAAWgB,KACdtC,OAAOC,eAAeqB,EAAWgB,IAAK,OAAQ,CAC7CjC,MAAQ,OAAOT,WAAWoC,QAAQ7B,GAAO,IAAIC,EAC7CE,cAAc,IAGTN,OAAOC,eAAeE,EAAKC,EAAMkB,KAoE1C,cAAiBzC,OAAS0D,UAAG1D,OAAS,SAAS2C,EAAegB,EAASC,GAEtE,IAAIrC,EACHsC,EAAmB1C,OAAO2C,OAAOF,EAAaA,EAAWC,iBAAmB,MAE5EE,EAAuB5C,OAAO2C,OAAOF,EAAaA,EAAWG,qBAAuB,MAEjFC,EAAS7D,yBAAyBwD,EAASC,EAAYjB,GAc3D,GAbAqB,EAAOH,iBAAmBA,EAC1BG,EAAOD,qBAAuBA,EAK9BhD,WAAWkD,QAAQD,EAAOE,YAAa,SAASzB,EAAY0B,GAC3DnE,OAAOmE,SAASxB,EAAewB,EAAU1B,EAAYoB,EAAkBE,EAAsBC,EAAOI,qBAMlGzB,EAAcZ,eAAe,SAC/B,IAAKR,KAAQsC,EACZQ,gBAAgB1B,EAAc2B,MAAO/C,EAAMsC,EAAiBtC,GAAMN,KAAK0B,IAAgB,QAGxF0B,gBAAgB1B,EAAe,QAAS,WACvC,IACI4B,EAAO,GACX,IAAK,IAAIhD,KAAQsC,EAChBQ,gBAAgBE,EAAMhD,EAAMsC,EAAiBtC,GAAMN,KAH1CuD,OAGqD,GAE/D,OAAOD,IAOT,GAAG5B,EAAcZ,eAAe,aAC/B,IAAKR,KAAQwC,EACZM,gBAAgB1B,EAAc8B,UAAWlD,EAAMwC,EAAqBxC,GAAMN,KAAK0B,SAGhF0B,gBAAgB1B,EAAe,YAAa,WAC3C,IACI4B,EAAOpD,OAAO2C,OAAO,MACzB,IAAK,IAAIvC,KAAQwC,EAChBM,gBAAgBE,EAAMhD,EAAMwC,EAAqBxC,GAAMN,KAH9CuD,OAKV,OAAOD,IAKTrC,0BAA0BnC,aAAa2E,QAAQ,SAASnD,GACvDJ,OAAOC,eAAeuB,EAAepB,EAAM,CAC1CG,YAAY,EACZF,MAAOzB,YAAYwB,GACnBE,cAAc,EACdE,UAAU,MAKZR,OAAOC,eAAeuB,EAAc,UAAU,CAC7CjB,YAAY,EACZF,MAAOwC,EACPvC,cAAc,EACdE,UAAU,IAKX,IAAIgD,EAAiBrE,UAAUsE,UAAYtE,UAAUC,IAAI,YAOzD,OANIoC,EAAcgC,IACjBtD,mCAAmCsB,EAAegC,EAAgB,WACjE,OAAO,IAAI3E,OAAO6E,SAASL,QAItBR,GAGJc,SAAW,SAASxD,GACvB,IAAI,IAAIC,KAAQD,EACf,GAAY,SAATC,EACF,OAAO,EAGT,OAAO,GAGRvB,OAAO+E,WAAa,aAIpB/E,OAAOmE,SAAW,SAASxB,EAAepB,EAAMkB,EAAYoB,EAAkBE,EAAsBK,GACnG,IAAIY,EAAqBhF,OAAO+E,WAAWE,MAAMT,KAAMU,WAEnDF,IACHvC,EAAavC,eAAeqB,EAAMyD,EAAoBZ,GAAqB,GAAIzB,IAGhF,IAAIwC,EAAO1C,EAAW0C,KAetB,GAZ4B,eAAzBrC,UAAQC,IAAIC,UACVmC,GAAQpE,WAAWqE,kBAAkBD,KAAU1E,aAAa0E,IAC/DlC,IAAUC,KACT,kCAAoCnC,WAAWoC,QAAQR,GAAiB,IAC5DpB,EACZ,wDAOC4D,GAAQL,SAASrC,IAAe0C,IAASnF,OAAOqF,MAAM,KACzDnE,oCAAoCyB,EAAepB,EAAM,CACxDiC,IAAKvD,KAAKuD,IAAIe,KAAKhD,GACnBkC,IAAKxD,KAAKwD,IAAI6B,OAAO/D,EAAMtB,KAAKuD,IAAIe,KAAKhD,GAAOtB,KAAKwD,IAAIc,KAAKhD,GAAOtB,KAAKsF,UAAUhB,KAAKhD,IACzFG,YAAY,EACZD,cAAc,QALhB,CASAgB,EAAW0C,KAAOA,EAKlB,IASCK,EATGC,EAAehD,EAAWe,KAAOD,gBAAgBd,GAAc,WAAa,OAM/EiD,EAASzF,KAAK0F,KAAKF,GAAclE,GACjCqE,EAAS3F,KAAKuD,IAAIiC,GAAclE,GAChCsE,EAAS5F,KAAKwD,IAAIgC,GAAclE,GAIL,eAAzBuB,UAAQC,IAAIC,WACVP,EAAWe,KACdrC,OAAOC,eAAeqB,EAAWe,IAAK,OAAQ,CAC7ChC,MAAOT,WAAWoC,QAAQR,GAAiB,MAAQpB,EAAO,UAC1DE,cAAc,IAGZgB,EAAWgB,KACdtC,OAAOC,eAAeqB,EAAWgB,IAAK,OAAQ,CAC7CjC,MAAOT,WAAWoC,QAAQR,GAAiB,MAAQpB,EAAO,UAC1DE,cAAc,IAGb8B,gBAAgBd,IAClBtB,OAAOC,eAAeqB,EAAWjB,MAAO,OAAQ,CAC/CA,MAAOT,WAAWoC,QAAQR,GAAiB,MAAQpB,EAAO,SAC1DE,cAAc,KAOjB,IAAIqE,EAAc,SAASC,GAC1B,OAAOA,GAGJtD,EAAWuD,OACdF,EAAc7F,KAAKwD,IAAIuC,KAAKzE,EAAMkB,EAAWuD,KAAMF,IAEhDX,IACHW,EAAc7F,KAAKwD,IAAI0B,KAAK5D,EAAM4D,EAAMW,IAIzC,IAAIG,EAAehG,KAAKwD,IAAI6B,OAAO/D,EAAMmE,EAAQG,EAAQ5F,KAAKsF,UAAUE,GAAclE,IACnFgC,gBAAgBd,GAClBsB,EAAqBxC,GAAQtB,KAAKiG,cAAc3E,EAAMkB,EAAYqD,QAGlClD,IAAvBH,EAAWW,cAAgDR,IAAvBH,EAAWa,UAG3B,eAAzBR,UAAQC,IAAIC,WAEY,OAAvBP,EAAWW,SAAkD,iBAAvBX,EAAWW,SACpDH,IAAUC,KAAK,qCAAuCnC,WAAWoC,QAAQR,GAAe,IAAIpB,EAAO,gIAGhGkB,EAAWW,SAAWrC,WAAWqE,kBAAkB3C,EAAWW,UACjEH,IAAUC,KAAK,iCAAqCnC,WAAWoC,QAAQR,GAAe,IAAIpB,EAAO,8DAKnGiE,EAAkB3E,oBAAoBC,OAAOb,KAAKuD,IAAI2C,aAAa5E,EAAMkB,EAAYqD,EAAaG,KAI/FxD,EAAWe,IACdO,EAAqBxC,GAAQtB,KAAKmG,QAAQ7E,EAAMkB,EAAWe,IAAKgC,GAIxDA,IACR3B,EAAiBtC,GAAQiE,GAQtB/C,EAAWe,KAAOf,EAAWgB,IAEhCoC,EAAS5F,KAAKwD,IAAIoC,OAAOtE,EAAMkB,EAAWgB,IAAKxD,KAAK0F,KAAKU,QAAQ9E,GAAOsE,GAAQ,GAGxEpD,EAAWgB,IAEnBoC,EAAS5F,KAAKwD,IAAIoC,OAAOtE,EAAMkB,EAAWgB,IAAKiC,EAAQO,GAAc,GAG5C,SAAjBR,EAERI,EAASI,EAGDxD,EAAWe,KAAOf,EAAWe,IAAIX,OAAS,IAClDgD,EAAS,WAEoB,eAAzB/C,UAAQC,IAAIC,UACdC,IAAUC,KAAK,sCACdnC,WAAWoC,QAAQR,GAAe,IAAKpB,EACvC,0EAQA4D,IACHU,EAAS5F,KAAKwD,IAAI0B,KAAK5D,EAAM4D,EAAMU,IAEhCpD,EAAWuD,OACdH,EAAS5F,KAAKwD,IAAIuC,KAAKzE,EAAMkB,EAAWuD,KAAMH,IAI/C3E,oCAAoCyB,EAAepB,EAAM,CACxDiC,IAAKoC,EACLnC,IAAKoC,EACLnE,WAAY,cAAee,IAAeA,EAAW6D,WAAa7D,EAAWe,IAC7E/B,cAAc,MAGhBzB,OAAOuG,sBAAwB,SAASC,GACvCA,EAAYlG,UAAUC,IAAI,0BAA4B,SAAS4D,EAAU3C,GACxE,IAAIiF,EAAejC,KAAKkC,UAAUC,QACd,iBAAVnF,GAETgB,kBAAkB2B,EAAU3C,GAAO,EAAOgD,MAE3C,IAAI/B,EAAarC,sBAAsB+D,EAAU3C,EAAOiF,EAAarC,kBAAmBI,MACrF/B,GAAoC,iBAAfA,GACvBzC,OAAOmE,SAASqC,EAAYE,UAAWvC,EAAU1B,EAAYgE,EAAa5C,iBAAkB4C,EAAa1C,qBAAsB0C,EAAarC,mBAC5IqC,EAAavC,YAAYC,GAAY1B,GAErCgE,EAAaG,QAAQzC,GAAY1B,EAGlC+B,KAAKkC,UAAUG,SAAS,CACvB1B,KAAM,WACN2B,OAAQtC,KAAKkC,cAMhB1G,OAAO+G,YAAc,SAASpD,EAASqD,GACtC,IAAIR,EAAc,SAA2BrE,GAC5ChB,OAAOC,eAAeoD,KAAK,YAAY,CACtC/C,cAAc,EACdC,YAAY,EACZF,OAAO,EACPG,UAAU,IAEX3B,OAAOiH,MAAMjF,KAAKwC,KAAMrC,EAAO6E,GAC/BxC,KAAK0C,WAAY,GAEdlD,EAAShE,OAAOwG,EAAYE,UAAW/C,GAG3C,OAFAwD,cAAcX,GACdxG,OAAOuG,sBAAsBC,EAAaxC,GACnCwC,GAIRvG,KAAO,CAENmH,WAAY,SAASvF,EAAKN,EAAM8F,GAC/B,IAAID,EAAa,CAChBE,cAAU1E,EACVwD,QAASiB,EACTE,MAAO,EACPC,QAAS,SAASC,GACjB,IAAIH,EAAWF,EAAWE,SAC1BF,EAAWE,SAAWG,EAEtB5F,EAAIgF,SAAS,CACZ1B,KAAM5D,EACNuF,OAAQjF,GACN,CAAC4F,EAAQH,MAGd,OAAOF,GAERlB,cAAe,SAAS3E,EAAMkB,EAAYqD,GACzC,IAAI4B,EAAazH,KAAKuD,IAAI2C,aAAa5E,EAAMkB,EAAYqD,GACzD,OAAO,WACN,IACIK,EAAeuB,EAAW1F,KAAKwC,MAC/B4C,EAAanH,KAAKmH,WAFZ5C,KAE4BjD,EAAM,IAAIoG,mBAAmBlF,EAAWjB,MAFpEgD,KAEgF2B,IAQ1F,MAN4B,eAAzBrD,UAAQC,IAAIC,UACd7B,OAAOC,eAAegG,EAAWI,QAAS,OAAQ,CACjDhG,MAAOT,WAAWoC,QAAQV,EAAWjB,OAAOoG,QAAQ,QAAS,mBAIxDR,IAIThB,QAAS,SAAS7E,EAAMiC,EAAKqE,GAE5B,OAAO,WACN,IAECR,EAAYD,EADZjB,EAAe0B,GAAkBA,EAAe7F,KAAKwC,MAqBtD,OAjBC6C,EADiB,IAAf7D,EAAIX,OACO,IAAIiF,YAAYtE,EALpBgB,MAMe,IAAfhB,EAAIX,OACA,IAAIkF,mBAAmBvE,EAP3BgB,KAOqC2B,GAEjC,IAAI6B,gBAAgBxE,EATxBgB,KASkC2B,GAG5CiB,EAAanH,KAAKmH,WAZR5C,KAYwBjD,EAAM8F,GAGZ,eAAzBvE,UAAQC,IAAIC,UACd7B,OAAOC,eAAegG,EAAWI,QAAS,OAAQ,CACjDhG,MAAOT,WAAWoC,QAAQK,GAAKoE,QAAQ,SAAU,mBAK5CR,IAIT3D,IAAK,CACJc,KAAM,SAAShD,GACd,OAAO,SAASkG,GACfjD,KAAKF,MAAM/C,GAAQkG,IAGrBQ,SAAU,SAAS1G,GAClB,OAAO,SAASwE,GACfhF,WAAWmH,SAAU1D,KAAKC,UAAUlD,GAAM6E,QAASL,KAGrDT,OAAQ,SAAS/D,EAAM4G,EAAYC,EAAS7C,GAC3C,OAAO,SAASkC,GACf,GAAIjD,KAAK0C,UACRkB,EAAQpG,KAAKwC,KAAMiD,OAEf,CACJ,IAEKY,EAFDC,EAAUH,EAAWnG,KAAKwC,MAC9B,GAAIiD,IAAWa,EAEdF,EAAQpG,KAAKwC,KAAMiD,GAEnBY,EAAa,CACZE,QAAS,CAAC,CAACpD,KAAM,MAAOqD,IAAKjH,EAAMC,MAAOiG,IAC1CtC,KAAM5D,EACNuF,OAAQtC,MAImB,eAAzB1B,UAAQC,IAAIC,WACdqF,EAAWI,UAAY,CAAE1H,WAAWoC,QAAQqB,MAAQ,KAAMjD,EAAM,aAAckG,EAAQ,OAAQa,IAI/F9D,KAAKqC,SAASwB,EAAY,CAACZ,EAAQa,OAKvCzC,OAAQ,SAAStE,EAAMsE,EAAQsC,EAAYO,EAAWC,GACrD,OAAO,SAASnH,GAEf,IAAIoH,EAGAC,EAAOrE,KAMXsE,OAAOC,MAAMC,QACb,IAAIC,GAAe,EAClBX,EAAUH,EAAWnG,KAAKwC,MAC1B0D,EAAWrC,EAAO7D,KAAKwC,KAAMhD,EAAO,SAASA,GAC5CkH,EAAU1G,KAAK6G,EAAMrH,GAErByH,GAAe,EAEa,eAAzBnG,UAAQC,IAAIC,UACdkG,aAAaN,IAGZN,GAEJ,GAAIW,EACHH,OAAOC,MAAMI,YAEb,GAAIR,EAEH,QAAiB/F,IAAbsF,EAGCI,IAAYJ,GACfQ,EAAU1G,KAAKwC,KAAM0D,GAEtBY,OAAOC,MAAMI,WAIT,CAAA,GAAsB,IAAlBtD,EAAOhD,OAGf,OAFA6F,EAAU1G,KAAKwC,KAAMhD,QACrBsH,OAAOC,MAAMI,OAIT,GAAsB,IAAlBtD,EAAOhD,OAgBf,MAP4B,eAAzBC,UAAQC,IAAIC,WACd4F,EAAaQ,WAAW,WACvBnG,IAAUC,KAAK,uBAAyBnC,WAAWoC,QAAQ0F,GAAM,IAAItH,EAAO,0DAC1E0B,IAAUoG,mBAGdP,OAAOC,MAAMI,OAXbL,OAAOC,MAAMI,YAgBd,QAAiBvG,IAAbsF,EAGHQ,EAAU1G,KAAKwC,KAAM0D,GACrBY,OAAOC,MAAMI,WAIT,CAAA,GAAsB,IAAlBtD,EAAOhD,OAGf,OAFA6F,EAAU1G,KAAKwC,KAAMhD,QACrBsH,OAAOC,MAAMI,OAIT,GAAsB,IAAlBtD,EAAOhD,OAgBf,MAP4B,eAAzBC,UAAQC,IAAIC,WACd4F,EAAaQ,WAAW,WACvBnG,IAAUC,KAAK,8BAAgCnC,WAAWoC,QAAQ0F,GAAM,IAAItH,EAAO,0DACjF0B,IAAUoG,mBAGdP,OAAOC,MAAMI,OAZbT,EAAU1G,KAAKwC,UAAM5B,GACrBkG,OAAOC,MAAMI,UAoBlBhE,KAAM,SAAS5D,EAAM4D,EAAM1B,GAC1B,SAASoC,EAAOyD,GACf,OAAO7F,EAAIzB,KAAKwC,KAAMW,EAAKnD,KAAKwC,KAAM8E,EAAU/H,IAEjD,OAAGd,aAAa0E,GAEZA,EAAKxE,cACAkF,EAEA,SAAgByD,GACtB,OAAO7F,EAAIzB,KAAKwC,KAAMzD,WAAWwI,QAAQD,EAAUnE,KAKlC,iBAATA,EACHlF,KAAKwD,IAAIuC,KAAKzE,EAAM4D,EAAM1B,GAE1BoC,GAGTG,KAAM,SAASzE,EAAMyE,EAAMvC,GAa1B,OAXG+F,MAAMC,QAAQzD,IAAShG,OAAO0J,WAChC1D,EAAOhG,OAAO0J,WAAWC,OAAO,CAC/BC,IAAK5D,EAAK,KAEe,iBAATA,IAEhBA,EADEhG,OAAO6J,UACF7J,OAAO6J,UAAUF,OAAO3D,GAExBhG,OAAO+G,YAAYf,IAGrB,SAASsD,GACf,OAAIA,aAAoBtD,GAAoB,MAAZsD,EACxB7F,EAAIzB,KAAKwC,KAAM8E,GAEf7F,EAAIzB,KAAKwC,KAAM,IAAIwB,EAAKsD,OAMnC/D,UAAW,CACVhB,KAAM,SAAShD,GACd,OAAO,SAASkG,EAAQqC,GACvB,YAAkBlH,IAAXkH,GAAwBtF,KAAKF,MAAMvC,eAAeR,GAAQ,MAAQ,QAG3E0G,SAAU,WACT,OAAO,WACN,MAAO,SAKVtC,KAAM,CACLpB,KAAM,SAAShD,GACd,OAAO,WACN,OAAOiD,KAAKF,MAAM/C,KAGpB0G,SAAU,SAAS1G,GAElB,OAAO,WACN,OAAOR,WAAWC,SAAUwD,KAAKC,UAAUlD,GAAM6E,WAGnDC,QAAS,SAAS9E,GACjB,OAAO,WACN,IAAI8F,EAAa7C,KAAKC,UAAUlD,GAAM6E,QACtC,GAAGiB,EAAW0C,aACb,OAAOhJ,WAAWC,SAASqG,EAAW0C,iBAM1CvG,IAAK,CAEJ2C,aAAc,SAAS5E,EAAMkB,EAAYqD,EAAakE,GACrD,OAAO,WACN,IAAIxI,EAAQiB,EAAWW,QACvB,QAAcR,IAAVpB,EACkB,mBAAVA,IACVA,EAAQA,EAAMQ,KAAKwC,OAEpBhD,EAAQsE,EAAY9D,KAAKwC,KAAMhD,OAE3B,CACJ,IAAI8B,EAAUb,EAAWa,QACrBA,IACH9B,EAAQsE,EAAY9D,KAAKwC,KAAK,IAAIlB,IAGpC,GAAGb,EAAWgB,IAAK,CAIlB,IAAIwG,EACAC,GAAO,EAcX,OAZajK,KAAKwD,IAAIoC,OAAOtE,EAAMkB,EAAWgB,IAAK,aAAc,SAASjC,GACtE0I,EACFD,EAAQzI,EAERwI,EAAWhI,KAAKwC,KAAMhD,IAErBiB,EAAWe,KAEPxB,KAAKwC,KAAKhD,GACjB0I,GAAM,EAGCD,EAIR,OAAOzI,IAGT+C,KAAM,SAAShD,GACd,OAAO,WAKN,OAJKiD,KAAK0C,WACTrG,oBAAoBsJ,IAAI3F,KAAMjD,GAGxBiD,KAAKF,MAAM/C,KAGpB0G,SAAU,SAAS1G,GAClB,OAAO,SAASwE,GACf,IAAIK,EAAU5B,KAAKC,UAAUlD,GAAM6E,QAQnC,OAPIvF,oBAAoBuJ,gBACvBvJ,oBAAoBsJ,IAAI3F,KAAMjD,GACzBR,WAAWsJ,QAAQjE,IACvB0B,YAAYwC,gBAAgBlE,IAIvBxF,KAAKwF,OAMhBpG,OAAOuK,UAAY,CAAC,MAAO,MAAO,QAAS,QAAS,OAAQ,OAAQ,aAGpE,IAAIC,wBAA0B,SAAS/H,EAAYgI,EAAUjJ,GAC5D,GAAgB,eAAbiJ,EAEFhI,EAAW6D,YAAc9E,OAErB,GAAgB,SAAbiJ,EAAqB,CAC5B,IAAIC,EAAclJ,EACQ,iBAAhBkJ,IAEiB,iBAD1BA,EAAc1K,OAAOqF,MAAMqF,KACYjK,aAAaiK,KACnDC,OAAOlI,EAAYiI,GACnBA,EAAcA,EAAYD,UAGD,IAAhBC,IACVjI,EAAWgI,GAAYC,QAIxBjI,EAAWgI,GAAYjJ,GAgJzB,SAASoJ,cAAcC,EAAUC,GAChC,IAAIC,EAAkBF,EAASpG,WAAaoG,EAASpG,UAAUqG,GAC3DC,GAAmBA,EAAgB3E,UACjC2E,EAAgBxD,MAKpBwD,EAAgBxD,SAJhBwD,EAAgBxD,MAAQ,EACxBxG,WAAWiK,QAAQD,EAAgB3E,QAAS2E,EAAgBvD,QAAS,UACrEuD,EAAgBzD,SAAWvG,WAAWC,SAAS+J,EAAgB3E,WAOlE,SAAS6E,iBAAiBJ,EAAUC,GACnC,IAAIC,EAAkBF,EAASpG,WAAaoG,EAASpG,UAAUqG,GAC3DC,IAC2B,IAA1BA,EAAgBxD,OACnBwD,EAAgBxD,MAAQ,EACxBxG,WAAWmK,SAASH,EAAgB3E,QAAS2E,EAAgBvD,QAAQ,WAErEuD,EAAgBxD,SA7JnBrH,eAAiB,SAASqB,EAAM4J,EAAK/G,EAAmBzB,GACvD,IAAIF,EAAa,GAejB,GAbA1B,WAAWkD,QAAQkH,EAAK,SAAS3J,EAAOiJ,GACvCD,wBAAwB/H,EAAYgI,EAAUjJ,KAG/CT,WAAWkD,QAAQG,EAAmB,SAAS5C,EAAOD,QAC7BqB,IAArBH,EAAWlB,IACD,SAATA,GAA4B,SAATA,IACrBkB,EAAWlB,GAAQC,KAMnB2J,EAAInF,KAAM,CACZ,IAAIxE,EAAQ2J,EAAInF,KAEZM,EAAY9E,EAAMhB,iBACnB8F,IACF7D,EAAW6D,UAAY,SAASP,GAC/B,OAAOO,EAAUtE,KAAK+D,KAGrBvE,EAAMnB,aACRoC,EAAW0C,KAAO3D,EAAMnB,kBACjBoC,EAAWuD,MAMpB,GAAuB,iBAAbmF,EAAIhG,KAAmB,CAEhC,IAAI1C,EAAW0C,OAAS1C,EAAWuD,KAAM,CAC/B,IAAIoF,EAAerK,WAAWsK,UAAU,GAAGjH,GAC3C3B,EAAa1B,WAAWsK,UAAUD,EAAc3I,GAGtB,IAAhC1B,WAAWuK,KAAK7I,KACnBA,EAAW0C,KAAOnF,OAAOqF,MAAM,MAIjC,OADA7C,kBAAkBjB,EAAMkB,GAAY,EAAME,GACnCF,GAORrC,sBAAwB,SAASmB,EAAMC,EAAO4C,EAAmBzB,GAEhE,IAAIF,EAmBJ,MAlBoB,iBAAVjB,EACTiB,EAAa,CAAC0C,KAAM3D,GAGbA,IAAUA,EAAMhB,kBAAoBgB,EAAMnB,YACjDoC,EAAa,CAAEuD,KAAMxE,GAEG,mBAAVA,EACXT,WAAWqE,kBAAkB5D,KAC/BiB,EAAa,CAACuD,KAAMxE,IAGXgI,MAAMC,QAAQjI,GACxBiB,EAAa,CAACuD,KAAMxE,GACVT,WAAWwK,cAAc/J,KACnCiB,EAAajB,GAGXiB,EACKvC,eAAeqB,EAAMkB,EAAY2B,EAAmBzB,GAGpDnB,GAITrB,yBAA2B,SAASwD,EAAS6H,EAAa7I,GAEzD,IAICyB,EAJGF,EAAc/C,OAAO2C,OAAO0H,EAAcA,EAAYtH,YAAc,MACpE0C,EAAU,GAEV6E,EAAW9H,EAAQ,KA8CvB,OA5CG8H,UACK9H,EAAQ,KACfS,EAAoBhE,sBAAsB,IAAKqL,EAAU,KAEzDrH,EAAoBjD,OAAO2C,OAAO,MAGnClC,uBAAuB+B,EAAS,SAAUpC,EAAMmK,GAE/C,IAAIlK,EAOJ,GALCA,EADEkK,EAAmBlI,KAAOkI,EAAmBjI,IACvC,CAACD,IAAKkI,EAAmBlI,IAAKC,IAAKiI,EAAmBjI,KAEtDiI,EAAmBlK,MAGhB,gBAATD,EAAH,CAIC,IAAIyC,EAAS5D,sBAAsBmB,EAAMC,EAAO4C,EAAmBzB,GAChEqB,GAA4B,iBAAXA,GAAuBjD,WAAWuK,KAAKtH,GAAU,EACpEE,EAAY3C,GAAQyC,EAIE,mBAAXA,EACV4C,EAAQrF,GAAQyC,OAGU,IAAXA,GACa,eAAzBlB,UAAQC,IAAIC,UAEdC,IAAU0I,MAAM5K,WAAWoC,QAAQR,GAAe,IAAIpB,EAAO,oHAhBhEqF,EAAQrF,GAAQC,IAuBfiK,GAEFpK,mCAAmCsC,EAAQ,IAAK8H,GAE1C,CAACvH,YAAaA,EAAa0C,QAASA,EAASxC,kBAAmBA,IAGxErE,YAAc6L,iBAAW,IA2BzB,IAAIC,cAAgBvL,UAAUC,IAAI,YAClCoK,OAAO5K,YAAa,CACnB+L,YAAa,aACbC,eAAgB,aAChBC,iBAAkB,SAASlB,EAAWtD,EAASyE,GAE9C,OADArB,cAAcpG,KAAMsG,GACbc,iBAAWI,iBAAiB/G,MAAMT,KAAMU,YAOhDgH,oBAAqB,SAASpB,EAAWtD,GAExC,OADAyD,iBAAiBzG,KAAMsG,GAChBc,iBAAWM,oBAAoBjH,MAAMT,KAAMU,cAIpDnF,YAAYoM,GAAKpM,YAAYkB,KAAOlB,YAAYiM,iBAChDjM,YAAYqM,IAAMrM,YAAYsM,OAAStM,YAAYmM,oBAGnD,IAAII,iBAAmBhM,UAAUC,IAAI,kBACjCgM,kBAAoBjM,UAAUC,IAAI,mBAEtCQ,WAAWyL,cAAczM,YAAY,CACpC0M,iBAAkB,SAASjE,GAE1B,OADAoC,cAAcpG,KAAMgE,GACboD,iBAAWU,kBAAkBrH,MAAMT,KAAMU,YAEjDwH,kBAAmB,SAASlE,GAE3B,OADAyC,iBAAiBzG,KAAMgE,GAChBoD,iBAAWW,mBAAmBtH,MAAMT,KAAMU,qBAI5CnF,YAAY4M,IAEnB3M,OAAOiH,MAAQ,SAAS9E,EAAO6E,GAC9B7F,OAAOC,eAAeoD,KAAK,cAAe,CAAChD,MAAOgD,KAAKgC,YAAa9E,YAAY,EAAOC,UAAU,IACjGR,OAAOC,eAAeoD,KAAKqH,cAAe,CAACrK,MAAOL,OAAO2C,OAAO,MAAOpC,YAAY,EAAOC,UAAU,IAIpG,IAAIuC,EAAcM,KAAKmC,QAAQzC,YAC3B0I,EAAsBzL,OAAO2C,OAAO,MACpCjC,EAAM2C,KACVzD,WAAWkD,QAAQ9B,EAAO,SAASX,EAAOD,QAChBqB,IAAtBsB,EAAY3C,GACdM,EAAIN,GAAQC,EAEZxB,OAAO6M,QAAQhL,EAAKN,EAAMC,KAGzBT,WAAWuK,KAAKsB,GAAuB,GACzCvL,mCAAmCmD,KAAM,uBAAwBoI,GAItC,eAAzB9J,UAAQC,IAAIC,WACdwB,KAAKF,MACLE,KAAKC,WACS,IAAXuC,GACF7F,OAAO2L,KAAKtI,QAOf,IAAIuI,eAAiB,SAASC,GAC7B,OAAOA,GAGRhN,OAAO6M,QAAU,SAAShL,EAAKN,EAAMC,GACpC,GAAGxB,OAAOiN,aAAa1L,GAEtB,OAAO,EAGR,IAAI2L,EAAqBrL,EAAI8E,QAAQzC,YACrC,IAAGgJ,IAAsBA,EAAmB3L,GAA5C,CAIA,IAAI4L,EAAkBtL,EAAIuL,qBAC1B,IAAID,EAAiB,CACpB,GAAGhM,OAAOkM,SAASxL,GAClB,OAEDV,OAAOC,eAAeS,EAAK,uBAAwB,CAClDJ,cAAc,EACdC,YAAY,EACZC,UAAU,EACVH,MAAO,KAER2L,EAAkBtL,EAAIuL,qBAEvB,IAAID,EAAgB5L,GAAO,CAC1B,IAAI6C,EAAoBvC,EAAI8E,QAAQvC,mBAAqB,CAACe,KAAMnF,OAAOqF,MAAMgC,YAyB7E,OAxBArH,OAAOmE,SAAStC,EAAKN,EAAM6C,EAAmB,GAAG,IAE9CA,EAAkBe,KACpBtD,EAAIyC,MAAM/C,GAAQvB,OAAOC,KAAKwD,IAAI0B,KAAK5D,EAAM6C,EAAkBe,KAAM4H,gBAAgB/K,KAAKH,EAAKL,GAE/FK,EAAIyC,MAAM/C,GAAQvB,OAAOqF,MAAMgC,WAAW7F,GAG3C2L,EAAgB5L,GAAQ6C,EACpBvC,EAAIqF,YACP4B,OAAOC,MAAMC,QACbnH,EAAIgF,SAAS,CACZ1B,KAAM,WACN2B,OAAQjF,SAEce,IAApBf,EAAIyC,MAAM/C,IACZM,EAAIgF,SAAS,CACZ1B,KAAM5D,EACNuF,OAAQjF,EACR0G,QAAS,CAAC,CAACpD,KAAM,MAAOqD,IAAKjH,EAAMC,MAAOK,EAAIyC,MAAM/C,MACnD,CAACM,EAAIyC,MAAM/C,QAAOqB,IAErBkG,OAAOC,MAAMI,SAEP,KAGTnJ,OAAOsN,YAAcjJ,gBACrBrE,OAAOD,YAAcA,YACrBC,OAAOqB,mCAAqCA,mCAC5CrB,OAAOC,KAAOA,KACdD,OAAOI,sBAAwBA,sBAC/BJ,OAAOiN,aAAe,CAAC3I,OAAO,EAAMG,WAAW,GAC/C,IAAI8I,oBAAsB,GAyD1B,SAASC,kBAAkBlM,GAC1B,OAAOP,WAAW0M,YAAYnM,IAAQP,WAAW2M,iBAAiBpM,GAzDnEtB,OAAO2N,uBAAyB,SAASpM,GACxC,QAAiCqB,IAA9B2K,oBAAoBhM,GAAqB,CAE3C,IAAIsE,EAAS5F,KAAKwD,IAAI6B,OAAO/D,EAAMtB,KAAKuD,IAAIe,KAAKhD,GAAOtB,KAAKwD,IAAIc,KAAKhD,GAAOtB,KAAKsF,UAAUhB,KAAKhD,IAEjGgM,oBAAoBhM,GAAQ,CAC3BiC,IAAKvD,KAAKuD,IAAIe,KAAKhD,GACnBkC,IAAK,SAASgE,GACb,OAAO5B,EAAO7D,KAAKwC,KAAMxE,OAAOqF,MAAMgC,WAAWI,KAElD/F,YAAY,EACHD,cAAc,GAGzB,OAAO8L,oBAAoBhM,IAG5BvB,OAAO6E,SAAW,SAASvD,GAC1BkD,KAAKlD,IAAMA,EACXkD,KAAKN,YAAc/C,OAAOyM,KAAKtM,EAAIqF,QAAQzC,aAC3CM,KAAKoI,oBAAsBtL,EAAI8L,qBAC9BjM,OAAOyM,KAAKtM,EAAI8L,sBAChBjM,OAAOyM,KAAKtM,GACbkD,KAAKqJ,OAA4B,mBAAZvM,EAAIkC,KAG1BxD,OAAO6E,SAAS6B,UAAUoH,KAAO,WAChC,IAAItF,EACJ,GAAGhE,KAAKN,YAAYrB,OAAQ,CAK3B,GAJA2F,EAAMhE,KAAKN,YAAY6J,QAGbvJ,KAAKlD,IAAIqF,QAAQzC,YAAYsE,GAChChF,IACN,OAAOgB,KAAKsJ,WAEP,CAAA,IAAGtJ,KAAKoI,oBAAoB/J,OAGlC,MAAO,CACNrB,WAAOoB,EACPoL,MAAM,GAJPxF,EAAMhE,KAAKoI,oBAAoBmB,QAQhC,MAAO,CACNvM,MAAO,CACNgH,EACAhE,KAAKqJ,OAASrJ,KAAKlD,IAAIkC,IAAIgF,GAAOhE,KAAKlD,IAAIkH,IAE5CwF,MAAM,IAURhO,OAAOqF,MAAQ,CAEd4I,KAAQC,UACRC,OAAUC,YACVC,QAAWC,aACXjH,WAAc,SAASI,GAOrB,OANG+B,MAAMC,QAAQhC,IAAWzH,OAAO0J,WACjCjC,EAAS,IAAIzH,OAAO0J,WAAWjC,GAEzB1G,WAAWwK,cAAc9D,IAAYzH,OAAO6J,YAClDpC,EAAS,IAAIzH,OAAO6J,UAAUpC,IAEzBA,GAET8G,mBAAsB,SAAS9G,GAC9B,OAAG+B,MAAMC,QAAQhC,GACT,IAAIzH,OAAOwO,YAAY/G,GAEvB1G,WAAWwK,cAAc9D,GACzB,IAAIzH,OAAOyO,WAAWhH,GAGtB1G,WAAWwI,QAAS9B,EAAQzH,OAAOqF,MAAMqJ,SAOlDC,SAAY,SAAS5I,GACpB,MAAY,KAARA,KAGK6I,YAAY7I,IAEtB8I,IAAK,SAAS9I,GACb,OAAOA,GAER+I,IAAO,SAAS/I,GACf,OAAOA,GAER2I,OAAUK,YAEV3I,QAAW,CACV3C,IAAK,SAAS6F,EAAU0F,EAAQC,EAAQ3H,GACvC,OAAIkG,kBAAkBlE,GACdA,EAEJkE,kBAAkBlG,IACrBvG,WAAWmH,SAASZ,EAASgC,GACtBhC,GAEDgC,GAER9F,IAAK,SAAShC,GACb,OAAOgM,kBAAkBhM,GAAST,WAAWC,SAASQ,GAASA,KAKlExB,OAAOkP,iBAAmB,SAASC,EAAQjL,GAC1C,IAAI,IAAI3C,KAAQ2C,EAAa,CAC5B,IAAIzB,EAAayB,EAAY3C,IACD,IAAzBkB,EAAW6D,YACV7D,EAAW0C,KACbgK,EAAOvB,KAAKrM,GAAQkB,EAAW0C,KAE/BgK,EAAOvB,KAAKrM,GAAQ,SAASwE,GAAM,OAAOA,IAGT,IAA/B7B,EAAY3C,GAAM6N,UACpBD,EAAOC,SAASC,KAAK9N,IAIxB,OAAO4N"}