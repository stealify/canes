{"version":3,"file":"chunk-54c27a9a.js","sources":["../node_modules/can-connect/behavior.js","../node_modules/can-connect/base/base.js"],"sourcesContent":["\"use strict\";\nvar behaviorsMap = {};\n\nfunction behavior(name, behavior){\n\tif(typeof name !== \"string\") {\n\t\tbehavior = name;\n\t\tname = undefined;\n\t}\n\tvar behaviorMixin = function(base){\n\t\t// basically Object.create\n\t\tvar Behavior = function(){};\n\t\tObject.defineProperty(Behavior,\"name\",{\n\t\t\tvalue: name,\n\t\t\tconfigurable: true\n\t\t});\n\t\tBehavior.prototype = base;\n\t\tvar newBehavior = new Behavior();\n\t\t// allows behaviors to be a simple object, not always a function\n\t\tvar res = typeof behavior === \"function\" ? behavior.apply(newBehavior, arguments) : behavior;\n\t\tfor(var prop in res) {\n\t\t\tif(res.hasOwnProperty(prop)) {\n\t\t\t\tObject.defineProperty(newBehavior, prop, Object.getOwnPropertyDescriptor(res, prop));\n\t\t\t} else {\n\t\t\t\t// we only copy values from up the proto chain\n\t\t\t\tnewBehavior[prop] = res[prop];\n\t\t\t}\n\t\t}\n\t\tnewBehavior.__behaviorName = name;\n\t\treturn newBehavior;\n\t};\n\tif(name) {\n\t\tbehaviorMixin.behaviorName = name;\n\t\tbehaviorsMap[name] = behaviorMixin;\n\t}\n\tbehaviorMixin.isBehavior = true;\n\treturn behaviorMixin;\n}\nbehavior.map = behaviorsMap;\nmodule.exports = behavior;\n","\"use strict\";\nvar behavior = require(\"../behavior\");\nvar canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\n/**\n * @module can-connect/base/base base\n * @group can-connect/base/base.options 0 behavior options\n * @group can-connect/base/base.identifiers 1 identifiers\n * @parent can-connect.behaviors\n *\n * The first behavior added to every `can-connect` connection. Provides methods to uniquely identify instances and\n * lists.\n *\n * @signature `base(connectionOptions)`\n *\n * Provides instance and list identifiers. Added automatically to every connection created by the `connect` helper.\n * So even if we do:\n *\n * ```js\n * var connection = connect([],{});\n * ```\n *\n * The connection still has the identification functionality provided by `base`:\n *\n * ```js\n * connection.id({id: 1, ...}) //-> 1\n * ```\n *\n * `can-connect` connections are typically created by the `connect` helper rather than by calling the behaviors directly.\n * This ensures the behaviors are called in the required order and is more elegant than requiring the user to chain\n * together the calls to all the behaviors.\n *\n * See the [can-connect/base/base.id id] and [can-connect/base/base.listQuery listQuery] methods for more specifics on\n * how ids are determined.\n *\n * @param {Object} connectionOptions Object containing the configuration for the behaviors of the connection. Added to the\n * prototype of the returned connection object. `base` is almost always configured with an [can-connect/base/base.queryLogic] option since it\n * [can-connect/base/base.id defines how to read the identity properties] and the majority of behaviors also require the queryLogic.\n *\n * @return {Object} A `can-connect` connection containing the methods provided by `base`.\n */\nmodule.exports = behavior(\"base\",function(baseConnection){\n\tvar setQueryLogic;\n\treturn {\n\t\t/**\n\t\t * @function can-connect/base/base.id id\n\t\t * @parent can-connect/base/base.identifiers\n\t\t *\n\t\t * Uniquely identify an instance or raw instance data.\n\t\t *\n\t\t * @signature `connection.id(instance)`\n\t\t *\n\t\t *   Returns the instance id as determined by [can-connect/base/base.queryLogic]'s id values.\n\t\t *\n\t\t *   @param {Instance|Object} instance An instance or raw properties for an instance.\n\t\t *\n\t\t *   @return {String|Number} A string or number uniquely representing `instance`.\n\t\t *\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * Many behaviors, such as the [can-connect/constructor/store/store], need to have a unique identifier for an\n\t\t * instance or instance data.  This `connection.id` method should return that.\n\t\t *\n\t\t * Typically, an item's id is a simply property value on the object. For example, \"Todo\" data might look like:\n\t\t *\n\t\t * ```js\n\t\t * {_id: 5, name: \"do the dishes\"}\n\t\t * ```\n\t\t *\n\t\t * In this case, [can-connect/base/base.queryLogic]'s `id` property should be set to \"_id\":\n\t\t *\n\t\t * ```js\n\t\t * import QueryLogic from \"can-query-logic\";\n\t\t *\n\t\t * var queryLogic = new QueryLogic({\n\t\t *   identity: [\"_id\"]\n\t \t * });\n\t\t *\n\t\t * connect([...],{queryLogic: queryLogic});\n\t\t * ```\n\t\t *\n\t\t */\n\t\tid: function(instance){\n\t\t\tif(this.queryLogic) {\n\t\t\t\treturn canReflect.getIdentity(instance, this.queryLogic.schema);\n\t\t\t} else if(this.idProp) {\n\t\t\t\treturn instance[this.idProp];\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"can-connect/base/base - Please add a queryLogic option.\")\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/base/base.listQuery listQuery\n\t\t * @parent can-connect/base/base.identifiers\n\t\t *\n\t\t * Uniquely identify the set of data a list contains.\n\t\t *\n\t\t * @signature `connection.listQuery(list)`\n\t\t *\n\t\t *   Returns the value of the property referenced by [can-connect/base/base.listQueryProp] if it exists.\n\t\t *   By default, this will return `list[Symbol.for(\"can.listQuery\")]`.\n\t\t *\n\t\t *   @param {can-connect.List} list A list instance.\n\t\t *\n\t\t *   @return {can-query-logic/query} An object that can be passed to `JSON.stringify` to represent the list.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * Many behaviors, such as the [can-connect/constructor/store/store], need to have a unique identifier for a list.\n\t\t * This `connection.listQuery` method should return that.\n\t\t *\n\t\t * Typically, a list's set identifier is a property on the list object.  As example, a list of Todos might look like\n\t\t * the following:\n\t\t *\n\t\t * ```js\n\t\t * var dueTodos = todoConnection.getList({filter: {due: \"today\"}});\n\t\t * dueTodos; // [{_id: 5, name: \"do dishes\", due:\"today\"}, {_id: 6, name: \"walk dog\", due:\"today\"}, ...]\n\t\t * dueTodos[Symbol.for(\"can.listQuery\")]; //-> {filter: {due: \"today\"}}\n\t\t * todoConnection.listQuery(dueTodos); //-> {filter: {due: \"today\"}}\n\t\t * ```\n\t\t *\n\t\t * In the above example the [can-connect/base/base.listQueryProp] would be the default `@can.listQuery`.\n\t\t */\n\t\tlistQuery: function(list){\n\t\t\treturn list[this.listQueryProp];\n\t\t},\n\n\t\t/**\n\t\t * @property {Symbol} can-connect/base/base.listQueryProp listQueryProp\n\t\t * @parent can-connect/base/base.identifiers\n\t\t *\n\t\t * Specifies the property that uniquely identifies a list.\n\t\t *\n\t\t * @option {Symbol} The property that uniquely identifies the list.\n\t\t * Defaults to `Symbol.for(\"can.listQuery\")`.\n\t\t *\n\t\t * ```js\n\t\t * var dataUrl = require(\"can-connect/data/url/\");\n\t\t * var connection = connect([dataUrl], {\n\t\t *   listQueryProp: \"set\"\n\t\t * });\n\t\t *\n\t\t * var list = [{id: 1, ...}, {id: 2, ...}]\n\t\t * list.set = {complete: true};\n\t\t *\n\t\t * connection.listQuery(list) //-> {complete: true}\n\t\t * ```\n\t\t *\n\t\t */\n\t\tlistQueryProp: canSymbol.for(\"can.listQuery\"),\n\n\t\tinit: function(){},\n\n\n\t\t/**\n\t\t * @property {can-query-logic} can-connect/base/base.queryLogic queryLogic\n\t\t * @parent can-connect/base/base.options\n\t\t *\n\t\t * Configuration for list comparison, instance identification and membership\n\t\t * calculations. A way for the `can-connect` behaviors to understand what the properties of a request mean and act\n\t\t * on them.\n\t\t *\n\t\t * @option {can-query-logic} A [can-query-logic queryLogic] that is used to perform calculations using set\n\t\t * definition objects passed to [can-connect/connection.getListData] and [can-connect/connection.getList].\n\t\t * Needed to enable [can-connect/fall-through-cache/fall-through-cache caching],\n\t\t * [can-connect/data/combine-requests/combine-requests request combining], [can-connect/real-time/real-time] and other\n\t\t * behaviors. By default no queryLogic is provided.\n\t\t *\n\t\t * An example of the types of calculations behaviors will make using the queryLogic:\n\t\t * ```js\n\t\t * var queryLogic = new QueryLogic({\n\t\t *   identity: ['_uid'],\n\t\t *   keys: {\n\t\t *     _uid: Number\n\t\t *   }\n\t\t * });\n\t\t *\n\t\t * var todoConnection = connect([...behaviors...],{\n\t\t *   queryLogic: queryLogic\n\t\t * });\n\t\t *\n\t\t * todoConnection.queryLogic.memberIdentity({_uid: 5, ...}); //-> 5\n\t\t * todoConnection.id({_uid: 5, ...}); //-> 5\n\t\t * todoConnection.queryLogic.intersection(\n\t\t *   {page: {first: 0, last: 10}},\n\t\t *   {page: {first:  d5, last: 20}}); //-> {first:5, last:10}\n\t\t * ```\n\t\t */\n\n\t\tget queryLogic(){\n\t\t\tif(setQueryLogic) {\n\t\t\t\treturn setQueryLogic;\n\t\t\t} else if(baseConnection.queryLogic) {\n\t\t\t\treturn baseConnection.queryLogic;\n\t\t\t} else if(baseConnection.algebra) {\n\t\t\t\treturn baseConnection.algebra;\n\t\t\t}\n\t\t},\n\t\tset queryLogic(newVal) {\n\t\t\tsetQueryLogic = newVal;\n\t\t}\n\n\t\t/**\n\t\t * @property {can-query-logic} can-connect/base/base.algebra algebra\n\t\t * @parent can-connect/base/base.options\n\t\t *\n\t\t * @description Legacy configuration for [can-set-legacy]. Use [can-connect/base/base.queryLogic] instead.\n\t\t */\n\n\t\t/**\n\t\t * @property {can-connect/DataInterface} can-connect/base/base.cacheConnection cacheConnection\n\t\t * @parent can-connect/base/base.options\n\t\t *\n\t\t * An underlying `can-connect` connection used when fetching data from a cache.\n\t\t *\n\t\t * @option {can-connect/DataInterface} A connection that provides access to a cache via [can-connect/DataInterface]\n\t\t * requests. Several behaviors including [can-connect/fall-through-cache/fall-through-cache] expect this property.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * ```js\n\t\t * import {memoryStore, connect, QueryLogic} from \"can\";\n\t\t *\n\t\t * var cacheConnection = memoryStore({\n\t\t *   queryLogic: new QueryLogic({identity: [\"id\"]})\n\t\t * });\n\t\t *\n\t\t * var todoConnection = connect([...behaviors...],{\n\t\t *   cacheConnection: cacheConnection\n\t\t * });\n\t\t * ```\n\t\t */\n\t};\n});\n"],"names":["behaviorsMap","behavior","name","undefined","behaviorMixin","base","Behavior","Object","defineProperty","value","configurable","prototype","newBehavior","res","apply","arguments","prop","hasOwnProperty","getOwnPropertyDescriptor","__behaviorName","behaviorName","isBehavior","map","baseConnection","setQueryLogic","id","instance","this","queryLogic","canReflect","getIdentity","schema","idProp","Error","listQuery","list","listQueryProp","canSymbol","for","init","algebra","newVal"],"mappings":"6HACA,IAAIA,aAAe,GAEnB,SAASC,SAASC,EAAMD,GACJ,iBAATC,IACTD,EAAWC,EACXA,OAAOC,GAER,IAAIC,EAAgB,SAASC,GAE5B,IAAIC,EAAW,aACfC,OAAOC,eAAeF,EAAS,OAAO,CACrCG,MAAOP,EACPQ,cAAc,IAEfJ,EAASK,UAAYN,EACrB,IAAIO,EAAc,IAAIN,EAElBO,EAA0B,mBAAbZ,EAA0BA,EAASa,MAAMF,EAAaG,WAAad,EACpF,IAAI,IAAIe,KAAQH,EACZA,EAAII,eAAeD,GACrBT,OAAOC,eAAeI,EAAaI,EAAMT,OAAOW,yBAAyBL,EAAKG,IAG9EJ,EAAYI,GAAQH,EAAIG,GAI1B,OADAJ,EAAYO,eAAiBjB,EACtBU,GAOR,OALGV,IACFE,EAAcgB,aAAelB,EAC7BF,aAAaE,GAAQE,GAEtBA,EAAciB,YAAa,EACpBjB,EAERH,SAASqB,IAAMtB,aACf,eAAiBC,cCGAA,WAAS,OAAO,SAASsB,GACzC,IAAIC,EACJ,MAAO,CA0CNC,GAAI,SAASC,GACZ,GAAGC,KAAKC,WACP,OAAOC,WAAWC,YAAYJ,EAAUC,KAAKC,WAAWG,QAClD,GAAGJ,KAAKK,OACd,OAAON,EAASC,KAAKK,QAErB,MAAM,IAAIC,MAAM,4DAsClBC,UAAW,SAASC,GACnB,OAAOA,EAAKR,KAAKS,gBAyBlBA,cAAeC,UAAUC,IAAI,iBAE7BC,KAAM,aAsCNX,iBACC,OAAGJ,IAEOD,EAAeK,WACjBL,EAAeK,WACbL,EAAeiB,QACjBjB,EAAeiB,aADhB,IAIRZ,eAAea,GACdjB,EAAgBiB"}