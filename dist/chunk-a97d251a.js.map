{"version":3,"file":"chunk-a97d251a.js","sources":["../node_modules/can-construct/can-construct.js"],"sourcesContent":["\"use strict\";\nvar canReflect = require(\"can-reflect\");\nvar dev = require(\"can-log/dev/dev\");\nvar namespace = require('can-namespace');\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\tvar CanString = require('can-string');\n\tvar reservedWords = {\n\t\t\"abstract\": true,\n\t\t\"boolean\": true,\n\t\t\"break\": true,\n\t\t\"byte\": true,\n\t\t\"case\": true,\n\t\t\"catch\": true,\n\t\t\"char\": true,\n\t\t\"class\": true,\n\t\t\"const\": true,\n\t\t\"continue\": true,\n\t\t\"debugger\": true,\n\t\t\"default\": true,\n\t\t\"delete\": true,\n\t\t\"do\": true,\n\t\t\"double\": true,\n\t\t\"else\": true,\n\t\t\"enum\": true,\n\t\t\"export\": true,\n\t\t\"extends\": true,\n\t\t\"false\": true,\n\t\t\"final\": true,\n\t\t\"finally\": true,\n\t\t\"float\": true,\n\t\t\"for\": true,\n\t\t\"function\": true,\n\t\t\"goto\": true,\n\t\t\"if\": true,\n\t\t\"implements\": true,\n\t\t\"import\": true,\n\t\t\"in\": true,\n\t\t\"instanceof\": true,\n\t\t\"int\": true,\n\t\t\"interface\": true,\n\t\t\"let\": true,\n\t\t\"long\": true,\n\t\t\"native\": true,\n\t\t\"new\": true,\n\t\t\"null\": true,\n\t\t\"package\": true,\n\t\t\"private\": true,\n\t\t\"protected\": true,\n\t\t\"public\": true,\n\t\t\"return\": true,\n\t\t\"short\": true,\n\t\t\"static\": true,\n\t\t\"super\": true,\n\t\t\"switch\": true,\n\t\t\"synchronized\": true,\n\t\t\"this\": true,\n\t\t\"throw\": true,\n\t\t\"throws\": true,\n\t\t\"transient\": true,\n\t\t\"true\": true,\n\t\t\"try\": true,\n\t\t\"typeof\": true,\n\t\t\"var\": true,\n\t\t\"void\": true,\n\t\t\"volatile\": true,\n\t\t\"while\": true,\n\t\t\"with\": true\n\t};\n\tvar constructorNameRegex = /[^A-Z0-9_]/gi;\n}\n//!steal-remove-end\n\n// ## construct.js\n// `Construct`\n// _This is a modified version of\n// [John Resig's class](http://ejohn.org/blog/simple-javascript-inheritance/).\n// It provides class level inheritance and callbacks._\n// A private flag used to initialize a new class instance without\n// initializing it's bindings.\nvar initializing = 0;\n\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\tvar namedCtor = (function(cache){\n\t\treturn function(name, fn) {\n\t\t\treturn ((name in cache) ? cache[name] : cache[name] = new Function(\n\t\t\t\t\"__\", \"function \"+name+\"(){return __.apply(this,arguments)};return \"+name\n\t\t\t))( fn );\n\t\t};\n\t}({}));\n}\n//!steal-remove-end\n\n/**\n * @add can-construct\n */\nvar Construct = function () {\n\tif (arguments.length) {\n\t\treturn Construct.extend.apply(Construct, arguments);\n\t}\n};\n\nvar canGetDescriptor;\ntry {\n\tObject.getOwnPropertyDescriptor({});\n\tcanGetDescriptor = true;\n} catch(e) {\n\tcanGetDescriptor = false;\n}\n\nvar getDescriptor = function(newProps, name) {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(newProps, name);\n\t\tif(descriptor && (descriptor.get || descriptor.set)) {\n\t\t\treturn descriptor;\n\t\t}\n\t\treturn null;\n\t},\n\tinheritGetterSetter = function(newProps, oldProps, addTo) {\n\t\taddTo = addTo || newProps;\n\t\tvar descriptor;\n\n\t\tfor (var name in newProps) {\n\t\t\tif( (descriptor = getDescriptor(newProps, name)) ) {\n\t\t\t\tthis._defineProperty(addTo, oldProps, name, descriptor);\n\t\t\t} else {\n\t\t\t\tConstruct._overwrite(addTo, oldProps, name, newProps[name]);\n\t\t\t}\n\t\t}\n\t},\n\tsimpleInherit = function (newProps, oldProps, addTo) {\n\t\taddTo = addTo || newProps;\n\n\t\tfor (var name in newProps) {\n\t\t\tConstruct._overwrite(addTo, oldProps, name, newProps[name]);\n\t\t}\n\t},\n\tdefineNonEnumerable = function(obj, prop, value) {\n\t\tObject.defineProperty(obj, prop, {\n\t\t\tconfigurable: true,\n\t\t\twritable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value\n\t\t});\n\t};\n/**\n * @static\n */\ncanReflect.assignMap(Construct, {\n\t/**\n\t * @property {Boolean} can-construct.constructorExtends constructorExtends\n\t * @parent can-construct.static\n\t *\n\t * @description\n\t * Toggles the behavior of a constructor function called\n\t * without the `new` keyword to extend the constructor function or\n\t * create a new instance.\n\t *\n\t * ```js\n\t * var animal = Animal();\n\t * // vs\n\t * var animal = new Animal();\n\t * ```\n\t *\n\t * @body\n\t *\n\t * If `constructorExtends` is:\n\t *\n\t *  - `true` - the constructor extends\n\t *  - `false` - a new instance of the constructor is created\n\t *\n\t * This property defaults to false.\n\t *\n\t * Example of constructExtends as `true`:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   constructorExtends: true // the constructor extends\n\t * },{\n\t *   sayHi: function() {\n\t *     console.log(\"hai!\");\n\t *   }\n\t * });\n\t *\n\t * var Pony = Animal({\n\t *   gallop: function () {\n\t *      console.log(\"Galloping!!\");\n\t *   }\n\t * }); // Pony is now a constructor function extended from Animal\n\t *\n\t * var frank = new Animal(); // frank is a new instance of Animal\n\t *\n\t * var gertrude = new Pony(); // gertrude is a new instance of Pony\n\t * gertrude.sayHi(); // \"hai!\" - sayHi is \"inherited\" from Animal\n\t * gertrude.gallop(); // \"Galloping!!\" - gallop is unique to instances of Pony\n\t *```\n\t *\n\t * The default behavior is shown in the example below:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   constructorExtends: false // the constructor does NOT extend\n\t * },{\n\t *   sayHi: function() {\n\t *     console.log(\"hai!\");\n\t *   }\n\t * });\n\t *\n\t * var pony = Animal(); // pony is a new instance of Animal\n\t * var frank = new Animal(); // frank is a new instance of Animal\n\t *\n\t * pony.sayHi() // \"hai!\"\n\t * frank.sayHi() // \"hai!\"\n\t *```\n\t * By default to extend a constructor, you must use [can-construct.extend extend].\n\t */\n\tconstructorExtends: true,\n\t/**\n\t * @function can-construct.newInstance newInstance\n\t * @parent can-construct.static\n\t *\n\t * @description Returns an instance of `Construct`. This method\n\t * can be overridden to return a cached instance.\n\t *\n\t * @signature `Construct.newInstance([...args])`\n\t *\n\t * @param {*} [args] arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\n\t * that if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\n\t * instead.\n\t * @return {class} instance of the class\n\t *\n\t * @body\n\t * Creates a new instance of the constructor function. This method is useful for creating new instances\n\t * with arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n\t * __new__ operator.\n\t *\n\t * ## Example\n\t *\n\t * The following creates a `Person` Construct and overrides `newInstance` to cache all\n\t * instances of Person to prevent duplication. If the properties of a new Person match an existing one it\n\t * will return a reference to the previously created object, otherwise it returns a new object entirely.\n\t *\n\t * ```js\n\t * // define and create the Person constructor\n\t * var Person = Construct.extend({\n\t *   init : function(first, middle, last) {\n\t *     this.first = first;\n\t *     this.middle = middle;\n\t *     this.last = last;\n\t *   }\n\t * });\n\t *\n\t * // store a reference to the original newInstance function\n\t * var _newInstance = Person.newInstance;\n\t *\n\t * // override Person's newInstance function\n\t * Person.newInstance = function() {\n\t *   // if cache does not exist make it an new object\n\t *   this.__cache = this.__cache || {};\n\t *   // id is a stingified version of the passed arguments\n\t *   var id = JSON.stringify(arguments);\n\t *\n\t *   // look in the cache to see if the object already exists\n\t *   var cachedInst = this.__cache[id];\n\t *   if(cachedInst) {\n\t *     return cachedInst;\n\t *   }\n\t *\n\t *   //otherwise call the original newInstance function and return a new instance of Person.\n\t *   var newInst = _newInstance.apply(this, arguments);\n\t *   this.__cache[id] = newInst;\n\t *   return newInst;\n\t * };\n\t *\n\t * // create two instances with the same arguments\n\t * var justin = new Person('Justin', 'Barry', 'Meyer'),\n\t *\t\tbrian = new Person('Justin', 'Barry', 'Meyer');\n\t *\n\t * console.log(justin === brian); // true - both are references to the same instance\n\t * ```\n\t *\n\t */\n\tnewInstance: function () {\n\t\t// Get a raw instance object (`init` is not called).\n\t\tvar inst = this.instance(),\n\t\t\targs;\n\t\t// Call `setup` if there is a `setup`\n\t\tif (inst.setup) {\n\t\t\tObject.defineProperty(inst,\"__inSetup\",{\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t\targs = inst.setup.apply(inst, arguments);\n\t\t\tif (args instanceof Construct.ReturnValue){\n\t\t\t\treturn args.value;\n\t\t\t}\n\t\t\tinst.__inSetup = false;\n\t\t}\n\t\t// Call `init` if there is an `init`\n\t\t// If `setup` returned `args`, use those as the arguments\n\t\tif (inst.init) {\n\t\t\tinst.init.apply(inst, args || arguments);\n\t\t}\n\t\treturn inst;\n\t},\n\t// Overwrites an object with methods. Used in the `super` plugin.\n\t// `newProps` - New properties to add.\n\t// `oldProps` - Where the old properties might be (used with `super`).\n\t// `addTo` - What we are adding to.\n\t_inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,\n\n\t// Adds a `defineProperty` with the given name and descriptor\n\t// Will only ever be called if ES5 is supported\n\t_defineProperty: function(what, oldProps, propName, descriptor) {\n\t\tObject.defineProperty(what, propName, descriptor);\n\t},\n\n\t// used for overwriting a single property.\n\t// this should be used for patching other objects\n\t// the super plugin overwrites this\n\t_overwrite: function (what, oldProps, propName, val) {\n\t\tObject.defineProperty(what, propName, {value: val, configurable: true, enumerable: true, writable: true});\n\t},\n\t// Set `defaults` as the merger of the parent `defaults` and this\n\t// object's `defaults`. If you overwrite this method, make sure to\n\t// include option merging logic.\n\t/**\n\t * @function can-construct.setup setup\n\t * @parent can-construct.static\n\t *\n\t * @description Perform initialization logic for a constructor function.\n\t *\n\t * @signature `Construct.setup(base, fullName, staticProps, protoProps)`\n\t *\n\t * A static `setup` method provides inheritable setup functionality\n\t * for a Constructor function. The following example\n\t * creates a Group constructor function.  Any constructor\n\t * functions that inherit from Group will be added to\n\t * `Group.childGroups`.\n\t *\n\t * ```js\n\t * Group = Construct.extend({\n\t *   setup: function(Construct, fullName, staticProps, protoProps){\n\t *     this.childGroups = [];\n\t *     if(Construct !== Construct){\n\t *       this.childGroups.push(Construct)\n\t *     }\n\t *     Construct.setup.apply(this, arguments)\n\t *   }\n\t * },{})\n\t * var Flock = Group.extend(...)\n\t * Group.childGroups[0] //-> Flock\n\t * ```\n\t * @param {constructor} base The base constructor that is being inherited from.\n\t * @param {String} fullName The name of the new constructor.\n\t * @param {Object} staticProps The static properties of the new constructor.\n\t * @param {Object} protoProps The prototype properties of the new constructor.\n\t *\n\t * @body\n\t * The static `setup` method is called immediately after a constructor\n\t * function is created and\n\t * set to inherit from its base constructor. It is useful for setting up\n\t * additional inheritance work.\n\t * Do not confuse this with the prototype `[can-construct::setup]` method.\n\t *\n\t * ## Example\n\t *\n\t * This `Parent` class adds a reference to its base class to itself, and\n\t * so do all the classes that inherit from it.\n\t *\n\t * ```js\n\t * Parent = Construct.extend({\n\t *   setup : function(base, fullName, staticProps, protoProps){\n\t *     this.base = base;\n\t *\n\t *     // call base functionality\n\t *     Construct.setup.apply(this, arguments)\n\t *   }\n\t * },{});\n\t *\n\t * Parent.base; // Construct\n\t *\n\t * Child = Parent({});\n\t *\n\t * Child.base; // Parent\n\t * ```\n\t */\n\tsetup: function (base) {\n\t\tvar defaults = canReflect.assignDeepMap({},base.defaults);\n\t\tthis.defaults = canReflect.assignDeepMap(defaults,this.defaults);\n\t},\n\t// Create's a new `class` instance without initializing by setting the\n\t// `initializing` flag.\n\tinstance: function () {\n\t\t// Prevents running `init`.\n\t\tinitializing = 1;\n\t\tvar inst = new this();\n\t\t// Allow running `init`.\n\t\tinitializing = 0;\n\t\treturn inst;\n\t},\n\t// Extends classes.\n\t/**\n\t * @function can-construct.extend extend\n\t * @parent can-construct.static\n\t *\n\t * @signature `Construct.extend([name,] [staticProperties,] instanceProperties)`\n\t *\n\t * Extends `Construct`, or constructor functions derived from `Construct`,\n\t * to create a new constructor function. Example:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   sayHi: function(){\n\t *     console.log(\"hi\")\n\t *   }\n\t * });\n\t *\n\t * var animal = new Animal()\n\t * animal.sayHi();\n\t * ```\n\t *\n\t * @param {String} [name] Adds a name to the constructor function so\n\t * it is nicely labeled in the developer tools. The following:\n\t *\n\t *     Construct.extend(\"ConstructorName\",{})\n\t *\n\t * returns a constructur function that will show up as `ConstructorName`\n\t * in the developer tools.\n\t * It also sets \"ConstructorName\" as [can-construct.shortName shortName].\n\t *\n\t * @param {Object} [staticProperties] Properties that are added the constructor\n\t * function directly. For example:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *   findAll: function(){\n\t *     return can.ajax({url: \"/animals\"})\n\t *   }\n\t * },{}); // need to pass an empty instanceProperties object\n\t *\n\t * Animal.findAll().then(function(json){ ... })\n\t * ```\n\t *\n\t * The [can-construct.setup static setup] method can be used to\n\t * specify inheritable behavior when a Constructor function is created.\n\t *\n\t * @param {Object} instanceProperties Properties that belong to\n\t * instances made with the constructor. These properties are added to the\n\t * constructor's `prototype` object. Example:\n\t *\n\t *     var Animal = Construct.extend({\n\t *\t\t  findAll: function() {\n\t *\t\t\treturn can.ajax({url: \"/animals\"});\n\t *\t\t  }\n\t *     },{\n\t *       init: function(name) {\n\t *         this.name = name;\n\t *       },\n\t *       sayHi: function() {\n\t *         console.log(this.name,\" says hai!\");\n\t *       }\n\t *     })\n\t *     var pony = new Animal(\"Gertrude\");\n\t *     pony.sayHi(); // \"Gertrude says hai!\"\n\t *\n\t * The [can-construct::init init] and [can-construct::setup setup] properties\n\t * are used for initialization.\n\t *\n\t * @return {function} The constructor function.\n\t *\n\t * ```js\n\t *\tvar Animal = Construct.extend(...);\n\t *\tvar pony = new Animal(); // Animal is a constructor function\n\t * ```\n\t * @body\n\t * ## Inheritance\n\t * Creating \"subclasses\" with `Construct` is simple. All you need to do is call the base constructor\n\t * with the new function's static and instance properties. For example, we want our `Snake` to\n\t * be an `Animal`, but there are some differences:\n\t *\n\t *\n\t *     var Snake = Animal.extend({\n\t *         legs: 0\n\t *     }, {\n\t *         init: function() {\n\t *             Animal.prototype.init.call(this, 'ssssss');\n\t *         },\n\t *         slither: function() {\n\t *             console.log('slithering...');\n\t *         }\n\t *     });\n\t *\n\t *     var baslisk = new Snake();\n\t *     baslisk.speak();   // \"ssssss\"\n\t *     baslisk.slither(); // \"slithering...\"\n\t *     baslisk instanceof Snake;  // true\n\t *     baslisk instanceof Animal; // true\n\t *\n\t *\n\t * ## Static properties and inheritance\n\t *\n\t * If you pass all three arguments to Construct, the second one will be attached directy to the\n\t * constructor, allowing you to imitate static properties and functions. You can access these\n\t * properties through the `[can-construct::constructor this.constructor]` property.\n\t *\n\t * Static properties can get overridden through inheritance just like instance properties. In the example below,\n\t * we override both the legs static property as well as the the init function for each instance:\n\t *\n\t * ```js\n\t * var Animal = Construct.extend({\n\t *     legs: 4\n\t * }, {\n\t *     init: function(sound) {\n\t *         this.sound = sound;\n\t *     },\n\t *     speak: function() {\n\t *         console.log(this.sound);\n\t *     }\n\t * });\n\t *\n\t * var Snake = Animal.extend({\n\t *     legs: 0\n\t * }, {\n\t *     init: function() {\n\t *         this.sound = 'ssssss';\n\t *     },\n\t *     slither: function() {\n\t *         console.log('slithering...');\n\t *     }\n\t * });\n\t *\n\t * Animal.legs; // 4\n\t * Snake.legs; // 0\n\t * var dog = new Animal('woof');\n\t * var blackMamba = new Snake();\n\t * dog.speak(); // 'woof'\n\t * blackMamba.speak(); // 'ssssss'\n\t * ```\n\t *\n\t * ## Alternative value for a new instance\n\t *\n\t * Sometimes you may want to return some custom value instead of a new object when creating an instance of your class.\n\t * For example, you want your class to act as a singleton, or check whether an item with the given id was already\n\t * created and return an existing one from your cache store (e.g. using [can-connect/constructor/store/store]).\n\t *\n\t * To achieve this you can return [can-construct.ReturnValue] from `setup` method of your class.\n\t *\n\t * Lets say you have `myStore` to cache all newly created instances. And if an item already exists you want to merge\n\t * the new data into the existing instance and return the updated instance.\n\t *\n\t * ```\n\t * var myStore = {};\n\t *\n\t * var Item = Construct.extend({\n\t *     setup: function(params){\n\t *         if (myStore[params.id]){\n\t *             var item = myStore[params.id];\n\t *\n\t *             // Merge new data to the existing instance:\n\t *             Object.assign(item, params);\n\t *\n\t *             // Return the updated item:\n\t *             return new Construct.ReturnValue( item );\n\t *         } else {\n\t *             // Save to cache store:\n\t *             myStore[this.id] = this;\n\t *\n\t *             return [params];\n\t *         }\n\t *     },\n\t *     init: function(params){\n\t *         Object.assign(this, params);\n\t *     }\n\t * });\n\t *\n\t * var item_1  = new Item( {id: 1, name: \"One\"} );\n\t * var item_1a = new Item( {id: 1, name: \"OnePlus\"} )\n\t * ```\n\t */\n\textend: function (name, staticProperties, instanceProperties) {\n\t\tvar shortName = name,\n\t\t\tklass = staticProperties,\n\t\t\tproto = instanceProperties;\n\n\t\t// Figure out what was passed and normalize it.\n\t\tif (typeof shortName !== 'string') {\n\t\t\tproto = klass;\n\t\t\tklass = shortName;\n\t\t\tshortName = null;\n\t\t}\n\t\tif (!proto) {\n\t\t\tproto = klass;\n\t\t\tklass = null;\n\t\t}\n\t\tproto = proto || {};\n\t\tvar _super_class = this,\n\t\t\t_super = this.prototype,\n\t\t\tConstructor, prototype;\n\t\t// Instantiate a base class (but only create the instance,\n\t\t// don't run the init constructor).\n\t\tprototype = this.instance();\n\t\t// Copy the properties over onto the new prototype.\n\t\tConstruct._inherit(proto, _super, prototype);\n\n\t\tif(shortName) {\n\n\t\t} else if(klass && klass.shortName) {\n\t\t\tshortName = klass.shortName;\n\t\t} else if(this.shortName) {\n\t\t\tshortName = this.shortName;\n\t\t}\n\t\t// We want constructor.name to be the same as shortName, within\n\t\t// the bounds of what the JS VM will allow (meaning no non-word characters).\n\t\t// new Function() is significantly faster than eval() here.\n\n\t\t// Strip semicolons\n\t\t//!steal-remove-start\n\t\t// wrapping this var will cause \"used out of scope.\" when linting\n\t\tvar constructorName = shortName ? shortName.replace(constructorNameRegex, '_') : 'Constructor';\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tif(reservedWords[constructorName]) {\n\t\t\t\tconstructorName = CanString.capitalize(constructorName);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// The dummy class constructor.\n\t\tfunction init() {\n\t\t\t/* jshint validthis: true */\n\t\t\t// All construction is actually done in the init method.\n\t\t\tif (!initializing) {\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tif(!this || (this.constructor !== Constructor) &&\n\t\t\t\t\t// We are being called without `new` or we are extending.\n\t\t\t\t\targuments.length && Constructor.constructorExtends) {\n\t\t\t\t\t\tdev.warn('can/construct/construct.js: extending a Construct without calling extend');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\treturn (!this || this.constructor !== Constructor) &&\n\t\t\t\t// We are being called without `new` or we are extending.\n\t\t\t\targuments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) :\n\t\t\t\t// We are being called with `new`.\n\t\t\t\tConstructor.newInstance.apply(Constructor, arguments);\n\t\t\t}\n\t\t}\n\t\tConstructor = typeof namedCtor === \"function\" ?\n\t\t\tnamedCtor( constructorName, init ) :\n\t\t\tfunction() { return init.apply(this, arguments); };\n\n\t\t// Copy old stuff onto class (can probably be merged w/ inherit)\n\t\tfor (var propName in _super_class) {\n\t\t\tif (_super_class.hasOwnProperty(propName)) {\n\t\t\t\tConstructor[propName] = _super_class[propName];\n\t\t\t}\n\t\t}\n\t\t// Copy new static properties on class.\n\t\tConstruct._inherit(klass, _super_class, Constructor);\n\n\t\t// Set things that shouldn't be overwritten.\n\t\tcanReflect.assignMap(Constructor, {\n\t\t\tconstructor: Constructor,\n\t\t\tprototype: prototype\n\t\t\t/**\n\t\t\t * @property {String} can-construct.shortName shortName\n\t\t\t * @parent can-construct.static\n\t\t\t *\n\t\t\t * If you pass a name when creating a Construct, the `shortName` property will be set to the\n\t\t\t * name.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var MyConstructor = Construct.extend(\"MyConstructor\",{},{});\n\t\t\t * MyConstructor.shortName // \"MyConstructor\"\n\t\t\t * ```\n\t\t\t */\n\t\t});\n\n\t\tif (shortName !== undefined) {\n\t\t\tif (Object.getOwnPropertyDescriptor) {\n\t\t\t\tvar desc = Object.getOwnPropertyDescriptor(Constructor, 'name');\n\t\t\t\tif (!desc || desc.configurable) {\n\t\t\t\t\tObject.defineProperty(\n\t\t\t\t\t\tConstructor,\n\t\t\t\t\t\t'name',\n\t\t\t\t\t\t{ writable: true, value: shortName, configurable: true }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tConstructor.shortName = shortName;\n\t\t}\n\t\t// Make sure our prototype looks nice.\n\t\tdefineNonEnumerable(Constructor.prototype, \"constructor\", Constructor);\n\t\t// Call the class `setup` and `init`\n\t\tvar t = [_super_class].concat(Array.prototype.slice.call(arguments)),\n\t\t\targs = Constructor.setup.apply(Constructor, t);\n\t\tif (Constructor.init) {\n\t\t\tConstructor.init.apply(Constructor, args || t);\n\t\t}\n\t\t/**\n\t\t * @prototype\n\t\t */\n\t\treturn Constructor; //\n\t\t/**\n\t\t * @property {Object} can-construct.prototype.constructor constructor\n\t\t * @parent can-construct.prototype\n\t\t *\n\t\t * A reference to the constructor function that created the instance. This allows you to access\n\t\t * the constructor's static properties from an instance.\n\t\t *\n\t\t * @body\n\t\t * ## Example\n\t\t *\n\t\t * This Construct has a static counter that counts how many instances have been created:\n\t\t *\n\t\t * ```js\n\t\t * var Counter = Construct.extend({\n\t\t *     count: 0\n\t\t * }, {\n\t\t *     init: function() {\n\t\t *         this.constructor.count++;\n\t\t *     }\n\t\t * });\n\t\t *\n\t\t * var childCounter = new Counter();\n\t\t * console.log(childCounter.constructor.count); // 1\n\t\t * console.log(Counter.count); // 1\n\t\t * ```\n\t\t */\n\t},\n\t/**\n\t * @function can-construct.ReturnValue ReturnValue\n\t * @parent can-construct.static\n\t *\n\t * Use to overwrite the return value of new Construct(...).\n\t *\n\t * @signature `new Construct.ReturnValue( value )`\n\t *\n\t *   This constructor function can be used for creating a return value of the `setup` method.\n\t *   [can-construct] will check if the return value is an instance of `Construct.ReturnValue`.\n\t *   If it is then its `value` will be used as the new instance.\n\t *\n\t *   @param {Object} value A value to be used for a new instance instead of a new object.\n\t *\n\t *   ```js\n\t *   var Student = function( name, school ){\n\t *       this.name = name;\n\t *       this.school = school;\n\t *   }\n\t *\n\t *   var Person = Construct.extend({\n\t *       setup: function( options ){\n\t *           if (options.school){\n\t *               return new Constructor.ReturnValue( new Student( options.name, options.school ) );\n\t *           } else {\n\t *               return [options];\n\t *           }\n\t *       }\n\t *   });\n\t *\n\t *   var myPerson = new Person( {name: \"Ilya\", school: \"PetrSU\"} );\n\t *\n\t *   myPerson instanceof Student // => true\n\t *   ```\n   */\n\tReturnValue: function(value){\n\t\tthis.value = value;\n\t}\n});\n/**\n * @function can-construct.prototype.setup setup\n * @parent can-construct.prototype\n *\n * @signature `construct.setup(...args)`\n *\n * A setup function for the instantiation of a constructor function.\n *\n * @param {*} args The arguments passed to the constructor.\n *\n * @return {Array|undefined|can-construct.ReturnValue} If an array is returned, the array's items are passed as\n * arguments to [can-construct::init init]. If a [can-construct.ReturnValue] instance is returned, the ReturnValue\n * instance's value will be returned as the result of calling new Construct(). The following example always makes\n * sure that init is called with a jQuery wrapped element:\n *\n * ```js\n * \tWidgetFactory = Construct.extend({\n * \t\t\tsetup: function(element){\n * \t\t\t\t\treturn [$(element)]\n * \t\t\t}\n * \t});\n *\n * \tMyWidget = WidgetFactory.extend({\n * \t\t\tinit: function($el){\n * \t\t\t\t\t$el.html(\"My Widget!!\")\n * \t\t\t}\n * \t});\n *  ```\n *\n * Otherwise, the arguments to the\n * constructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n *\n * @body\n *\n * ## Deciding between `setup` and `init`\n *\n *\n * Usually, you should use [can-construct::init init] to do your constructor function's initialization.\n * You should, instead, use `setup` when:\n *\n *   - there is initialization code that you want to run before the inheriting constructor's\n *     `init` method is called.\n *   - there is initialization code that should run whether or not inheriting constructors\n *     call their base's `init` methods.\n *   - you want to modify the arguments that will get passed to `init`.\n *\n */\ndefineNonEnumerable(Construct.prototype, \"setup\", function () {});\n/**\n * @function can-construct.prototype.init init\n * @parent can-construct.prototype\n *\n * @description Called when a new instance of a Construct is created.\n *\n * @signature `construct.init(...args)`\n * @param {*} args the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n *\n * @body\n * If a prototype `init` method is provided, `init` is called when a new Construct is created---\n * after [can-construct::setup]. The `init` method is where the bulk of your initialization code\n * should go. A common thing to do in `init` is save the arguments passed into the constructor.\n *\n * ## Examples\n *\n * First, we'll make a Person constructor that has a first and last name:\n *\n * ```js\n * var Person = Construct.extend({\n *     init: function(first, last) {\n *         this.first = first;\n *         this.last  = last;\n *     }\n * });\n *\n * var justin = new Person(\"Justin\", \"Meyer\");\n * justin.first; // \"Justin\"\n * justin.last; // \"Meyer\"\n * ```\n *\n * Then, we'll extend Person into Programmer, and add a favorite language:\n *\n * ```js\n * var Programmer = Person.extend({\n *     init: function(first, last, language) {\n *         // call base's init\n *         Person.prototype.init.apply(this, arguments);\n *\n *         // other initialization code\n *         this.language = language;\n *     },\n *     bio: function() {\n *         return \"Hi! I'm \" + this.first + \" \" + this.last +\n *             \" and I write \" + this.language + \".\";\n *     }\n * });\n *\n * var brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\n * brian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";\n * ```\n *\n * ## Modified Arguments\n *\n * [can-construct::setup] is able to modify the arguments passed to `init`.\n * If you aren't receiving the arguments you passed to `new Construct(args)`,\n * check that they aren't being changed by `setup` along\n * the inheritance chain.\n */\ndefineNonEnumerable(Construct.prototype, \"init\", function () {});\n\nmodule.exports = namespace.Construct = Construct;\n"],"names":["process","env","NODE_ENV","CanString","require$$0","reservedWords","abstract","boolean","break","byte","case","catch","char","class","const","continue","debugger","default","delete","do","double","else","enum","export","extends","false","final","finally","float","for","function","goto","if","implements","import","in","instanceof","int","interface","let","long","native","new","null","package","private","protected","public","return","short","static","super","switch","synchronized","this","throw","throws","transient","true","try","typeof","var","void","volatile","while","with","constructorNameRegex","initializing","namedCtor","cache","name","fn","Function","canGetDescriptor","Construct","arguments","length","extend","apply","e","getDescriptor","newProps","descriptor","Object","getOwnPropertyDescriptor","get","set","inheritGetterSetter","oldProps","addTo","_defineProperty","_overwrite","simpleInherit","defineNonEnumerable","obj","prop","value","defineProperty","configurable","writable","enumerable","canReflect","assignMap","constructorExtends","newInstance","args","inst","instance","setup","ReturnValue","__inSetup","init","_inherit","what","propName","val","base","defaults","assignDeepMap","staticProperties","instanceProperties","shortName","klass","proto","Constructor","prototype","_super_class","_super","constructorName","replace","constructor","dev","warn","capitalize","hasOwnProperty","undefined","desc","t","concat","Array","slice","call","namespace"],"mappings":"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"}