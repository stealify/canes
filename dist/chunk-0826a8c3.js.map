{"version":3,"file":"chunk-0826a8c3.js","sources":["../node_modules/can-query-logic/src/set.js","../node_modules/can-query-logic/src/array-union-intersection-difference.js","../node_modules/can-query-logic/src/types/comparisons.js","../node_modules/can-query-logic/src/types/make-real-number-range-inclusive.js","../node_modules/can-query-logic/src/types/types.js","../node_modules/can-query-logic/src/types/values-or.js","../node_modules/can-query-logic/src/types/values-not.js","../node_modules/can-query-logic/src/types/keys-and.js","../node_modules/can-query-logic/src/types/and-or-not.js","../node_modules/can-query-logic/src/helpers.js","../node_modules/can-query-logic/src/types/basic-query.js","../node_modules/can-query-logic/src/serializer.js","../node_modules/can-query-logic/src/serializers/comparisons.js","../node_modules/can-query-logic/src/schema-helpers.js","../node_modules/can-query-logic/src/types/make-maybe.js","../node_modules/can-query-logic/src/types/make-enum.js","../node_modules/can-query-logic/src/serializers/basic-query.js","../node_modules/can-query-logic/can-query-logic.js"],"sourcesContent":["// # can-query-logic/set.js\n// This file defines the set mechanics of types.\n// It provides ways for types to define how to perform\n// `union`, `difference`, `intersection` operations.\n//\n// It also derives other operators (`isEqual`, `isSubset`, etc) from these\n// core operators.\n//\n// `.memberOf` is a property that defines if a value is within the set. It's\n// currently a different thing.\n\nvar canSymbol = require(\"can-symbol\");\nvar canReflect = require(\"can-reflect\");\n\n\n// This is what we are defining\nvar set;\n\n// ## HELPERS =========\n//\n// Used to make sure an object serializes to itself.\n// This makes sure the empty object won't try to clone itself.\nvar addSerializeToThis = function(obj) {\n\treturn canReflect.assignSymbols(obj, {\n\t\t\"can.serialize\": function() {\n\t\t\treturn this;\n\t\t}\n\t});\n};\n\n// Reverses the arguments of a function.\nfunction reverseArgs(fn) {\n\treturn function(first, second) {\n\t\treturn fn.call(this, second, first);\n\t};\n}\n\n// This symbol is put on constructor functions to track the comparator operators\n// available to that type.\nvar setComparisonsSymbol = canSymbol.for(\"can.setComparisons\");\n\n// Adds comparators to a type. They are stored like:\n// Type[@can.setComparisons] = Map({\n//    [type1]: Map({[type2]: {union, different, intersection}})\n// })\n//\n// Why do we need the outer object?\nfunction addComparators(type1, type2, comparators) {\n\tvar comparisons = type1[setComparisonsSymbol];\n\tif (!type1[setComparisonsSymbol]) {\n\t\tcomparisons = type1[setComparisonsSymbol] = new Map();\n\t}\n\tvar subMap = comparisons.get(type1);\n\n\tif (!subMap) {\n\t\tsubMap = new Map();\n\t\tcomparisons.set(type1, subMap);\n\t}\n\tvar existingComparators = subMap.get(type2);\n\tif (existingComparators) {\n\t\tfor (var prop in comparators) {\n\t\t\tif (existingComparators.hasOwnProperty(prop)) {\n\t\t\t\tconsole.warn(\"Overwriting \" + type1.name + \" \" + prop + \" \" + type2.name + \" comparitor\");\n\t\t\t}\n\t\t\texistingComparators[prop] = comparators[prop];\n\t\t}\n\t} else {\n\t\tsubMap.set(type2, comparators);\n\t}\n}\n\n\n// This type is used for primitives in JS, but it can be used for\n// any value that should only === itself.\nfunction Identity() {}\n\nvar typeMap = {\n\t\"number\": Identity,\n\t\"string\": Identity,\n\t\"undefined\": Identity,\n\t\"boolean\": Identity\n};\n\n// `get.intersection`, etc is used to look within the types\n// maps and get the right comparator operators.\nvar get = {};\n/*\nvar algebraSymbol = {\n    \"intersection\": \"∩\",\n    \"union\": \"∪\",\n    \"difference\": \"\\\\\"\n};\n*/\n\n[\"intersection\", \"difference\", \"union\"].forEach(function(prop) {\n\tget[prop] = function(forwardComparators, value1, value2) {\n\n\t\tif (value2 === set.UNIVERSAL) {\n\t\t\tif (prop === \"intersection\") {\n\t\t\t\treturn value1;\n\t\t\t}\n\t\t\tif (prop === \"union\") {\n\t\t\t\treturn set.UNIVERSAL;\n\t\t\t}\n\t\t\tif (prop === \"difference\") {\n\t\t\t\treturn set.EMPTY;\n\t\t\t}\n\t\t}\n\t\tif (value1 === set.UNIVERSAL) {\n\t\t\tif (prop === \"intersection\") {\n\t\t\t\treturn value1;\n\t\t\t}\n\t\t\tif (prop === \"union\") {\n\t\t\t\treturn set.UNIVERSAL;\n\t\t\t}\n\t\t}\n\n\t\tif (forwardComparators && forwardComparators[prop]) {\n\t\t\tvar result = forwardComparators[prop](value1, value2);\n\t\t\t// console.log(\"\",/*name1,*/ value1, algebraSymbol[prop], /*name2,*/ value2,\"=\", result);\n\t\t\tif (result === undefined && forwardComparators.undefinedIsEmptySet === true) {\n\t\t\t\treturn set.EMPTY;\n\t\t\t} else {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"Unable to perform \" + prop + \" between \" + set.getType(value1).name + \" and \" + set.getType(value2).name);\n\t\t}\n\n\t};\n});\n\n\n\nset = {\n\t// The special types\n\n\t// All values within the \"universe\". Other sets can equal UNIVERSAL.\n\tUNIVERSAL: canReflect.assignSymbols({\n\t\tname: \"UNIVERSAL\"\n\t}, {\n\t\t\"can.serialize\": function() {\n\t\t\treturn this;\n\t\t},\n\t\t\"can.isMember\": function(){\n\t\t\treturn true;\n\t\t}\n\t}),\n\t// Nothing\n\tEMPTY: canReflect.assignSymbols({\n\t\tname: \"EMPTY\"\n\t}, {\n\t\t\"can.serialize\": function() {\n\t\t\treturn this;\n\t\t},\n\t\t\"can.isMember\": function(){\n\t\t\treturn false;\n\t\t}\n\t}),\n\t// The set exists, but we lack the language to represent it.\n\tUNDEFINABLE: addSerializeToThis({\n\t\tname: \"UNDEFINABLE\"\n\t}),\n\t// We don't know if this exists. Intersection between two paginated sets.\n\tUNKNOWABLE: addSerializeToThis({\n\t\tname: \"UNKNOWABLE\"\n\t}),\n\tIdentity: Identity,\n\tisSpecial: function(setA) {\n\t\treturn setA === set.UNIVERSAL || setA === set.EMPTY ||\n\t\t\tsetA === set.UNDEFINABLE || setA === set.UNKNOWABLE;\n\t},\n\tisDefinedAndHasMembers: function(setA) {\n\t\tif (setA !== set.EMPTY && setA !== set.UNDEFINABLE && setA !== set.UNKNOWABLE) {\n\t\t\treturn setA;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t},\n\tgetType: function(value) {\n\t\tif (value === set.UNIVERSAL) {\n\t\t\treturn set.UNIVERSAL;\n\t\t}\n\t\tif (value === set.EMPTY) {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t\tif (value === set.UNKNOWABLE) {\n\t\t\treturn set.UNKNOWABLE;\n\t\t}\n\t\tif (value === null) {\n\t\t\treturn Identity;\n\t\t}\n\t\tif (typeMap.hasOwnProperty(typeof value)) {\n\t\t\treturn typeMap[typeof value];\n\t\t}\n\t\treturn value.constructor;\n\t},\n\townAndMemberValue: function(startOwnValue, startMemberValue) {\n\t\t// If either side has a value, then try to type-coerse.\n\t\tif (startOwnValue != null || startMemberValue != null) {\n\t\t\tvar ownValue = startOwnValue != null ? startOwnValue.valueOf() : startOwnValue,\n\t\t\t\tmemberValue = startMemberValue != null ? startMemberValue.valueOf() : startMemberValue;\n\t\t\t// if we have nulls or undefineds\n\t\t\tif (startOwnValue == null || startMemberValue == null) {\n\t\t\t\treturn {\n\t\t\t\t\town: ownValue,\n\t\t\t\t\tmember: memberValue\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (ownValue.constructor !== memberValue.constructor) {\n\t\t\t\tmemberValue = new startOwnValue.constructor(memberValue).valueOf();\n\t\t\t}\n\t\t\treturn {\n\t\t\t\town: ownValue,\n\t\t\t\tmember: memberValue\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\town: startMemberValue,\n\t\t\tmember: startOwnValue\n\t\t};\n\t},\n\tgetComparisons: function(Type1, Type2) {\n\t\tvar comparisons = Type1[setComparisonsSymbol];\n\t\tif (comparisons) {\n\t\t\tvar subMap = comparisons.get(Type1);\n\n\t\t\tif (subMap) {\n\t\t\t\treturn subMap.get(Type2);\n\t\t\t}\n\t\t}\n\t},\n\thasComparisons: function(Type) {\n\t\treturn !!Type[setComparisonsSymbol];\n\t},\n\tdefineComparison: function(type1, type2, comparators) {\n\t\taddComparators(type1, type2, comparators);\n\t\tif (type1 !== type2) {\n\t\t\tvar reverse = {};\n\t\t\tfor (var prop in comparators) {\n\t\t\t\t// difference can not be reversed\n\t\t\t\tif (prop !== \"difference\") {\n\t\t\t\t\treverse[prop] = reverseArgs(comparators[prop]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\taddComparators(type2, type1, reverse);\n\t\t}\n\t},\n\t/**\n\t * Checks if A is a subset of B.  If A is a subset of B if:\n\t * - A \\ B = EMPTY (A has nothing outside what's in B)\n\t * - A ∩ B = defined\n\t */\n\tisSubset: function(value1, value2) {\n\t\t// check primary direction\n\t\tif (value1 === value2) {\n\t\t\treturn true;\n\t\t}\n\t\tvar Type1 = set.getType(value1),\n\t\t\tType2 = set.getType(value2);\n\t\tvar forwardComparators = set.getComparisons(Type1, Type2);\n\t\tif (forwardComparators) {\n\t\t\t// A set is a subset, if it intersects with the set, and it has nothing\n\t\t\t// outside the other set.\n\t\t\tvar intersection = get.intersection(forwardComparators, value1, value2);\n\t\t\t// [a, b] \\ [a, b, c]\n\t\t\tvar difference = get.difference(forwardComparators, value1, value2);\n\t\t\t// they intersect, but value2 has nothing value1 outside value2\n\t\t\tif (intersection === set.UNKNOWABLE || difference === set.UNKNOWABLE) {\n\t\t\t\t// {sort: \"a\", page: 0-2} E {sort: \"b\", page: 2-3}\n\t\t\t\treturn undefined;\n\t\t\t} else if (intersection !== set.EMPTY && difference === set.EMPTY) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"Unable to perform subset comparison between \" + Type1.name + \" and \" + Type2.name);\n\t\t}\n\t},\n\tisProperSubset: function(setA, setB) {\n\t\treturn set.isSubset(setA, setB) && !set.isEqual(setA, setB);\n\t},\n\tisEqual: function(value1, value2) {\n\t\tif (value1 === set.UNKNOWABLE || value2 === set.UNKNOWABLE) {\n\t\t\treturn set.UNKNOWABLE;\n\t\t}\n\t\t//console.group(\"is\", value1, \"==\", value2);\n\t\tvar isSpecial1 = set.isSpecial(value1),\n\t\t\tisSpecial2 = set.isSpecial(value2);\n\n\t\t// Both have to be specail because some other sets will be equal to UNIVERSAL without being UNIVERSAL\n\t\tif (isSpecial1 && isSpecial2) {\n\t\t\treturn isSpecial1 === isSpecial2;\n\t\t}\n\t\tvar Type1 = set.getType(value1),\n\t\t\tType2 = set.getType(value2);\n\t\tif (value1 === value2) {\n\t\t\treturn true;\n\t\t}\n\t\tvar forwardComparators = set.getComparisons(Type1, Type2);\n\t\tvar reverseComparators = set.getComparisons(Type2, Type1);\n\t\tif (forwardComparators && reverseComparators) {\n\n\t\t\t// Two sets are equal if there's an intersection, but not difference\n\t\t\tvar intersection = get.intersection(forwardComparators, value1, value2);\n\t\t\tvar difference = get.difference(forwardComparators, value1, value2);\n\t\t\tif (intersection !== set.EMPTY && difference === set.EMPTY) {\n\t\t\t\tvar reverseIntersection = get.intersection(reverseComparators, value2, value1);\n\t\t\t\tvar reverseDifference = get.difference(reverseComparators, value2, value1);\n\t\t\t\t//console.groupEnd();\n\t\t\t\treturn reverseIntersection !== set.EMPTY && reverseDifference === set.EMPTY;\n\t\t\t} else {\n\t\t\t\t//console.groupEnd();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tvar values = set.ownAndMemberValue(value1, value2);\n\t\t\tif (canReflect.isPrimitive(values.own) && canReflect.isPrimitive(values.member)) {\n\t\t\t\treturn values.own === values.member;\n\t\t\t} else {\n\t\t\t\t// try to convert ...\n\t\t\t\tthrow new Error(\"Unable to perform equal comparison between \" + Type1.name + \" and \" + Type2.name);\n\t\t\t}\n\n\t\t}\n\t},\n\n\tunion: function(value1, value2) {\n\t\tif (value1 === set.UNIVERSAL || value2 === set.UNIVERSAL) {\n\t\t\treturn set.UNIVERSAL;\n\t\t}\n\t\tif (value1 === set.EMPTY) {\n\t\t\treturn value2;\n\t\t} else if (value2 === set.EMPTY) {\n\t\t\treturn value1;\n\t\t}\n\t\tif (value1 === set.UNKNOWABLE || value2 === set.UNKNOWABLE) {\n\t\t\treturn set.UNKNOWABLE;\n\t\t}\n\t\tvar Type1 = set.getType(value1),\n\t\t\tType2 = set.getType(value2);\n\t\tvar forwardComparators = set.getComparisons(Type1, Type2);\n\t\treturn get.union(forwardComparators, value1, value2);\n\t},\n\n\tintersection: function(value1, value2) {\n\t\tif (value1 === set.UNIVERSAL) {\n\t\t\treturn value2;\n\t\t}\n\t\tif (value2 === set.UNIVERSAL) {\n\t\t\treturn value1;\n\t\t}\n\t\tif (value1 === set.EMPTY || value2 === set.EMPTY) {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t\tif (value1 === set.UNKNOWABLE || value2 === set.UNKNOWABLE) {\n\t\t\treturn set.UNKNOWABLE;\n\t\t}\n\t\tvar Type1 = set.getType(value1),\n\t\t\tType2 = set.getType(value2);\n\t\tvar forwardComparators = set.getComparisons(Type1, Type2);\n\t\tif (forwardComparators) {\n\t\t\treturn get.intersection(forwardComparators, value1, value2);\n\t\t} else {\n\t\t\tthrow new Error(\"Unable to perform intersection comparison between \" + Type1.name + \" and \" + Type2.name);\n\t\t}\n\t},\n\tdifference: function(value1, value2) {\n\t\tif (value1 === set.EMPTY) {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t\tif (value2 === set.EMPTY) {\n\t\t\treturn value1;\n\t\t}\n\t\tif (value1 === set.UNKNOWABLE || value2 === set.UNKNOWABLE) {\n\t\t\treturn set.UNKNOWABLE;\n\t\t}\n\t\tvar Type1 = set.getType(value1),\n\t\t\tType2 = set.getType(value2);\n\t\tvar forwardComparators = set.getComparisons(Type1, Type2);\n\t\tif (forwardComparators) {\n\t\t\treturn get.difference(forwardComparators, value1, value2);\n\t\t} else {\n\t\t\tthrow new Error(\"Unable to perform difference comparison between \" + Type1.name + \" and \" + Type2.name);\n\t\t}\n\t},\n\n\tindexWithEqual: function(arr, value) {\n\t\tfor (var i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (set.isEqual(arr[i], value)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n};\n\n\n\nfunction identityIntersection(v1, v2) {\n\treturn v1 === v2 ? v1 : set.EMPTY;\n}\n\nfunction identityDifference(v1, v2) {\n\treturn v1 === v2 ? set.EMPTY : v1;\n}\n\nfunction identityUnion(v1, v2) {\n\treturn v1 === v2 ? v1 : set.UNDEFINABLE;\n}\nvar identityComparitor = {\n\tintersection: identityIntersection,\n\tdifference: identityDifference,\n\tunion: identityUnion\n};\nset.defineComparison(Identity, Identity, identityComparitor);\n\nset.defineComparison(set.UNIVERSAL, set.UNIVERSAL, identityComparitor);\n\nmodule.exports = set;\n","var SET = require(\"./set\");\n\n\nfunction getValue(value){\n    return value == null ? value : value.valueOf();\n}\n\nmodule.exports = function arrayUnionIntersectionDifference(arr1, arr2){\n    var set = new Set();\n\n    var intersection = [];\n    var union = [];\n    var difference = arr1.slice(0);\n\n\n    arr1.forEach(function(value){\n        set.add(getValue(value));\n        union.push(value);\n    });\n\n    arr2.forEach(function(value){\n        if(set.has(getValue(value))) {\n            intersection.push(value);\n            var index = SET.indexWithEqual(difference, value);\n            if(index !== -1) {\n                difference.splice(index, 1);\n            }\n        } else {\n            union.push(value);\n        }\n    });\n\n    return {\n        intersection: intersection,\n        union: union,\n        difference: difference\n    };\n};\n","var set = require(\"../set\");\nvar arrayUnionIntersectionDifference = require(\"../array-union-intersection-difference\");\nvar canSymbol = require(\"can-symbol\");\nvar isMemberSymbol = canSymbol.for(\"can.isMember\");\n// $ne\tMatches all values that are not equal to a specified value.\n// $eq\tMatches values that are equal to a specified value.\n//\n// $gt\tMatches values that are greater than a specified value.\n// $gte\tMatches values that are greater than or equal to a specified value.\n\n// $lt\tMatches values that are less than a specified value.\n// $lte\tMatches values that are less than or equal to a specified value.\n\n// $in\tMatches any of the values specified in an array.\n// $nin\tMatches none of the values specified in an array.\n\n\n\nvar comparisons = {\n\tIn: function In(values) {\n\t\t// TODO: change this to store as `Set` later.\n\t\tthis.values = values;\n\t},\n\tNotIn: function NotIn(values) {\n\t\tthis.values = values;\n\t},\n\tGreaterThan: function GreaterThan(value) {\n\t\tthis.value = value;\n\t},\n\tGreaterThanEqual: function GreaterThanEqual(value) {\n\t\tthis.value = value;\n\t},\n\tLessThan: function LessThan(value) {\n\t\tthis.value = value;\n\t},\n\tLessThanEqual: function LessThanEqual(value) {\n\t\tthis.value = value;\n\t},\n\t// This is used to And something like `GT(3)` n `LT(4)`.\n\t// These are all value comparisons.\n\tAnd: function ValueAnd(ands) {\n\t\tthis.values = ands;\n\t},\n\t// This is used to OR something like `GT(4)` n `LT(3)`.\n\t// These are all value comparisons.\n\tOr: function ValueOr(ors) {\n\t\tthis.values = ors;\n\t}\n};\n\ncomparisons.Or.prototype.orValues = function() {\n\treturn this.values;\n};\n\n\ncomparisons.In.test = function(values, b) {\n\treturn values.some(function(value) {\n\t\tvar values = set.ownAndMemberValue(value, b)\n\t\treturn values.own === values.member;\n\t});\n};\n\ncomparisons.NotIn.test = function(values, b) {\n\treturn !comparisons.In.test(values, b);\n};\ncomparisons.NotIn.testValue = function(value, b) {\n\treturn !comparisons.In.testValue(value, b);\n};\n\nfunction nullIsFalse(test) {\n\treturn function(arg1, arg2) {\n\t\tif (arg1 == null || arg2 == null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn test(arg1, arg2);\n\t\t}\n\t};\n}\n\nfunction nullIsFalseTwoIsOk(test) {\n\treturn function(arg1, arg2) {\n\t\tif (arg1 === arg2) {\n\t\t\treturn true;\n\t\t} else if (arg1 == null || arg2 == null) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn test(arg1, arg2);\n\t\t}\n\t};\n}\n\ncomparisons.GreaterThan.test = nullIsFalse(function(a, b) {\n\treturn a > b;\n});\ncomparisons.GreaterThanEqual.test = nullIsFalseTwoIsOk(function(a, b) {\n\treturn a >= b;\n});\ncomparisons.LessThan.test = nullIsFalse(function(a, b) {\n\treturn a < b;\n});\ncomparisons.LessThanEqual.test = nullIsFalseTwoIsOk(function(a, b) {\n\treturn a <= b;\n});\n\n\n\nfunction isMemberThatUsesTest(value) {\n\tvar values = set.ownAndMemberValue(this.value, value);\n\treturn this.constructor.test(values.member, values.own);\n}\n[comparisons.GreaterThan, comparisons.GreaterThanEqual, comparisons.LessThan, comparisons.LessThanEqual, comparisons.LessThan].forEach(function(Type) {\n\tType.prototype.isMember = isMemberThatUsesTest;\n});\n\nfunction isMemberThatUsesTestOnValues(value) {\n\treturn this.constructor.test(this.values, value);\n}\n[comparisons.In, comparisons.NotIn].forEach(function(Type) {\n\tType.prototype.isMember = isMemberThatUsesTestOnValues;\n});\n\ncomparisons.And.prototype.isMember = function(value) {\n\treturn this.values.every(function(and) {\n\t\treturn and.isMember(value);\n\t});\n};\ncomparisons.Or.prototype.isMember = function(value) {\n\treturn this.values.some(function(and) {\n\t\treturn and.isMember(value);\n\t});\n};\nObject.keys(comparisons).forEach(function(name){\n\tcomparisons[name].prototype[isMemberSymbol] = comparisons[name].prototype.isMember;\n});\n\n\n\nfunction makeNot(Type) {\n\treturn {\n\t\ttest: function(vA, vB) {\n\t\t\treturn !Type.test(vA, vB);\n\t\t}\n\t}\n}\n\n\nfunction makeEnum(type, Type, emptyResult) {\n\treturn function(a, b) {\n\t\tvar result = arrayUnionIntersectionDifference(a.values, b.values);\n\t\tif (result[type].length) {\n\t\t\treturn new Type(result[type]);\n\t\t} else {\n\t\t\treturn emptyResult || set.EMPTY;\n\t\t}\n\t};\n}\n\nfunction isUniversal(aSet) {\n\treturn set.isEqual(set.UNIVERSAL, aSet);\n}\n\nfunction swapArgs(fn) {\n\treturn function(a, b) {\n\t\treturn fn(b, a)\n\t};\n}\n\n\nfunction makeSecondValue(Type, prop) {\n\treturn function(universe, value) {\n\t\treturn new Type(value[prop || \"value\"]);\n\t};\n}\n\nfunction returnBiggerValue(gtA, gtB) {\n\tif (gtA.value < gtB.value) {\n\t\treturn gtB;\n\t} else {\n\t\treturn gtA;\n\t}\n}\n\nfunction returnSmallerValue(gtA, gtB) {\n\tif (gtA.value > gtB.value) {\n\t\treturn gtB;\n\t} else {\n\t\treturn gtA;\n\t}\n}\n\nfunction makeAndIf(Comparison, Type) {\n\treturn function(ltA, ltB) {\n\t\tif (Comparison.test(ltA.value, ltB.value)) {\n\t\t\treturn makeAnd([ltA, new Type(ltB.value)]);\n\t\t} else {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t};\n}\n\nfunction make_InIfEqual_else_andIf(Comparison, Type) {\n\tvar elseCase = makeAndIf(Comparison, Type);\n\treturn function(a, b) {\n\t\tif (a.value === b.value) {\n\t\t\treturn new is.In([a.value]);\n\t\t} else {\n\t\t\treturn elseCase(a, b);\n\t\t}\n\t};\n}\n\nfunction make_filterFirstValueAgainstSecond(Comparison, Type, defaultReturn) {\n\treturn function(inSet, gt) {\n\t\tvar values = inSet.values.filter(function(value) {\n\t\t\treturn Comparison.test(gt, value);\n\t\t});\n\t\treturn values.length ?\n\t\t\tnew Type(values) : defaultReturn || set.EMPTY;\n\t};\n}\n\nfunction make_filterFirstValues(Comparison, Type, defaultReturn) {\n\treturn function(inSet, gt) {\n\t\tvar values = inSet.values.filter(function(value) {\n\t\t\treturn Comparison.test(value, gt.value);\n\t\t});\n\t\treturn values.length ?\n\t\t\tnew Type(values) : defaultReturn || set.EMPTY;\n\t};\n}\n\nvar isMemberTest = {\n\ttest: function isMemberTest(set, value) {\n\t\treturn set.isMember(value);\n\t}\n};\nvar returnTrue = {\n\ttest: function returnTrue() {\n\t\treturn true;\n\t}\n};\nvar returnFalse = {\n\ttest: function returnFalse() {\n\t\treturn false;\n\t}\n};\n\nfunction isOr(value) {\n\treturn (value instanceof is.Or);\n}\n\nfunction isAnd(value) {\n\treturn (value instanceof is.And);\n}\n\nfunction isAndOrOr(value) {\n\treturn isAnd(value) || isOr(value);\n}\n\n\n// `value` - has a test function to check values\n// `with` - the type we use to combined with the \"other\" value.\n// `combinedUsing` - If there are values, how do we stick it together with `with`\nfunction combineFilterFirstValues(options) {\n\treturn function(inSet, gt) {\n\t\tvar values = inSet.values.filter(function(value) {\n\t\t\treturn options.values.test(value, gt.value);\n\t\t});\n\t\tvar range = options.with ? new options.with(gt.value) : gt;\n\t\treturn values.length ?\n\t\t\toptions.combinedUsing([new options.arePut(values), range]) : range;\n\t};\n}\n\nfunction combineFilterFirstValuesAgainstSecond(options) {\n\treturn function(inSet, gt) {\n\t\tvar values = inSet.values.filter(function(value) {\n\t\t\treturn options.values.test(gt, value);\n\t\t});\n\t\tvar range\n\t\tif (options.complement) {\n\t\t\trange = set.difference(set.UNIVERSAL, gt);\n\t\t} else if (options.with) {\n\t\t\trange = new options.with(gt.value);\n\t\t} else {\n\t\t\trange = gt;\n\t\t}\n\t\treturn values.length ?\n\t\t\toptions.combinedUsing([new options.arePut(values), range]) : range;\n\t};\n}\n\nfunction makeOrUnless(Comparison, result) {\n\treturn function(setA, setB) {\n\t\tif (Comparison.test(setA.value, setB.value)) {\n\t\t\treturn result || set.UNIVERSAL;\n\t\t} else {\n\t\t\treturn makeOr([setA, setB]);\n\t\t}\n\t}\n}\n\nfunction makeAndUnless(Comparison, result) {\n\treturn function(setA, setB) {\n\t\tif (Comparison.test(setA.value, setB.value)) {\n\t\t\treturn result || set.EMPTY;\n\t\t} else {\n\t\t\treturn makeAnd([setA, setB]);\n\t\t}\n\t}\n}\n\nfunction makeComplementSecondArgIf(Comparison) {\n\treturn function(setA, setB) {\n\t\tif (Comparison.test(setA.value, setB.value)) {\n\t\t\treturn set.difference(set.UNIVERSAL, setB);\n\t\t} else {\n\t\t\treturn setA;\n\t\t}\n\t}\n}\n\n\nfunction makeAnd(ands) {\n\treturn comparisons.And ? new comparisons.And(ands) : set.UNDEFINABLE;\n}\n\nfunction makeOr(ors) {\n\treturn comparisons.Or ? new comparisons.Or(ors) : set.UNDEFINABLE;\n}\n\nvar is = comparisons;\n\nfunction combineValueWithRangeCheck(inSet, rangeSet, RangeOrEqType){\n\tvar gte = new RangeOrEqType(rangeSet.value);\n\tvar leftValues = inSet.values.filter(function(value){\n\t\treturn !gte.isMember(value);\n\t});\n\tif(!leftValues.length) {\n\t\treturn gte;\n\t}\n\n\tif(leftValues.length < inSet.values.length) {\n\t\treturn makeOr([new is.In(leftValues), gte]);\n\t} else {\n\t\treturn makeOr([inSet, rangeSet]);\n\t}\n}\n\n// This tries to unify In([1]) with GT(1) -> GTE(1)\nfunction makeOrWithInAndRange(inSet, rangeSet) {\n\tif(rangeSet instanceof is.Or) {\n\t\tvar firstResult = makeOrWithInAndRange(inSet, rangeSet.values[0]);\n\t\tif( !(firstResult instanceof is.Or) ) {\n\t\t\treturn set.union(firstResult, rangeSet.values[1]);\n\t\t}\n\t\tvar secondResult = makeOrWithInAndRange(inSet, rangeSet.values[1]);\n\t\tif( !(secondResult instanceof is.Or) ) {\n\t\t\treturn set.union(secondResult, rangeSet.values[0]);\n\t\t}\n\t\treturn makeOr([inSet, rangeSet]);\n\t} else {\n\t\tif(rangeSet instanceof is.GreaterThan) {\n\t\t\treturn combineValueWithRangeCheck(inSet, rangeSet, is.GreaterThanEqual);\n\t\t}\n\t\tif(rangeSet instanceof is.LessThan) {\n\t\t\treturn combineValueWithRangeCheck(inSet, rangeSet, is.LessThanEqual);\n\t\t}\n\t\treturn makeOr([inSet, rangeSet]);\n\t}\n}\n\nvar In_RANGE = {\n\tunion: combineFilterFirstValuesAgainstSecond({\n\t\tvalues: makeNot(isMemberTest),\n\t\tarePut: is.In,\n\t\tcombinedUsing: function(ors){\n\t\t\treturn makeOrWithInAndRange(ors[0], ors[1]);\n\t\t}\n\t}),\n\tintersection: make_filterFirstValueAgainstSecond(isMemberTest, is.In, set.EMPTY),\n\tdifference: make_filterFirstValueAgainstSecond(makeNot(isMemberTest), is.In, set.EMPTY)\n};\nvar RANGE_IN = {\n\tdifference: swapArgs(combineFilterFirstValuesAgainstSecond({\n\t\tvalues: isMemberTest,\n\t\tarePut: is.NotIn,\n\t\tcombinedUsing: makeAnd\n\t}))\n};\n\nvar NotIn_RANGE = function() {\n\treturn {\n\t\tunion: make_filterFirstValueAgainstSecond(makeNot(isMemberTest), is.NotIn, set.UNIVERSAL),\n\t\tintersection: combineFilterFirstValuesAgainstSecond({\n\t\t\tvalues: isMemberTest,\n\t\t\tarePut: is.NotIn,\n\t\t\tcombinedUsing: makeAnd\n\t\t}),\n\t\tdifference: combineFilterFirstValuesAgainstSecond({\n\t\t\tvalues: makeNot(isMemberTest),\n\t\t\tarePut: is.NotIn,\n\t\t\tcombinedUsing: makeAnd,\n\t\t\tcomplement: true\n\t\t})\n\t}\n};\nvar RANGE_NotIn = {\n\tdifference: swapArgs(make_filterFirstValueAgainstSecond(isMemberTest, is.In, set.EMPTY))\n};\n\nvar RANGE_And_Union = function(gt, and) {\n\n\tvar union1 = set.union(gt, and.values[0]);\n\tvar union2 = set.union(gt, and.values[1]);\n\n\tif (!isAndOrOr(union1) && !isAndOrOr(union2)) {\n\t\treturn set.intersection(union1, union2);\n\t} else {\n\t\treturn new is.Or([gt, and]);\n\t}\n};\nvar RANGE_And_Intersection = function(gt, and) {\n\tvar and1 = and.values[0],\n\t\tand2 = and.values[1];\n\tvar intersection1 = set.intersection(gt, and1);\n\tvar intersection2 = set.intersection(gt, and2);\n\tif (intersection1 === set.EMPTY || intersection2 === set.EMPTY) {\n\t\treturn set.EMPTY;\n\t}\n\tif (!isAndOrOr(intersection1)) {\n\t\treturn new set.intersection(intersection1, and2);\n\t}\n\n\tif (!isAndOrOr(intersection2)) {\n\t\treturn new set.intersection(intersection2, and1);\n\t} else {\n\t\treturn new is.And([gt, and]);\n\t}\n\n};\n\nvar RANGE_And_Difference = function(gt, and) {\n\tvar and1 = and.values[0],\n\t\tand2 = and.values[1];\n\tvar difference1 = set.difference(gt, and1);\n\tvar difference2 = set.difference(gt, and2);\n\tif (difference1 === set.EMPTY) {\n\t\treturn difference2;\n\t}\n\tif (difference2 === set.EMPTY) {\n\t\treturn difference1;\n\t}\n\treturn new is.Or([difference1, difference2]);\n};\n\nvar And_RANGE_Difference = function(and, gt) {\n\tvar and1 = and.values[0],\n\t\tand2 = and.values[1];\n\tvar difference1 = set.difference(and1, gt);\n\tvar difference2 = set.difference(and2, gt);\n\n\treturn set.intersection(difference1, difference2);\n};\n\nvar RANGE_Or = {\n\tunion: function(gt, or) {\n\t\tvar or1 = or.values[0],\n\t\t\tor2 = or.values[1];\n\t\tvar union1 = set.union(gt, or1);\n\t\tif (!isAndOrOr(union1)) {\n\t\t\treturn set.union(union1, or2);\n\t\t}\n\t\tvar union2 = set.union(gt, or2);\n\t\tif (!isAndOrOr(union2)) {\n\t\t\treturn set.union(or1, union2);\n\t\t} else {\n\t\t\treturn new is.Or([gt, or]);\n\t\t}\n\t},\n\tintersection: function(gt, or) {\n\t\tvar or1 = or.values[0],\n\t\t\tor2 = or.values[1];\n\t\tvar intersection1 = set.intersection(gt, or1);\n\t\tvar intersection2 = set.intersection(gt, or2);\n\t\tif (intersection1 === set.EMPTY) {\n\t\t\treturn intersection2;\n\t\t}\n\t\tif (intersection2 === set.EMPTY) {\n\t\t\treturn intersection1;\n\t\t}\n\t\treturn set.union(intersection1, intersection2);\n\t},\n\t// v \\ (a || b) -> (v \\ a) n (v \\ b)\n\tdifference: function(gt, or) {\n\n\t\tvar or1 = or.values[0],\n\t\t\tor2 = or.values[1];\n\t\tvar difference1 = set.difference(gt, or1);\n\t\tvar difference2 = set.difference(gt, or2);\n\t\treturn set.intersection(difference1, difference2);\n\t}\n};\n\nvar Or_RANGE = {\n\t// ( a || b ) \\ v -> (a \\ v) U (b \\ v)\n\tdifference: function(or, gt) {\n\t\tvar or1 = or.values[0],\n\t\t\tor2 = or.values[1];\n\t\tvar difference1 = set.difference(or1, gt);\n\t\tvar difference2 = set.difference(or2, gt);\n\t\treturn set.union(difference1, difference2);\n\t}\n};\n\n\nvar comparators = {\n\t// In\n\tIn_In: {\n\t\tunion: makeEnum(\"union\", is.In),\n\t\tintersection: makeEnum(\"intersection\", is.In),\n\t\tdifference: makeEnum(\"difference\", is.In)\n\t},\n\tUNIVERSAL_In: {\n\t\tdifference: makeSecondValue(is.NotIn, \"values\")\n\t},\n\n\tIn_NotIn: {\n\t\tunion: swapArgs(makeEnum(\"difference\", is.NotIn, set.UNIVERSAL)),\n\t\t// what does In have on its own\n\t\tintersection: makeEnum(\"difference\", is.In),\n\t\tdifference: makeEnum(\"intersection\", is.In)\n\t},\n\tNotIn_In: {\n\t\tdifference: makeEnum(\"union\", is.NotIn)\n\t},\n\n\tIn_GreaterThan: In_RANGE,\n\tGreaterThan_In: RANGE_IN,\n\n\tIn_GreaterThanEqual: In_RANGE,\n\tGreaterThanEqual_In: RANGE_IN,\n\n\tIn_LessThan: In_RANGE,\n\tLessThan_In: RANGE_IN,\n\n\tIn_LessThanEqual: In_RANGE,\n\tLessThanEqual_In: RANGE_IN,\n\tIn_And: In_RANGE,\n\tAnd_In: RANGE_IN,\n\n\tIn_Or: In_RANGE,\n\tOr_In: RANGE_IN,\n\n\t// NotIn ===============================\n\tNotIn_NotIn: {\n\t\tunion: makeEnum(\"intersection\", is.NotIn, set.UNIVERSAL),\n\t\tintersection: makeEnum(\"union\", is.NotIn),\n\t\tdifference: makeEnum(\"difference\", is.In)\n\t},\n\tUNIVERSAL_NotIn: {\n\t\tdifference: makeSecondValue(is.In, \"values\")\n\t},\n\n\tNotIn_GreaterThan: NotIn_RANGE(),\n\tGreaterThan_NotIn: RANGE_NotIn,\n\n\tNotIn_GreaterThanEqual: NotIn_RANGE(),\n\tGreaterThanEqual_NotIn: RANGE_NotIn,\n\n\tNotIn_LessThan: NotIn_RANGE(),\n\tLessThan_NotIn: RANGE_NotIn,\n\n\tNotIn_LessThanEqual: NotIn_RANGE(),\n\tLessThanEqual_NotIn: RANGE_NotIn,\n\n\tNotIn_And: NotIn_RANGE(),\n\tAnd_NotIn: RANGE_NotIn,\n\n\tNotIn_Or: NotIn_RANGE(),\n\tOr_NotIn: RANGE_NotIn,\n\n\t// GreaterThan ===============================\n\tGreaterThan_GreaterThan: {\n\t\tunion: returnSmallerValue,\n\t\tintersection: returnBiggerValue,\n\t\t// {$gt:5} \\ {gt: 6} -> AND( {$gt:5}, {$lte: 6} )\n\t\tdifference: makeAndIf(is.LessThan, is.LessThanEqual)\n\t},\n\tUNIVERSAL_GreaterThan: {\n\t\tdifference: makeSecondValue(is.LessThanEqual)\n\t},\n\n\tGreaterThan_GreaterThanEqual: {\n\t\tunion: returnSmallerValue,\n\t\tintersection: returnBiggerValue,\n\t\t// {$gt:5} \\ {gte: 6} -> AND( {$gt:5}, {$lt: 6} )\n\t\tdifference: makeAndIf(is.LessThan, is.LessThan)\n\t},\n\tGreaterThanEqual_GreaterThan: {\n\t\tdifference: make_InIfEqual_else_andIf(is.LessThan, is.LessThanEqual)\n\t},\n\n\tGreaterThan_LessThan: {\n\t\tunion: (function(){\n\t\t\tvar makeOrUnlessLessThan = makeOrUnless(is.LessThan);\n\t\t\treturn function greaterThan_lessThan_union(a, b){\n\t\t\t\tif( comparisons.In.test([a.value], b.value) ) {\n\t\t\t\t\treturn new is.NotIn([a.value]);\n\t\t\t\t} else {\n\t\t\t\t\treturn makeOrUnlessLessThan(a, b);\n\t\t\t\t}\n\t\t\t}\n\t\t})(),\n\t\tintersection: makeAndUnless(is.GreaterThan),\n\t\tdifference: makeComplementSecondArgIf(is.LessThan)\n\t},\n\tLessThan_GreaterThan: {\n\t\tdifference: makeComplementSecondArgIf(is.GreaterThan)\n\t},\n\n\tGreaterThan_LessThanEqual: {\n\t\tunion: makeOrUnless(is.LessThanEqual),\n\t\tintersection: makeAndUnless(is.GreaterThanEqual),\n\t\tdifference: makeComplementSecondArgIf(is.LessThanEqual)\n\t},\n\tLessThanEqual_GreaterThan: {\n\t\tdifference: makeComplementSecondArgIf(is.GreaterThanEqual)\n\t},\n\n\tGreaterThan_And: {\n\t\tunion: RANGE_And_Union,\n\t\tintersection: RANGE_And_Intersection,\n\t\tdifference: RANGE_And_Difference\n\t},\n\tAnd_GreaterThan: {\n\t\tdifference: And_RANGE_Difference\n\t},\n\tGreaterThan_Or: RANGE_Or,\n\tOr_GreaterThan: Or_RANGE,\n\n\t// GreaterThanEqual =========\n\tGreaterThanEqual_GreaterThanEqual: {\n\t\tunion: returnSmallerValue,\n\t\tintersection: returnBiggerValue,\n\t\t// {gte: 2} \\ {gte: 3} = {gte: 2} AND {lt: 3}\n\t\tdifference: makeAndIf(is.LessThan, is.LessThan)\n\t},\n\tUNIVERSAL_GreaterThanEqual: {\n\t\tdifference: makeSecondValue(is.LessThan)\n\t},\n\n\tGreaterThanEqual_LessThan: {\n\t\tunion: makeOrUnless(is.LessThanEqual),\n\t\tintersection: makeAndUnless(is.GreaterThanEqual),\n\t\tdifference: makeComplementSecondArgIf(is.LessThanEqual)\n\t},\n\tLessThan_GreaterThanEqual: {\n\t\tdifference: makeComplementSecondArgIf(is.GreaterThanEqual)\n\t},\n\n\tGreaterThanEqual_LessThanEqual: {\n\t\tunion: makeOrUnless(is.LessThanEqual),\n\t\t// intersect on a number\n\t\tintersection: (function() {\n\t\t\tvar makeAnd = makeAndUnless(is.GreaterThan);\n\t\t\treturn function gte_lte_intersection(gte, lte) {\n\t\t\t\tvar inSet = new is.In([gte.value]);\n\t\t\t\tif (inSet.isMember(lte.value)) {\n\t\t\t\t\treturn inSet\n\t\t\t\t} else {\n\t\t\t\t\treturn makeAnd(gte, lte);\n\t\t\t\t}\n\t\t\t};\n\t\t})(),\n\t\tdifference: makeComplementSecondArgIf(is.LessThanEqual)\n\t},\n\tLessThanEqual_GreaterThanEqual: {\n\t\tdifference: makeComplementSecondArgIf(is.GreaterThanEqual)\n\t},\n\n\tGreaterThanEqual_And: {\n\t\tunion: RANGE_And_Union,\n\t\tintersection: RANGE_And_Intersection,\n\t\tdifference: RANGE_And_Difference\n\t},\n\tAnd_GreaterThanEqual: {\n\t\tdifference: And_RANGE_Difference\n\t},\n\tGreaterThanEqual_Or: RANGE_Or,\n\tOr_GreaterThanEqual: Or_RANGE,\n\n\t// LessThan\n\tLessThan_LessThan: {\n\t\tunion: returnBiggerValue,\n\t\tintersection: returnSmallerValue,\n\t\tdifference: makeAndIf(is.GreaterThan, is.GreaterThanEqual)\n\t},\n\tUNIVERSAL_LessThan: {\n\t\tdifference: makeSecondValue(is.GreaterThanEqual)\n\t},\n\n\tLessThan_LessThanEqual: {\n\t\tunion: returnBiggerValue,\n\t\tintersection: returnSmallerValue,\n\t\t// {lt: 3} \\ {lte: 2} -> {lt: 3} AND {gt: 2}\n\t\tdifference: makeAndIf(is.GreaterThan, is.GreaterThan)\n\t},\n\tLessThanEqual_LessThan: {\n\t\tdifference: make_InIfEqual_else_andIf(is.GreaterThanEqual, is.GreaterThanEqual)\n\t},\n\n\tLessThan_And: {\n\t\tunion: RANGE_And_Union,\n\t\tintersection: RANGE_And_Intersection,\n\t\tdifference: RANGE_And_Difference\n\t},\n\tAnd_LessThan: {\n\t\tdifference: And_RANGE_Difference\n\t},\n\tLessThan_Or: RANGE_Or,\n\tOr_LessThan: Or_RANGE,\n\n\t// LessThanEqual\n\tLessThanEqual_LessThanEqual: {\n\t\tunion: returnBiggerValue,\n\t\tintersection: returnSmallerValue,\n\t\tdifference: function(lteA, lteB) {\n\t\t\tif (lteA.value >= lteB.value) {\n\t\t\t\treturn makeAnd([lteA, new is.GreaterThan(lteB.value)]);\n\t\t\t} else {\n\t\t\t\treturn set.EMPTY;\n\t\t\t}\n\t\t}\n\t},\n\tUNIVERSAL_LessThanEqual: {\n\t\tdifference: makeSecondValue(is.GreaterThan)\n\t},\n\n\tLessThanEqual_And: {\n\t\tunion: RANGE_And_Union,\n\t\tintersection: RANGE_And_Intersection,\n\t\tdifference: RANGE_And_Difference\n\t},\n\tAnd_LessThanEqual: {\n\t\tdifference: And_RANGE_Difference\n\t},\n\tLessThanEqual_Or: RANGE_Or,\n\tOr_LessThanEqual: Or_RANGE,\n\n\t// AND =====\n\tAnd_And: {\n\t\t// (a n b) U (c n d) => (a U c) n (b U d)?\n\t\t// union both ways ... if one is unviersal, the other is the result.\n\t\t// (a ∩ b) ∪ (c ∩ d) where Z = (a ∩ b)\n\t\t// -> Z ∪ (c ∩ d)\n\t\t// -> (Z ∪ c) ∩ (Z ∪ d)\n\t\t// -> ((a ∩ b) ∪ c) ∪ ((a ∩ b) ∪ d)\n\t\tunion: function(and1, and2) {\n\t\t\tvar union1 = set.union(and1, and2.values[0]);\n\t\t\tvar union2 = set.union(and1, and2.values[1]);\n\n\t\t\tif (isAndOrOr(union1) || isAndOrOr(union2)) {\n\t\t\t\t// try the other direction\n\t\t\t\tunion1 = set.union(and2, and1.values[0]);\n\t\t\t\tunion2 = set.union(and2, and1.values[1]);\n\t\t\t}\n\t\t\tif (isAndOrOr(union1) || isAndOrOr(union2)) {\n\t\t\t\treturn new is.Or([and1, and2]);\n\t\t\t} else {\n\t\t\t\treturn set.intersection(union1, union2);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tvar combo1 = [\n\t\t\t\t\tset.union(and1.values[0], and2.values[0]),\n\t\t\t\t\tset.union(and1.values[1], and2.values[1])\n\t\t\t\t],\n\t\t\t\tcombo2 = [\n\t\t\t\t\tset.union(and1.values[0], and2.values[1]),\n\t\t\t\t\tset.union(and1.values[1], and2.values[0])\n\t\t\t\t];\n\t\t\tif(combo1.every(isUniversal)) {\n\t\t\t\treturn set.intersection.apply(set, combo2);\n\t\t\t}\n\t\t\tif(combo2.every(isUniversal)) {\n\t\t\t\treturn set.intersection.apply(set, combo1);\n\t\t\t}\n\t\t\treturn new is.Or([and1, and2]);*/\n\t\t},\n\n\t\tintersection: function(and1, and2) {\n\t\t\tvar intersection1 = set.intersection(and1.values[0], and2.values[0]);\n\t\t\tvar intersection2 = set.intersection(and1.values[1], and2.values[1]);\n\n\t\t\tif (!isAndOrOr(intersection1) || !isAndOrOr(intersection2)) {\n\t\t\t\treturn set.intersection(intersection1, intersection2);\n\t\t\t}\n\t\t\tintersection1 = set.intersection(and1.values[0], and2.values[1]);\n\t\t\tintersection2 = set.intersection(and1.values[1], and2.values[0]);\n\n\t\t\tif (!isAndOrOr(intersection1) || !isAndOrOr(intersection2)) {\n\t\t\t\treturn set.intersection(intersection1, intersection2);\n\t\t\t} else {\n\t\t\t\treturn new is.And([and1, and2]);\n\t\t\t}\n\t\t},\n\t\t// (a ∩ b) \\ (c ∩ d) where Z = (a ∩ b)\n\t\t// -> Z \\ (c ∩ d)\n\t\t// -> (Z \\ c) ∪ (Z \\ d)\n\t\t// -> ((a ∩ b) \\ c) ∪ ((a ∩ b) \\ d)\n\t\tdifference: (function() {\n\n\t\t\treturn function(and1, and2) {\n\t\t\t\tvar d1 = set.difference(and1, and2.values[0]);\n\t\t\t\tvar d2 = set.difference(and1, and2.values[1]);\n\t\t\t\treturn set.union(d1, d2);\n\t\t\t}\n\t\t\t/*\n\t\t\tfunction getDiffIfPartnerIsEmptyAndOtherComboNotDisjoint(inOrderDiffs, reverseOrderDiffs, diffedAnd) {\n\t\t\t\tvar diff;\n\t\t\t\tif(inOrderDiffs[0] === set.EMPTY) {\n\t\t\t\t\tdiff = inOrderDiffs[1];\n\t\t\t\t}\n\t\t\t\tif(inOrderDiffs[1] === set.EMPTY) {\n\t\t\t\t\tdiff = inOrderDiffs[0];\n\t\t\t\t}\n\t\t\t\tif(diff) {\n\t\t\t\t\t// check if a diff equals itself (and therefor is disjoint)\n\n\t\t\t\t\tif(set.isEqual(diffedAnd.values[0], reverseOrderDiffs[0] ) ) {\n\t\t\t\t\t\t// is disjoint\n\t\t\t\t\t\treturn diffedAnd;\n\t\t\t\t\t}\n\t\t\t\t\tif( set.isEqual(diffedAnd.values[1], reverseOrderDiffs[1] ) ) {\n\t\t\t\t\t\treturn diffedAnd;\n\t\t\t\t\t}\n\t\t\t\t\treturn diff;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn function(and1, and2) {\n\t\t\t\tvar inOrderDiffs = [\n\t\t\t\t\t\tset.difference(and1.values[0], and2.values[0]),\n\t\t\t\t\t\tset.difference(and1.values[1], and2.values[1])\n\t\t\t\t\t],\n\t\t\t\t\treverseOrderDiffs = [\n\t\t\t\t\t\tset.difference(and1.values[0], and2.values[1]),\n\t\t\t\t\t\tset.difference(and1.values[1], and2.values[0])\n\t\t\t\t\t];\n\n\t\t\t\tvar diff = getDiffIfPartnerIsEmptyAndOtherComboNotDisjoint(inOrderDiffs, reverseOrderDiffs, and1);\n\t\t\t\tif(diff) {\n\t\t\t\t\treturn diff;\n\t\t\t\t}\n\t\t\t\tdiff = getDiffIfPartnerIsEmptyAndOtherComboNotDisjoint(reverseOrderDiffs, inOrderDiffs, and1);\n\t\t\t\tif(diff) {\n\t\t\t\t\treturn diff;\n\t\t\t\t} else {\n\t\t\t\t\t// if one is a double And ... that's the outer \\\\ inner\n\t\t\t\t\tif(isAndOrOr(inOrderDiffs[0]) && isAndOrOr(inOrderDiffs[1])) {\n\t\t\t\t\t\treturn new is.Or([inOrderDiffs[0], inOrderDiffs[1]]);\n\t\t\t\t\t} else if( isAndOrOr(reverseOrderDiffs[0]) && isAndOrOr(reverseOrderDiffs[1]) ) {\n\t\t\t\t\t\treturn new is.Or([reverseOrderDiffs[0], reverseOrderDiffs[1]]);\n\t\t\t\t\t}\n\t\t\t\t\treturn set.UNKNOWABLE;\n\t\t\t\t}\n\t\t\t};*/\n\t\t})()\n\t},\n\tAnd_Or: {\n\t\t// (a ∩ b) ∪ (c u d) where Z = (c u d)\n\t\t// -> Z u (a ∩ b)\n\t\t// -> (Z u a) ∩ (Z u b)\n\t\t// -> ((c u d) u a) ∩ ((c u d) u b)\n\t\tunion: function(and, or) {\n\t\t\tvar aUnion = set.union(and.values[0], or);\n\t\t\tvar bUnion = set.union(and.values[1], or);\n\n\t\t\tif (!isAndOrOr(aUnion) || !isAndOrOr(bUnion)) {\n\t\t\t\treturn set.intersection(aUnion, bUnion);\n\t\t\t}\n\n\t\t\treturn new is.Or([and, or]);\n\t\t},\n\t\t// (a ∩ b) ∩ (c u d) where Z = (a ∩ b)\n\t\t// -> Z ∩ (c u d)\n\t\t// -> (Z ∩ c) u (Z ∩ d)\n\t\t// -> (a ∩ b ∩ c) u (a ∩ b ∩ d)\n\t\tintersection: function(and, or) {\n\t\t\tvar aIntersection = set.intersection(and, or.values[0]);\n\t\t\tvar bIntersection = set.intersection(and, or.values[1]);\n\t\t\tif (!isOr(aIntersection) && !isOr(bIntersection)) {\n\t\t\t\treturn set.union(aIntersection, bIntersection);\n\t\t\t}\n\t\t\treturn new is.And([and, or]);\n\t\t},\n\t\t// (a ∩ b) \\ (c u d) where Z = (a ∩ b)\n\t\t// -> Z \\ (c u d)\n\t\t// -> (Z \\ c) ∩ (Z \\ d)\n\t\t// -> ((a ∩ b) \\ c) ∩ ((a ∩ b) \\ d)\n\t\tdifference: function(and, or) {\n\t\t\tvar aDiff = set.difference(and, or.values[0]);\n\t\t\tvar bDiff = set.difference(and, or.values[1]);\n\t\t\treturn set.intersection(aDiff, bDiff);\n\t\t}\n\t},\n\tOr_And: {\n\t\t// (a ∪ b) \\ (c ∩ d) where Z = (a ∪ b)\n\t\t// -> Z \\ (c ∩ d)\n\t\t// -> (Z \\ c) ∪ (Z \\ d)\n\t\t// -> ((a ∪ b) \\ c) ∪ ((a ∪ b) \\ d)\n\t\tdifference: function(or, and) {\n\t\t\tvar aDiff = set.difference(or, and.values[0]);\n\t\t\tvar bDiff = set.difference(or, and.values[1]);\n\t\t\treturn set.union(aDiff, bDiff);\n\t\t}\n\t},\n\tUNIVERSAL_And: {\n\t\tdifference: function(universe, and) {\n\t\t\tvar inverseFirst = set.difference(universe, and.values[0]),\n\t\t\t\tinverseSecond = set.difference(universe, and.values[1]);\n\t\t\treturn set.union(inverseFirst, inverseSecond);\n\t\t}\n\t},\n\n\tOr_Or: {\n\t\t// (a ∪ b) ∪ (c ∪ d)\n\t\tunion: function(or1, or2) {\n\t\t\tvar union1 = set.union(or1.values[0], or2.values[0]);\n\t\t\tvar union2 = set.union(or1.values[1], or2.values[1]);\n\n\t\t\tif (!isAndOrOr(union1) || !isAndOrOr(union2)) {\n\t\t\t\treturn set.union(union1, union2);\n\t\t\t}\n\t\t\tunion1 = set.union(or1.values[0], or2.values[1]);\n\t\t\tunion2 = set.union(or1.values[1], or2.values[0]);\n\n\t\t\tif (!isAndOrOr(union1) || !isAndOrOr(union2)) {\n\t\t\t\treturn set.union(union1, union2);\n\t\t\t} else {\n\t\t\t\treturn new is.Or([or1, or2]);\n\t\t\t}\n\t\t},\n\t\t// (a ∪ b) ∩ (c ∪ d) where Z = (a ∪ b)\n\t\t// -> Z ∩ (c ∪ d)\n\t\t// -> (Z ∩ c) ∪ (Z ∪ d)\n\t\t// -> ((a ∪ b) ∩ c) ∪ ((a ∪ b) ∩ d)\n\t\tintersection: function(or1, or2) {\n\t\t\tvar c = or2.values[0],\n\t\t\t\td = or2.values[1];\n\n\t\t\tvar intersection1 = set.intersection(or1, c);\n\t\t\tvar intersection2 = set.intersection(or1, d);\n\n\t\t\tif (!isOr(intersection1) || !isOr(intersection2)) {\n\t\t\t\treturn set.union(intersection1, intersection2);\n\t\t\t}\n\t\t\tintersection1 = set.union(or2, or1.values[0]);\n\t\t\tintersection2 = set.union(or2, or1.values[1]);\n\n\t\t\tif (!isOr(intersection1) || !isOr(intersection2)) {\n\t\t\t\treturn set.union(intersection1, intersection2);\n\t\t\t} else {\n\t\t\t\treturn new is.Or([or1, or2]);\n\t\t\t}\n\t\t},\n\t\t// (a ∪ b) \\ (c ∪ d) where Z = (a ∪ b)\n\t\t// -> Z \\ (c ∪ d)\n\t\t// -> (Z \\ c) ∩ (Z \\ d)\n\t\t// -> ((a ∪ b) \\ c) ∩ ((a ∪ b) \\ d)\n\t\tdifference: function(or1, or2) {\n\t\t\tvar d1 = set.difference(or1, or2.values[0]);\n\t\t\tvar d2 = set.difference(or1, or2.values[1]);\n\t\t\treturn set.intersection(d1, d2);\n\t\t}\n\t},\n\tUNIVERSAL_Or: {\n\t\tdifference: function(universe, or) {\n\t\t\tvar inverseFirst = set.difference(universe, or.values[0]),\n\t\t\t\tinverseSecond = set.difference(universe, or.values[1]);\n\t\t\treturn set.intersection(inverseFirst, inverseSecond);\n\t\t}\n\t},\n};\n\n// Registers all the comparisons above\nvar names = Object.keys(comparisons);\nnames.forEach(function(name1, i) {\n\tif (!comparators[name1 + \"_\" + name1]) {\n\t\tconsole.warn(\"no \" + name1 + \"_\" + name1);\n\t} else {\n\t\tset.defineComparison(comparisons[name1], comparisons[name1], comparators[name1 + \"_\" + name1]);\n\t}\n\n\tif (!comparators[\"UNIVERSAL_\" + name1]) {\n\t\tconsole.warn(\"no UNIVERSAL_\" + name1);\n\t} else {\n\t\tset.defineComparison(set.UNIVERSAL, comparisons[name1], comparators[\"UNIVERSAL_\" + name1]);\n\t}\n\n\tfor (var j = i + 1; j < names.length; j++) {\n\t\tvar name2 = names[j];\n\t\tif (!comparators[name1 + \"_\" + name2]) {\n\t\t\tconsole.warn(\"no \" + name1 + \"_\" + name2);\n\t\t} else {\n\t\t\tset.defineComparison(comparisons[name1], comparisons[name2], comparators[name1 + \"_\" + name2]);\n\t\t}\n\t\tif (!comparators[name2 + \"_\" + name1]) {\n\t\t\tconsole.warn(\"no \" + name2 + \"_\" + name1);\n\t\t} else {\n\t\t\tset.defineComparison(comparisons[name2], comparisons[name1], comparators[name2 + \"_\" + name1]);\n\t\t}\n\t}\n});\n\nmodule.exports = comparisons;\n","var set = require(\"../set\");\nvar is = require(\"./comparisons\");\n\n// THIS IS REALLY INTEGERS!!!\n\nmodule.exports = function(min, max) {\n\n\n\n\n    function RealNumberRangeInclusive(start, end){\n\n        this.start =  arguments.length > 0 ? +start : min;\n        this.end = arguments.length > 1 ? +end : max;\n\t\tthis.range = new is.And([\n\t\t\tnew is.GreaterThanEqual( this.start ),\n\t\t\tnew is.LessThanEqual( this.end )\n\t\t])\n    }\n\n\tvar universeRange = new RealNumberRangeInclusive( min , max );\n\n    function isUniversal(range) {\n        return set.isSubset(universeRange.range, range.range);\n    }\n\n\tfunction rangeFromAnd(aSet) {\n\t\tvar values = {};\n\t\taSet.values.forEach(function(value){\n\t\t\tif(value instanceof is.GreaterThanEqual) {\n\t\t\t\tvalues.start = value.value;\n\t\t\t}\n\t\t\tif(value instanceof is.GreaterThan) {\n\t\t\t\tvalues.start = value.value+1;\n\t\t\t}\n\t\t\tif(value instanceof is.LessThanEqual) {\n\t\t\t\tvalues.end = value.value;\n\t\t\t}\n\t\t\tif(value instanceof is.LessThan) {\n\t\t\t\tvalues.end = value.value-1;\n\t\t\t}\n\t\t})\n\t\tif(\"start\" in values && \"end\" in values) {\n\t\t\treturn new RealNumberRangeInclusive(values.start, values.end );\n\t\t}\n\t}\n\n\tfunction toRange(aSet) {\n\t\tvar range;\n\t\tif(aSet instanceof is.And) {\n\t\t\trange = rangeFromAnd(aSet);\n\t\t}\n\t\tif(aSet instanceof is.Or) {\n\t\t\t// check if next to each other ...\n\t\t\tvar first = rangeFromAnd(aSet.values[0]),\n\t\t\t\tsecond = rangeFromAnd(aSet.values[1]);\n\t\t\tif(first && second) {\n\t\t\t\tvar firstValues = first.range.values,\n\t\t\t\t\tsecondValues = second.range.values;\n\t\t\t\tif(firstValues[1].value + 1 === secondValues[0].value) {\n\t\t\t\t\trange = new RealNumberRangeInclusive(firstValues[0].value, secondValues[1].value );\n\t\t\t\t}\n\t\t\t\telse if(secondValues[1].value + 1 === firstValues[0].value) {\n\t\t\t\t\trange = new RealNumberRangeInclusive(secondValues[0].value, firstValues[1].value );\n\t\t\t\t} else {\n\t\t\t\t\treturn set.UNDEFINABLE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn set.UNDEFINABLE;\n\t\t\t}\n\t\t}\n\t\tif(range && isUniversal(range)) {\n\t\t\treturn set.UNIVERSAL;\n\t\t} else {\n\t\t\treturn range;\n\t\t}\n\t}\n\n    function intersection(range1, range2){\n\t\tvar intersection = toRange(set.intersection(range1.range, range2.range));\n\t\tif(intersection) {\n\t\t\treturn intersection;\n\t\t} else {\n            return set.EMPTY;\n        }\n    }\n\n    function difference(range1, range2){\n\n\t\tvar difference = toRange( set.difference(range1.range, range2.range) );\n\t\tif(difference) {\n\t\t\treturn difference;\n\t\t} else {\n            return set.EMPTY;\n        }\n    }\n\n    set.defineComparison(RealNumberRangeInclusive, RealNumberRangeInclusive,{\n        union: function(range1, range2){\n\t\t\tvar union = toRange( set.union(range1.range, range2.range) );\n\t\t\tif(union) {\n\t\t\t\treturn union;\n\t\t\t} else {\n\t            return set.EMPTY;\n\t        }\n        },\n        intersection: intersection,\n        difference: difference\n    });\n\n    set.defineComparison(set.UNIVERSAL,RealNumberRangeInclusive, {\n        difference: function(universe, range){\n            if(isUniversal(range)) {\n                return set.EMPTY;\n            } else {\n                return difference(universeRange, range);\n            }\n        }\n    });\n\n    return RealNumberRangeInclusive;\n};\n","/*\n * # types\n * This folder is for SetTypes that are used to compare against a single value.\n * For example, `new comparisons.GreaterThan(5)` is used to compare against \n */\n\n\n\n// this is a placeholder for types that have cycle dependencies\nmodule.exports = {};\n","\nvar set = require(\"../set\");\nvar types = require(\"./types\");\n\n// this is intended to be used for $or ... it\n// ors expected key values\n// `{age: 22}` U `{name: \"Justin\"}`\nfunction ValuesOr(values) {\n    // the if values can be unioned into a single value\n    this.values = values;\n}\n\nValuesOr.prototype.isMember = function(props){\n    return this.values.some(function(value){\n            return value && value.isMember ?\n                value.isMember( props ) : value === props;\n    });\n};\n\n\n// Or comparisons\nset.defineComparison(set.UNIVERSAL, ValuesOr,{\n    difference: function(){\n        return set.UNDEFINABLE;\n    }\n});\n\n\nmodule.exports = types.ValuesOr = ValuesOr;\n","var set = require(\"../set\");\nvar keysLogic = require(\"./types\");\n\nfunction NotIdentity(value) {\n    this.value = value;\n}\n\n// Not comparisons ---------\nvar Identity = set.Identity;\n\n// Only difference is needed w/ universal\nset.defineComparison(set.UNIVERSAL, Identity,{\n    // A \\ B -> what's in b, but not in A\n    difference: function(universe, value){\n        return new NotIdentity(value);\n    }\n});\n\n// Only difference is needed w/ universal\nset.defineComparison(set.UNIVERSAL, NotIdentity,{\n    // A \\ B -> what's in b, but not in A\n    difference: function(universe, not){\n        return not.value;\n    }\n});\n\nset.defineComparison(NotIdentity, NotIdentity,{\n    /*\n    // not 5 and not 6\n    union: function(obj1, obj2){\n        // must unroll the value\n\n    },\n    // {foo: zed, abc: d}\n    intersection: function(obj1, obj2){\n\n    },\n    // A \\ B -> what's in b, but not in A\n    difference: function(obj1, obj2){\n\n    }\n    */\n});\n\n\n\nset.defineComparison(NotIdentity, Identity,{\n    // not 5 and not 6\n    union: function(not, primitive){\n        // NOT(5) U 5\n        if( set.isEqual( not.value, primitive) ) {\n            return set.UNIVERSAL;\n        }\n        // NOT(4) U 6\n        else {\n            throw new Error(\"Not,Identity Union is not filled out\");\n        }\n    },\n    // {foo: zed, abc: d}\n    intersection: function(not, primitive){\n        return set.isEqual( !not.value, primitive ) ? primitive: set.EMPTY;\n    },\n    // A \\ B -> what's in b, but not in A\n    difference: function difference(not, primitive){\n        // NOT(5) \\ 3 -> UNDEFINABLE\n        // NOT(3) \\ 3 -> NOT(3)\n        if(set.isEqual( not.value, primitive )) {\n            return not;\n        } else {\n            return set.UNDEFINABLE;\n        }\n    }\n});\n\nset.defineComparison(Identity, NotIdentity,{\n    difference: function(primitive, not){\n        if(set.isEqual(primitive, not.value)) {\n            return primitive;\n        } else {\n            return set.UNDEFINABLE;\n        }\n    }\n});\n\nmodule.exports = keysLogic.Not = NotIdentity;\n","var set = require(\"../set\");\nvar assign = require(\"can-assign\");\nvar arrayUnionIntersectionDifference = require(\"../array-union-intersection-difference\");\nvar canReflect = require(\"can-reflect\");\nvar canGet = require(\"can-key/get/get\");\nvar canSymbol = require(\"can-symbol\");\nvar canReflect = require(\"can-reflect\");\nvar keysLogic = require(\"./types\");\n\n// Define the sub-types that BasicQuery will use\nfunction KeysAnd(values) {\n\tvar vals = this.values = {};\n\tcanReflect.eachKey(values, function(value, key) {\n\t\tif (canReflect.isPlainObject(value) && !set.isSpecial(value)) {\n\t\t\tvals[key] = new KeysAnd(value);\n\t\t} else {\n\t\t\tvals[key] = value;\n\t\t}\n\t});\n}\n\nvar isMemberSymbol = canSymbol.for(\"can.isMember\");\n\n\nKeysAnd.prototype.isMember = function(props, root, rootKey) {\n\tvar equal = true;\n\tvar preKey = rootKey ? rootKey + \".\" : \"\";\n\tcanReflect.eachKey(this.values, function(value, key) {\n\t\tvar isMember = value && (value[isMemberSymbol] || value.isMember);\n\t\tif (isMember) {\n\t\t\tif (!isMember.call(value, canGet(props, key), root || props, preKey + key)) {\n\t\t\t\tequal = false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (value !== canGet(props, key)) {\n\t\t\t\tequal = false;\n\t\t\t}\n\t\t}\n\t});\n\treturn equal;\n};\n\n\n// ====== DEFINE COMPARISONS ========\n\n// Helpers ----------------------------\nfunction checkIfUniversalAndReturnUniversal(setA) {\n\treturn set.isEqual(setA, set.UNIVERSAL) ? set.UNIVERSAL : setA;\n}\n\nvar MISSING = {};\n\nfunction eachInUnique(a, acb, b, bcb, defaultReturn) {\n\tvar bCopy = assign({}, b),\n\t\tres;\n\tfor (var prop in a) {\n\t\tres = acb(prop, a[prop], (prop in b) ? b[prop] : MISSING, a, b);\n\t\tif (res !== undefined) {\n\t\t\treturn res;\n\t\t}\n\t\tdelete bCopy[prop];\n\t}\n\tfor (prop in bCopy) {\n\t\tres = bcb(prop, MISSING, b[prop], a, b);\n\t\tif (res !== undefined) {\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn defaultReturn;\n}\n\nfunction keyDiff(valuesA, valuesB) {\n\tvar keyResults = arrayUnionIntersectionDifference(\n\t\tObject.keys(valuesA),\n\t\tObject.keys(valuesB));\n\treturn {\n\t\taOnlyKeys: keyResults.difference,\n\t\taAndBKeys: keyResults.intersection,\n\t\tbOnlyKeys: arrayUnionIntersectionDifference(\n\t\t\tObject.keys(valuesB),\n\t\t\tObject.keys(valuesA)).difference\n\t};\n}\n\nfunction notEmpty(value) {\n\treturn value !== set.EMPTY;\n}\n\n// Difference of two ANDs is used two places\nfunction difference(objA, objB) {\n\n\tvar valuesA = objA.values,\n\t\tvaluesB = objB.values,\n\t\tdiff = keyDiff(valuesA, valuesB),\n\t\taOnlyKeys = diff.aOnlyKeys,\n\t\taAndBKeys = diff.aAndBKeys,\n\t\tbOnlyKeys = diff.bOnlyKeys;\n\n\t// check if all aAndB are equal\n\n\t// With the shared keys, perform vA \\ vB difference. If the DIFFERENCE is:\n\t// - EMPTY: vA has nothing outside vB. vA is equal or subset of vB.\n\t//   - IF sB has keys not in sA, the shared keys will be part of the result;\n\t//     OTHERWISE, if all empty, sA is subset of sB, EMPTY will be returned\n\t//                (even if sA has some extra own keys)\n\t// - NON-EMPTY: something in sA that is not in sB\n\t//   Now we need to figure out if it's \"product-able\" or not.\n\t//   Product-able -> some part of B is in A.\n\t//   Perform B ∩ A intersection.  INTERSECTION is:\n\t//   - EMPTY: NOT \"product-able\". DISJOINT.  Must return something.\n\t//   - non-EMPTY: Use to performa  product (in the future.)\n\tvar sharedKeysAndValues = {},\n\t\tproductAbleKeysAndData = {},\n\t\tdisjointKeysAndValues = {};\n\taAndBKeys.forEach(function(key) {\n\t\tvar difference = set.difference(valuesA[key], valuesB[key]);\n\t\tif (difference === set.EMPTY) {\n\t\t\tsharedKeysAndValues[key] = valuesA[key];\n\t\t} else {\n\t\t\tvar intersection = set.intersection(valuesA[key], valuesB[key]);\n\t\t\tvar isProductable = intersection !== set.EMPTY\n\t\t\tif (isProductable) {\n\t\t\t\tproductAbleKeysAndData[key] = {\n\t\t\t\t\t// Products with `difference U intersection` would be subtracted\n\t\t\t\t\t// from produts with `intersection`\n\t\t\t\t\tdifference: difference,\n\t\t\t\t\tintersection: intersection\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdisjointKeysAndValues[key] = valuesA[key];\n\t\t\t}\n\t\t}\n\t});\n\tvar productAbleKeys = Object.keys(productAbleKeysAndData);\n\tvar singleProductKeyAndValue;\n\tif (productAbleKeys.length === 1) {\n\t\tsingleProductKeyAndValue = {};\n\t\tsingleProductKeyAndValue[productAbleKeys[0]] = productAbleKeysAndData[productAbleKeys[0]].difference;\n\t}\n\n\t// Now that we've got the shared keys organized\n\t// we can make decisions based on this information\n\t// and A-only and B-only keys.\n\n\t// if we have any disjoint keys, these sets can not intersect\n\t// {age: 21, ...} \\ {age: 22, ...} ->  {age: 21, ...}\n\tif (Object.keys(disjointKeysAndValues).length) {\n\t\treturn objA;\n\t}\n\n\t// contain all the same keys\n\tif ((aOnlyKeys.length === 0) && (bOnlyKeys.length === 0)) {\n\t\tif (productAbleKeys.length > 1) {\n\t\t\treturn set.UNDEFINABLE;\n\t\t}\n\t\t// {color: [RED, GREEN], ...X...} \\ {color: [RED], ...X...} -> {color: [GREEN], ...X...}\n\t\telse if (productAbleKeys.length === 1) {\n\t\t\tassign(sharedKeysAndValues, singleProductKeyAndValue);\n\t\t\treturn new KeysAnd(sharedKeysAndValues);\n\t\t} else {\n\t\t\t// {...X...} \\ {...X...} -> EMPTY\n\t\t\treturn set.EMPTY;\n\t\t}\n\t}\n\t// sA is likely a subset of sB\n\tif (aOnlyKeys.length > 0 && bOnlyKeys.length === 0) {\n\t\tif (productAbleKeys.length > 1) {\n\t\t\treturn set.UNDEFINABLE;\n\t\t}\n\t\t// {age: 35, color: [RED, GREEN], ...X...} \\ {color: [RED], ...X...} -> {age: 35, color: [GREEN], ...X...}\n\t\telse if (productAbleKeys.length === 1) {\n\t\t\tassign(sharedKeysAndValues, singleProductKeyAndValue);\n\t\t\taOnlyKeys.forEach(function(key) {\n\t\t\t\tsharedKeysAndValues[key] = valuesA[key];\n\t\t\t});\n\t\t\treturn new KeysAnd(sharedKeysAndValues);\n\t\t} else {\n\t\t\t// sharedKeysAndValues\n\t\t\treturn set.EMPTY;\n\t\t}\n\t}\n\t// sB is likely subset of sA\n\t// {}, {foo: \"bar\"} -> {foo: NOT(\"bar\")}\n\tif (aOnlyKeys.length === 0 && bOnlyKeys.length > 0) {\n\t\t// Lets not figure out productAbleKeys right now.\n\t\t// Example:\n\t\t// {color: [RED, GREEN], ...X...}\n\t\t// \\ {age: 35, color: [RED], ...X...}\n\t\t// = OR( {color: [GREEN], ...X...}, {age: NOT(35), color: [RED], ...X...} )\n\t\tif (productAbleKeys.length > 1) {\n\t\t\treturn set.UNDEFINABLE;\n\t\t}\n\t\tvar productAbleOr;\n\t\tif (productAbleKeys.length === 1) {\n\t\t\t// we add the intersection to the AND\n\t\t\t// the difference is the or\n\t\t\tvar productableKey = productAbleKeys[0];\n\t\t\tproductAbleOr = assign({}, sharedKeysAndValues);\n\t\t\tproductAbleOr[productableKey] = productAbleKeysAndData[productableKey].difference;\n\t\t\tsharedKeysAndValues[productableKey] = productAbleKeysAndData[productableKey].intersection;\n\t\t}\n\n\t\tvar ands = bOnlyKeys.map(function(key) {\n\t\t\tvar shared = assign({}, sharedKeysAndValues);\n\t\t\tvar result = shared[key] = set.difference(set.UNIVERSAL, valuesB[key]);\n\t\t\treturn result === set.EMPTY ? result : new KeysAnd(shared);\n\t\t}).filter(notEmpty);\n\n\t\tif (productAbleOr) {\n\t\t\tands.push(new KeysAnd(productAbleOr))\n\t\t}\n\n\t\t// {c: \"g\"}\n\t\t// \\ {c: \"g\", age: 22, name: \"justin\"}\n\t\t// = OR[ AND(name: NOT(\"justin\"), c:\"g\"), AND(age: NOT(22), c: \"g\") ]\n\t\tif (ands.length > 1) {\n\t\t\treturn new keysLogic.ValuesOr(ands);\n\t\t} else if (ands.length === 1) {\n\t\t\t// {c: \"g\"}\n\t\t\t// \\ {c: \"g\", age: 22}\n\t\t\t// = AND(age: NOT(22), c: \"g\")\n\t\t\treturn ands[0];\n\t\t} else {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t}\n\n\t// {name: \"Justin\"} \\\\ {age: 35} -> {name: \"Justin\", age: NOT(35)}\n\tif (aOnlyKeys.length > 0 && bOnlyKeys.length > 0) {\n\t\tif (productAbleKeys.length) {\n\t\t\tthrow new Error(\"Can't handle any productable keys right now\")\n\t\t}\n\t\t// add everything in sA into the result:\n\t\taOnlyKeys.forEach(function(key) {\n\t\t\tsharedKeysAndValues[key] = valuesA[key];\n\t\t});\n\n\t\tif (bOnlyKeys.length === 1) {\n\t\t\t// TODO: de-duplicate below\n\t\t\tvar key = bOnlyKeys[0];\n\t\t\tvar shared = assign({}, sharedKeysAndValues);\n\t\t\tshared[key] = set.difference(set.UNIVERSAL, valuesB[key]);\n\t\t\treturn new KeysAnd(shared);\n\t\t}\n\t\t// {foo: \"bar\"} \\\\ {name: \"Justin\", age: 35} -> UNDEFINABLE\n\t\telse {\n\t\t\treturn set.UNDEFINABLE;\n\t\t}\n\n\t}\n}\n\n// KeysAnd comaprisons\n\n\n\n\nset.defineComparison(KeysAnd, KeysAnd, {\n\t// {name: \"Justin\"} or {age: 35} -> new OR[{name: \"Justin\"},{age: 35}]\n\t// {age: 2} or {age: 3} -> {age: new OR[2,3]}\n\t// {age: 3, name: \"Justin\"} OR {age: 4} -> {age: 3, name: \"Justin\"} OR {age: 4}\n\tunion: function(objA, objB) {\n\t\t// first see if we can union a single property\n\t\t// {age: 21, color: [\"R\"]} U {age: 21, color: [\"B\"]} -> {age: 21, color: [\"R\",\"B\"]}\n\n\t\tvar diff = keyDiff(objA.values, objB.values);\n\n\n\t\t// find the different keys\n\t\tvar aAndBKeysThatAreNotEqual = [],\n\t\t\tsameKeys = {};\n\n\t\tdiff.aAndBKeys.forEach(function(key) {\n\t\t\tif (!set.isEqual(objA.values[key], objB.values[key])) {\n\t\t\t\taAndBKeysThatAreNotEqual.push(key)\n\t\t\t} else {\n\t\t\t\tsameKeys[key] = objA.values[key];\n\t\t\t}\n\t\t});\n\t\tvar aUnequal = {}, bUnequal = {};\n\t\taAndBKeysThatAreNotEqual.forEach(function(key){\n\t\t\taUnequal[key] = objA.values[key];\n\t\t\tbUnequal[key] = objB.values[key];\n\t\t});\n\n\t\t// if all keys are shared\n\t\tif (!diff.aOnlyKeys.length && !diff.bOnlyKeys.length) {\n\n\t\t\tif (aAndBKeysThatAreNotEqual.length === 1) {\n\t\t\t\tvar keyValue = aAndBKeysThatAreNotEqual[0];\n\n\t\t\t\tvar result = sameKeys[keyValue] = set.union(objA.values[keyValue], objB.values[keyValue]);\n\n\t\t\t\t// if there is only one property, we can just return the universal set\n\t\t\t\treturn canReflect.size(sameKeys) === 1 && set.isEqual(result, set.UNIVERSAL) ?\n\t\t\t\t\tset.UNIVERSAL : new KeysAnd(sameKeys);\n\t\t\t} else if (aAndBKeysThatAreNotEqual.length === 0) {\n\t\t\t\t// these things are equal\n\t\t\t\treturn objA;\n\t\t\t}\n\t\t}\n\t\t// If everything shared is the same\n\t\tif (aAndBKeysThatAreNotEqual.length === 0) {\n\t\t\t// the set with the extra keys is a subset\n\t\t\tif (diff.aOnlyKeys.length > 0 && diff.bOnlyKeys.length === 0) {\n\t\t\t\treturn checkIfUniversalAndReturnUniversal(objB);\n\t\t\t} else if (diff.aOnlyKeys.length === 0 && diff.bOnlyKeys.length > 0) {\n\t\t\t\treturn checkIfUniversalAndReturnUniversal(objA);\n\t\t\t}\n\t\t}\n\t\t// (count > 5 && age > 25 ) || (count > 7 && age > 35 && name > \"Justin\" )\n\t\t//\n\t\t// ( age > 25 ) || ( name > \"Justin\" && age > 35)  A U (B & C) => (A U B) & (A U C)\n\t\t// ( age > 25 || name > \"Justin\" ) && (age > 25)\n\t\t// lets see if one side is different\n\t\tif (diff.aOnlyKeys.length > 0 && diff.bOnlyKeys.length === 0) {\n\t\t\t// collect shared value\n\t\t\tif( set.isSubset(new KeysAnd(aUnequal), new KeysAnd(bUnequal) )) {\n\t\t\t\treturn objB;\n\t\t\t}\n\t\t}\n\t\tif (diff.bOnlyKeys.length > 0 && diff.aOnlyKeys.length === 0) {\n\t\t\t// collect shared value\n\t\t\tif( set.isSubset(new KeysAnd(bUnequal),  new KeysAnd(aUnequal) )) {\n\t\t\t\treturn objA;\n\t\t\t}\n\t\t}\n\n\t\treturn new keysLogic.ValuesOr([objA, objB]);\n\t},\n\t// {foo: zed, abc: d}\n\tintersection: function(objA, objB) {\n\t\t// combine all properties ... if the same property, try to take\n\t\t// an intersection ... if an intersection isn't possible ... freak out?\n\t\tvar valuesA = objA.values,\n\t\t\tvaluesB = objB.values,\n\t\t\tfoundEmpty = false;\n\t\tvar resultValues = {};\n\t\teachInUnique(valuesA,\n\t\t\tfunction(prop, aVal, bVal) {\n\t\t\t\tresultValues[prop] = bVal === MISSING ? aVal : set.intersection(aVal, bVal);\n\t\t\t\tif (resultValues[prop] === set.EMPTY) {\n\t\t\t\t\tfoundEmpty = true;\n\t\t\t\t}\n\t\t\t},\n\t\t\tvaluesB,\n\t\t\tfunction(prop, aVal, bVal) {\n\t\t\t\tresultValues[prop] = bVal;\n\t\t\t\tif (resultValues[prop] === set.EMPTY) {\n\t\t\t\t\tfoundEmpty = true;\n\t\t\t\t}\n\t\t\t});\n\t\tif (foundEmpty) {\n\t\t\treturn set.EMPTY;\n\t\t} else {\n\t\t\treturn new KeysAnd(resultValues);\n\t\t}\n\n\t},\n\t// A \\ B -> what's in A, but not in B\n\tdifference: difference\n});\n\nset.defineComparison(set.UNIVERSAL, KeysAnd, {\n\t// A \\ B -> what's in A, but not in B\n\tdifference: function(universe, and) {\n\t\treturn difference({\n\t\t\tvalues: {}\n\t\t}, and);\n\t}\n});\n\n\nmodule.exports = keysLogic.KeysAnd = KeysAnd;\n","var ValuesOr = require(\"./values-or\");\nvar ValuesNot = require(\"./values-not\");\nvar KeysAnd = require(\"./keys-and\");\n\nmodule.exports = {\n    KeysAnd: KeysAnd,\n    ValuesOr: ValuesOr,\n    ValuesNot: ValuesNot\n};\n","var canReflect = require(\"can-reflect\");\nvar defaultCompare = {\n    $gt: function(valueA, valueB) {\n        return valueA > valueB;\n    },\n    $lt: function(valueA, valueB) {\n        return valueA < valueB;\n    }\n};\n\nvar helpers =  {\n    // given two arrays of items, combines and only returns the unique ones\n    uniqueConcat: function(itemsA, itemsB, getId) {\n        var ids = new Set();\n        return itemsA.concat(itemsB).filter(function(item){\n            var id = getId(item);\n            if(!ids.has(id)) {\n                ids.add(id);\n                return true;\n            } else {\n                return false;\n            }\n        });\n    },\n    //\n    getIndex: function(compare, items, props){\n        if(!items || !items.length) {\n            return undefined;\n        }\n        // check the start and the end\n        if( compare(props, items[0]) === -1 ) {\n            return 0;\n        }\n        else if(compare(props, items[items.length -1] ) === 1 ) {\n            return items.length;\n        }\n        var low = 0,\n            high = items.length;\n\n        // From lodash lodash 4.6.1 <https://lodash.com/>\n        // Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n        while (low < high) {\n            var mid = (low + high) >>> 1,\n                item = items[mid],\n                computed = compare(props, item);\n            if ( computed === -1 ) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n        // bisect by calling sortFunc\n    },\n    sortData: function (sortPropValue) {\n        if(sortPropValue[0] === \"-\") {\n            return {prop: sortPropValue.slice(1), desc: true};\n        } else {\n            return {prop: sortPropValue, desc: false};\n        }\n    },\n    defaultCompare: defaultCompare,\n    sorter: function (sortPropValue, sorters) {\n        var data = helpers.sortData(sortPropValue);\n        var compare;\n        if(sorters && sorters[data.prop]) {\n            compare = sorters[data.prop];\n        } else {\n            compare = defaultCompare;\n        }\n        return function(item1, item2){\n            var item1Value = canReflect.getKeyValue(item1, data.prop);\n            var item2Value = canReflect.getKeyValue(item2, data.prop);\n            var temp;\n\n            if(data.desc) {\n                temp = item1Value;\n                item1Value = item2Value;\n                item2Value = temp;\n            }\n\n            if( compare.$lt( item1Value, item2Value) ) {\n                return -1;\n            }\n\n            if( compare.$gt( item1Value, item2Value)) {\n                return 1;\n            }\n\n            return 0;\n        };\n    },\n\t\tvalueHydrator: function(value){\n\t\t\t\tif(canReflect.isBuiltIn(value)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"can-query-logic doesn't support comparison operator: \"+JSON.stringify(value));\n\t\t\t\t}\n\t\t}\n};\nmodule.exports = helpers;\n","var set = require(\"../set\");\nvar makeRealNumberRangeInclusive = require(\"./make-real-number-range-inclusive\");\nvar assign = require(\"can-assign\");\nvar canReflect = require(\"can-reflect\");\nvar andOrNot = require(\"./and-or-not\");\nvar helpers = require(\"../helpers\");\nvar defineLazyValue = require(\"can-define-lazy-value\");\nvar canSymbol = require(\"can-symbol\");\nvar isMemberSymbol = canSymbol.for(\"can.isMember\");\n\n// TYPES FOR FILTERING\nvar KeysAnd = andOrNot.KeysAnd,\n\tOr = andOrNot.ValuesOr,\n\tNot = andOrNot.ValuesNot;\n\n// TYPES FOR PAGINATION\nvar RecordRange = makeRealNumberRangeInclusive(0, Infinity);\n\n// WILL MAKE A TYPE FOR SORTING\nfunction makeSort(schemaKeys, hydrateAndValue){\n\t// Makes gt and lt functions that `helpers.sorter` can use\n\t// to make a `compare` function for `Array.sort(compare)`.`\n\tvar sorters = {};\n    canReflect.eachKey(schemaKeys, function(schemaProp, key){\n\n        sorters[key] = {\n            // valueA is GT valueB\n            $gt: function(valueA, valueB) {\n                var $gt = hydrateAndValue({$gt: valueB}, key, schemaProp,\n\t\t\t\t\t\t\t\t\thelpers.valueHydrator);\n                return $gt[isMemberSymbol](valueA);\n            },\n            $lt: function( valueA, valueB ){\n                var $lt = hydrateAndValue({$lt: valueB}, key, schemaProp,\n\t\t\t\t\t\t\t\t\thelpers.valueHydrator);\n                return $lt[isMemberSymbol](valueA);\n            }\n        };\n    });\n\n\tfunction Sort(key) {\n\t\tthis.key = key;\n\t\tthis.compare = helpers.sorter(key, sorters);\n\t}\n\n\tfunction identityIntersection(v1, v2) {\n\t\treturn v1.key === v2.key ? v1 : set.EMPTY;\n\t}\n\tfunction identityDifference(v1, v2) {\n\t\treturn v1.key === v2.key ? set.EMPTY : v1;\n\t}\n\tfunction identityUnion(v1, v2) {\n\t\treturn v1.key === v2.key ? v1 : set.UNDEFINABLE;\n\t}\n\tset.defineComparison(Sort, Sort, {\n\t\tintersection: identityIntersection,\n\t\tdifference: identityDifference,\n\t\tunion: identityUnion\n\t});\n\treturn Sort;\n}\n\nvar DefaultSort = makeSort({});\n\n\n// Define the BasicQuery type\nfunction BasicQuery(query) {\n\tassign(this, query);\n\tif (!this.filter) {\n\t\tthis.filter = set.UNIVERSAL;\n\t}\n\tif (!this.page) {\n\t\tthis.page = new RecordRange();\n\t}\n\tif (!this.sort) {\n\t\tthis.sort = \"id\";\n\t}\n\tif(typeof this.sort === \"string\") {\n\t\tthis.sort = new DefaultSort(this.sort);\n\t}\n}\n\n// BasicQuery's static properties\nBasicQuery.KeysAnd = KeysAnd;\nBasicQuery.Or = Or;\nBasicQuery.Not = Not;\nBasicQuery.RecordRange = RecordRange;\nBasicQuery.makeSort = makeSort;\n\n// BasicQuery's prototype methods.\n// These are \"additional\" features beyond what `set` provides.\n// These typically pertain to actual data results of a query.\ncanReflect.assignMap(BasicQuery.prototype, {\n\tcount: function() {\n\t\treturn this.page.end - this.page.start + 1;\n\t},\n\tsortData: function(data) {\n\t\treturn data.slice(0).sort(this.sort.compare);\n\t},\n\tfilterMembersAndGetCount: function(bData, parentQuery) {\n\t\tif (parentQuery) {\n\t\t\tif (!set.isSubset(this, parentQuery)) {\n\t\t\t\tthrow new Error(\"can-query-logic: Unable to get members from a set that is not a superset of the current set.\");\n\t\t\t}\n\t\t} else {\n\t\t\tparentQuery = new BasicQuery();\n\t\t}\n\n\t\t// reduce response to items in data that meet where criteria\n\t\tvar aData = bData.filter(function(data) {\n\t\t\treturn this.filter.isMember(data);\n\t\t}, this);\n\n\t\tvar count = aData.length;\n\n\t\t// sort the data if needed\n\t\tif (count && (this.sort.key !== parentQuery.sort.key)) {\n\t\t\taData = this.sortData(aData);\n\t\t}\n\n\t\tvar thisIsUniversal = set.isEqual(this.page, set.UNIVERSAL),\n\t\t\tparentIsUniversal = set.isEqual(parentQuery.page, set.UNIVERSAL);\n\n\t\tif (parentIsUniversal) {\n\t\t\tif (thisIsUniversal) {\n\t\t\t\treturn {\n\t\t\t\t\tdata: aData,\n\t\t\t\t\tcount: count\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tdata: aData.slice(this.page.start, this.page.end + 1),\n\t\t\t\t\tcount: count\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\t// everything but range is equal\n\t\telse if (this.sort.key === parentQuery.sort.key && set.isEqual(parentQuery.filter, this.filter)) {\n\t\t\treturn {\n\t\t\t\tdata: aData.slice(this.page.start - parentQuery.page.start, this.page.end - parentQuery.page.start + 1),\n\t\t\t\tcount: count\n\t\t\t};\n\t\t} else {\n\t\t\t// parent starts at something ...\n\t\t\tthrow new Error(\"can-query-logic: Unable to get members from the parent set for this subset.\");\n\t\t}\n\t},\n\tfilterFrom: function(bData, parentQuery) {\n\t\treturn this.filterMembersAndGetCount(bData, parentQuery).data;\n\t},\n\tmerge: function(b, aItems, bItems, getId) {\n\t\tvar union = set.union(this, b);\n\n\t\tif (union === set.UNDEFINABLE) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tvar combined = helpers.uniqueConcat(aItems, bItems, getId);\n\t\t\treturn union.sortData(combined);\n\t\t}\n\t},\n\tindex: function(props, items) {\n\t\t// make sure we have the property\n\t\tvar data = helpers.sortData(this.sort.key);\n\t\tif (!canReflect.hasOwnKey(props, data.prop)) {\n\t\t\treturn undefined;\n\t\t}\n\t\t// use the passed sort's compare function\n\t\treturn helpers.getIndex(this.sort.compare, items, props);\n\t},\n\tisMember: function(props) {\n\t\t// Use the AND type for it's isMember method\n\t\treturn this.filter.isMember(props);\n\t},\n\tremovePagination: function(){\n\t\tthis.page = new RecordRange();\n\t}\n});\n\n// Helpers used for the `set` comparators\nvar CLAUSE_TYPES = [\"filter\", \"page\",\"sort\"];\n\nfunction getDifferentClauseTypes(queryA, queryB) {\n\tvar differentTypes = [];\n\n\tCLAUSE_TYPES.forEach(function(clause) {\n\t\tif (!set.isEqual(queryA[clause], queryB[clause])) {\n\t\t\tdifferentTypes.push(clause);\n\t\t}\n\t});\n\n\treturn differentTypes;\n}\n\nfunction isSubset(subLetter, superLetter, meta) {\n\tif (meta[subLetter + \"FilterIsSubset\"]) {\n\t\tif (meta[superLetter + \"PageIsUniversal\"]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn meta[subLetter + \"PageIsSubset\"] && meta.sortIsEqual;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}\n\n// This type contains a bunch of lazy getters that\n// cache their value after being read.\n// This helps performance.\nfunction MetaInformation(queryA, queryB) {\n\tthis.queryA = queryA;\n\tthis.queryB = queryB;\n}\n\ncanReflect.eachKey({\n\t\"pageIsEqual\": function() {\n\t\treturn set.isEqual(this.queryA.page, this.queryB.page);\n\t},\n\t\"aPageIsUniversal\": function() {\n\t\treturn set.isEqual(this.queryA.page, set.UNIVERSAL);\n\t},\n\t\"bPageIsUniversal\": function() {\n\t\treturn set.isEqual(this.queryB.page, set.UNIVERSAL);\n\t},\n\t\"pagesAreUniversal\": function() {\n\t\treturn this.pageIsEqual && this.aPageIsUniversal;\n\t},\n\t\"sortIsEqual\": function() {\n\t\treturn this.queryA.sort.key === this.queryB.sort.key;\n\t},\n\t\"aFilterIsSubset\": function() {\n\t\treturn set.isSubset(this.queryA.filter, this.queryB.filter);\n\t},\n\t\"bFilterIsSubset\": function() {\n\t\treturn set.isSubset(this.queryB.filter, this.queryA.filter);\n\t},\n\t\"aPageIsSubset\": function() {\n\t\treturn set.isSubset(this.queryA.page, this.queryB.page);\n\t},\n\t\"bPageIsSubset\": function() {\n\t\treturn set.isSubset(this.queryB.page, this.queryA.page);\n\t},\n\t\"filterIsEqual\": function() {\n\t\treturn set.isEqual(this.queryA.filter, this.queryB.filter);\n\t},\n\t\"aIsSubset\": function() {\n\t\treturn isSubset(\"a\", \"b\", this);\n\t},\n\t\"bIsSubset\": function() {\n\t\treturn isSubset(\"b\", \"a\", this);\n\t}\n}, function(def, prop) {\n\tdefineLazyValue(MetaInformation.prototype, prop, def);\n});\n\nfunction metaInformation(queryA, queryB) {\n\tvar meta = new MetaInformation(queryA, queryB);\n\treturn meta;\n}\n\n\n// Define comparators\nset.defineComparison(BasicQuery, BasicQuery, {\n\tunion: function(queryA, queryB) {\n\n\t\tvar meta = metaInformation(queryA, queryB);\n\n\n\t\tvar filterUnion = set.union(queryA.filter, queryB.filter);\n\n\t\tif (meta.pagesAreUniversal) {\n\t\t\t// We ignore the sort.\n\t\t\treturn new BasicQuery({\n\t\t\t\tfilter: filterUnion,\n\t\t\t\tsort: meta.sortIsEqual ? queryA.sort.key : undefined\n\t\t\t});\n\t\t}\n\n\n\t\tif (meta.filterIsEqual) {\n\t\t\tif (meta.sortIsEqual) {\n\t\t\t\treturn new BasicQuery({\n\t\t\t\t\tfilter: queryA.filter,\n\t\t\t\t\tsort: queryA.sort.key,\n\t\t\t\t\tpage: set.union(queryA.page, queryB.page)\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (meta.aIsSubset) {\n\t\t\t\t\treturn queryB;\n\t\t\t\t} else if (meta.bIsSubset) {\n\t\t\t\t\treturn queryA;\n\t\t\t\t}\n\t\t\t\t// we can't specify which pagination would bring in everything.\n\t\t\t\t// but a union does exist.\n\t\t\t\treturn set.UNDEFINABLE;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"different filters, non-universal pages\");\n\t\t}\n\t},\n\tintersection: function(queryA, queryB) {\n\n\t\t// {age: 35} U {name: \"JBM\"} -> {age: 35, name: \"JBM\"}\n\n\t\t// { filter: {age: 35},\n\t\t//   page: {0, 10},\n\t\t//   sort: \"foo\" }\n\t\t// U\n\t\t// { filter: {name: \"JBM\"},\n\t\t//   page: {0, 10},\n\t\t//   sort: \"foo\" }\n\n\t\tvar meta = metaInformation(queryA, queryB);\n\n\t\tif (meta.pagesAreUniversal) {\n\t\t\t// We ignore the sort.\n\t\t\tvar filterResult = set.intersection(queryA.filter, queryB.filter);\n\t\t\tif (set.isDefinedAndHasMembers(filterResult)) {\n\t\t\t\treturn new BasicQuery({\n\t\t\t\t\tfilter: filterResult,\n\t\t\t\t\tsort: meta.sortIsEqual ? queryA.sort.key : undefined\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\treturn filterResult;\n\t\t\t}\n\t\t}\n\n\n\n\t\t// check if disjoint wheres\n\t\tif (set.intersection(queryA.filter, queryB.filter) === set.EMPTY) {\n\t\t\treturn set.EMPTY;\n\t\t}\n\n\t\tif (meta.filterIsEqual) {\n\t\t\tif (meta.sortIsEqual) {\n\t\t\t\treturn new BasicQuery({\n\t\t\t\t\tfilter: queryA.filter,\n\t\t\t\t\tsort: queryA.sort.key,\n\t\t\t\t\tpage: set.intersection(queryA.page, queryB.page)\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (meta.aIsSubset) {\n\t\t\t\t\treturn queryA;\n\t\t\t\t} else if (meta.bIsSubset) {\n\t\t\t\t\treturn queryB;\n\t\t\t\t}\n\t\t\t\treturn set.UNKNOWABLE;\n\t\t\t\t//throw new Error(\"same filter, different sorts, non universal pages\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (meta.aIsSubset) {\n\t\t\t\treturn queryA;\n\t\t\t} else if (meta.bIsSubset) {\n\t\t\t\treturn queryB;\n\t\t\t} else {\n\t\t\t\t// filters are different, both pagination isn't universal\n\t\t\t\treturn set.UNDEFINABLE;\n\t\t\t}\n\n\t\t}\n\n\t},\n\tdifference: function(queryA, queryB) {\n\n\t\tvar differentClauses = getDifferentClauseTypes(queryA, queryB);\n\t\tvar meta = metaInformation(queryA, queryB);\n\t\tvar clause;\n\t\tif (differentClauses.length > 1) {\n\t\t\tif (meta.aIsSubset) {\n\t\t\t\treturn set.EMPTY;\n\t\t\t}\n\t\t\tif (meta.pagesAreUniversal) {\n\t\t\t\treturn new BasicQuery({\n\t\t\t\t\tfilter: set.difference(queryA.filter, queryB.filter),\n\t\t\t\t\tsort: queryA.sort.key\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn set.UNDEFINABLE;\n\t\t} else {\n\t\t\tswitch (clause = differentClauses[0]) {\n\t\t\t\t// if all the clauses are the same, then there can't be a difference\n\t\t\t\tcase undefined:\n\t\t\t\t\t{\n\t\t\t\t\t\treturn set.EMPTY;\n\t\t\t\t\t}\n\t\t\t\tcase \"sort\":\n\t\t\t\t\t{\n\t\t\t\t\t\t// if order is the only difference, then there can't be a difference\n\t\t\t\t\t\t// if items are paged but the order is different, though, the sets are not comparable\n\t\t\t\t\t\t// Either way, the result is false\n\t\t\t\t\t\tif (meta.pagesAreUniversal) {\n\t\t\t\t\t\t\treturn set.EMPTY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn set.UNKNOWABLE;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t}\n\t\t\t\tcase \"page\":\n\t\t\t\tcase \"filter\":\n\t\t\t\t\t{\n\t\t\t\t\t\t// if there's only one clause to evaluate or the clauses are where + id,\n\t\t\t\t\t\t// then we can try to determine the difference set.\n\t\t\t\t\t\t// Note that any difference in the ID clause will cause the result to be\n\t\t\t\t\t\t// true (if A has no ID but B has ID) or false (any case where A has ID)\n\t\t\t\t\t\tvar result = set.difference(queryA[clause],\n\t\t\t\t\t\t\tqueryB[clause]);\n\n\t\t\t\t\t\tif (set.isSpecial(result)) {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar query = {\n\t\t\t\t\t\t\t\tfilter: queryA.filter,\n\t\t\t\t\t\t\t\tpage: queryA.page,\n\t\t\t\t\t\t\t\tsort: queryA.sort.key\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tquery[clause] = result;\n\t\t\t\t\t\t\treturn new BasicQuery(query);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n\nmodule.exports = BasicQuery;\n","var canReflect = require(\"can-reflect\");\n\nvar Serializer = function(entries){\n    this.serializers = new Map(entries || []);\n    this.serialize = this.serialize.bind(this);\n};\nSerializer.prototype.add = function(serializers){\n    canReflect.assign( this.serializers, serializers instanceof Serializer ? serializers.serializers : serializers );\n};\n\n\nSerializer.prototype.serialize = function(item) {\n    if(!item) {\n        return item;\n    }\n    var Type = item.constructor;\n    var serializer = this.serializers.get(Type);\n    if(!serializer) {\n        return canReflect.serialize(item);\n    } else {\n        return serializer(item, this.serialize);\n    }\n};\n\nmodule.exports = Serializer;\n","var is = require(\"../types/comparisons\");\nvar Serializer = require(\"../serializer\");\nvar canReflect = require(\"can-reflect\");\n\nfunction makeNew(Constructor) {\n\treturn function(value){\n\t\treturn new Constructor(value);\n\t};\n}\nvar hydrateMap = {};\nfunction addHydrateFrom(key, hydrate) {\n\thydrateMap[key] = function(value, unknownHydrator) {\n\t\treturn hydrate( unknownHydrator ? unknownHydrator(value[key]) : value[key]);\n\t};\n\tObject.defineProperty(hydrateMap[key], \"name\", {\n\t\tvalue: \"hydrate \"+key,\n\t\twritable: true\n\t});\n}\n\nfunction addHydrateFromValues(key, hydrate) {\n\thydrateMap[key] = function(value, unknownHydrator) {\n\t\tvar clones = value[key];\n\t\tif(unknownHydrator) {\n\t\t\tclones = clones.map(function(value){\n\t\t\t\treturn unknownHydrator(value);\n\t\t\t});\n\t\t}\n\t\treturn hydrate( clones );\n\t};\n\tObject.defineProperty(hydrateMap[key], \"name\", {\n\t\tvalue: \"hydrate \"+key,\n\t\twritable: true\n\t});\n}\n\n// https://docs.mongodb.com/manual/reference/operator/query-comparison/\naddHydrateFrom(\"$eq\", function(value){\n\treturn new is.In([value]);\n});\naddHydrateFrom(\"$ne\", function(value){\n\treturn new is.NotIn([value]);\n});\n\naddHydrateFrom(\"$gt\", makeNew(is.GreaterThan));\naddHydrateFrom(\"$gte\", makeNew(is.GreaterThanEqual));\naddHydrateFromValues(\"$in\", makeNew(is.In));\naddHydrateFrom(\"$lt\", makeNew(is.LessThan));\naddHydrateFrom(\"$lte\", makeNew(is.LessThanEqual));\naddHydrateFromValues(\"$nin\", makeNew(is.GreaterThan));\n\n\n\n\n\nvar serializer = new Serializer([\n\t[is.In,function(isIn, serialize){\n\t\treturn isIn.values.length === 1 ?\n\t\t\tserialize(isIn.values[0]) :\n\t\t\t{$in: isIn.values.map(serialize)};\n\t}],\n\t[is.NotIn,function(notIn, serialize){\n\t\treturn notIn.values.length === 1 ?\n\t\t\t{$ne: serialize(notIn.values[0])} : {$nin: notIn.values.map(serialize)};\n\t}],\n\t[is.GreaterThan, function(gt, serialize){ return {$gt: serialize(gt.value) }; }],\n\t[is.GreaterThanEqual, function(gte, serialize){ return {$gte: serialize(gte.value) }; }],\n\t[is.LessThan, function(lt, serialize){ return {$lt: serialize(lt.value) }; }],\n\t[is.LessThanEqual, function(lt, serialize){ return {$lte: serialize(lt.value) }; }],\n\t[is.And, function(and, serialize){\n\t\tvar obj = {};\n\t\tand.values.forEach(function(clause){\n\t\t\tcanReflect.assignMap(obj, serialize(clause) );\n\t\t});\n\t\treturn obj;\n\t}]\n\t/*[is.Or, function(or, serialize){\n\t\treturn {\n\t\t\t$or: or.values.map(function(value){\n\t\t\t\treturn serialize(value, serialize);\n\t\t\t})\n\t\t};\n\t}]*/\n]);\n\nmodule.exports = {\n\thydrate: function(value, hydrateUnknown){\n\t\tif(!hydrateUnknown) {\n\t\t\thydrateUnknown = function(){\n\t\t\t\tthrow new Error(\"can-query-logic doesn't recognize operator: \"+JSON.stringify(value));\n\t\t\t}\n\t\t}\n\t\tif(Array.isArray(value)) {\n\t\t\treturn new is.In(value.map(function(value){\n\t\t\t\treturn hydrateUnknown(value);\n\t\t\t}));\n\t\t}\n\t\telse if(value && typeof value === \"object\") {\n\t\t\tvar keys = Object.keys(value);\n\t\t\tvar allKeysAreComparisons = keys.every(function(key){\n\t\t\t\treturn hydrateMap[key]\n\t\t\t});\n\t\t\tif(allKeysAreComparisons) {\n\t\t\t\tvar andClauses = keys.map(function(key){\n\t\t\t\t\tvar part = {};\n\t\t\t\t\tpart[key] = value[key];\n\t\t\t\t\tvar hydrator = hydrateMap[key];\n\t\t\t\t\treturn hydrator(part, hydrateUnknown);\n\t\t\t\t});\n\t\t\t\tif(andClauses.length > 1) {\n\t\t\t\t\treturn new is.And(andClauses);\n\t\t\t\t} else {\n\t\t\t\t\treturn andClauses[0];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn hydrateUnknown(value);\n\t\t\t}\n\t\t} else {\n\t\t\treturn new is.In([hydrateUnknown(value)]);\n\t\t}\n\t},\n\tserializer: serializer\n};\n","var canReflect = require(\"can-reflect\");\nvar set = require(\"./set\");\nvar canSymbol = require(\"can-symbol\");\nvar schemaHelpers;\nmodule.exports = schemaHelpers = {\n\n    // Number is a ranged type\n    isRangedType: function(Type){\n        return Type && canReflect.isConstructorLike(Type) &&\n            !set.hasComparisons(Type) &&\n            !Type[canSymbol.for(\"can.SetType\")] &&\n            Type.prototype.valueOf && Type.prototype.valueOf !== Object.prototype.valueOf;\n    },\n    categorizeOrValues: function categorizeOrValues(values){\n\n    \tvar categories = {\n    \t\tprimitives: [],\n    \t\tvalueOfTypes: [],\n    \t\tothers: []\n    \t};\n\n    \tvalues.forEach(function(value){\n    \t\tif( canReflect.isPrimitive( value ) ) {\n    \t\t\tcategories.primitives.push(value);\n    \t\t}\n    \t\telse if( schemaHelpers.isRangedType(value) ) {\n    \t\t\tcategories.valueOfTypes.push(value);\n    \t\t}\n    \t\telse {\n    \t\t\tcategories.others.push(value);\n    \t\t}\n    \t});\n    \treturn categories;\n    }\n};\n","var set = require(\"../set\");\nvar is = require(\"./comparisons\");\nvar canReflect = require(\"can-reflect\");\nvar schemaHelpers = require(\"../schema-helpers\");\nvar canSymbol = require(\"can-symbol\");\n\nvar comparisonSetTypeSymbol = canSymbol.for(\"can.ComparisonSetType\");\nvar isMemberSymbol = canSymbol.for(\"can.isMember\");\n\n// This helper function seperates out sets that relate to the \"maybe\" values\n// like `null` or `undefined`. For example, if `rangeToBeSplit`\n// is `In([null, 3])`, it will produce `{enum: In([null]), range: In(3)}`\nfunction splitByRangeAndEnum(maybeUniverse, rangeToBeSplit) {\n\tvar enumSet;\n\n\t// If it's an AND\n\tif (rangeToBeSplit instanceof is.And) {\n\t\t// recursively split each value\n\t\tvar sets = rangeToBeSplit.values.map(function(setInAnd) {\n\t\t\treturn splitByRangeAndEnum(maybeUniverse, setInAnd);\n\t\t});\n\t\t// take the intersections\n\t\treturn sets.reduce(function(last, maybe) {\n\t\t\treturn {\n\t\t\t\trange: set.intersection(last.range, maybe.range),\n\t\t\t\tenum: set.intersection(last.enum, maybe.enum)\n\t\t\t};\n\t\t}, {\n\t\t\trange: set.UNIVERSAL,\n\t\t\tenum: maybeUniverse\n\t\t});\n\n\t} else if (rangeToBeSplit instanceof is.In) {\n\n\t\tvar shouldBeInValues = rangeToBeSplit.values.filter(function(value) {\n\t\t\treturn maybeUniverse.isMember(value);\n\t\t});\n\t\tif (shouldBeInValues.length) {\n\t\t\tvar valuesCopy = rangeToBeSplit.values.slice(0);\n\t\t\tcanReflect.removeValues(valuesCopy, shouldBeInValues);\n\n\t\t\treturn {\n\t\t\t\tenum: new is.In(shouldBeInValues),\n\t\t\t\trange: valuesCopy.length ? new is.In(valuesCopy) : set.EMPTY\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tenum: set.EMPTY,\n\t\t\t\trange: rangeToBeSplit\n\t\t\t};\n\t\t}\n\t} else if (rangeToBeSplit instanceof is.NotIn) {\n\n\t\t// Gets the 'maybe' values in the range\n\t\tenumSet = set.intersection(maybeUniverse, rangeToBeSplit);\n\n\t\t// We should remove all the values within $in matching an in values.\n\t\tvar rangeValues = rangeToBeSplit.values.filter(function(value) {\n\t\t\treturn !maybeUniverse.isMember(value);\n\t\t});\n\t\treturn {\n\t\t\trange: rangeValues.length ? new is.NotIn(rangeValues) : set.UNIVERSAL,\n\t\t\tenum: enumSet\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\tenum: set.EMPTY,\n\t\t\trange: rangeToBeSplit\n\t\t};\n\t}\n}\n\n// Builds a type for ranged values plus some other enum values.\n// This is great for 'maybe' values. For example, it might be a string OR `null` OR `undefined`\n// `makeMaybe([null, undefined])`\nfunction makeMaybe(inValues, makeChildType) {\n\n\n\tvar maybeUniverse = new is.In(inValues);\n\n\tfunction Maybe(values) {\n\n\t\t// Maybe has two sub-sets:\n\t\t// - `.range` - Selects the non-enum values. Ex: `GreaterThan(3)`\n\t\t// - `.enum` - Selects the enum values. This is ALWAYS an `In`. Ex: `In([null])`.\n\t\t// Maybe is effectively an OR with these two properties.\n\t\tvar result = splitByRangeAndEnum(maybeUniverse, values.range);\n\t\tthis.range = result.range || set.EMPTY;\n\t\tif (values.enum) {\n\t\t\tif (result.enum !== set.EMPTY) {\n\t\t\t\tthis.enum = set.union(result.enum, values.enum);\n\t\t\t} else {\n\t\t\t\tthis.enum = values.enum;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.enum = result.enum;\n\t\t}\n\t\tif(this.enum === set.EMPTY && this.range === set.EMPTY) {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t}\n\tMaybe.prototype.orValues = function() {\n\t\tvar values = [];\n\t\tif( this.range !== set.EMPTY ) {\n\t\t\tvalues.push(this.range);\n\t\t}\n\t\tif( this.enum !== set.EMPTY ) {\n\t\t\tvalues.push(this.enum);\n\t\t}\n\t\treturn values;\n\t};\n\tMaybe.prototype[isMemberSymbol] = function isMember() {\n\t\tvar rangeIsMember = this.range[isMemberSymbol] || this.range.isMember,\n\t\t\tenumIsMember = this.enum[isMemberSymbol] || this.enum.isMember;\n\t\treturn rangeIsMember.apply(this.range, arguments) || enumIsMember.apply(this.enum, arguments);\n\t}\n\n\n\n\tset.defineComparison(Maybe, Maybe, {\n\t\tunion: function(maybeA, maybeB) {\n\t\t\tvar enumSet = set.union(maybeA.enum, maybeB.enum);\n\t\t\tvar range = set.union(maybeA.range, maybeB.range);\n\n\t\t\treturn new Maybe({\n\t\t\t\tenum: enumSet,\n\t\t\t\trange: range\n\t\t\t});\n\t\t},\n\t\tdifference: function(maybeA, maybeB) {\n\t\t\tvar enumSet = set.difference(maybeA.enum, maybeB.enum);\n\t\t\tvar range = set.difference(maybeA.range, maybeB.range);\n\n\t\t\treturn new Maybe({\n\t\t\t\tenum: enumSet,\n\t\t\t\trange: range\n\t\t\t});\n\t\t},\n\t\tintersection: function(maybeA, maybeB) {\n\t\t\tvar enumSet = set.intersection(maybeA.enum, maybeB.enum);\n\t\t\tvar range = set.intersection(maybeA.range, maybeB.range);\n\n\t\t\treturn new Maybe({\n\t\t\t\tenum: enumSet,\n\t\t\t\trange: range\n\t\t\t});\n\t\t}\n\t});\n\tMaybe.inValues = inValues;\n\n\tset.defineComparison(set.UNIVERSAL, Maybe, {\n\t\tdifference: function(universe, maybe) {\n\t\t\tvar primary,\n\t\t\t\tsecondary;\n\n\t\t\tif (maybe.range === set.UNIVERSAL) {\n\t\t\t\t// there is only the enum\n\t\t\t\treturn new Maybe({\n\t\t\t\t\trange: maybe.range,\n\t\t\t\t\tenum: set.difference(maybeUniverse, maybe.enum)\n\t\t\t\t});\n\t\t\t}\n\t\t\t// there is only a primary\n\t\t\tif (maybe.enum === set.EMPTY) {\n\t\t\t\tvar rangeSet = set.difference(set.UNIVERSAL, maybe.range);\n\t\t\t\tvar notPresent = set.difference(maybeUniverse, maybe.range);\n\t\t\t\t// make sure they are included\n\t\t\t\tvar enumSet = set.difference(notPresent, rangeSet);\n\n\n\t\t\t\treturn new Maybe({\n\t\t\t\t\trange: rangeSet,\n\t\t\t\t\tenum: enumSet\n\t\t\t\t});\n\t\t\t\t// check enum things that aren't included in primary\n\n\t\t\t} else {\n\t\t\t\tprimary = set.difference(universe, maybe.range);\n\t\t\t\tsecondary = set.difference(maybeUniverse, maybe.enum);\n\t\t\t}\n\t\t\treturn new Maybe({\n\t\t\t\tenum: secondary,\n\t\t\t\trange: primary\n\t\t\t});\n\t\t}\n\t});\n\tmakeChildType = makeChildType || function(v) {\n\t\treturn v;\n\t}\n\n\tMaybe.hydrate = function(value, childHydrate) {\n\t\treturn new Maybe({\n\t\t\trange: childHydrate(value, makeChildType)\n\t\t});\n\t};\n\n\treturn Maybe;\n}\n\n\n\nmakeMaybe.canMakeMaybeSetType = function(Type) {\n\tvar schema = canReflect.getSchema(Type);\n\tif (schema && schema.type === \"Or\") {\n\t\tvar categories = schemaHelpers.categorizeOrValues(schema.values);\n\n\t\treturn categories.valueOfTypes.length === 1 &&\n\t\t\t(categories.valueOfTypes.length + categories.primitives.length === schema.values.length);\n\t}\n\treturn false;\n};\n\n// Given an __Or__ type like:\n// ```\n// var MaybeString = {\n//   \"can.new\"(val){ ... },\n// \t \"can.getSchema\"(){ return  { type: \"Or\", values: [String, undefined, null] }\n// });\n// ```\n//\n// This creates two types:\n// - `Value` - A value type used for what's within `GreaterThan`, etc.\n// - `Maybe` - A SetType for this property. It will have `GreaterThan` within its\n//            `{enum, range}` sub values.\n//\n// This creates the outer `SetType` and the innermost `Value` type while the Comparisons\n// are used inbetween.\n//\n// The `MaybeString` could probably be directly used to hydrate values to what they should be.\nmakeMaybe.makeMaybeSetTypes = function(Type) {\n\tvar schema = canReflect.getSchema(Type);\n\tvar categories = schemaHelpers.categorizeOrValues(schema.values);\n\tvar ComparisonSetType;\n\n\t// No need to build the comparison type if we are given it.\n\tif (Type[comparisonSetTypeSymbol]) {\n\t\tComparisonSetType = Type[comparisonSetTypeSymbol];\n\t} else {\n\n\t\tComparisonSetType = function(value) {\n\t\t\tthis.value = canReflect.new(Type, value)\n\t\t};\n\t\tComparisonSetType.prototype.valueOf = function() {\n\t\t\treturn this.value;\n\t\t};\n\t\tcanReflect.assignSymbols(ComparisonSetType.prototype, {\n\t\t\t\"can.serialize\": function() {\n\t\t\t\treturn this.value;\n\t\t\t}\n\t\t});\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tObject.defineProperty(ComparisonSetType, \"name\", {\n\t\t\t\tvalue: \"Or[\" + categories.valueOfTypes[0].name + \",\" + categories.primitives.map(String).join(\" \") + \"]\"\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\t}\n\n\treturn {\n\t\tMaybe: makeMaybe(categories.primitives, function hydrateMaybesValueType(value) {\n\t\t\treturn new ComparisonSetType(value);\n\t\t}),\n\t\tComparisonSetType: ComparisonSetType\n\t}\n};\n\n\nmodule.exports = makeMaybe;\n","var set = require(\"../set\");\nvar arrayUnionIntersectionDifference = require(\"../array-union-intersection-difference\");\nvar schemaHelpers = require(\"../schema-helpers\");\n\nvar canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\n\nvar setTypeSymbol = canSymbol.for(\"can.SetType\"),\n\tisMemberSymbol = canSymbol.for(\"can.isMember\"),\n\tnewSymbol = canSymbol.for(\"can.new\");\n\nfunction makeEnumSetType(allValues, hydrate) {\n\tfunction Enum(values) {\n\t\tvar arr = Array.isArray(values) ? values : [values];\n\t\tthis.values = hydrate ? arr.map(hydrate) : arr;\n\t}\n\tcanReflect.assignSymbols(Enum.prototype, {\n\t\t\"can.serialize\": function() {\n\t\t\treturn this.values.length === 1 ? this.values[0] : this.values;\n\t\t}\n\t});\n\n\tEnum.prototype[isMemberSymbol] = function(value) {\n\t\treturn this.values.some(function(val) {\n\t\t\treturn set.isEqual(val, value);\n\t\t});\n\t};\n\n\tEnum.UNIVERSAL = new Enum(allValues);\n\n\tvar difference = function(enum1, enum2) {\n\t\tvar result = arrayUnionIntersectionDifference(enum1.values, enum2.values);\n\t\tif (result.difference.length) {\n\t\t\treturn new Enum(result.difference);\n\t\t} else {\n\t\t\treturn set.EMPTY;\n\t\t}\n\t};\n\n\tset.defineComparison(Enum, Enum, {\n\t\tunion: function(enum1, enum2) {\n\t\t\tvar result = arrayUnionIntersectionDifference(enum1.values, enum2.values);\n\t\t\tif (result.union.length) {\n\t\t\t\treturn new Enum(result.union);\n\t\t\t} else {\n\t\t\t\treturn set.EMPTY;\n\t\t\t}\n\t\t},\n\t\tintersection: function(enum1, enum2) {\n\t\t\tvar result = arrayUnionIntersectionDifference(enum1.values, enum2.values);\n\t\t\tif (result.intersection.length) {\n\t\t\t\treturn new Enum(result.intersection);\n\t\t\t} else {\n\t\t\t\treturn set.EMPTY;\n\t\t\t}\n\t\t},\n\t\tdifference: difference\n\t});\n\n\tset.defineComparison(Enum, set.UNIVERSAL, {\n\t\tdifference: function(enumA) {\n\t\t\treturn difference(enumA, {\n\t\t\t\tvalues: allValues.slice(0)\n\t\t\t});\n\t\t}\n\t});\n\n\tset.defineComparison(set.UNIVERSAL, Enum, {\n\t\tdifference: function(universe, enumB) {\n\t\t\treturn difference({\n\t\t\t\tvalues: allValues.slice(0)\n\t\t\t}, enumB);\n\t\t}\n\t});\n\n\treturn Enum;\n}\n\nfunction makeEnum(Type, allValues, hydrate) {\n\n\tvar Enum = makeEnumSetType(allValues, hydrate);\n\n\tType[setTypeSymbol] = Enum;\n\tType[isMemberSymbol] = function(value) {\n\t\treturn allValues.some(function(val) {\n\t\t\treturn set.isEqual(val, value);\n\t\t});\n\t};\n\n\treturn Enum;\n}\n\nmakeEnum.canMakeEnumSetType = function(Type) {\n\tvar schema = canReflect.getSchema(Type);\n\tif (schema && schema.type === \"Or\") {\n\t\tvar categories = schemaHelpers.categorizeOrValues(schema.values);\n\t\treturn categories.primitives.length === schema.values.length;\n\t}\n\treturn false;\n};\n\nmakeEnum.makeEnumSetType = function(Type) {\n\tvar schema = canReflect.getSchema(Type);\n\tvar categories = schemaHelpers.categorizeOrValues(schema.values);\n\tvar hydrate = Type[newSymbol] ? Type[newSymbol].bind(Type) : undefined;\n\treturn makeEnumSetType(categories.primitives, hydrate);\n};\n\nmodule.exports = makeEnum;\n","var canSymbol = require(\"can-symbol\");\nvar canReflect = require(\"can-reflect\");\nvar BasicQuery = require(\"../types/basic-query\");\nvar set = require(\"../set\");\nvar comparisonsConverter = require(\"../serializers/comparisons\");\nvar Serializer = require(\"../serializer\");\nvar is = require(\"../types/comparisons\");\nvar makeMaybe = require(\"../types/make-maybe\");\nvar makeEnum = require(\"../types/make-enum\");\nvar logDev = require(\"can-log/dev/dev\");\nvar helpers = require(\"../helpers\");\n\nvar setTypeSymbol = canSymbol.for(\"can.SetType\");\nvar schemaSymbol = canSymbol.for(\"can.getSchema\");\n\nvar defaultQuery = new BasicQuery({});\n\n\nfunction getSchemaProperties(value) {\n\tvar constructor = value.constructor;\n\tif (constructor && constructor[schemaSymbol]) {\n\t\tvar schema = constructor[schemaSymbol]();\n\t\treturn schema.keys || {};\n\t} else {\n\t\treturn {};\n\t}\n}\n\nfunction hydrateFilter(values, schemaProperties, hydrateUnknown) {\n\tif (values && typeof values === \"object\" && (\"$or\" in values)) {\n\t\treturn hydrateOrs(values.$or, schemaProperties, hydrateUnknown);\n\t} else {\n\t\treturn hydrateAndValues(values, schemaProperties, hydrateUnknown);\n\t}\n}\n\nvar setTypeMap = new WeakMap();\n\n// This is used to hydrate a value directly within a `filter`'s And.\nfunction hydrateAndValue(value, prop, SchemaType, hydrateChild) {\n\t// The `SchemaType` is the type of value on `instances` of\n\t// the schema. `Instances` values are different from `Set` values.\n\tif (SchemaType) {\n\t\t// If there's a `SetType`, we will use that\n\t\tvar SetType = SchemaType[setTypeSymbol];\n\t\tif (SetType) {\n\t\t\t/// If it exposes a hydrate, this means it can use the current hydrator to\n\t\t\t// hydrate its children.\n\t\t\t// I'm not sure why it's not taking the `unknown` hydrator instead.\n\t\t\tif (SetType.hydrate) {\n\t\t\t\treturn SetType.hydrate(value, comparisonsConverter.hydrate);\n\t\t\t}\n\t\t\t// If the SetType implemented `union`, `intersection`, `difference`\n\t\t\t// We can create instances of it directly.\n\t\t\telse if (set.hasComparisons(SetType)) {\n\t\t\t\t// Todo ... canReflect.new\n\t\t\t\treturn new SetType(value);\n\t\t\t}\n\t\t\t// If the SetType did not implement the comparison methods,\n\t\t\t// it's probably just a \"Value\" comparison type. We will hydrate\n\t\t\t// as a comparison converter, but create an instance of this `\"Value\"`\n\t\t\t// comparison type within the comparison converter.\n\t\t\telse {\n\t\t\t\t// inner types\n\t\t\t\treturn comparisonsConverter.hydrate(value, function(value) {\n\t\t\t\t\treturn new SetType(value);\n\t\t\t\t});\n\t\t\t}\n\n\t\t} else {\n\t\t\t// There is a `SchemaType`, but it doesn't have a `SetType`.\n\t\t\t// Can we create the SetType from the `SchemaType`?\n\t\t\tif (makeEnum.canMakeEnumSetType(SchemaType)) {\n\t\t\t\tif (!setTypeMap.has(SchemaType)) {\n\t\t\t\t\tsetTypeMap.set(SchemaType, makeEnum.makeEnumSetType(SchemaType));\n\t\t\t\t}\n\t\t\t\tSetType = setTypeMap.get(SchemaType);\n\t\t\t\treturn new SetType(value);\n\t\t\t}\n\t\t\t// It could also have a `ComparisonSetType` which are the values\n\t\t\t// within the Maybe type.\n\t\t\telse if (makeMaybe.canMakeMaybeSetType(SchemaType)) {\n\t\t\t\tif (!setTypeMap.has(SchemaType)) {\n\t\t\t\t\tsetTypeMap.set(SchemaType, makeMaybe.makeMaybeSetTypes(SchemaType));\n\t\t\t\t}\n\t\t\t\tSetType = setTypeMap.get(SchemaType).Maybe;\n\t\t\t\treturn SetType.hydrate(value, comparisonsConverter.hydrate);\n\t\t\t}\n\t\t\t// We can't create the `SetType`, so lets hydrate with the default behavior.\n\t\t\telse {\n\t\t\t\treturn comparisonsConverter.hydrate(value, hydrateChild);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// HERE {$gt: 1} -> new is.GreaterThan(1)\n\t\treturn comparisonsConverter.hydrate(value, hydrateChild);\n\t}\n}\n\nfunction hydrateAndValues(values, schemaProperties, hydrateUnknown) {\n\tschemaProperties = schemaProperties || {};\n\n\tfunction hydrateChild(value) {\n\t\tif (value) {\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\treturn value.map(hydrateUnknown);\n\t\t\t} else if (canReflect.isPlainObject(value)) {\n\t\t\t\t// lets try to get the schema ...\n\t\t\t\treturn hydrateAndValues(value, getSchemaProperties(value));\n\t\t\t}\n\t\t}\n\t\tif (hydrateUnknown) {\n\t\t\treturn hydrateUnknown(value);\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t}\n\tvar clone = {};\n\tcanReflect.eachKey(values, function(value, prop) {\n\t\tclone[prop] = hydrateAndValue(value, prop, schemaProperties[prop], hydrateChild);\n\t});\n\n\treturn new BasicQuery.KeysAnd(clone);\n\n}\n// This tries to combine a bunch of OR-ed ANDS into a single AND.\n// Example: [{name: \"j\", age: 3},{name: \"j\", age: 4}] //-> {name: \"j\", age: in[3,4]}\nfunction combineAnds(ands) {\n\tvar firstKeys = Object.keys(ands[0].values);\n\tvar keys = {};\n\n\tvar keysCompare = new is.In(firstKeys);\n\n\tfirstKeys.map(function(key) {\n\t\tkeys[key] = [];\n\t});\n\n\tvar sameKeys = ands.every(function(and) {\n\t\t// have to have the same keys\n\t\tif (!set.isEqual(keysCompare, new is.In(Object.keys(and.values)))) {\n\t\t\treturn false;\n\t\t}\n\t\tcanReflect.eachKey(and.values, function(value, key) {\n\t\t\tkeys[key].push(value);\n\t\t});\n\t\treturn true;\n\t});\n\tif (!sameKeys) {\n\t\treturn;\n\t}\n\t// now try to union everything and see if it simplifies ...\n\tvar unequalKeys = [];\n\tfirstKeys.forEach(function(key) {\n\t\tvar isEqual = keys[key].reduce(function(newSet, lastSetOrFalse) {\n\t\t\tif (lastSetOrFalse === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (lastSetOrFalse === undefined) {\n\t\t\t\treturn newSet;\n\t\t\t}\n\t\t\tvar res = set.isEqual(newSet, lastSetOrFalse);\n\t\t\treturn res ? newSet : false;\n\t\t});\n\t\tif (!isEqual) {\n\t\t\tunequalKeys.push(key);\n\t\t}\n\t});\n\n\tif (unequalKeys.length !== 1) {\n\t\treturn;\n\t}\n\tvar unionKey = unequalKeys[0];\n\t// lets see if we can union that one value\n\tvar unioned = keys[unionKey].reduce(function(cur, last) {\n\t\treturn set.union(cur, last);\n\t}, set.EMPTY);\n\n\tvar result = {};\n\tfirstKeys.map(function(key) {\n\t\tresult[key] = keys[key][0];\n\t});\n\tresult[unionKey] = unioned;\n\treturn new BasicQuery.KeysAnd(result);\n}\n\nfunction hydrateOrs(values, schemaProperties, hydrateUnknown) {\n\tvar comparisons = values.map(function(value) {\n\t\treturn hydrateAndValues(value, schemaProperties, hydrateUnknown);\n\t});\n\tvar combined = combineAnds(comparisons);\n\tif (combined) {\n\t\treturn combined;\n\t}\n\treturn new BasicQuery.Or(comparisons);\n}\n\nfunction recursivelyAddOrs(ors, value, serializer, key){\n    value.orValues().forEach(function(orValue){\n        if(typeof orValue.orValues === \"function\") {\n            recursivelyAddOrs(ors, orValue, serializer, key);\n        } else {\n            var result = {};\n            result[key] = serializer(orValue);\n            ors.push( result );\n        }\n    });\n}\n\nmodule.exports = function(schema) {\n\n\tvar id = schema.identity && schema.identity[0];\n\tvar keys = schema.keys;\n\n\tvar serializeMap = [\n\t\t[BasicQuery.Or, function(or, serializer) {\n\t\t\treturn or.values.map(function(value) {\n\t\t\t\treturn serializer(value);\n\t\t\t});\n\t\t}],\n\t\t// this destructures ANDs with OR-like clauses\n\t\t[BasicQuery.KeysAnd, function(and, serializer) {\n\t\t\tvar ors = [];\n\t\t\tvar result = {};\n\t\t\tcanReflect.eachKey(and.values, function(value, key) {\n\t\t\t\t// is value universal ... if not, we don't need to add anything\n\n\t\t\t\tif (typeof value.orValues === \"function\") {\n\t\t\t\t\trecursivelyAddOrs(ors, value, serializer, key);\n\t\t\t\t} else {\n\t\t\t\t\tresult[key] = serializer(value);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (ors.length) {\n\t\t\t\tif (ors.length === 1) {\n\t\t\t\t\treturn ors[0];\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t$or: ors.map(function(orPart) {\n\t\t\t\t\t\t\treturn canReflect.assign(canReflect.serialize(result), orPart);\n\t\t\t\t\t\t})\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t}],\n\t\t[BasicQuery.RecordRange, function(range) {\n\t\t\treturn {\n\t\t\t\tstart: range.start,\n\t\t\t\tend: range.end\n\t\t\t};\n\t\t}],\n\t\t[BasicQuery, function(basicQuery, childSerializer) {\n\n\t\t\tvar filter = set.isEqual(basicQuery.filter, set.UNIVERSAL) ? {} : childSerializer(basicQuery.filter);\n\n\t\t\tvar res = {};\n\t\t\tif (canReflect.size(filter) !== 0) {\n\t\t\t\tres.filter = filter;\n\t\t\t}\n\n\t\t\tif (!set.isEqual(basicQuery.page, defaultQuery.page)) {\n\t\t\t\t// we always provide the start, even if it's 0\n\t\t\t\tres.page = {\n\t\t\t\t\tstart: basicQuery.page.start\n\t\t\t\t};\n\t\t\t\tif (basicQuery.page.end !== defaultQuery.page.end) {\n\t\t\t\t\tres.page.end = basicQuery.page.end;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (basicQuery.sort.key !== id) {\n\t\t\t\tres.sort = basicQuery.sort.key;\n\t\t\t}\n\t\t\treturn res;\n\n\t\t}]\n\t];\n\n\n\n\t// Makes a sort type that can make a compare function using the SetType\n\tvar Sort = BasicQuery.makeSort(keys, hydrateAndValue);\n\tvar serializer = new Serializer(serializeMap);\n\tserializer.add(comparisonsConverter.serializer);\n\n\treturn {\n\t\thydrate: function(data) {\n\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tvar AcceptedFields = makeEnum(function() {}, [\"filter\", \"sort\", \"page\"]);\n\t\t\t\tvar diff = set.difference(new AcceptedFields(Object.keys(data)), AcceptedFields.UNIVERSAL);\n\t\t\t\tif (diff.values && diff.values.length) {\n\t\t\t\t\tlogDev.warn(\n\t\t\t\t\t\t\"can-query-logic: Ignoring keys: \" + diff.values.join(\", \") + \".\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//!steal-remove-end\n\n\n\t\t\tvar filter = canReflect.serialize(data.filter);\n\n\t\t\t// this mutates\n\t\t\tvar filterAnd = hydrateFilter(filter, keys, helpers.valueHydrator);\n\n\t\t\t// Conver the filter arguments\n\n\t\t\tvar query = {\n\t\t\t\tfilter: filterAnd\n\t\t\t};\n\t\t\tif (data.page) {\n\t\t\t\tquery.page = new BasicQuery.RecordRange(data.page.start, data.page.end);\n\t\t\t}\n\t\t\tif (data.sort) {\n\t\t\t\tquery.sort = new Sort(data.sort);\n\t\t\t} else {\n\t\t\t\tquery.sort = new Sort(id);\n\t\t\t}\n\t\t\treturn new BasicQuery(query);\n\t\t},\n\t\tserializer: serializer\n\t};\n};\n","var set = require(\"./src/set\");\nvar canSymbol = require(\"can-symbol\");\nvar canReflect = require(\"can-reflect\");\nvar makeBasicQueryConvert = require(\"./src/serializers/basic-query\");\nvar BasicQuery = require(\"./src/types/basic-query\");\nvar valueComparisons = require(\"./src/types/comparisons\");\nvar schemaSymbol = canSymbol.for(\"can.getSchema\");\nvar newSymbol = canSymbol.for(\"can.new\");\nvar makeEnum = require(\"./src/types/make-enum\");\n\n\n// Creates an algebra used to convert primitives to types and back\nfunction QueryLogic(Type, options){\n    Type = Type || {};\n    var passedHydrator = options && options.toQuery;\n    var passedSerializer = options && options.toParams;\n    var schema;\n    if(Type[schemaSymbol]) {\n        schema = Type[schemaSymbol]();\n    } else {\n        schema = Type;\n    }\n\n    // check that the basics are here\n\n    var id = schema.identity && schema.identity[0];\n    if(!id) {\n        //console.warn(\"can-query given a type without an identity schema.  Using `id` as the identity id.\");\n        schema.identity = [\"id\"];\n    }\n\n    var converter = makeBasicQueryConvert(schema),\n        hydrate,\n        serialize;\n\n    if(passedHydrator) {\n        hydrate = function(query){\n            return converter.hydrate(passedHydrator(query));\n        };\n    } else {\n        hydrate = converter.hydrate;\n    }\n\n    if(passedSerializer) {\n        serialize = function(query){\n            return passedSerializer(converter.serializer.serialize(query));\n        };\n    } else {\n        serialize = converter.serializer.serialize;\n    }\n    this.hydrate = hydrate;\n    this.serialize = serialize;\n    this.schema = schema;\n\n}\n\nfunction makeNewSet(prop){\n    return function(qA, qB){\n        var queryA = this.hydrate(qA),\n            queryB = this.hydrate(qB);\n        var unionQuery = set[prop](queryA , queryB );\n        return this.serialize( unionQuery );\n    };\n}\n\nfunction makeReturnValue(prop) {\n    return function(qA, qB){\n        var queryA = this.hydrate(qA),\n            queryB = this.hydrate(qB);\n        return set[prop](queryA , queryB );\n    };\n}\n\ncanReflect.assignSymbols(QueryLogic.prototype,{\n    \"can.getSchema\": function(){\n        return this.schema;\n    }\n});\n\ncanReflect.assign(QueryLogic.prototype,{\n    union: makeNewSet(\"union\"),\n    difference: makeNewSet(\"difference\"),\n    intersection: makeNewSet(\"intersection\"),\n\n    isEqual: makeReturnValue(\"isEqual\"),\n    isProperSubset: makeReturnValue(\"isProperSubset\"),\n    isSubset: makeReturnValue(\"isSubset\"),\n\n    isSpecial: set.isSpecial,\n    isDefinedAndHasMembers: set.isDefinedAndHasMembers,\n\n    count: function(a){\n        var queryA = this.hydrate(a);\n        return queryA.page.end - queryA.page.start + 1;\n    },\n\n    // identity keys\n    identityKeys: function(){\n        //console.warn(\"you probably can get the identity keys some other way\");\n        return this.schema.identity;\n    },\n\n    filterMembers: function(a, b, bData){\n        var queryA = this.hydrate(a);\n        if(arguments.length >= 3) {\n            var queryB = this.hydrate(b);\n            return queryA.filterFrom(bData, queryB);\n        } else {\n            return queryA.filterFrom(b);\n        }\n\n    },\n    // filterMembersAndGetCount\n    filterMembersAndGetCount: function(a, b, bData) {\n        var queryA = this.hydrate(a),\n            queryB = this.hydrate(b);\n        return queryA.filterMembersAndGetCount(bData, queryB);\n    },\n    // unionMembers\n    unionMembers: function(a, b, aData, bData) {\n        var queryA = this.hydrate(a),\n            queryB = this.hydrate(b);\n\n        var schema = this.schema;\n        return queryA.merge(queryB, aData, bData, function(obj){\n            return canReflect.getIdentity(obj, schema);\n        });\n    },\n    // isMember\n    isMember: function(query, props) {\n        return this.hydrate(query).isMember(props);\n    },\n\n    memberIdentity: function(props) {\n        // console.warn(\"you probably can get the member identity some other way\");\n        return canReflect.getIdentity(props, this.schema);\n    },\n    index: function(query, items, props){\n        return this.hydrate(query).index(props, items);\n    },\n\n    insert: function(query, items, item){\n    \tvar index = this.index(query, items, item);\n    \tif(index === undefined) {\n    \t\tindex = items.length;\n    \t}\n\n    \tvar copy = items.slice(0);\n    \tcopy.splice(index, 0, item);\n\n    \treturn copy;\n    },\n\n    isPaginated: function(query) {\n        var basicQuery = this.hydrate(query);\n        return !set.isEqual(basicQuery.page, set.UNIVERSAL);\n    },\n    removePagination: function(query) {\n        var basicQuery = this.hydrate(query);\n        basicQuery.removePagination();\n        return this.serialize( basicQuery );\n    },\n\n});\n\n// Copy everything on `set` to QueryLogic\nfor(var prop in set) {\n    if(QueryLogic[prop] === undefined) {\n        QueryLogic[prop] = set[prop];\n    }\n}\n\n\n\nQueryLogic.makeEnum = function(values){\n    var Type = function(){};\n\t\tType[newSymbol] = function(val) { return val; };\n    makeEnum(Type, values);\n    return Type;\n};\n\n\n\nQueryLogic.KeysAnd = BasicQuery.KeysAnd;\nQueryLogic.ValuesOr = BasicQuery.Or;\n\n\n\nQueryLogic.In = valueComparisons.In;\nQueryLogic.NotIn = valueComparisons.NotIn;\nQueryLogic.GreaterThan = valueComparisons.GreaterThan;\nQueryLogic.GreaterThanEqual = valueComparisons.GreaterThanEqual;\nQueryLogic.LessThan = valueComparisons.LessThan;\nQueryLogic.LessThanEqual = valueComparisons.LessThanEqual;\nQueryLogic.ValueAnd = valueComparisons.And;\nQueryLogic.ValueOr = valueComparisons.Or;\n\nmodule.exports = QueryLogic;\n"],"names":["set","addSerializeToThis","obj","canReflect","assignSymbols","can.serialize","this","reverseArgs","fn","first","second","call","setComparisonsSymbol","canSymbol","for","addComparators","type1","type2","comparators","comparisons","Map","subMap","get","existingComparators","prop","hasOwnProperty","console","warn","name","Identity","typeMap","number","string","undefined","boolean","identityIntersection","v1","v2","EMPTY","identityDifference","identityUnion","UNDEFINABLE","forEach","forwardComparators","value1","value2","UNIVERSAL","result","undefinedIsEmptySet","Error","getType","identityComparitor","intersection","difference","union","can.isMember","UNKNOWABLE","isSpecial","setA","isDefinedAndHasMembers","value","constructor","ownAndMemberValue","startOwnValue","startMemberValue","ownValue","valueOf","memberValue","own","member","getComparisons","Type1","Type2","hasComparisons","Type","defineComparison","reverse","isSubset","isProperSubset","setB","isEqual","isSpecial1","isSpecial2","reverseComparators","reverseIntersection","reverseDifference","values","isPrimitive","indexWithEqual","arr","i","len","length","getValue","arr1","arr2","Set","slice","add","push","has","index","SET","splice","isMemberSymbol","In","NotIn","GreaterThan","GreaterThanEqual","LessThan","LessThanEqual","And","ands","Or","ors","nullIsFalse","test","arg1","arg2","nullIsFalseTwoIsOk","isMemberThatUsesTest","isMemberThatUsesTestOnValues","makeNot","vA","vB","makeEnum","type","emptyResult","a","b","arrayUnionIntersectionDifference","swapArgs","makeSecondValue","universe","returnBiggerValue","gtA","gtB","returnSmallerValue","makeAndIf","Comparison","ltA","ltB","makeAnd","make_InIfEqual_else_andIf","elseCase","is","make_filterFirstValueAgainstSecond","defaultReturn","inSet","gt","filter","prototype","orValues","some","testValue","isMember","every","and","Object","keys","isMemberTest","isOr","isAnd","isAndOrOr","combineFilterFirstValuesAgainstSecond","options","range","complement","with","combinedUsing","arePut","makeOrUnless","makeOr","makeAndUnless","makeComplementSecondArgIf","combineValueWithRangeCheck","rangeSet","RangeOrEqType","gte","leftValues","makeOrWithInAndRange","firstResult","secondResult","In_RANGE","RANGE_IN","NotIn_RANGE","RANGE_NotIn","RANGE_And_Union","union1","union2","RANGE_And_Intersection","and1","and2","intersection1","intersection2","RANGE_And_Difference","difference1","difference2","And_RANGE_Difference","RANGE_Or","or","or1","or2","Or_RANGE","In_In","UNIVERSAL_In","In_NotIn","NotIn_In","In_GreaterThan","GreaterThan_In","In_GreaterThanEqual","GreaterThanEqual_In","In_LessThan","LessThan_In","In_LessThanEqual","LessThanEqual_In","In_And","And_In","In_Or","Or_In","NotIn_NotIn","UNIVERSAL_NotIn","NotIn_GreaterThan","GreaterThan_NotIn","NotIn_GreaterThanEqual","GreaterThanEqual_NotIn","NotIn_LessThan","LessThan_NotIn","NotIn_LessThanEqual","LessThanEqual_NotIn","NotIn_And","And_NotIn","NotIn_Or","Or_NotIn","GreaterThan_GreaterThan","UNIVERSAL_GreaterThan","GreaterThan_GreaterThanEqual","GreaterThanEqual_GreaterThan","GreaterThan_LessThan","makeOrUnlessLessThan","LessThan_GreaterThan","GreaterThan_LessThanEqual","LessThanEqual_GreaterThan","GreaterThan_And","And_GreaterThan","GreaterThan_Or","Or_GreaterThan","GreaterThanEqual_GreaterThanEqual","UNIVERSAL_GreaterThanEqual","GreaterThanEqual_LessThan","LessThan_GreaterThanEqual","GreaterThanEqual_LessThanEqual","lte","LessThanEqual_GreaterThanEqual","GreaterThanEqual_And","And_GreaterThanEqual","GreaterThanEqual_Or","Or_GreaterThanEqual","LessThan_LessThan","UNIVERSAL_LessThan","LessThan_LessThanEqual","LessThanEqual_LessThan","LessThan_And","And_LessThan","LessThan_Or","Or_LessThan","LessThanEqual_LessThanEqual","lteA","lteB","UNIVERSAL_LessThanEqual","LessThanEqual_And","And_LessThanEqual","LessThanEqual_Or","Or_LessThanEqual","And_And","d1","d2","And_Or","aUnion","bUnion","aIntersection","bIntersection","aDiff","bDiff","Or_And","UNIVERSAL_And","inverseFirst","inverseSecond","Or_Or","c","d","UNIVERSAL_Or","names","name1","j","name2","min","max","RealNumberRangeInclusive","start","end","arguments","universeRange","isUniversal","rangeFromAnd","aSet","toRange","firstValues","secondValues","range1","range2","ValuesOr","props","types","NotIdentity","not","primitive","keysLogic","Not","KeysAnd","vals","eachKey","key","isPlainObject","checkIfUniversalAndReturnUniversal","root","rootKey","equal","preKey","canGet","MISSING","eachInUnique","acb","bcb","res","bCopy","assign","keyDiff","valuesA","valuesB","keyResults","aOnlyKeys","aAndBKeys","bOnlyKeys","notEmpty","objA","objB","diff","sharedKeysAndValues","productAbleKeysAndData","disjointKeysAndValues","singleProductKeyAndValue","productAbleKeys","productAbleOr","productableKey","map","shared","aAndBKeysThatAreNotEqual","sameKeys","aUnequal","bUnequal","keyValue","size","foundEmpty","resultValues","aVal","bVal","ValuesNot","defaultCompare","$gt","valueA","valueB","$lt","helpers","uniqueConcat","itemsA","itemsB","getId","ids","concat","item","id","getIndex","compare","items","low","high","mid","sortData","sortPropValue","desc","sorter","sorters","data","item1","item2","temp","item1Value","getKeyValue","item2Value","valueHydrator","isBuiltIn","JSON","stringify","andOrNot","RecordRange","makeRealNumberRangeInclusive","Infinity","makeSort","schemaKeys","hydrateAndValue","Sort","schemaProp","DefaultSort","BasicQuery","query","page","sort","assignMap","count","filterMembersAndGetCount","bData","parentQuery","aData","thisIsUniversal","filterFrom","merge","aItems","bItems","combined","hasOwnKey","removePagination","CLAUSE_TYPES","getDifferentClauseTypes","queryA","queryB","differentTypes","clause","subLetter","superLetter","meta","sortIsEqual","MetaInformation","metaInformation","pageIsEqual","aPageIsUniversal","bPageIsUniversal","pagesAreUniversal","aFilterIsSubset","bFilterIsSubset","aPageIsSubset","bPageIsSubset","filterIsEqual","aIsSubset","bIsSubset","def","defineLazyValue","filterUnion","filterResult","differentClauses","Serializer","entries","serializers","serialize","bind","serializer","makeNew","Constructor","hydrateMap","addHydrateFrom","hydrate","unknownHydrator","defineProperty","writable","addHydrateFromValues","clones","schemaHelpers","isIn","$in","notIn","$ne","$nin","$gte","lt","$lte","hydrateUnknown","Array","isArray","andClauses","part","hydrator","isRangedType","isConstructorLike","categorizeOrValues","categories","primitives","valueOfTypes","others","comparisonSetTypeSymbol","splitByRangeAndEnum","maybeUniverse","rangeToBeSplit","enumSet","setInAnd","reduce","last","maybe","enum","shouldBeInValues","valuesCopy","removeValues","rangeValues","makeMaybe","inValues","makeChildType","Maybe","rangeIsMember","enumIsMember","apply","maybeA","maybeB","primary","notPresent","v","childHydrate","canMakeMaybeSetType","schema","getSchema","makeMaybeSetTypes","ComparisonSetType","new","process","env","NODE_ENV","String","join","setTypeSymbol","newSymbol","makeEnumSetType","allValues","Enum","val","enum1","enum2","enumA","enumB","canMakeEnumSetType","schemaSymbol","defaultQuery","getSchemaProperties","hydrateFilter","schemaProperties","hydrateOrs","$or","hydrateAndValues","setTypeMap","WeakMap","SchemaType","hydrateChild","SetType","comparisonsConverter","clone","combineAnds","firstKeys","keysCompare","unequalKeys","newSet","lastSetOrFalse","unionKey","unioned","cur","recursivelyAddOrs","orValue","identity","serializeMap","orPart","basicQuery","childSerializer","AcceptedFields","logDev","QueryLogic","passedHydrator","toQuery","passedSerializer","toParams","converter","makeBasicQueryConvert","makeNewSet","qA","qB","unionQuery","makeReturnValue","can.getSchema","identityKeys","filterMembers","unionMembers","getIdentity","memberIdentity","insert","copy","isPaginated","valueComparisons","ValueAnd","ValueOr"],"mappings":"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"}