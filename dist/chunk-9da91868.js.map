{"version":3,"file":"chunk-9da91868.js","sources":["../node_modules/can-connect/helpers/get-items.js","../node_modules/can-connect/data/callbacks-cache/callbacks-cache.js","../node_modules/can-connect/helpers/deferred.js","../node_modules/can-connect/data/combine-requests/combine-requests.js","../node_modules/can-connect/data/localstorage-cache/localstorage-cache.js","../node_modules/can-connect/fall-through-cache/fall-through-cache.js","../node_modules/can-connect/can/ref/ref.js"],"sourcesContent":["\"use strict\";\nmodule.exports = function(data){\n\tif(Array.isArray(data)) {\n\t\treturn data;\n\t} else {\n\t\treturn data.data;\n\t}\n};\n","\"use strict\";\n/**\n * @module can-connect/data/callbacks-cache/callbacks-cache data/callbacks-cache\n * @parent can-connect.behaviors\n *\n * Implements the data interface callbacks to call the [can-connect/base/base.cacheConnection]\n * [can-connect/DataInterface]. These calls keep the [can-connect/base/base.cacheConnection] contents\n * up to date.\n *\n * @signature `dataCallbacksCache( baseConnection )`\n * Implements the data interface callbacks so that a corresponding [can-connect/DataInterface] method is called on the\n * [can-connect/base/base.cacheConnection]. This updates the [can-connect/base/base.cacheConnection] contents whenever\n * data is updated on the primary connection.\n *\n * @param {{}} baseConnection `can-connect` connection object that is having the `data/callbacks-cache` behavior added\n * on to it.\n *\n * @return {{}} a `can-connect` connection containing the method implementations provided by `data/callbacks-cache`.\n *\n * ### Example\n * Shows synchronization between primary connection and cacheConnection data when using this behavior:\n * ```\n * import dataUrl from \"can-connect/data/url/\";\n * import dataCallbacks from \"can-connect/data/callbacks/\";\n * import cacheCallbacks from \"can-connect/data/callbacks-cache/\";\n * import memoryCache from \"can-connect/data/memory-cache/\";\n *\n * var cacheConnection = connect([memoryCache], {});\n * var todoConnection = connect([dataUrl, dataCallback, cacheCallbacks], {\n *   cacheConnection,\n *   url: \"/todo\"\n * });\n *\n * todoConnection.createData({name:'do the dishes', completed: false}).then(function(data) {\n *   todoConnection.cacheConnection.getData({id: data.id}).then(function(cachedData) {\n *     // data returned from connection and data returned from cache have the same contents\n *     data.id === cachedData.id; // true\n *     data.name === cachedData.name; // true\n *     data.completed === cachedData.completed; // true\n *     data === cachedData; // false, since callbacks-cache creates a copy of the data when adding it to the cache\n *   })\n * });\n * ```\n */\nvar connect = require(\"../../can-connect\");\nvar assign = require(\"can-reflect\").assignMap;\nvar each = require(\"can-reflect\").each;\n\n// wires up the following methods\nvar pairs = {\n\t/**\n\t * @function can-connect/data/callbacks-cache/callbacks-cache.createdData createdData\n\t * @parent can-connect/data/callbacks-cache/callbacks-cache\n\t *\n\t * Data callback that updates the [can-connect/base/base.cacheConnection cache] when a new data record is created.\n\t *\n\t * @signature `connection.createdData(responseData, requestData, cid)`\n\t *\n\t * Calls `createData` on the [can-connect/base/base.cacheConnection] to add a newly created data record to the cache.\n\t * Calls and returns the response from any underlying behavior's `createdData` callback.\n\t *\n\t * @param {{}} responseData the data returned by the data creation request\n\t * @param {{}} requestData the data that was passed to the data creation request\n\t * @param {Number} cid the unique identifier for this data. Used before data has a [can-connect/base/base.id] added\n\t * at creation time.\n\t *\n\t * @return {{}} the data returned from an underlying behavior's `createdData` callback, if one exists. Otherwise\n\t * returns the `responseData`.\n\t */\n\tcreatedData: \"createData\",\n\n\t/**\n\t * @function can-connect/data/callbacks-cache/callbacks-cache.updatedData updatedData\n\t * @parent can-connect/data/callbacks-cache/callbacks-cache\n\t *\n\t * Data callback that updates the [can-connect/base/base.cacheConnection cache] when a data record is modified.\n\t *\n\t * @signature `connection.updatedData(responseData, requestData)`\n\t *\n\t * Calls `updateData` on the [can-connect/base/base.cacheConnection] to modify a data record stored in the cache.\n\t * Calls and returns the response from any underlying behavior's `updatedData` callback.\n\t *\n\t * @param {{}} responseData the data returned by the data update request\n\t * @param {{}} requestData the data that was passed to the data update request\n\t *\n\t * @return {{}} the data returned from an underlying behavior's `updatedData` callback, if one exists. Otherwise\n\t * returns the `responseData`.\n\t */\n\tupdatedData: \"updateData\",\n\n\t/**\n\t * @function can-connect/data/callbacks-cache/callbacks-cache.destroyedData destroyedData\n\t * @parent can-connect/data/callbacks-cache/callbacks-cache\n\t *\n\t * Data callback that updates the [can-connect/base/base.cacheConnection cache] when a data record is deleted.\n\t *\n\t * @signature `connection.destroyedData(responseData, requestData)`\n\t *\n\t * Calls `destroyData` on the [can-connect/base/base.cacheConnection] to remove a data record stored in the cache.\n\t * Calls and returns the response from any underlying behavior's `destroyedData` callback.\n\t *\n\t * @param {{}} responseData the data returned by the data destroy request\n\t * @param {{}} requestData the data that was passed to the data destroy request\n\t *\n\t * @return {{}} the data returned from an underlying behavior's `destroyedData` callback, if one exists. Otherwise\n\t * returns the `responseData`.\n\t */\n\tdestroyedData: \"destroyData\"\n};\n\n\n\nvar callbackCache = connect.behavior(\"data/callbacks-cache\",function(baseConnection){\n\tvar behavior = {};\n\n\teach(pairs, function(crudMethod, dataCallback){\n\t\tbehavior[dataCallback] = function(data, params, cid){\n\n\t\t\t// update the data in the cache\n\t\t\tthis.cacheConnection[crudMethod]( assign(assign({}, params), data) );\n\n\t\t\t// return underlying dataCallback implementation if one exists or return input data\n\t\t\tif (baseConnection[dataCallback]) {\n\t\t\t\treturn baseConnection[dataCallback].call(this, data, params, cid);\n\t\t\t} else {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t};\n\t});\n\n\treturn behavior;\n});\n\nmodule.exports = callbackCache;\n\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\tvar validate = require(\"../../helpers/validate\");\n\tmodule.exports = validate(callbackCache, []);\n}\n//!steal-remove-end\n","\n\"use strict\";\nmodule.exports = function(){\n\tvar def = {};\n\tdef.promise = new Promise(function(resolve, reject){\n\t\tdef.resolve = resolve;\n\t\tdef.reject = reject;\n\t});\n\treturn def;\n};\n","var connect = require(\"../../can-connect\");\nvar getItems = require(\"../../helpers/get-items\");\nvar canReflect = require(\"can-reflect\");\n\nvar makeDeferred = require(\"../../helpers/deferred\");\nvar forEach = [].forEach;\n/**\n * @module can-connect/data/combine-requests/combine-requests combine-requests\n * @parent can-connect.behaviors\n * @group can-connect/data/combine-requests.options 1 behavior options\n * @group can-connect/data/combine-requests.types 2 types\n * @group can-connect/data/combine-requests.data-methods 3 data methods\n * @group can-connect/data/combine-requests.queryLogic 4 queryLogic methods\n *\n * Combines multiple incoming lists requests into a single list request when possible.\n *\n * @signature `combineRequests( baseConnection )`\n *\n * Implements [can-connect/data/combine-requests.getListData] to collect the requested sets for some\n * [can-connect/data/combine-requests.time].  Once the configured amount of time has passed, it tries to take the\n * [can-connect/data/combine-requests.unionPendingRequests union] of the requested sets. It then makes requests with\n * those unified sets. Once the unified set requests have returned, the original requests are resolved by taking\n * [can-connect/data/combine-requests.filterMembers subsets] of the unified response data.\n *\n * @param {{}} baseConnection `can-connect` connection object that is having the `combine-requests` behavior added\n * on to it. Should already contain a behavior that provides `getListData` (e.g [can-connect/data/url/url]). If\n * the `connect` helper is used to build the connection, the behaviors will automatically be ordered as required.\n *\n * @return {{}} a `can-connect` connection containing the method implementations provided by `combine-requests`.\n *\n * @body\n *\n * ## Use\n *\n * Create a connection with the `combine-requests` plugin:\n *\n * ```\n * var combineRequests = require(\"can-connect/data/combine-requests/\");\n * var dataUrl = require(\"can-connect/data/url/\");\n * var todosConnection = connect([dataUrl, combineRequests], {\n *   url: \"/todos\"\n * });\n * ```\n * Since the configuration above doesn't include the [can-connect/data/combine-requests.time] option, the following\n * will only make a single request if all requests are made during the same \"thread of execution\" (i.e. before the\n * browser takes a break from executing the current JavaScript):\n *\n * ```\n * todosConnection.getListData({})\n * todosConnection.getListData({filter: {userId: 5}});\n * todosConnection.getListData({filter: {userId: 5, type: \"critical\"}});\n * ```\n *\n * The above requests can all be joined since [can-set] intuitively knows that\n * `({filter: {userId: 5}}` and `{filter: {userId: 5, type: \"critical\"}}` are subsets of the complete set of todos, `{}`.\n *\n * For more advanced combining, a [can-query-logic queryLogic] must be configured. This allows `combine-requests` to understand\n * what certain parameters of a set mean, and how they might be combined.\n *\n *\n *\n */\nvar combineRequests = connect.behavior(\"data/combine-requests\",function(baseConnection){\n\tvar pendingRequests; //[{set, deferred}]\n\n\treturn {\n\t\t/**\n\t\t * @function can-connect/data/combine-requests.unionPendingRequests unionPendingRequests\n\t\t * @parent can-connect/data/combine-requests.queryLogic\n\t\t *\n\t\t * Group pending requests by the request that they are a subset of.\n\t\t *\n\t\t * @signature `connection.unionPendingRequests( pendingRequests )`\n\t\t *\n\t\t * This is called by [can-connect/data/combine-requests.getListData] to determine which pending requests can be unified\n\t\t * into a broader request. This produces a grouping of 'parent' sets to 'child' requests whose data will be\n\t\t * derived from the data retrieved by the parent.\n\t\t *\n\t\t * After this grouping is returned, [can-connect/data/combine-requests.getListData] executes requests for the parent\n\t\t * sets. After a parent request succeeds, the child requests will have their data calculated from the parent data.\n\t\t *\n\t\t * @param {Array<can-connect/data/combine-requests.PendingRequest>} pendingRequests\n\t\t * an array of objects, each containing:\n\t\t *   - `set` - the requested set\n\t\t *   - `deferred` - a wrapper around a `Promise` that will be resolved with this sets data\n\t\t *\n\t\t * @return {Array<{set: Set, pendingRequests: can-connect/data/combine-requests.PendingRequest}>}\n\t\t * an array of each of the unified requests to be made.  Each unified request should have:\n\t\t *   - `set` - the set to request\n\t\t *   - `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the `set` satisfies\n\t\t *\n\t\t * ### Example\n\t\t *\n\t\t * This function converts something like:\n\t\t *\n\t\t * ```\n\t\t * [\n\t\t *   {set: {completed: false}, deferred: def1},\n\t\t *   {set: {completed: true}, deferred: def2}\n\t\t * ]\n\t\t * ```\n\t\t *\n\t\t * to:\n\t\t *\n\t\t * ```\n\t\t * [\n\t\t *   {\n\t\t *    set: {},\n\t\t *    pendingRequests: [\n\t\t *      {set: {completed: false}, deferred: def1},\n\t\t *      {set: {completed: true}, deferred: def2}\n\t\t *    ]\n\t\t *   }\n\t\t * ]\n\t\t * ```\n\t\t *\n\t\t */\n\t\tunionPendingRequests: function(pendingRequests){\n\t\t\t// this should try to merge existing param requests, into an array of\n\t\t\t// others to send out\n\t\t\t// but this data structure keeps the original promises.\n\n\n\t\t\t// we need the \"biggest\" sets first so they can swallow up everything else\n\t\t\t// O(n log n)\n\t\t\tvar self = this;\n\n\t\t\tpendingRequests.sort(function(pReq1, pReq2){\n\n\t\t\t\tif(self.queryLogic.isSubset(pReq1.set, pReq2.set)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else if( self.queryLogic.isSubset(pReq2.set, pReq1.set) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\t// O(n^2).  This can probably be made faster, but there are rarely lots of pending requests.\n\t\t\tvar combineData = [];\n\t\t\tvar current;\n\n\t\t\tdoubleLoop(pendingRequests, {\n\t\t\t\tstart: function(pendingRequest){\n\t\t\t\t\tcurrent = {\n\t\t\t\t\t\tset: pendingRequest.set,\n\t\t\t\t\t\tpendingRequests: [pendingRequest]\n\t\t\t\t\t};\n\t\t\t\t\tcombineData.push(current);\n\t\t\t\t},\n\t\t\t\titerate: function(pendingRequest){\n\t\t\t\t\tvar combined = self.queryLogic.union(current.set, pendingRequest.set);\n\t\t\t\t\tif( self.queryLogic.isDefinedAndHasMembers(combined) ) {\n\t\t\t\t\t\t// add next\n\t\t\t\t\t\tcurrent.set = combined;\n\t\t\t\t\t\tcurrent.pendingRequests.push(pendingRequest);\n\t\t\t\t\t\t// removes this from iteration\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn Promise.resolve(combineData);\n\t\t},\n\n\t\t/**\n\t\t * @property {Number} can-connect/data/combine-requests.time time\n\t\t * @parent can-connect/data/combine-requests.options\n\t\t *\n\t\t * Specifies the amount of time to wait to combine requests.\n\t\t *\n\t\t * @option {Number} Defaults to `1`, meaning only requests made within the same \"thread of execution\" will be\n\t\t * combined (i.e. requests made before the browser takes a break from the ongoing JavaScript execution).\n\t\t *\n\t\t * Increasing this number will mean that requests are delayed that length of time in case other requests\n\t\t * are made. In general, we advise against increasing this amount of time except in cases where loads take a\n\t\t * significant amount of time and the increased delay is unlikely to be noticed.\n\t\t *\n\t\t * ```\n\t\t * var combineRequests = require(\"can-connect/data/combine-requests/\");\n\t\t * connect([... combineRequests, ...],{\n\t\t *   time: 100\n\t\t * })\n\t\t * ```\n\t\t */\n\t\ttime:1,\n\n\t\t/**\n\t\t * @function can-connect/data/combine-requests.getListData getListData\n\t\t * @parent can-connect/data/combine-requests.data-methods\n\t\t *\n\t\t * Combines multiple list data requests into a single request, when possible.\n\t\t *\n\t\t * @signature `connection.getListData( set )`\n\t\t *\n\t\t * Extension of [can-connect/connection.getListData `getListData`] that tries to combine calls to it into a single\n\t\t * call. The calls are fulfilled by an underlying behavior's `getListData` implementation.\n\t\t *\n\t\t * Waits for a configured [can-connect/data/combine-requests.time] then tries to unify the sets requested during it.\n\t\t * After unification, calls for the unified sets are made to the underlying `getListData`. Once the unified\n\t\t * data has returned, the individual calls to `getListData` are resolved with a\n\t\t * [can-query-logic.prototype.filterMembers calculated subset] of the unified data.\n\t\t *\n\t\t * @param {can-query-logic/query} query the parameters of the requested set of data\n\t\t * @return {Promise<can-connect.listData>} `Promise` resolving the data of the requested set\n\t\t */\n\t\tgetListData: function(set){\n\t\t\tset = set || {};\n\t\t\tvar self = this;\n\n\t\t\tif(!pendingRequests) {\n\n\t\t\t\tpendingRequests = [];\n\n\t\t\t\tsetTimeout(function(){\n\n\t\t\t\t\tvar combineDataPromise = self.unionPendingRequests(pendingRequests);\n\t\t\t\t\tpendingRequests = null;\n\t\t\t\t\tcombineDataPromise.then(function(combinedData){\n\t\t\t\t\t\t// farm out requests\n\t\t\t\t\t\tforEach.call(combinedData, function(combined){\n\t\t\t\t\t\t\t// clone combine.set to prevent mutations by baseConnection.getListData\n\t\t\t\t\t\t\tvar combinedSet = canReflect.serialize(combined.set);\n\n\t\t\t\t\t\t\tbaseConnection.getListData(combinedSet).then(function(data){\n\t\t\t\t\t\t\t\tif(combined.pendingRequests.length === 1) {\n\t\t\t\t\t\t\t\t\tcombined.pendingRequests[0].deferred.resolve(data);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tforEach.call(combined.pendingRequests, function(pending){\n\t\t\t\t\t\t\t\t\t\t// get the subset using the combine.set property before being passed down\n\t\t\t\t\t\t\t\t\t\t// to baseConnection.getListData which might mutate it causing combinedRequests\n\t\t\t\t\t\t\t\t\t\t// to resolve with an `undefined` value instead of an actual set\n\t\t\t\t\t\t\t\t\t\t// https://github.com/canjs/can-connect/issues/139\n\t\t\t\t\t\t\t\t\t\tpending.deferred.resolve( {data: self.queryLogic.filterMembers(pending.set, combined.set, getItems(data))} );\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, function(err){\n\t\t\t\t\t\t\t\tif(combined.pendingRequests.length === 1) {\n\t\t\t\t\t\t\t\t\tcombined.pendingRequests[0].deferred.reject(err);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tforEach.call(combined.pendingRequests, function(pending){\n\t\t\t\t\t\t\t\t\t\tpending.deferred.reject(err);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\n\t\t\t\t}, this.time || 1);\n\t\t\t}\n\t\t\tvar deferred = makeDeferred();\n\n\t\t\tpendingRequests.push({deferred: deferred, set: set});\n\n\t\t\treturn deferred.promise;\n\t\t}\n\t};\n});\n\nmodule.exports = combineRequests;\n\n//!steal-remove-start\nvar validate = require(\"../../helpers/validate\");\nmodule.exports = validate(combineRequests, ['getListData']);\n//!steal-remove-end\n\n/**\n * @typedef {PendingRequest} can-connect/data/combine-requests.PendingRequest PendingRequest\n * @parent can-connect/data/combine-requests.types\n *\n * @description Type to keep track of the multiple requests that were unified into a single request.\n *\n * @type {PendingRequest} Record of an individual request that has been unified as part of the combined request. After\n * the unified request completes instances of these types are processed to complete the individual requests with the\n * subset of the unified data.\n *\n * @option {can-query-logic/query} query a requested [can-set/Set set] of data that has been unified into the combined request\n * @option {{}} deferred a type that keeps track of the individual [can-connect/data/combine-requests.getListData]\n * promise that will be resolved after the unified request completes\n */\n\n// ### doubleLoop\nvar doubleLoop = function(arr, callbacks){\n\tvar i = 0;\n\twhile(i < arr.length) {\n\t\tcallbacks.start(arr[i]);\n\t\tvar j = i+1;\n\t\twhile( j < arr.length ) {\n\t\t\tif(callbacks.iterate(arr[j]) === true) {\n\t\t\t\tarr.splice(j, 1);\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n};\n","\"use strict\";\n/**\n * @module can-connect/data/localstorage-cache/localstorage-cache localstorage-cache\n * @parent can-connect.deprecated\n * @group can-connect/data/localstorage-cache/localstorage-cache.identifiers 0 identifiers\n * @group can-connect/data/localstorage-cache/localstorage-cache.data-methods 1 data methods\n *\n * Saves raw data in localStorage.\n *\n * @deprecated {5.0} Use [can-local-store] instead.\n *\n * @signature `localStorage( baseConnection )`\n *\n *   Creates a cache of instances and a cache of sets of instances that is\n *   accessible to read via [can-connect/data/localstorage-cache/localstorage-cache.getSets],\n *   [can-connect/data/localstorage-cache/localstorage-cache.getData], and [can-connect/data/localstorage-cache/localstorage-cache.getListData].\n *   The caches are updated via [can-connect/data/localstorage-cache/localstorage-cache.createData],\n *   [can-connect/data/localstorage-cache/localstorage-cache.updateData], [can-connect/data/localstorage-cache/localstorage-cache.destroyData],\n *   and [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n *\n *   [can-connect/data/localstorage-cache/localstorage-cache.createData],\n *   [can-connect/data/localstorage-cache/localstorage-cache.updateData],\n *   [can-connect/data/localstorage-cache/localstorage-cache.destroyData] are able to move items in and out\n *   of sets.\n *\n * @body\n *\n * ## Use\n *\n * `data/localstorage-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n * [can-connect/cache-requests/cache-requests].  Make sure you configure the connection's [can-connect/data/localstorage-cache/localstorage-cache.name].\n *\n * ```\n * var cacheConnection = connect([\n *   require(\"can-connect/data/localstorage-cache/localstorage-cache\")\n * ],{\n *   name: \"todos\"\n * });\n *\n * var todoConnection = connect([\n *   require(\"can-connect/data/url/url\"),\n *   require(\"can-connect/fall-through-cache/fall-through-cache\")\n * ],\n * {\n *   url: \"/services/todos\",\n *   cacheConnection: cacheConnection\n * });\n * ```\n *\n */\n \nmodule.exports = require(\"can-local-store\");\n","\"use strict\";\n/**\n * @module can-connect/fall-through-cache/fall-through-cache fall-through-cache\n * @parent can-connect.behaviors\n * @group can-connect/fall-through-cache/fall-through-cache.data data callbacks\n * @group can-connect/fall-through-cache/fall-through-cache.hydrators hydrators\n *\n * Add fall-through caching with the `cacheConnection`.\n *\n * @signature `fallThroughCache( baseConnection )`\n *\n *   Implements a `getData` and `getListData` that\n *   check their [can-connect/base/base.cacheConnection] for data. If there is data,\n *   this data will be immediately returned.\n *   In the background, the `baseConnection` method will be called and used to update the instance or list.\n *\n * @body\n *\n * ## Use\n *\n * To use the `fall-through-cache`, create a connection with a\n * [can-connect/base/base.cacheConnection] and a behavior that implements\n * [can-connect/connection.getData] and [can-connect/connection.getListData].\n *\n * ```js\n * var QueryLogic = require(\"can-query-logic\");\n *\n * var queryLogic = new QueryLogic();\n *\n * var cache = connect([\n *   require(\"can-local-store\")\n * ],{\n *   name: \"todos\",\n *   queryLogic: queryLogic\n * });\n *\n * var todoConnection = connect([\n *    require(\"can-connect/fall-through-cache/fall-through-cache\"),\n *    require(\"can-connect/data/url/url\"),\n *    require(\"can-connect/constructor/constructor\"),\n *    require(\"can-connect/constructor/store/store\")\n *   ], {\n *   url: \"/todos\",\n *   cacheConnection: cache,\n *   queryLogic: queryLogic\n * });\n * ```\n *\n * Then, make requests.  If the cache has the data,\n * it will be returned immediately, and then the item or list updated later\n * with the response from the base connection:\n *\n * ```js\n * todoConnection.getList({due: \"today\"}).then(function(todos){\n *\n * })\n * ```\n *\n * ## Demo\n *\n * The following shows the `fall-through-cache` behavior.\n *\n * @demo demos/can-connect/fall-through-cache.html\n *\n * Clicking\n * \"Completed\" or \"Incomplete\" will make one of the following requests and\n * display the results in the page:\n *\n * ```\n * todoConnection.getList({completed: true});\n * todoConnection.getList({completed: false});\n * ```\n *\n * If you click back and forth between \"Completed\" and \"Incomplete\" multiple times\n * you'll notice that the old data is displayed immediately and then\n * updated after about a second.\n *\n */\nvar connect = require(\"../can-connect\");\nvar sortedSetJSON = require(\"../helpers/sorted-set-json\");\nvar canLog = require(\"can-log\");\n\nvar fallThroughCache = connect.behavior(\"fall-through-cache\",function(baseConnection){\n\n\tvar behavior = {\n\t\t/**\n\t\t * @function can-connect/fall-through-cache/fall-through-cache.hydrateList hydrateList\n\t\t * @parent can-connect/fall-through-cache/fall-through-cache.hydrators\n\t\t *\n\t\t * Returns a List instance given raw data.\n\t\t *\n\t\t * @signature `connection.hydrateList(listData, set)`\n\t\t *\n\t\t *   Calls the base `hydrateList` to create a List for `listData`.\n\t\t *\n\t\t *   Then, Looks for registered hydrateList callbacks for a given `set` and\n\t\t *   calls them.\n\t\t *\n\t\t *   @param {can-connect.listData} listData\n\t\t *   @param {can-query-logic/query} query\n\t\t *   @return {can-connect.List}\n\t\t */\n\t\thydrateList: function(listData, set){\n\t\t\tset = set || this.listQuery(listData);\n\t\t\tvar id = sortedSetJSON( set );\n\t\t\tvar list = baseConnection.hydrateList.call(this, listData, set);\n\n\t\t\tif(this._getHydrateListCallbacks[id]) {\n\t\t\t\tthis._getHydrateListCallbacks[id].shift()(list);\n\t\t\t\tif(!this._getHydrateListCallbacks[id].length){\n\t\t\t\t\tdelete this._getHydrateListCallbacks[id];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn list;\n\t\t},\n\t\t_getHydrateListCallbacks: {},\n\t\t_getHydrateList: function(set, callback){\n\t\t\tvar id = sortedSetJSON( set );\n\t\t\tif(!this._getHydrateListCallbacks[id]) {\n\t\t\t\tthis._getHydrateListCallbacks[id]= [];\n\t\t\t}\n\t\t\tthis._getHydrateListCallbacks[id].push(callback);\n\t\t},\n\t\t/**\n\t\t * @function can-connect/fall-through-cache/fall-through-cache.getListData getListData\n\t\t * @parent can-connect/fall-through-cache/fall-through-cache.data\n\t\t *\n\t\t * Get raw data from the cache if available, and then update\n\t\t * the list later with data from the base connection.\n\t\t *\n\t\t * @signature `connection.getListData(set)`\n\t\t *\n\t\t *   Checks the [can-connect/base/base.cacheConnection] for `set`'s data.\n\t\t *\n\t\t *   If the cache connection has data, the cached data is returned. Prior to\n\t\t *   returning the data, the [can-connect/constructor.hydrateList] method\n\t\t *   is intercepted so we can get a handle on the list that's being created\n\t\t *   for the returned data. Once the intercepted list is retrieved,\n\t\t *   we use the base connection to get data and update the intercepted list and\n\t\t *   the cacheConnection.\n\t\t *\n\t\t *   If the cache connection does not have data, the base connection\n\t\t *   is used to load the data and the cached connection is updated with that\n\t\t *   data.\n\t\t *\n\t\t *   @param {can-query-logic/query} query The set to load.\n\t\t *\n\t\t *   @return {Promise<can-connect.listData>} A promise that returns the\n\t\t *   raw data.\n\t\t */\n\t\t// if we do getList, the cacheConnection runs on\n\t\t// if we do getListData, ... we need to register the list that is going to be created\n\t\t// so that when the data is returned, it updates this\n\t\tgetListData: function(set){\n\t\t\tset = set || {};\n\t\t\tvar self = this;\n\t\t\treturn this.cacheConnection.getListData(set).then(function(data){\n\n\t\t\t\t// get the list that is going to be made\n\t\t\t\t// it might be possible that this never gets called, but not right now\n\t\t\t\tself._getHydrateList(set, function(list){\n\t\t\t\t\tself.addListReference(list, set);\n\n\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\tbaseConnection.getListData.call(self, set).then(function(listData){\n\n\t\t\t\t\t\t\tself.cacheConnection.updateListData(listData, set);\n\t\t\t\t\t\t\tself.updatedList(list, listData, set);\n\t\t\t\t\t\t\tself.deleteListReference(list, set);\n\n\t\t\t\t\t\t}, function(e){\n\t\t\t\t\t\t\t// what do we do here?  self.rejectedUpdatedList ?\n\t\t\t\t\t\t\tcanLog.log(\"REJECTED\", e);\n\t\t\t\t\t\t});\n\t\t\t\t\t},1);\n\t\t\t\t});\n\t\t\t\t// TODO: if we wired up all responses to updateListData, this one should not\n\t\t\t\t// updateListData with itself.\n\t\t\t\t// But, how would we do a bypass?\n\t\t\t\treturn data;\n\t\t\t}, function(){\n\n\t\t\t\tvar listData = baseConnection.getListData.call(self, set);\n\t\t\t\tlistData.then(function(listData){\n\n\t\t\t\t\tself.cacheConnection.updateListData(listData, set);\n\t\t\t\t});\n\n\t\t\t\treturn listData;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * @function can-connect/fall-through-cache/fall-through-cache.hydrateInstance hydrateInstance\n\t\t * @parent can-connect/fall-through-cache/fall-through-cache.hydrators\n\t\t *\n\t\t * Returns an instance given raw data.\n\t\t *\n\t\t * @signature `connection.hydrateInstance(props)`\n\t\t *\n\t\t *   Calls the base `hydrateInstance` to create an Instance for `props`.\n\t\t *\n\t\t *   Then, Looks for registered hydrateInstance callbacks for a given [can-connect/base/base.id] and\n\t\t *   calls them.\n\t\t *\n\t\t *   @param {Object} props\n\t\t *   @return {can-connect/Instance}\n\t\t */\n\t\thydrateInstance: function(props){\n\n\t\t\tvar id = this.id( props );\n\t\t\tvar instance = baseConnection.hydrateInstance.apply(this, arguments);\n\n\t\t\tif(this._getMakeInstanceCallbacks[id]) {\n\t\t\t\tthis._getMakeInstanceCallbacks[id].shift()(instance);\n\t\t\t\tif(!this._getMakeInstanceCallbacks[id].length){\n\t\t\t\t\tdelete this._getMakeInstanceCallbacks[id];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn instance;\n\t\t},\n\t\t_getMakeInstanceCallbacks: {},\n\t\t_getMakeInstance: function(id, callback){\n\t\t\tif(!this._getMakeInstanceCallbacks[id]) {\n\t\t\t\tthis._getMakeInstanceCallbacks[id]= [];\n\t\t\t}\n\t\t\tthis._getMakeInstanceCallbacks[id].push(callback);\n\t\t},\n\t\t/**\n\t\t * @function can-connect/fall-through-cache/fall-through-cache.getData getData\n\t\t * @parent can-connect/fall-through-cache/fall-through-cache.data\n\t\t *\n\t\t * Get raw data from the cache if available, and then update\n\t\t * the instance later with data from the base connection.\n\t\t *\n\t\t * @signature `connection.getData(params)`\n\t\t *\n\t\t *   Checks the [can-connect/base/base.cacheConnection] for `params`'s data.\n\t\t *\n\t\t *   If the cache connection has data, the cached data is returned. Prior to\n\t\t *   returning the data, the [can-connect/constructor/constructor.hydrateInstance] method\n\t\t *   is intercepted so we can get a handle on the instance that's being created\n\t\t *   for the returned data. Once the intercepted instance is retrieved,\n\t\t *   we use the base connection to get data and update the intercepted instance and\n\t\t *   the cacheConnection.\n\t\t *\n\t\t *   If the cache connection does not have data, the base connection\n\t\t *   is used to load the data and the cached connection is updated with that\n\t\t *   data.\n\t\t *\n\t\t *   @param {Object} params The set to load.\n\t\t *\n\t\t *   @return {Promise<Object>} A promise that returns the\n\t\t *   raw data.\n\t\t */\n\t\tgetData: function(params){\n\t\t\t// first, always check the cache connection\n\t\t\tvar self = this;\n\t\t\treturn this.cacheConnection.getData(params).then(function(instanceData){\n\n\t\t\t\t// get the list that is going to be made\n\t\t\t\t// it might be possible that this never gets called, but not right now\n\t\t\t\tself._getMakeInstance(self.id(instanceData) || self.id(params), function(instance){\n\t\t\t\t\tself.addInstanceReference(instance);\n\n\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\tbaseConnection.getData.call(self, params).then(function(instanceData2){\n\n\t\t\t\t\t\t\tself.cacheConnection.updateData(instanceData2);\n\t\t\t\t\t\t\tself.updatedInstance(instance, instanceData2);\n\t\t\t\t\t\t\tself.deleteInstanceReference(instance);\n\n\t\t\t\t\t\t}, function(e){\n\t\t\t\t\t\t\t// what do we do here?  self.rejectedUpdatedList ?\n\t\t\t\t\t\t\tcanLog.log(\"REJECTED\", e);\n\t\t\t\t\t\t});\n\t\t\t\t\t},1);\n\t\t\t\t});\n\n\t\t\t\treturn instanceData;\n\t\t\t}, function(){\n\t\t\t\tvar listData = baseConnection.getData.call(self, params);\n\t\t\t\tlistData.then(function(instanceData){\n\t\t\t\t\tself.cacheConnection.updateData(instanceData);\n\t\t\t\t});\n\n\t\t\t\treturn listData;\n\t\t\t});\n\t\t}\n\n\t};\n\n\treturn behavior;\n\n});\n\nmodule.exports = fallThroughCache;\n\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\tvar validate = require(\"../helpers/validate\");\n\tmodule.exports = validate(fallThroughCache, ['hydrateList', 'hydrateInstance', 'getListData', 'getData']);\n}\n//!steal-remove-end\n","\"use strict\";\n/**\n * @module {connect.Behavior} can-connect/can/ref/ref can/ref\n * @parent can-connect.behaviors\n * @group can-connect/can/ref/ref.hydrators hydrators\n * @group can-connect/can/ref/ref.methods methods\n *\n * @description Handle references to instances in the data returned by the server. Allows several means of\n * loading referenced instances, determined on-the-fly.\n *\n * @signature `canRef( baseConnection )`\n *\n * Adds a reference type to [can-connect/can/map/map._Map `connection.Map`] that loads the related type or holds onto\n * an existing one. This handles circular references and loads relevant data as needed. The reference type can be loaded\n * by:\n * - it's data being included in the response for the referencing instance\n * - having an existing instance available in the [can-connect/constructor/store/store.instanceStore]\n * - lazy loading via the connection for the reference type\n *\n * @param {{}} baseConnection `can-connect` connection object that is having the `can/ref` behavior added on to it.\n * Expects the [can-connect/can/map/map] behavior to already be added to this base connection. If the `connect` helper\n * is used to build the connection, the behaviors will automatically be ordered as required.\n *\n * @return {{}} a connection with the [can-connect/can/map/map._Map `Map`] having the reference type property\n * (`Map.Ref.type`) created by `can/ref`.\n *\n * @body\n *\n * ## Use\n *\n * `can/ref` is useful when the server might return either a reference to\n * a value or the value itself.  For example, in a MongoDB setup,\n * a request like `GET /game/5` might return:\n *\n * ```\n * {\n *   id: 5,\n *   teamRef: 7,\n *   score: 21\n * }\n * ```\n *\n * But a request like `GET /game/5?$populate=teamRef` might return:\n *\n * ```\n * {\n *   id: 5,\n *   teamRef: {id: 7, name: \"Cubs\"},\n *   score: 21\n * }\n * ```\n *\n * `can/ref` can handle this ambiguity and even make lazy loading possible.\n *\n * To use `can/ref`, first create a Map and a connection for the referenced type:\n *\n * ```\n * var Team = DefineMap.extend({\n *   id: 'string'\n * });\n *\n * connect([\n *   require(\"can-connect/constructor/constructor\"),\n *   require(\"can-connect/constructor/store/store\"),\n *   require(\"can-connect/can/map/map\"),\n *   require(\"can-connect/can/ref/ref\")\n * ],{\n *     Map: Team,\n *     List: Team.List,\n *     ...\n * })\n * ```\n *\n * The connection is necessary because it creates an instance store which will\n * hold instances of `Team` that the `Team.Ref` type will be able to access.\n *\n * Now we can create a reference to the Team within a Game map and the Game's connection:\n *\n * ```\n * var Game = DefineMap.extend({\n *   id: 'string',\n *   teamRef: {type: Team.Ref.type},\n *   score: \"number\"\n * });\n *\n * superMap({\n *   Map: Game,\n *   List: Game.List\n * })\n * ```\n *\n * Now, `teamRef` is a [can-connect/can/ref/ref.Map.Ref] type, which will\n * house the id of the reference no matter how the server returns data, e.g.\n * `game.teamRef.id`.\n *\n * For example, without populating the team data:\n *\n * ```\n * Game.get({id: 5}).then(function(game){\n *   game.teamRef.id //-> 7\n * });\n * ```\n *\n * With populating the team data:\n *\n * ```\n * Game.get({id: 5, $populate: \"teamRef\"}).then(function(game){\n *   game.teamRef.id //-> 7\n * });\n * ```\n *\n * The values of other properties and methods on the [can-connect/can/ref/ref.Map.Ref] type\n * are determined by if the reference was populated or the referenced item already exists\n * in the [can-connect/constructor/store/store.instanceStore].\n *\n * For example, `value`, which points to the referenced instance, will be populated if the reference was populated:\n *\n * ```\n * Game.get({id: 5, $populate: \"teamRef\"}).then(function(game){\n *   game.teamRef.value.name //-> 5\n * });\n * ```\n *\n * Or, it will be populated if that instance had been loaded through another means and\n * it’s in the instance store:\n *\n * ```\n * Team.get({id: 7}).then(function(team){\n *   // binding adds things to the store\n *   team.on(\"name\", function(){})\n * }).then(function(){\n *   Game.get({id: 5}).then(function(game){\n *     game.teamRef.value.name //-> 5\n *   });\n * })\n * ```\n *\n * `value` is an [can-define.types.get asynchronous getter], which means that even if\n * the referenced value isn't populated or loaded through the store, it can be lazy loaded. This\n * is generally most useful in a template.\n *\n * The following will make an initial request for game `5`, but when the template\n * tried to read and listen to `game.teamRef.value.name`, a request for team `7`\n * will be made.\n *\n * ```\n * var template = stache(\"{{game.teamRef.value.name}} scored {{game.score}} points\");\n * Game.get({id: 5}).then(function(game){\n *   template({game: game});\n * });\n * ```\n *\n *\n */\nvar connect = require(\"../../can-connect\");\nvar WeakReferenceMap = require(\"../../helpers/weak-reference-map\");\nvar ObservationRecorder = require(\"can-observation-recorder\");\nvar constructorStore = require(\"../../constructor/store/store\");\nvar define = require(\"can-define\");\nvar canReflect = require(\"can-reflect\");\n\nvar makeRef = function(connection) {\n\tvar idProp = canReflect.getSchema(connection.queryLogic).identity[0];\n\t/**\n\t * @property {constructor} can-connect/can/ref/ref.Map.Ref Map.Ref\n\t * @parent can-connect/can/ref/ref.hydrators\n\t * @group can-connect/can/ref/ref.Map.Ref.static static\n\t * @group can-connect/can/ref/ref.Map.Ref.prototype prototype\n\t *\n\t * A reference type with `instanceRef.value` primed to return an existing instance of the\n\t * [can-connect/can/map/map._Map] type, if available, or lazy load an instance upon accessing `instanceRef.value`.\n\t *\n\t * @signature `new Map.Ref(id, value)`\n\t * @param  {string} id    string representing the record id\n\t * @param  {Object} value properties to be loaded / hydrated\n\t * @return {Map.Ref}       instance reference object for the id\n\t */\n\tvar Ref = (function(){\n\t\treturn function(id, value) {\n\t\t\tif (typeof id === \"object\") {\n\t\t\t\tvalue = id;\n\t\t\t\tid = value[idProp];\n\t\t\t}\n\t\t\t// check if this is in the store\n\t\t\tvar storeRef = Ref.store.get(id);\n\t\t\tif (storeRef) {\n\t\t\t\tif (value && !storeRef._value) {\n\t\t\t\t\tif (value instanceof connection.Map) {\n\t\t\t\t\t\tstoreRef._value = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstoreRef._value = connection.hydrateInstance(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn storeRef;\n\t\t\t}\n\t\t\t// if not, create it\n\t\t\tthis[idProp] = id;\n\t\t\tif (value) {\n\t\t\t\t// if the value is already an instance, use it.\n\n\t\t\t\tif (value instanceof connection.Map) {\n\t\t\t\t\tthis._value = value;\n\t\t\t\t} else {\n\t\t\t\t\tthis._value = connection.hydrateInstance(value);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// check if this is being made during a request\n\t\t\t// if it is, save it\n\t\t\tif (constructorStore.requests.count() > 0) {\n\t\t\t\tif (!Ref._requestInstances[id]) {\n\t\t\t\t\tRef.store.addReference(id, this);\n\t\t\t\t\tRef._requestInstances[id] = this;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t})();\n\t/**\n\t * @property {can-connect/helpers/weak-reference-map} can-connect/can/ref/ref.Map.Ref.store store\n\t * @parent can-connect/can/ref/ref.Map.Ref.static\n\t * @hide // not something that needs to be documented for the average user\n\t * A WeakReferenceMap that contains instances being created by their `._cid` property.\n\t */\n\tRef.store = new WeakReferenceMap();\n\tRef._requestInstances = {};\n\t/**\n\t * @function can-connect/can/ref/ref.Map.Ref.type type\n\t * @parent can-connect/can/ref/ref.Map.Ref.static\n\t *\n\t * Returns a new instance of `Map.Ref`.\n\t *\n\t * @signature `Map.Ref.type(reference)`\n\t *\n\t *   @param {Object|String|Number} reference either data or an id for an instance of [can-connect/can/map/map._Map].\n\t *   @return {can-connect/can/ref/ref.Map.Ref} reference instance for the passed data or identifier.\n\t */\n\tRef.type = function(ref) {\n\t\tif (ref && typeof ref !== \"object\") {\n\t\t\t// get or make the existing reference from the store\n\t\t\treturn new Ref(ref);\n\t\t} else {\n\t\t\t// get or make the reference in the store, update the instance too\n\t\t\treturn new Ref(ref[idProp], ref);\n\t\t}\n\t};\n\tvar defs = {\n\t\t/**\n\t\t * @property {Promise} can-connect/can/ref/ref.Map.Ref.prototype.promise promise\n\t\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t\t * @hide // don't know if this is part of the public API\n\t\t *\n\t\t * Returns a resolved promise if the referenced instance is already available, if not, returns a new promise\n\t\t * to retrieve the instance by the id.\n\t\t *\n\t\t * @signature `ref.promise`\n\t\t * @return {Promise} Promise resolving the instance referenced\n\t\t */\n\t\tpromise: {\n\t\t\tget: function() {\n\t\t\t\tif (this._value) {\n\t\t\t\t\treturn Promise.resolve(this._value);\n\t\t\t\t} else {\n\t\t\t\t\tvar props = {};\n\t\t\t\t\tprops[idProp] = this[idProp];\n\t\t\t\t\treturn connection.Map.get(props);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_state: {\n\t\t\tget: function(lastSet, resolve) {\n\t\t\t\tif (resolve) {\n\t\t\t\t\tthis.promise.then(function() {\n\t\t\t\t\t\tresolve(\"resolved\");\n\t\t\t\t\t}, function() {\n\t\t\t\t\t\tresolve(\"rejected\");\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn \"pending\";\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @property {*} can-connect/can/ref/ref.Map.Ref.prototype.value value\n\t\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t\t *\n\t\t * Returns the actual instance the reference points to. Returns `undefined` if the instance is still being loaded.\n\t\t * Accessing this property will start lazy loading if the instance isn't already available.\n\t\t *\n\t\t * @signature `ref.value`\n\t\t * @return {object} actual instance referenced or `undefined` if lazy loading ongoing\n\t\t */\n\t\tvalue: {\n\t\t\tget: function(lastSet, resolve) {\n\t\t\t\tif (this._value) {\n\t\t\t\t\treturn this._value;\n\t\t\t\t} else if (resolve) {\n\t\t\t\t\tthis.promise.then(function(value) {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @property {*} can-connect/can/ref/ref.Map.Ref.prototype.reason reason\n\t\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t\t *\n\t\t * Returns the failure message from the lazy loading promise. Returns `undefined` if the referenced instance is\n\t\t * available or loading is ongoing.\n\t\t *\n\t\t * @signature `ref.reason`\n\t\t * @return {Object} error message if the promise is rejected\n\t\t */\n\t\treason: {\n\t\t\tget: function(lastSet, resolve) {\n\t\t\t\tif (this._value) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else {\n\t\t\t\t\tthis.promise.catch(function(value) {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tdefs[idProp] = {\n\t\ttype: \"*\",\n\t\tset: function() {\n\t\t\tthis._value = undefined;\n\t\t}\n\t};\n\n\tdefine(Ref.prototype, defs);\n\n\tRef.prototype.unobservedId = ObservationRecorder.ignore(function() {\n\t\treturn this[idProp];\n\t});\n\t/**\n\t * @function can-connect/can/ref/ref.Map.Ref.prototype.isResolved isResolved\n\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t *\n\t * Observable property typically for use in templates to indicate to the user if lazy loading has succeeded.\n\t *\n\t * @signature `ref.isResolved`\n\t * @return {boolean} `true` if the lazy loading promise was resolved.\n\t */\n\tRef.prototype.isResolved = function() {\n\t\treturn !!this._value || this._state === \"resolved\";\n\t};\n\t/**\n\t * @function can-connect/can/ref/ref.Map.Ref.prototype.isRejected isRejected\n\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t *\n\t * Observable property typically for use in templates to indicate to the user if lazy loading has failed.\n\t *\n\t * @signature `ref.isRejected`\n\t * @return {boolean} `true` if the lazy loading promise was rejected.\n\t */\n\tRef.prototype.isRejected = function() {\n\t\treturn this._state === \"rejected\";\n\t};\n\n\t/**\n\t * @function can-connect/can/ref/ref.Map.Ref.prototype.isPending isPending\n\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t *\n\t * Observable property typically for use in templates to indicate to the user if lazy loading is ongoing.\n\t *\n\t * @signature `ref.isPending`\n\t * @return {boolean} `true` if the lazy loading promise state is not resolved or rejected.\n\t */\n\tRef.prototype.isPending = function() {\n\t\treturn !this._value && (this._state !== \"resolved\" || this._state !== \"rejected\");\n\t};\n\n\t/**\n\t * @function can-connect/can/ref/ref.Map.Ref.prototype.serialize serialize\n\t * @parent can-connect/can/ref/ref.Map.Ref.prototype\n\t *\n\t * Return the id of the referenced instance when serializing. Prevents the referenced instance from\n\t * being entirely serialized when serializing the referencing instance.\n\t *\n\t * @signature `ref.serialize`\n\t * @return {string} id the id of the referenced instance\n\t */\n\tRef.prototype.serialize = function() {\n\t\treturn this[idProp];\n\t};\n\tcanReflect.assignSymbols(Ref.prototype, {\n\t\t\"can.serialize\": Ref.prototype.serialize,\n\t\t\"can.getName\": function(){\n\t\t\treturn canReflect.getName(this.constructor)+\"{\"+this[idProp]+\"}\";\n\t\t}\n\t})\n\n\tvar baseEventSetup = Ref.prototype._eventSetup;\n\tRef.prototype._eventSetup = function() {\n\t\tRef.store.addReference(this.unobservedId(), this);\n\t\treturn baseEventSetup.apply(this, arguments);\n\t};\n\tvar baseTeardown = Ref.prototype._eventTeardown;\n\tRef.prototype._eventTeardown = function() {\n\t\tRef.store.deleteReference(this.unobservedId(), this);\n\t\treturn baseTeardown.apply(this, arguments);\n\t};\n\n\n\tconstructorStore.requests.on(\"end\", function() {\n\t\tfor (var id in Ref._requestInstances) {\n\t\t\tRef.store.deleteReference(id);\n\t\t}\n\t\tRef._requestInstances = {};\n\t});\n\n\t//!steal-remove-start\n\tObject.defineProperty(Ref, \"name\", {\n\t\tvalue: canReflect.getName(connection.Map) + \"Ref\",\n\t\tconfigurable: true\n\t});\n\t//!steal-remove-end\n\n\treturn Ref;\n};\n\n\nmodule.exports = connect.behavior(\"can/ref\", function(baseConnection) {\n\treturn {\n\t\t/**\n\t\t * @can-connect/can/ref/ref.init init\n\t\t * @parent can-connect/can/ref/ref.methods\n\t\t *\n\t\t * @signature `connection.init()`\n\t\t *\n\t\t * Initializes the base connection and then creates and sets [can-connect/can/ref/ref.Map.Ref].\n\t\t * Typically called by the `connect` helper after the connection behaviors have been assembled.\n\t\t *\n\t\t * @return {undefined} no return value\n\t\t **/\n\t\tinit: function() {\n\t\t\tbaseConnection.init.apply(this, arguments);\n\t\t\tthis.Map.Ref = makeRef(this);\n\t\t}\n\t};\n});\n"],"names":["data","Array","isArray","assign","require$$0","assignMap","each","pairs","createdData","updatedData","destroyedData","callbackCache","connect","behavior","baseConnection","crudMethod","dataCallback","params","cid","this","cacheConnection","call","module","process","env","NODE_ENV","validate","require$$1","def","promise","Promise","resolve","reject","forEach","combineRequests","pendingRequests","unionPendingRequests","self","sort","pReq1","pReq2","queryLogic","isSubset","set","current","combineData","doubleLoop","start","pendingRequest","push","iterate","combined","union","isDefinedAndHasMembers","time","getListData","setTimeout","combineDataPromise","then","combinedData","combinedSet","canReflect","serialize","length","deferred","pending","filterMembers","getItems","err","makeDeferred","arr","callbacks","i","j","splice","fallThroughCache","hydrateList","listData","listQuery","id","sortedSetJSON","list","_getHydrateListCallbacks","shift","_getHydrateList","callback","addListReference","updateListData","updatedList","deleteListReference","e","canLog","log","hydrateInstance","props","instance","apply","arguments","_getMakeInstanceCallbacks","_getMakeInstance","getData","instanceData","addInstanceReference","instanceData2","updateData","updatedInstance","deleteInstanceReference","makeRef","connection","idProp","getSchema","identity","Ref","value","storeRef","store","get","_value","Map","constructorStore","requests","count","_requestInstances","addReference","WeakReferenceMap","type","ref","defs","_state","lastSet","reason","catch","undefined","define","prototype","unobservedId","ObservationRecorder","ignore","isResolved","isRejected","isPending","assignSymbols","can.serialize","can.getName","getName","constructor","baseEventSetup","_eventSetup","baseTeardown","_eventTeardown","deleteReference","on","Object","defineProperty","configurable","init"],"mappings":"wrBACA,aAAiB,SAASA,GACzB,OAAGC,MAAMC,QAAQF,GACTA,EAEAA,EAAKA,sDCwCd,IAAIG,EAASC,WAAuBC,UAChCC,EAAOF,WAAuBE,KAG9BC,EAAQ,CAoBXC,YAAa,aAmBbC,YAAa,aAmBbC,cAAe,eAKZC,EAAgBC,QAAQC,SAAS,uBAAuB,SAASC,GACpE,IAAID,EAAW,GAiBf,OAfAP,EAAKC,EAAO,SAASQ,EAAYC,GAChCH,EAASG,GAAgB,SAAShB,EAAMiB,EAAQC,GAM/C,OAHAC,KAAKC,gBAAgBL,GAAaZ,EAAOA,EAAO,GAAIc,GAASjB,IAGzDc,EAAeE,GACXF,EAAeE,GAAcK,KAAKF,KAAMnB,EAAMiB,EAAQC,GAEtDlB,KAKHa,IAMR,GAHAS,UAAiBX,EAGW,eAAzBY,UAAQC,IAAIC,SAA2B,CACzC,IAAIC,EAAWC,WACfL,UAAiBI,EAASf,EAAe,gBCxIzB,WAChB,IAAIiB,EAAM,GAKV,OAJAA,EAAIC,QAAU,IAAIC,QAAQ,SAASC,EAASC,GAC3CJ,EAAIG,QAAUA,EACdH,EAAII,OAASA,IAEPJ,GCHJK,QAAU,GAAGA,QAyDbC,gBAAkBtB,QAAQC,SAAS,wBAAwB,SAASC,GACvE,IAAIqB,EAEJ,MAAO,CAoDNC,qBAAsB,SAASD,GAQ9B,IAAIE,EAAOlB,KAEXgB,EAAgBG,KAAK,SAASC,EAAOC,GAEpC,OAAGH,EAAKI,WAAWC,SAASH,EAAMI,IAAKH,EAAMG,KACrC,EACGN,EAAKI,WAAWC,SAASF,EAAMG,IAAKJ,EAAMI,MAC5C,EAED,IAMT,IACIC,EADAC,EAAc,GAuBlB,OApBAC,WAAWX,EAAiB,CAC3BY,MAAO,SAASC,GACfJ,EAAU,CACTD,IAAKK,EAAeL,IACpBR,gBAAiB,CAACa,IAEnBH,EAAYI,KAAKL,IAElBM,QAAS,SAASF,GACjB,IAAIG,EAAWd,EAAKI,WAAWW,MAAMR,EAAQD,IAAKK,EAAeL,KACjE,GAAIN,EAAKI,WAAWY,uBAAuBF,GAK1C,OAHAP,EAAQD,IAAMQ,EACdP,EAAQT,gBAAgBc,KAAKD,IAEtB,KAKHlB,QAAQC,QAAQc,IAuBxBS,KAAK,EAqBLC,YAAa,SAASZ,GACrBA,EAAMA,GAAO,GACb,IAAIN,EAAOlB,KAEPgB,IAEHA,EAAkB,GAElBqB,WAAW,WAEV,IAAIC,EAAqBpB,EAAKD,qBAAqBD,GACnDA,EAAkB,KAClBsB,EAAmBC,KAAK,SAASC,GAEhC1B,QAAQZ,KAAKsC,EAAc,SAASR,GAEnC,IAAIS,EAAcC,WAAWC,UAAUX,EAASR,KAEhD7B,EAAeyC,YAAYK,GAAaF,KAAK,SAAS1D,GACd,IAApCmD,EAAShB,gBAAgB4B,OAC3BZ,EAAShB,gBAAgB,GAAG6B,SAASjC,QAAQ/B,GAE7CiC,QAAQZ,KAAK8B,EAAShB,gBAAiB,SAAS8B,GAK/CA,EAAQD,SAASjC,QAAS,CAAC/B,KAAMqC,EAAKI,WAAWyB,cAAcD,EAAQtB,IAAKQ,EAASR,IAAKwB,SAASnE,SAGnG,SAASoE,GAC4B,IAApCjB,EAAShB,gBAAgB4B,OAC3BZ,EAAShB,gBAAgB,GAAG6B,SAAShC,OAAOoC,GAE5CnC,QAAQZ,KAAK8B,EAAShB,gBAAiB,SAAS8B,GAC/CA,EAAQD,SAAShC,OAAOoC,YAS3BjD,KAAKmC,MAAQ,IAEjB,IAAIU,EAAWK,WAIf,OAFAlC,EAAgBc,KAAK,CAACe,SAAUA,EAAUrB,IAAKA,IAExCqB,EAASnC,8BAKFK,gBAuBbY,8BAnBapB,WAASQ,gBAAiB,CAAC,gBAmB3B,SAASoC,EAAKC,GAE9B,IADA,IAAIC,EAAI,EACFA,EAAIF,EAAIP,QAAQ,CACrBQ,EAAUxB,MAAMuB,EAAIE,IAEpB,IADA,IAAIC,EAAID,EAAE,EACHC,EAAIH,EAAIP,SACmB,IAA9BQ,EAAUrB,QAAQoB,EAAIG,IACxBH,EAAII,OAAOD,EAAG,GAEdA,IAGFD,yBCtPepE,kEC+BjB,IAAIuE,EAAmB/D,QAAQC,SAAS,qBAAqB,SAASC,GAiNrE,MA/Me,CAkBd8D,YAAa,SAASC,EAAUlC,GAC/BA,EAAMA,GAAOxB,KAAK2D,UAAUD,GAC5B,IAAIE,EAAKC,cAAerC,GACpBsC,EAAOnE,EAAe8D,YAAYvD,KAAKF,KAAM0D,EAAUlC,GAQ3D,OANGxB,KAAK+D,yBAAyBH,KAChC5D,KAAK+D,yBAAyBH,GAAII,OAAlChE,CAA0C8D,GACtC9D,KAAK+D,yBAAyBH,GAAIhB,eAC9B5C,KAAK+D,yBAAyBH,IAGhCE,GAERC,yBAA0B,GAC1BE,gBAAiB,SAASzC,EAAK0C,GAC9B,IAAIN,EAAKC,cAAerC,GACpBxB,KAAK+D,yBAAyBH,KACjC5D,KAAK+D,yBAAyBH,GAAK,IAEpC5D,KAAK+D,yBAAyBH,GAAI9B,KAAKoC,IAgCxC9B,YAAa,SAASZ,GACrBA,EAAMA,GAAO,GACb,IAAIN,EAAOlB,KACX,OAAOA,KAAKC,gBAAgBmC,YAAYZ,GAAKe,KAAK,SAAS1D,GAuB1D,OAnBAqC,EAAK+C,gBAAgBzC,EAAK,SAASsC,GAClC5C,EAAKiD,iBAAiBL,EAAMtC,GAE5Ba,WAAW,WACV1C,EAAeyC,YAAYlC,KAAKgB,EAAMM,GAAKe,KAAK,SAASmB,GAExDxC,EAAKjB,gBAAgBmE,eAAeV,EAAUlC,GAC9CN,EAAKmD,YAAYP,EAAMJ,EAAUlC,GACjCN,EAAKoD,oBAAoBR,EAAMtC,IAE7B,SAAS+C,GAEXC,OAAOC,IAAI,WAAYF,MAEvB,KAKI1F,GACL,WAEF,IAAI6E,EAAW/D,EAAeyC,YAAYlC,KAAKgB,EAAMM,GAMrD,OALAkC,EAASnB,KAAK,SAASmB,GAEtBxC,EAAKjB,gBAAgBmE,eAAeV,EAAUlC,KAGxCkC,KAmBTgB,gBAAiB,SAASC,GAEzB,IAAIf,EAAK5D,KAAK4D,GAAIe,GACdC,EAAWjF,EAAe+E,gBAAgBG,MAAM7E,KAAM8E,WAQ1D,OANG9E,KAAK+E,0BAA0BnB,KACjC5D,KAAK+E,0BAA0BnB,GAAII,OAAnChE,CAA2C4E,GACvC5E,KAAK+E,0BAA0BnB,GAAIhB,eAC/B5C,KAAK+E,0BAA0BnB,IAGjCgB,GAERG,0BAA2B,GAC3BC,iBAAkB,SAASpB,EAAIM,GAC1BlE,KAAK+E,0BAA0BnB,KAClC5D,KAAK+E,0BAA0BnB,GAAK,IAErC5D,KAAK+E,0BAA0BnB,GAAI9B,KAAKoC,IA6BzCe,QAAS,SAASnF,GAEjB,IAAIoB,EAAOlB,KACX,OAAOA,KAAKC,gBAAgBgF,QAAQnF,GAAQyC,KAAK,SAAS2C,GAqBzD,OAjBAhE,EAAK8D,iBAAiB9D,EAAK0C,GAAGsB,IAAiBhE,EAAK0C,GAAG9D,GAAS,SAAS8E,GACxE1D,EAAKiE,qBAAqBP,GAE1BvC,WAAW,WACV1C,EAAesF,QAAQ/E,KAAKgB,EAAMpB,GAAQyC,KAAK,SAAS6C,GAEvDlE,EAAKjB,gBAAgBoF,WAAWD,GAChClE,EAAKoE,gBAAgBV,EAAUQ,GAC/BlE,EAAKqE,wBAAwBX,IAE3B,SAASL,GAEXC,OAAOC,IAAI,WAAYF,MAEvB,KAGIW,GACL,WACF,IAAIxB,EAAW/D,EAAesF,QAAQ/E,KAAKgB,EAAMpB,GAKjD,OAJA4D,EAASnB,KAAK,SAAS2C,GACtBhE,EAAKjB,gBAAgBoF,WAAWH,KAG1BxB,QAaX,GAHAvD,UAAiBqD,EAGW,eAAzBpD,UAAQC,IAAIC,SAA2B,CACzC,IAAIC,EAAWtB,WACfkB,UAAiBI,EAASiD,EAAkB,CAAC,cAAe,kBAAmB,cAAe,eC3I3FgC,QAAU,SAASC,GACtB,IAAIC,EAAShD,WAAWiD,UAAUF,EAAWnE,YAAYsE,SAAS,GAe9DC,EACI,SAASjC,EAAIkC,GACD,iBAAPlC,IAEVA,GADAkC,EAAQlC,GACG8B,IAGZ,IAAIK,EAAWF,EAAIG,MAAMC,IAAIrC,GAC7B,GAAImC,EAQH,OAPID,IAAUC,EAASG,SAClBJ,aAAiBL,EAAWU,IAC/BJ,EAASG,OAASJ,EAElBC,EAASG,OAAST,EAAWf,gBAAgBoB,IAGxCC,EAGR/F,KAAK0F,GAAU9B,EACXkC,IAGCA,aAAiBL,EAAWU,IAC/BnG,KAAKkG,OAASJ,EAEd9F,KAAKkG,OAAST,EAAWf,gBAAgBoB,IAOvCM,iBAAiBC,SAASC,QAAU,IAClCT,EAAIU,kBAAkB3C,KAC1BiC,EAAIG,MAAMQ,aAAa5C,EAAI5D,MAC3B6F,EAAIU,kBAAkB3C,GAAM5D,QAWhC6F,EAAIG,MAAQ,IAAIS,iBAChBZ,EAAIU,kBAAoB,GAYxBV,EAAIa,KAAO,SAASC,GACnB,OAAIA,GAAsB,iBAARA,EAEV,IAAId,EAAIc,GAGR,IAAId,EAAIc,EAAIjB,GAASiB,IAG9B,IAAIC,EAAO,CAYVlG,QAAS,CACRuF,IAAK,WACJ,GAAIjG,KAAKkG,OACR,OAAOvF,QAAQC,QAAQZ,KAAKkG,QAE5B,IAAIvB,EAAQ,GAEZ,OADAA,EAAMe,GAAU1F,KAAK0F,GACdD,EAAWU,IAAIF,IAAItB,KAK7BkC,OAAQ,CACPZ,IAAK,SAASa,EAASlG,GAStB,OARIA,GACHZ,KAAKU,QAAQ6B,KAAK,WACjB3B,EAAQ,aACN,WACFA,EAAQ,cAIH,YAcTkF,MAAO,CACNG,IAAK,SAASa,EAASlG,GACtB,GAAIZ,KAAKkG,OACR,OAAOlG,KAAKkG,OACFtF,GACVZ,KAAKU,QAAQ6B,KAAK,SAASuD,GAC1BlF,EAAQkF,OAgBZiB,OAAQ,CACPd,IAAK,SAASa,EAASlG,GAClBZ,KAAKkG,QAGRlG,KAAKU,QAAQsG,MAAM,SAASlB,GAC3BlF,EAAQkF,QAMbc,EAAKlB,GAAU,CACdgB,KAAM,IACNlF,IAAK,WACJxB,KAAKkG,YAASe,IAIhBC,OAAOrB,EAAIsB,UAAWP,GAEtBf,EAAIsB,UAAUC,aAAeC,oBAAoBC,OAAO,WACvD,OAAOtH,KAAK0F,KAWbG,EAAIsB,UAAUI,WAAa,WAC1B,QAASvH,KAAKkG,QAA0B,aAAhBlG,KAAK6G,QAW9BhB,EAAIsB,UAAUK,WAAa,WAC1B,MAAuB,aAAhBxH,KAAK6G,QAYbhB,EAAIsB,UAAUM,UAAY,WACzB,OAAQzH,KAAKkG,SAA2B,aAAhBlG,KAAK6G,QAAyC,aAAhB7G,KAAK6G,SAa5DhB,EAAIsB,UAAUxE,UAAY,WACzB,OAAO3C,KAAK0F,IAEbhD,WAAWgF,cAAc7B,EAAIsB,UAAW,CACvCQ,gBAAiB9B,EAAIsB,UAAUxE,UAC/BiF,cAAe,WACd,OAAOlF,WAAWmF,QAAQ7H,KAAK8H,aAAa,IAAI9H,KAAK0F,GAAQ,OAI/D,IAAIqC,EAAiBlC,EAAIsB,UAAUa,YACnCnC,EAAIsB,UAAUa,YAAc,WAE3B,OADAnC,EAAIG,MAAMQ,aAAaxG,KAAKoH,eAAgBpH,MACrC+H,EAAelD,MAAM7E,KAAM8E,YAEnC,IAAImD,EAAepC,EAAIsB,UAAUe,eAqBjC,OApBArC,EAAIsB,UAAUe,eAAiB,WAE9B,OADArC,EAAIG,MAAMmC,gBAAgBnI,KAAKoH,eAAgBpH,MACxCiI,EAAapD,MAAM7E,KAAM8E,YAIjCsB,iBAAiBC,SAAS+B,GAAG,MAAO,WACnC,IAAK,IAAIxE,KAAMiC,EAAIU,kBAClBV,EAAIG,MAAMmC,gBAAgBvE,GAE3BiC,EAAIU,kBAAoB,KAIzB8B,OAAOC,eAAezC,EAAK,OAAQ,CAClCC,MAAOpD,WAAWmF,QAAQpC,EAAWU,KAAO,MAC5CoC,cAAc,IAIR1C,OAISpG,QAAQC,SAAS,UAAW,SAASC,GACrD,MAAO,CAYN6I,KAAM,WACL7I,EAAe6I,KAAK3D,MAAM7E,KAAM8E,WAChC9E,KAAKmG,IAAIN,IAAML,QAAQxF"}