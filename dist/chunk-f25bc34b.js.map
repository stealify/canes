{"version":3,"file":"chunk-f25bc34b.js","sources":["../node_modules/can-list/can-list.js"],"sourcesContent":["\"use strict\";\n/* jshint -W079 */\nvar namespace = require('can-namespace');\nvar Map = require('can-map');\nvar bubble = require('can-map/bubble');\nvar mapHelpers = require('can-map/map-helpers');\nvar queues = require('can-queues');\nvar canEvent = require('can-event-queue/map/map');\nvar ObservationRecorder = require('can-observation-recorder');\n\nvar CID = require('can-cid');\nvar canReflect = require('can-reflect');\nvar assign = require('can-assign');\nvar types = require('can-types');\nvar canSymbol = require('can-symbol');\nvar CIDMap = require(\"can-cid/map/map\");\n\n\n// Helpers for `observable` lists.\nvar splice = [].splice,\n\t// test if splice works correctly\n\tspliceRemovesProps = (function () {\n\t\t// IE's splice doesn't remove properties\n\t\tvar obj = {\n\t\t\t0: \"a\",\n\t\t\tlength: 1\n\t\t};\n\t\tsplice.call(obj, 0, 1);\n\t\treturn !obj[0];\n\t})();\n\n// Function that serializes the passed arg if\n// type does not match MapType of `this` list\n// then adds to args array\nvar serializeNonTypes = function(MapType, arg, args) {\n\tif(arg && arg.serialize && !(arg instanceof MapType)) {\n\t\targs.push(new MapType(arg.serialize()));\n\t} else {\n\t\targs.push(arg);\n\t}\n};\n\nvar List = Map.extend(\n\t{\n\t\tMap: Map\n\t},\n\t{\n\t\tsetup: function (instances, options) {\n\t\t\tthis.length = 0;\n\t\t\tCID(this, \".map\");\n\t\t\tthis._setupComputedProperties();\n\t\t\tinstances = instances === undefined ? [] : canReflect.toArray(instances);\n\t\t\tvar teardownMapping;\n\n\t\t\tif (canReflect.isPromise(instances)) {\n\t\t\t\tthis.replace(instances);\n\t\t\t} else {\n\t\t\t\tteardownMapping = instances.length && mapHelpers.addToMap(instances, this);\n\t\t\t\tthis.push.apply(this, instances);\n\t\t\t}\n\n\t\t\tif (teardownMapping) {\n\t\t\t\tteardownMapping();\n\t\t\t}\n\n\t\t\t// this change needs to be ignored\n\t\t\tassign(this, options);\n\t\t},\n\t\t_triggerChange: function (attr, how, newVal, oldVal) {\n\t\t\tqueues.batch.start();\n\t\t\t// `batchTrigger` direct add and remove events...\n\t\t\tvar index = +attr, patches;\n\t\t\t// Make sure this is not nested and not an expando\n\n\t\t\tif (!~(\"\"+attr).indexOf('.') && !isNaN(index)) {\n\t\t\t\tif(bubble.isBubbling(this, \"change\")) {\n\t\t\t\t\tcanEvent.dispatch.call(this, {\n\t\t\t\t\t\ttype: \"change\",\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t}, [attr, how, newVal, oldVal]);\n\t\t\t\t}\n\t\t\t\tif (how === 'add') {\n\t\t\t\t\tpatches = [{insert: newVal, index: index, deleteCount: 0, type: \"splice\"}];\n\t\t\t\t\tcanEvent.dispatch.call(this, {type: how, patches: patches}, [newVal, index]);\n\t\t\t\t\tcanEvent.dispatch.call(this, 'length', [this.length]);\n\t\t\t\t\t//canEvent.dispatch.call(this, 'can.patches', [patches]);\n\t\t\t\t} else if (how === 'remove') {\n\t\t\t\t\tpatches = [{index: index, deleteCount: oldVal.length, type: \"splice\"}];\n\t\t\t\t\tcanEvent.dispatch.call(this, {type: how, patches: patches}, [oldVal, index]);\n\t\t\t\t\tcanEvent.dispatch.call(this, 'length', [this.length]);\n\t\t\t\t\t//canEvent.dispatch.call(this, 'can.patches', [patches]);\n\t\t\t\t} else {\n\t\t\t\t\tcanEvent.dispatch.call(this, how, [newVal, index]);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tMap.prototype._triggerChange.apply(this, arguments);\n\t\t\t}\n\t\t\tqueues.batch.stop();\n\t\t},\n\t\t___get: function (attr) {\n\t\t\tif (attr) {\n\t\t\t\tvar computedAttr = this._computedAttrs[attr];\n\t\t\t\tif(computedAttr && computedAttr.compute) {\n\t\t\t\t\treturn canReflect.getValue(computedAttr.compute);\n\t\t\t\t}\n\n\t\t\t\tif (this[attr] && this[attr].isComputed && typeof this.constructor.prototype[attr] === \"function\" ) {\n\t\t\t\t\treturn canReflect.getValue(this[attr]);\n\t\t\t\t} else {\n\t\t\t\t\treturn this[attr];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t},\n\t\t__set: function (prop, value, current) {\n\t\t\t// We want change events to notify using integers if we're\n\t\t\t// setting an integer index. Note that <float> % 1 !== 0;\n\t\t\tprop = isNaN(+prop) || (prop % 1) ? prop : +prop;\n\n\t\t\t// Check to see if we're doing a .attr() on an out of\n\t\t\t// bounds index property.\n\t\t\tif (typeof prop === \"number\") {\n\t\t\t\tif( prop > this.length - 1 ) {\n\t\t\t\t\tvar newArr = new Array((prop + 1) - this.length);\n\t\t\t\t\tnewArr[newArr.length-1] = value;\n\t\t\t\t\tthis.push.apply(this, newArr);\n\t\t\t\t\treturn newArr;\n\t\t\t\t} else {\n\t\t\t\t\tthis.splice(prop,1,value);\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Map.prototype.__set.call(this, \"\"+prop, value, current);\n\t\t},\n\t\t___set: function (attr, val) {\n\t\t\tthis[attr] = val;\n\t\t\tif (+attr >= this.length) {\n\t\t\t\tthis.length = (+attr + 1);\n\t\t\t}\n\t\t},\n\t\t__remove: function(prop, current) {\n\t\t\t// if removing an expando property\n\t\t\tif(isNaN(+prop)) {\n\t\t\t\tdelete this[prop];\n\t\t\t\tthis._triggerChange(prop, \"remove\", undefined, current);\n\t\t\t} else {\n\t\t\t\tthis.splice(prop, 1);\n\t\t\t}\n\t\t},\n\t\t_each: function (callback) {\n\t\t\tvar data = this.___get();\n\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\tcallback(data[i], i);\n\t\t\t}\n\t\t},\n\t\t// Returns the serialized form of this list.\n\t\t/**\n\t\t * @hide\n\t\t * Returns the serialized form of this list.\n\t\t */\n\t\tserialize: function () {\n\t\t\treturn canReflect.serialize(this, CIDMap);\n\t\t},\n\t\tsplice: function (index, howMany) {\n\t\t\tvar args = canReflect.toArray(arguments),\n\t\t\t\tadded =[],\n\t\t\t\ti, len, listIndex,\n\t\t\t\tallSame = args.length > 2;\n\n\t\t\tindex = index || 0;\n\n\t\t\t// converting the arguments to the right type\n\t\t\tfor (i = 0, len = args.length-2; i < len; i++) {\n\t\t\t\tlistIndex = i + 2;\n\t\t\t\targs[listIndex] = this.__type(args[listIndex], listIndex);\n\t\t\t\tadded.push(args[listIndex]);\n\n\t\t\t\t// Now lets check if anything will change\n\t\t\t\tif(this[i+index] !== args[listIndex]) {\n\t\t\t\t\tallSame = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if nothing has changed, then return\n\t\t\tif(allSame && this.length <= added.length) {\n\t\t\t\treturn added;\n\t\t\t}\n\n\t\t\t// default howMany if not provided\n\t\t\tif (howMany === undefined) {\n\t\t\t\thowMany = args[1] = this.length - index;\n\t\t\t}\n\n\t\t\tvar removed = splice.apply(this, args);\n\n\t\t\t// delete properties for browsers who's splice sucks (old ie)\n\t\t\tif (!spliceRemovesProps) {\n\t\t\t\tfor (i = this.length; i < removed.length + this.length; i++) {\n\t\t\t\t\tdelete this[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tqueues.batch.start();\n\t\t\tif (howMany > 0) {\n\t\t\t\t// tears down bubbling\n\t\t\t\tbubble.removeMany(this, removed);\n\t\t\t\tthis._triggerChange(\"\" + index, \"remove\", undefined, removed);\n\t\t\t}\n\t\t\tif (args.length > 2) {\n\t\t\t\t// make added items bubble to this list\n\t\t\t\tbubble.addMany(this, added);\n\t\t\t\tthis._triggerChange(\"\" + index, \"add\", added, removed);\n\t\t\t}\n\t\t\tqueues.batch.stop();\n\t\t\treturn removed;\n\t\t}\n\t}),\n\n\t// Converts to an `array` of arguments.\n\tgetArgs = function (args) {\n\t\treturn args[0] && Array.isArray(args[0]) ?\n\t\t\targs[0] :\n\t\t\tcanReflect.toArray(args);\n\t};\n// Create `push`, `pop`, `shift`, and `unshift`\ncanReflect.eachKey({\n\t\t/**\n\t\t * @function can-list.prototype.push push\n\t\t * @parent can-list.prototype\n\t\t * @description Add elements to the end of a list.\n\t\t * @signature `list.push(...elements)`\n\t\t *\n\t\t * `push` adds elements onto the end of a List.\n\t\t *\n\t\t * @param {*} elements the elements to add to the List\n\t\t *\n\t\t * @return {Number} the new length of the List\n\t\t *\n\t\t * @body\n\t\t * `push` adds elements onto the end of a List here is an example:\n\t\t *\n\t\t * ```\n\t\t * var list = new List(['Alice']);\n\t\t *\n\t\t * list.push('Bob', 'Eve');\n\t\t * list.attr(); // ['Alice', 'Bob', 'Eve']\n\t\t * ```\n\t\t *\n\t\t * If you have an array you want to concatenate to the end\n\t\t * of the List, you can use `apply`:\n\t\t *\n\t\t * ```\n\t\t * var names = ['Bob', 'Eve'],\n\t\t *     list = new List(['Alice']);\n\t\t *\n\t\t * list.push.apply(list, names);\n\t\t * list.attr(); // ['Alice', 'Bob', 'Eve']\n\t\t * ```\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `push` causes _change_, _add_, and _length_ events to be fired.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `push` has a counterpart in [can-list.prototype.pop], or you may be\n\t\t * looking for [can-list.prototype.unshift] and its counterpart [can-list.prototype.shift].\n\t\t */\n\t\tpush: \"length\",\n\t\t/**\n\t\t * @function can-list.prototype.unshift unshift\n\t\t * @parent can-list.prototype\n\t\t * @description Add elements to the beginning of a List.\n\t\t * @signature `list.unshift(...elements)`\n\t\t *\n\t\t * `unshift` adds elements onto the beginning of a List.\n\t\t *\n\t\t * @param {*} elements the elements to add to the List\n\t\t *\n\t\t * @return {Number} the new length of the List\n\t\t *\n\t\t * @body\n\t\t * `unshift` adds elements to the front of the list in bulk in the order specified:\n\t\t *\n\t\t * ```\n\t\t * var list = new List(['Alice']);\n\t\t *\n\t\t * list.unshift('Bob', 'Eve');\n\t\t * list.attr(); // ['Bob', 'Eve', 'Alice']\n\t\t * ```\n\t\t *\n\t\t * If you have an array you want to concatenate to the beginning\n\t\t * of the List, you can use `apply`:\n\t\t *\n\t\t * ```\n\t\t * var names = ['Bob', 'Eve'],\n\t\t *     list = new List(['Alice']);\n\t\t *\n\t\t * list.unshift.apply(list, names);\n\t\t * list.attr(); // ['Bob', 'Eve', 'Alice']\n\t\t * ```\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `unshift` causes _change_, _add_, and _length_ events to be fired.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `unshift` has a counterpart in [can-list.prototype.shift], or you may be\n\t\t * looking for [can-list.prototype.push] and its counterpart [can-list.prototype.pop].\n\t\t */\n\t\tunshift: 0\n\t},\n\t// Adds a method\n\t// `name` - The method name.\n\t// `where` - Where items in the `array` should be added.\n\tfunction (where, name) {\n\t\tvar orig = [][name];\n\t\tList.prototype[name] = function () {\n\t\t\t// Get the items being added.\n\t\t\tvar args = [],\n\t\t\t\t// Where we are going to add items.\n\t\t\t\tlen = where ? this.length : 0,\n\t\t\t\ti = arguments.length,\n\t\t\t\tres, val;\n\n\t\t\t// Go through and convert anything to a `map` that needs to be converted.\n\t\t\twhile (i--) {\n\t\t\t\tval = arguments[i];\n\t\t\t\targs[i] = bubble.set(this, i, this.__type(val, i) );\n\t\t\t}\n\n\t\t\t// Call the original method.\n\t\t\tres = orig.apply(this, args);\n\n\t\t\tif (!this.comparator || args.length) {\n\n\t\t\t\tthis._triggerChange(\"\" + len, \"add\", args, undefined);\n\t\t\t}\n\n\t\t\treturn res;\n\t\t};\n\t});\n\ncanReflect.eachKey({\n\t\t/**\n\t\t * @function can-list.prototype.pop pop\n\t\t * @parent can-list.prototype\n\t\t * @description Remove an element from the end of a List.\n\t\t * @signature `list.pop()`\n\t\t *\n\t\t * `pop` removes an element from the end of a List.\n\t\t *\n\t\t * @return {*} the element just popped off the List, or `undefined` if the List was empty\n\t\t *\n\t\t * @body\n\t\t * `pop` is the opposite action from [can-list.prototype.push]:\n\t\t *\n\t\t * ```\n\t\t * var list = new List(['Alice', 'Bob', 'Eve']);\n\t\t * list.attr(); // ['Alice', 'Bob', 'Eve']\n\t\t *\n\t\t * list.pop(); // 'Eve'\n\t\t * list.pop(); // 'Bob'\n\t\t * list.pop(); // 'Alice'\n\t\t * list.pop(); // undefined\n\t\t * ```\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\n\t\t * when it is called.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `pop` has its counterpart in [can-list.prototype.push], or you may be\n\t\t * looking for [can-list.prototype.unshift] and its counterpart [can-list.prototype.shift].\n\t\t */\n\t\tpop: \"length\",\n\t\t/**\n\t\t * @function can-list.prototype.shift shift\n\t\t * @parent can-list.prototype\n\t\t * @description Remove en element from the front of a list.\n\t\t * @signature `list.shift()`\n\t\t *\n\t\t * `shift` removes an element from the beginning of a List.\n\t\t *\n\t\t * @return {*} the element just shifted off the List, or `undefined` if the List is empty\n\t\t *\n\t\t * @body\n\t\t * `shift` is the opposite action from `[can-list.prototype.unshift]`:\n\t\t *\n\t\t * ```\n\t\t * var list = new List(['Alice']);\n\t\t *\n\t\t * list.unshift('Bob', 'Eve');\n\t\t * list.attr(); // ['Bob', 'Eve', 'Alice']\n\t\t *\n\t\t * list.shift(); // 'Bob'\n\t\t * list.shift(); // 'Eve'\n\t\t * list.shift(); // 'Alice'\n\t\t * list.shift(); // undefined\n\t\t * ```\n\t\t *\n\t\t * ## Events\n\t\t *\n\t\t * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\n\t\t * when it is called.\n\t\t *\n\t\t * ## See also\n\t\t *\n\t\t * `shift` has a counterpart in [can-list.prototype.unshift], or you may be\n\t\t * looking for [can-list.prototype.push] and its counterpart [can-list.prototype.pop].\n\t\t */\n\t\tshift: 0\n\t},\n\t// Creates a `remove` type method\n\tfunction (where, name) {\n\t\tList.prototype[name] = function () {\n\t\t\tif (!this.length) {\n\t\t\t\t// For shift and pop, we just return undefined without\n\t\t\t\t// triggering events.\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tvar args = getArgs(arguments),\n\t\t\t\tlen = where && this.length ? this.length - 1 : 0;\n\n\t\t\tvar res = [][name].apply(this, args);\n\n\t\t\t// Create a change where the args are\n\t\t\t// `len` - Where these items were removed.\n\t\t\t// `remove` - Items removed.\n\t\t\t// `undefined` - The new values (there are none).\n\t\t\t// `res` - The old, removed values (should these be unbound).\n\t\t\tthis._triggerChange(\"\" + len, \"remove\", undefined, [res]);\n\n\t\t\tif (res && res.removeEventListener) {\n\t\t\t\tbubble.remove(this, res);\n\t\t\t}\n\n\t\t\treturn res;\n\t\t};\n\t});\n\nassign(List.prototype, {\n\t/**\n\t * @function can-list.prototype.indexOf indexOf\n\t * @parent can-list.prototype\n\t * @description Look for an item in a List.\n\t * @signature `list.indexOf(item)`\n\t *\n\t * `indexOf` finds the position of a given item in the List.\n\t *\n\t * @param {*} item the item to find\n\t *\n\t * @return {Number} the position of the item in the List, or -1 if the item is not found.\n\t *\n\t * @body\n\t * ```\n\t * var list = new List(['Alice', 'Bob', 'Eve']);\n\t * list.indexOf('Alice');   // 0\n\t * list.indexOf('Charlie'); // -1\n\t * ```\n\t *\n\t * It is trivial to make a `contains`-type function using `indexOf`:\n\t *\n\t * ```\n\t * function(list, item) {\n\t *     return list.indexOf(item) >= 0;\n\t * }\n\t * ```\n\t */\n\tindexOf: function (item, fromIndex) {\n\t\tObservationRecorder.add(this, \"length\");\n\t\tfor(var i = fromIndex || 0, len = this.length; i < len; i++) {\n\t\t\tif(this.attr(i) === item) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\t/**\n\t * @function can-list.prototype.join join\n\t * @parent can-list.prototype\n\t * @description Join a List's elements into a string.\n\t * @signature `list.join(separator)`\n\t *\n\t * `join` turns a List into a string by inserting _separator_ between the string representations\n\t * of all the elements of the List.\n\t *\n\t * @param {String} separator the string to seperate elements with\n\t *\n\t * @return {String} the joined string\n\t *\n\t * @body\n\t * ```\n\t * var list = new List(['Alice', 'Bob', 'Eve']);\n\t * list.join(', '); // 'Alice, Bob, Eve'\n\t *\n\t * var beatles = new List(['John', 'Paul', 'Ringo', 'George']);\n\t * beatles.join('&'); // 'John&Paul&Ringo&George'\n\t * ```\n\t */\n\tjoin: function () {\n\t\tObservationRecorder.add(this, \"length\");\n\t\treturn [].join.apply(this, arguments);\n\t},\n\n\t/**\n\t * @function can-list.prototype.reverse reverse\n\t * @parent can-list.prototype\n\t * @description Reverse the order of a List.\n\t * @signature `list.reverse()`\n\t *\n\t * `reverse` reverses the elements of the List in place.\n\t *\n\t * @return {can-list} the List, for chaining\n\t *\n\t * @body\n\t * ```\n\t * var list = new List(['Alice', 'Bob', 'Eve']);\n\t * var reversedList = list.reverse();\n\t *\n\t * reversedList.attr(); // ['Eve', 'Bob', 'Alice'];\n\t * list === reversedList; // true\n\t * ```\n\t */\n\treverse: function() {\n\t\tvar list = [].reverse.call(canReflect.toArray(this));\n\t\treturn this.replace(list);\n\t},\n\n\t/**\n\t * @function can-list.prototype.slice slice\n\t * @parent can-list.prototype\n\t * @description Make a copy of a part of a List.\n\t * @signature `list.slice([start[, end]])`\n\t *\n\t * `slice` creates a copy of a portion of the List.\n\t *\n\t * @param {Number} [start=0] the index to start copying from\n\t *\n\t * @param {Number} [end] the first index not to include in the copy\n\t * If _end_ is not supplied, `slice` will copy until the end of the list.\n\t *\n\t * @return {can-list} a new `can-list` with the extracted elements\n\t *\n\t * @body\n\t * ```\n\t * var list = new List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\n\t * var newList = list.slice(1, 4);\n\t * newList.attr(); // ['Bob', 'Charlie', 'Daniel']\n\t * ```\n\t *\n\t * `slice` is the simplest way to copy a List:\n\t *\n\t * ```\n\t * var list = new List(['Alice', 'Bob', 'Eve']);\n\t * var copy = list.slice();\n\t *\n\t * copy.attr();   // ['Alice', 'Bob', 'Eve']\n\t * list === copy; // false\n\t * ```\n\t */\n\tslice: function () {\n\t\t// tells computes to listen on length for changes.\n\t\tObservationRecorder.add(this, \"length\");\n\t\tvar temp = Array.prototype.slice.apply(this, arguments);\n\t\treturn new this.constructor(temp);\n\t},\n\n\t/**\n\t * @function can-list.prototype.concat concat\n\t * @parent can-list.prototype\n\t * @description Merge many collections together into a List.\n\t * @signature `list.concat(...args)`\n\t * @param {Array|can-list|*} args Any number of arrays, Lists, or values to add in\n\t * For each parameter given, if it is an Array or a List, each of its elements will be added to\n\t * the end of the concatenated List. Otherwise, the parameter itself will be added.\n\t *\n\t * @body\n\t * `concat` makes a new List with the elements of the List followed by the elements of the parameters.\n\t *\n\t * ```\n\t * var list = new List();\n\t * var newList = list.concat(\n\t *     'Alice',\n\t *     ['Bob', 'Charlie']),\n\t *     new List(['Daniel', 'Eve']),\n\t *     {f: 'Francis'}\n\t * );\n\t * newList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n\t * ```\n\t */\n\tconcat: function() {\n\t\tvar args = [],\n\t\t\tMapType = this.constructor.Map;\n\t\t// Go through each of the passed `arguments` and\n\t\t// see if it is list-like, an array, or something else\n\t\tcanReflect.each(arguments, function(arg) {\n\t\t\tif((canReflect.isObservableLike(arg) && canReflect.isListLike(arg)) || Array.isArray(arg)) {\n\t\t\t\t// If it is list-like we want convert to a JS array then\n\t\t\t\t// pass each item of the array to serializeNonTypes\n\t\t\t\tvar arr = (canReflect.isObservableLike(arg) && canReflect.isListLike(arg)) ? canReflect.toArray(arg) : arg;\n\t\t\t\tcanReflect.each(arr, function(innerArg) {\n\t\t\t\t\tserializeNonTypes(MapType, innerArg, args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// If it is a Map, Object, or some primitive\n\t\t\t\t// just pass arg to serializeNonTypes\n\t\t\t\tserializeNonTypes(MapType, arg, args);\n\t\t\t}\n\t\t});\n\n\t\t// We will want to make `this` list into a JS array\n\t\t// as well (We know it should be list-like), then\n\t\t// concat with our passed in args, then pass it to\n\t\t// list constructor to make it back into a list\n\t\treturn new this.constructor(Array.prototype.concat.apply(canReflect.toArray(this), args));\n\t},\n\n\t/**\n\t * @function can-list.prototype.forEach forEach\n\t * @parent can-list.prototype\n\t * @description Call a function for each element of a List.\n\t * @signature `list.forEach(callback[, thisArg])`\n\t * @param {function(element, index, list)} callback a function to call with each element of the List\n\t * The three parameters that _callback_ gets passed are _element_, the element at _index_, _index_ the\n\t * current element of the list, and _list_ the List the elements are coming from. _callback_ is\n\t * not invoked for List elements that were never initialized.\n\t * @param {Object} [thisArg] the object to use as `this` inside the callback\n\t *\n\t * @body\n\t * `forEach` calls a callback for each element in the List.\n\t *\n\t * ```\n\t * var list = new List([1, 2, 3]);\n\t * list.forEach(function(element, index, list) {\n\t *     list.attr(index, element * element);\n\t * });\n\t * list.attr(); // [1, 4, 9]\n\t * ```\n\t */\n\tforEach: function (cb, thisarg) {\n\t\tvar item;\n\t\tfor (var i = 0, len = this.attr(\"length\"); i < len; i++) {\n\t\t\titem = this.attr(i);\n\t\t\tif (item !== undefined && cb.call(thisarg || item, item, i, this) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * @function can-list.prototype.replace replace\n\t * @parent can-list.prototype\n\t * @description Replace all the elements of a List.\n\t * @signature `list.replace(collection)`\n\t * @param {Array|can-list|can.Deferred} collection the collection of new elements to use\n\t * If a [can.Deferred] is passed, it must resolve to an `Array` or `can-list`.\n\t * The elements of the list are not actually removed until the Deferred resolves.\n\t *\n\t * @body\n\t * `replace` replaces all the elements of this List with new ones.\n\t *\n\t * `replace` is especially useful when `can-list`s are live-bound into `[can-control]`s,\n\t * and you intend to populate them with the results of a `[can-model]` call:\n\t *\n\t * ```\n\t * can.Control({\n\t *     init: function() {\n\t *         this.list = new Todo.List();\n\t *         // live-bind the list into the DOM\n\t *         this.element.html(can.view('list.stache', this.list));\n\t *         // when this AJAX call returns, the live-bound DOM will be updated\n\t *         this.list.replace(Todo.findAll());\n\t *     }\n\t * });\n\t * ```\n\t *\n\t * Learn more about [can.Model.List making Lists of models].\n\t *\n\t * ## Events\n\t *\n\t * A major difference between `replace` and `attr(newElements, true)` is that `replace` always emits\n\t * an _add_ event and a _remove_ event, whereas `attr` will cause _set_ events along with an _add_ or _remove_\n\t * event if needed. Corresponding _change_ and _length_ events will be fired as well.\n\t *\n\t * The differences in the events fired by `attr` and `replace` are demonstrated concretely by this example:\n\t * ```\n\t * var attrList = new List(['Alexis', 'Bill']);\n\t * attrList.bind('change', function(ev, index, how, newVals, oldVals) {\n\t *     console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n\t * });\n\t *\n\t * var replaceList = new List(['Alexis', 'Bill']);\n\t * replaceList.bind('change', function(ev, index, how, newVals, oldVals) {\n\t *     console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n\t * });\n\t *\n\t * attrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis\n\t *                                               // 1, set, Ben, Bill\n\t * replaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']\n\t *                                               // 0, add, ['Adam', 'Ben'], ['Alexis', 'Bill']\n\t *\n\t * attrList.attr(['Amber'], true);               // 0, set, Amber, Adam\n\t *                                               // 1, remove, undefined, Ben\n\t * replaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']\n\t *                                               // 0, add, Amber, ['Adam', 'Ben']\n\t *\n\t * attrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber\n\t *                                               // 1, add, ['Bob', 'Eve'], undefined\n\t * replaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber\n\t *                                               // 0, add, ['Alice', 'Bob', 'Eve'], Amber\n\t * ```\n\t */\n\treplace: function (newList) {\n\t\tif (canReflect.isPromise(newList)) {\n\t\t\tif(this._promise) {\n\t\t\t\tthis._promise.__isCurrentPromise = false;\n\t\t\t}\n\t\t\tvar promise = this._promise = newList;\n\t\t\tpromise.__isCurrentPromise = true;\n\t\t\tvar self = this;\n\t\t\tnewList.then(function(newList){\n\t\t\t\tif(promise.__isCurrentPromise) {\n\t\t\t\t\tself.replace(newList);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tnewList = newList === undefined ? [] : canReflect.toArray(newList);\n\t\t\tthis.splice.apply(this, [0, this.length].concat(newList));\n\t\t}\n\n\t\treturn this;\n\t},\n\tfilter: function (callback, thisArg) {\n\t\tvar filteredList = new this.constructor(),\n\t\t\tself = this,\n\t\t\tfiltered;\n\t\tthis.forEach(function(item, index, list){\n\t\t\tfiltered = callback.call( thisArg || self, item, index, self);\n\t\t\tif(filtered){\n\t\t\t\tfilteredList.push(item);\n\t\t\t}\n\t\t});\n\t\treturn filteredList;\n\t},\n\tmap: function (callback, thisArg) {\n\t\tvar filteredList = new List(),\n\t\t\tself = this;\n\t\tthis.forEach(function(item, index, list){\n\t\t\tvar mapped = callback.call( thisArg || self, item, index, self);\n\t\t\tfilteredList.push(mapped);\n\n\t\t});\n\t\treturn filteredList;\n\t}\n});\n\n// change some map stuff to include list stuff\nvar oldType = Map.prototype.__type;\nMap.prototype.__type = function(value, prop){\n\n\tif (typeof value === \"object\" && Array.isArray(value) ) {\n\n\t\tvar cached = mapHelpers.getMapFromObject(value);\n\t\tif(cached) {\n\t\t\treturn cached;\n\t\t}\n\n\t\treturn new List(value);\n\n\t}\n\treturn oldType.apply(this, arguments);\n};\n\nvar oldSetup = Map.setup;\nMap.setup = function(){\n\toldSetup.apply(this, arguments);\n\tif (!(this.prototype instanceof List)) {\n\t\tthis.List = Map.List.extend({\n\t\t\tMap: this\n\t\t}, {});\n\t}\n};\n\nif(!types.DefaultList) {\n\ttypes.DefaultList = List;\n}\n\n// Setup other symbols\n\ncanReflect.assignSymbols(List.prototype,{\n\t// -type-\n\n\t\"can.isMoreListLikeThanMapLike\":  true,\n\t\"can.isListLike\":  true,\n\n\t// -get/set-\n\t\"can.getKeyValue\": List.prototype._get,\n\t\"can.setKeyValue\": List.prototype._set,\n\t\"can.deleteKeyValue\": List.prototype._remove,\n\n\t// -shape\n\t\"can.getOwnEnumerableKeys\": function(){\n\t\treturn Object.keys(this._data || {}).concat(this.map(function(val, index) {\n\t\t\treturn index;\n\t\t}));\n\t},\n\n\t// -shape get/set-\n\t\"can.assignDeep\": function(source){\n\t\tqueues.batch.start();\n\t\t// TODO: we should probably just throw an error instead of cleaning\n\t\tcanReflect.assignDeepList(this, source);\n\t\tqueues.batch.stop();\n\t},\n\t\"can.updateDeep\": function(source){\n\t\tqueues.batch.start();\n\t\t// TODO: we should probably just throw an error instead of cleaning\n\t\tcanReflect.updateDeepList(this, source);\n\t\tqueues.batch.stop();\n\t},\n\n\t\"can.unwrap\": mapHelpers.reflectUnwrap,\n\t\"can.serialize\": mapHelpers.reflectSerialize,\n\n\t// observable\n\t\"can.onKeysAdded\": function(handler) {\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](\"add\", handler);\n\t},\n\t\"can.onKeysRemoved\":  function(handler) {\n\t\tthis[canSymbol.for(\"can.onKeyValue\")](\"remove\", handler);\n\t},\n\t\"can.splice\": function(index, deleteCount, insert){\n\t\tthis.splice.apply(this, [index, deleteCount].concat(insert));\n\t}\n});\n\n\n\n\n// @@can.keyHasDependencies and @@can.getKeyDependencies same as can-map\n\nMap.List = List;\nmodule.exports = namespace.List = List;\n"],"names":["splice","spliceRemovesProps","obj","0","length","call","serializeNonTypes","MapType","arg","args","serialize","push","List","Map","extend","setup","instances","options","teardownMapping","this","CID","_setupComputedProperties","undefined","canReflect","toArray","isPromise","replace","mapHelpers","addToMap","apply","assign","_triggerChange","attr","how","newVal","oldVal","queues","batch","start","patches","index","indexOf","isNaN","prototype","arguments","bubble","isBubbling","canEvent","dispatch","type","target","insert","deleteCount","stop","___get","computedAttr","_computedAttrs","compute","getValue","isComputed","constructor","__set","prop","value","current","newArr","Array","___set","val","__remove","_each","callback","data","i","CIDMap","howMany","len","listIndex","added","allSame","__type","removed","removeMany","addMany","getArgs","isArray","eachKey","unshift","where","name","orig","res","set","comparator","pop","shift","removeEventListener","remove","item","fromIndex","ObservationRecorder","add","join","reverse","list","slice","temp","concat","each","isObservableLike","isListLike","arr","innerArg","forEach","cb","thisarg","newList","_promise","__isCurrentPromise","promise","self","then","filter","thisArg","filteredList","map","mapped","oldType","cached","getMapFromObject","oldSetup","types","DefaultList","assignSymbols","can.isMoreListLikeThanMapLike","can.isListLike","can.getKeyValue","_get","can.setKeyValue","_set","can.deleteKeyValue","_remove","can.getOwnEnumerableKeys","Object","keys","_data","can.assignDeep","source","assignDeepList","can.updateDeep","updateDeepList","can.unwrap","reflectUnwrap","can.serialize","reflectSerialize","can.onKeysAdded","handler","canSymbol","for","can.onKeysRemoved","can.splice","namespace"],"mappings":"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"}