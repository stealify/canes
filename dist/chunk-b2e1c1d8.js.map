{"version":3,"file":"chunk-b2e1c1d8.js","sources":["../node_modules/can-event-queue/type/type.js"],"sourcesContent":["\"use strict\";\n/**\n * @module {function} can-event-queue/type/type\n * @parent can-event-queue\n *\n * @description Mixin methods and symbols to make a type constructor function able to\n * broadcast changes in its instances.\n *\n * @signature `mixinTypeBindings( type )`\n *\n * Adds symbols and methods that make `type` work with the following [can-reflect] APIs:\n *\n * - [can-reflect/observe.onInstanceBoundChange] - Observe when instances are bound.\n * - [can-reflect/observe.onInstancePatches] - Observe patche events on all instances.\n *\n * When `mixinTypeBindings` is called on an `Person` _type_ like:\n *\n * ```js\n * var mixinTypeBindings = require(\"can-event-queue/type/type\");\n * var mixinLegacyMapBindings = require(\"can-event-queue/map/map\");\n *\n * class Person {\n *   constructor(data){\n *     this.data = data;\n *   }\n * }\n * mixinTypeBindings(Person);\n * mixinLegacyMapBindings(Person.prototype);\n *\n * var me = new Person({first: \"Justin\", last: \"Meyer\"});\n *\n * // mixinTypeBindings allows you to listen to\n * // when a person instance's bind stache changes\n * canReflect.onInstanceBoundChange(Person, function(person, isBound){\n *    console.log(\"isBound\");\n * });\n *\n * // mixinTypeBindings allows you to listen to\n * // when a patch change happens.\n * canReflect.onInstancePatches(Person, function(person, patches){\n *    console.log(patches[0]);\n * });\n *\n * me.on(\"name\",function(ev, newVal, oldVal){}) //-> logs: \"isBound\"\n *\n * me.dispatch({\n *   type: \"first\",\n *   patches: [{type: \"set\", key: \"first\", value: \"Ramiya\"}]\n * }, [\"Ramiya\",\"Justin\"])\n * //-> logs: {type: \"set\", key: \"first\", value: \"Ramiya\"}\n * ```\n *\n */\nvar canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\nvar KeyTree = require(\"can-key-tree\");\nvar queues = require(\"can-queues\");\n\nvar metaSymbol = canSymbol.for(\"can.meta\");\n\nfunction addHandlers(obj, meta) {\n    if (!meta.lifecycleHandlers) {\n        meta.lifecycleHandlers = new KeyTree([Object, Array]);\n    }\n    if (!meta.instancePatchesHandlers) {\n        meta.instancePatchesHandlers = new KeyTree([Object, Array]);\n    }\n}\n\nfunction ensureMeta(obj) {\n    var meta = obj[metaSymbol];\n\n    if (!meta) {\n        meta = {};\n        canReflect.setKeyValue(obj, metaSymbol, meta);\n    }\n\n    addHandlers(obj, meta);\n    return meta;\n}\n\nvar props = {\n    /**\n     * @function can-event-queue/type/type.can.onInstanceBoundChange @can.onInstanceBoundChange\n     * @parent can-event-queue/type/type\n     * @description Listen to when any instance is bound for the first time or all handlers are removed.\n     *\n     * @signature `canReflect.onInstanceBoundChange(Type, handler(instance, isBound) )`\n     *\n     * ```js\n     * canReflect.onInstanceBoundChange(Person, function(person, isBound){\n     *    console.log(\"isBound\");\n     * });\n     * ```\n     *\n     * @param {function(Any,Boolean)} handler(instance,isBound) A function is called\n     * when an instance is bound or unbound.  `isBound` will be `true` when the instance\n     * becomes bound and `false` when unbound.\n     */\n\n    /**\n     * @function can-event-queue/type/type.can.offInstanceBoundChange @can.offInstanceBoundChange\n     * @parent can-event-queue/type/type\n     *\n     * @description Stop listening to when an instance's bound status changes.\n     *\n     * @signature `canReflect.offInstanceBoundChange(Type, handler )`\n     *\n     * Stop listening to a handler bound with\n     * [can-event-queue/type/type.can.onInstanceBoundChange].\n     */\n\n\n    /**\n     * @function can-event-queue/type/type.can.onInstancePatches @can.onInstancePatches\n     * @parent can-event-queue/type/type\n     *\n     * @description Listen to patch changes on any isntance.\n     *\n     * @signature `canReflect.onInstancePatches(Type, handler(instance, patches) )`\n     *\n     * Listen to patch changes on any instance of `Type`. This is used by\n     * [can-connect] to know when a potentially `unbound` instance's `id`\n     * changes. If the `id` changes, the instance can be moved into the store\n     * while it is being saved.\n     *\n     */\n\n    /**\n     * @function can-event-queue/type/type.can.offInstancePatches @can.offInstancePatches\n     * @parent can-event-queue/type/type\n     *\n     * @description Stop listening to patch changes on any instance.\n     *\n     * @signature `canReflect.onInstancePatches(Type, handler )`\n     *\n     * Stop listening to a handler bound with [can-event-queue/type/type.can.onInstancePatches].\n     */\n};\n\nfunction onOffAndDispatch(symbolName, dispatchName, handlersName){\n    props[\"can.on\"+symbolName] = function(handler, queueName) {\n        ensureMeta(this)[handlersName].add([queueName || \"mutate\", handler]);\n    };\n    props[\"can.off\"+symbolName] = function(handler, queueName) {\n        ensureMeta(this)[handlersName].delete([queueName || \"mutate\", handler]);\n    };\n    props[\"can.\"+dispatchName] = function(instance, arg){\n        queues.enqueueByQueue(ensureMeta(this)[handlersName].getNode([]), this, [instance, arg]);\n    };\n}\n\nonOffAndDispatch(\"InstancePatches\",\"dispatchInstanceOnPatches\",\"instancePatchesHandlers\");\nonOffAndDispatch(\"InstanceBoundChange\",\"dispatchInstanceBoundChange\",\"lifecycleHandlers\");\n\nfunction mixinTypeBindings(obj){\n    return canReflect.assignSymbols(obj,props);\n}\n\nObject.defineProperty(mixinTypeBindings, \"addHandlers\", {\n    enumerable: false,\n    value: addHandlers\n});\n\nmodule.exports = mixinTypeBindings;\n"],"names":["metaSymbol","canSymbol","for","addHandlers","obj","meta","lifecycleHandlers","KeyTree","Object","Array","instancePatchesHandlers","ensureMeta","canReflect","setKeyValue","props","onOffAndDispatch","symbolName","dispatchName","handlersName","handler","queueName","this","add","delete","instance","arg","queues","enqueueByQueue","getNode","mixinTypeBindings","assignSymbols","defineProperty","enumerable","value"],"mappings":"gRA0DA,IAAIA,WAAaC,UAAUC,IAAI,YAE/B,SAASC,YAAYC,EAAKC,GACjBA,EAAKC,oBACND,EAAKC,kBAAoB,IAAIC,QAAQ,CAACC,OAAQC,SAE7CJ,EAAKK,0BACNL,EAAKK,wBAA0B,IAAIH,QAAQ,CAACC,OAAQC,SAI5D,SAASE,WAAWP,GAChB,IAAIC,EAAOD,EAAIJ,YAQf,OANKK,IACDA,EAAO,GACPO,WAAWC,YAAYT,EAAKJ,WAAYK,IAG5CF,YAAYC,EAAKC,GACVA,EAGX,IAAIS,MAAQ,GA2DZ,SAASC,iBAAiBC,EAAYC,EAAcC,GAChDJ,MAAM,SAASE,GAAc,SAASG,EAASC,GAC3CT,WAAWU,MAAMH,GAAcI,IAAI,CAACF,GAAa,SAAUD,KAE/DL,MAAM,UAAUE,GAAc,SAASG,EAASC,GAC5CT,WAAWU,MAAMH,GAAcK,OAAO,CAACH,GAAa,SAAUD,KAElEL,MAAM,OAAOG,GAAgB,SAASO,EAAUC,GAC5CC,OAAOC,eAAehB,WAAWU,MAAMH,GAAcU,QAAQ,IAAKP,KAAM,CAACG,EAAUC,KAO3F,SAASI,kBAAkBzB,GACvB,OAAOQ,WAAWkB,cAAc1B,EAAIU,OAJxCC,iBAAiB,kBAAkB,4BAA4B,2BAC/DA,iBAAiB,sBAAsB,8BAA8B,qBAMrEP,OAAOuB,eAAeF,kBAAmB,cAAe,CACpDG,YAAY,EACZC,MAAO9B,cAGX,SAAiB0B"}