{"version":3,"file":"chunk-b270b042.js","sources":["../node_modules/can-key/set/set.js","../node_modules/can-key/can-key.js"],"sourcesContent":["\"use strict\";\n\nvar canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\nvar utils = require(\"../utils\");\n\nvar setValueSymbol = canSymbol.for(\"can.setValue\");\n\n/**\n * @module {function} can-key/set/set\n * @parent can-key\n * @description Set properties on deep/nested objects of different types: Object, Map, [can-reflect] types, etc.\n *\n * @signature `set(object, path, value)`\n * @param  {Object} object The object to use as the root for property-based navigation.\n * @param  {String} path A String of dot-separated keys, representing a path of properties.\n * @param  {*} value The new value to be set at the property path.\n * @return {*} The object passed to set (for chaining calls).\n *\n * @body\n *\n * A *path* is a dot-delimited sequence of one or more property names, such that \"foo.bar\" means \"the property\n * 'bar' of the object at the property 'foo' of the root.\"\n *\n * ```js\n * import set from \"can-key/set/set\";\n *\n * const object = {a: {b: {c: \"foo\"}}};\n * set(object, \"a.b.c\", \"bar\");\n * // Now object.a.b.c === \"bar\"\n *\n * var map = new Map();\n * map.set(\"first\", {second: \"third\"});\n *\n * set(map, \"first.second\", \"3rd\");\n * // Now map.first.second === \"3rd\"\n * ```\n *\n * > **Note:** an error will be thrown if one of the objects in the key path does not exist.\n */\nfunction set(object, path, value) {\n    var parts = utils.parts(path);\n\n    var current = object;\n    var length = parts.length;\n\n    // Walk current until there is not a container\n    for (var i = 0; i < length - 1; i++) {\n        if (utils.isContainer(current)) {\n            current = canReflect.getKeyValue(current, parts[i]);\n        } else {\n            break;\n        }\n    }\n\n    // Set the value\n    if (current) {\n        canReflect.setKeyValue(current, parts[i], value);\n    } else {\n        throw new TypeError(\"Cannot set value at key path '\" + path + \"'\");\n    }\n\n    return object;\n}\n\nmodule.exports = set;\n","\"use strict\";\nvar deleteKey = require(\"can-key/delete/delete\"),\n    get = require(\"can-key/get/get\"),\n    replaceWith = require(\"can-key/replace-with/replace-with\"),\n    set = require(\"can-key/set/set\"),\n    transform = require(\"can-key/transform/transform\"),\n    walk = require(\"can-key/walk/walk\"),\n    namespace = require(\"can-namespace\");\n\nmodule.exports = namespace.key = {\n    deleteKey: deleteKey,\n    get: get,\n    replaceWith: replaceWith,\n    set: set,\n    transform: transform,\n    walk: walk\n};\n"],"names":["setValueSymbol","canSymbol","for","set","object","path","value","parts","utils","current","length","i","isContainer","canReflect","getKeyValue","TypeError","setKeyValue","namespace","key","deleteKey","get","replaceWith","transform","walk"],"mappings":"gaAMA,IAAIA,eAAiBC,UAAUC,IAAI,gBAkCnC,SAASC,IAAIC,EAAQC,EAAMC,GAOvB,IANA,IAAIC,EAAQC,YAAMD,MAAMF,GAEpBI,EAAUL,EACVM,EAASH,EAAMG,OAGVC,EAAI,EAAGA,EAAID,EAAS,GACrBF,YAAMI,YAAYH,GADME,IAExBF,EAAUI,WAAWC,YAAYL,EAASF,EAAMI,IAOxD,IAAIF,EAGA,MAAM,IAAIM,UAAU,iCAAmCV,EAAO,KAGlE,OALIQ,WAAWG,YAAYP,EAASF,EAAMI,GAAIL,GAKvCF,EAGX,UAAiBD,WCxDAc,UAAUC,IAAM,CAC7BC,UAAWA,UACXC,IAAKA,IACLC,YAAaA,YACblB,IAAKA,MACLmB,UAAWA,UACXC,KAAMA"}