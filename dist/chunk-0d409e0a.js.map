{"version":3,"file":"chunk-0d409e0a.js","sources":["../node_modules/can-view-live/lib/core.js","../node_modules/can-view-live/lib/attr.js","../node_modules/can-view-live/lib/attrs.js","../node_modules/can-view-live/lib/html.js","../node_modules/can-view-live/lib/set-observable.js","../node_modules/can-view-live/lib/list.js","../node_modules/can-view-live/lib/text.js","../node_modules/can-view-live/can-view-live.js"],"sourcesContent":["\"use strict\";\nvar parser = require('can-view-parser');\nvar domMutate = require('can-dom-mutate');\nvar nodeLists = require('can-view-nodelist');\nvar makeFrag = require('can-fragment');\nvar childNodes = require('can-child-nodes');\nvar canReflect = require('can-reflect');\nvar canReflectDeps = require('can-reflect-dependencies');\n\nfunction contains(parent, child){\n\tif(parent.contains) {\n\t\treturn parent.contains(child);\n\t}\n\tif(parent.nodeType === Node.DOCUMENT_NODE && parent.documentElement) {\n\t\treturn contains(parent.documentElement, child);\n    } else {\n\t\tchild = child.parentNode;\n\tif(child === parent) {\n\t\treturn true;\n\t}\n\t\treturn false;\n\t}\n}\n\n/**\n * @module {{}} can-view-live can-view-live\n * @parent can-views\n * @collection can-infrastructure\n * @package ../package.json\n *\n * Setup live-binding between the DOM and a compute manually.\n *\n * @option {Object} An object with the live-binding methods:\n * [can-view-live.html], [can-view-live.list], [can-view-live.text], and\n * [can-view-live.attr].\n *\n * @release 2.0.4\n *\n * @body\n *\n * ## Use\n *\n *  [can-view-live] is an object with utility methods for setting up\n *  live-binding in relation to different parts of the DOM and DOM elements.  For\n *  example, to make an `<h2>`'s text stay live with\n *  a compute:\n *\n *  ```js\n *  var live = require(\"can-view-live\");\n *  var text = canCompute(\"Hello World\");\n *  var textNode = $(\"h2\").text(\" \")[0].childNodes[0];\n *  live.text(textNode, text);\n *  ```\n *\n */\n\nvar live = {\n\tsetup: function(el, bind, unbind) {\n\t\t// #### setup\n\t\t// Setup a live listener on an element that binds now,\n\t\t//  but unbinds when an element is no longer in the DOM\n\t\tvar tornDown = false,\n\t\t\tremovalDisposal,\n\t\t\tdata,\n\t\t\tteardown = function() {\n\t\t\t\t// Removing an element can call teardown which\n\t\t\t\t// unregister the nodeList which calls teardown\n\t\t\t\tif (!tornDown) {\n\t\t\t\t\ttornDown = true;\n\t\t\t\t\tunbind(data);\n\t\t\t\t\tif (removalDisposal) {\n\t\t\t\t\t\tremovalDisposal();\n\t\t\t\t\t\tremovalDisposal = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t};\n\t\tdata = {\n\t\t\tteardownCheck: function(parent) {\n\t\t\t\treturn parent ? false : teardown();\n\t\t\t}\n\t\t};\n\t\tremovalDisposal = domMutate.onNodeRemoval(el, function () {\n\t\t\tvar doc = el.ownerDocument;\n\t\t\t//var ownerNode = doc.contains ? doc : doc.documentElement;\n\n\t\t\tif (!contains(doc,el)) {\n\t\t\t\tteardown();\n\t\t\t}\n\t\t});\n\t\tbind(data);\n\t\treturn data;\n\t},\n\t// #### listen\n\t// Calls setup, but presets bind and unbind to\n\t// operate on a compute\n\tlisten: function(el, compute, change, queueName) {\n\t\treturn live.setup(\n\t\t\tel,\n\t\t\tfunction bind() {\n\t\t\t\t// listen to notify, so on a change, this can\n\t\t\t\t// teardown all children quickly.\n\t\t\t\tcanReflect.onValue(compute, change, queueName || \"notify\");\n\t\t\t\t//compute.computeInstance.addEventListener('change', change);\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tcanReflectDeps.addMutatedBy(el, compute);\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\t\t\t},\n\t\t\tfunction unbind(data) {\n\t\t\t\tcanReflect.offValue(compute, change, queueName || \"notify\");\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tcanReflectDeps.deleteMutatedBy(el, compute);\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\t//compute.computeInstance.removeEventListener('change', change);\n\t\t\t\tif (data.nodeList) {\n\t\t\t\t\tnodeLists.unregister(data.nodeList);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t},\n\t// #### getAttributeParts\n\t// Breaks up a string like foo='bar' into an object of {\"foo\": \"bar\"} pairs\n\t// See can-view-parser for more about attrStart/attrEnd/attrValue\n\tgetAttributeParts: function(newVal) {\n\t\tvar attrs = {},\n\t\t\tattr;\n\t\tparser.parseAttrs(newVal, {\n\t\t\tattrStart: function(name) {\n\t\t\t\tattrs[name] = \"\";\n\t\t\t\tattr = name;\n\t\t\t},\n\t\t\tattrValue: function(value) {\n\t\t\t\tattrs[attr] += value;\n\t\t\t},\n\t\t\tattrEnd: function() {}\n\t\t});\n\t\treturn attrs;\n\t},\n\t// #### isNode\n\t// Checks a possible node object for the nodeType property\n\tisNode: function(obj) {\n\t\treturn obj && obj.nodeType;\n\t},\n\t// #### addTextNodeIfNoChildren\n\t// Append an empty text node to a parent with no children;\n\t//  do nothing if the parent already has children.\n\taddTextNodeIfNoChildren: function(frag) {\n\t\tif (!frag.firstChild) {\n\t\t\tfrag.appendChild(frag.ownerDocument.createTextNode(\"\"));\n\t\t}\n\t},\n\n\n\t/**\n\t * @function can.view.live.replace\n\t * @parent can.view.live\n\t * @release 2.0.4\n\t * @hide\n\t *\n\t * Replaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data\n\t * correct.\n\t *\n\t * @param {Array.<HTMLElement>} nodes An array of elements.  There should typically be one element.\n\t * @param {String|HTMLElement|DocumentFragment} val The content that should replace\n\t * `nodes`.  If a string is passed, it will be [can.view.hookup hookedup].\n\t *\n\t * @param {function} [teardown] A callback if these elements are torn down.\n\t */\n\treplace: function(nodes, val, teardown) {\n\t\t// #### replace\n\t\t// Replaces one element with some content while keeping nodeLists data\n\t\t// correct.\n\t\t//\n\t\t// Take a copy of old nodeList\n\t\tvar oldNodes = nodes.slice(0),\n\t\t\tfrag = makeFrag(val);\n\t\t// Register a teardown callback\n\t\tnodeLists.register(nodes, teardown);\n\t\t// Mark each node as belonging to the node list.\n\t\tnodeLists.update(nodes, childNodes(frag));\n\t\t// Replace old nodes with new on the DOM\n\t\tnodeLists.replace(oldNodes, frag);\n\t\treturn nodes;\n\t},\n\t// #### getParentNode\n\t// Return default parent if el is a fragment, el's parent otherwise\n\tgetParentNode: function(el, defaultParentNode) {\n\t\treturn defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;\n\t},\n\t// #### makeString\n\t// any -> string converter (including nullish)\n\tmakeString: function(txt) {\n\t\treturn txt == null ? \"\" : \"\" + txt;\n\t}\n};\n\nmodule.exports = live;\n","\"use strict\";\nvar live = require('./core');\nvar canReflect = require('can-reflect');\nvar queues = require(\"can-queues\");\nvar attr = require(\"can-attribute-observable/behaviors\");\n\n/**\n * @function can-view-live.attr attr\n * @parent can-view-live\n *\n * @signature `live.attr(el, attributeName, observable)`\n *\n * Keep an attribute live to a [can-reflect]-ed observable.\n *\n * ```js\n * var div = document.createElement('div');\n * var value = new SimpleObservable(\"foo bar\");\n * live.attr(div,\"class\", value);\n * ```\n *\n * @param {HTMLElement} el The element whos attribute will be kept live.\n * @param {String} attributeName The attribute name.\n * @param {Object} observable An observable value.\n *\n * @body\n *\n * ## How it works\n *\n * This listens for the changes in the observable and uses those changes to\n * set the specified attribute.\n */\nlive.attr = function(el, attributeName, compute) {\n\tfunction liveUpdateAttr(newVal) {\n\t\tqueues.domUIQueue.enqueue(attr.set, attr, [el, attributeName, newVal]);\n\t}\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\t// register that the handler changes the parent element\n\t\tcanReflect.assignSymbols(liveUpdateAttr, {\n\t\t\t\"can.getChangesDependencyRecord\": function() {\n\t\t\t\tvar s = new Set();\n\t\t\t\ts.add(el);\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: s\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(liveUpdateAttr, \"name\", {\n\t\t\tvalue: \"live.attr update::\"+canReflect.getName(compute),\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\t// Bind a single attribute on an element to a compute\n\tlive.listen(el, compute, liveUpdateAttr);\n\n\t// do initial set of attribute as well\n\tattr.set(el, attributeName, canReflect.getValue(compute));\n};\n","\"use strict\";\n// This provides live binding for stache attributes.\nvar live = require('./core');\nvar viewCallbacks = require('can-view-callbacks');\nvar domMutate = require('can-dom-mutate');\nvar domMutateNode = require('can-dom-mutate/node');\nvar canReflect = require('can-reflect');\nvar canReflectDeps = require('can-reflect-dependencies');\n\nlive.attrs = function(el, compute, scope, options) {\n\n\tif (!canReflect.isObservableLike(compute)) {\n\t\t// Non-live case (`compute` was not a compute):\n\t\t//  set all attributes on the element and don't\n\t\t//  worry about setting up live binding since there\n\t\t//  is not compute to bind on.\n\t\tvar attrs = live.getAttributeParts(compute);\n\t\tfor (var name in attrs) {\n\t\t\tdomMutateNode.setAttribute.call(el, name, attrs[name]);\n\t\t}\n\t\treturn;\n\t}\n\n\t// last set of attributes\n\tvar oldAttrs = {};\n\n\t// set up a callback for handling changes when the compute\n\t// changes\n\tfunction liveAttrsUpdate(newVal) {\n\t\tvar newAttrs = live.getAttributeParts(newVal),\n\t\t\tname;\n\t\tfor (name in newAttrs) {\n\t\t\tvar newValue = newAttrs[name],\n\t\t\t\t// `oldAttrs` was set on the last run of setAttrs in this context\n\t\t\t\t//  (for this element and compute)\n\t\t\t\toldValue = oldAttrs[name];\n\t\t\t// Only fire a callback\n\t\t\t//  if the value of the attribute has changed\n\t\t\tif (newValue !== oldValue) {\n\t\t\t\t// set on DOM attributes (dispatches an \"attributes\" event as well)\n\t\t\t\tdomMutateNode.setAttribute.call(el, name, newValue);\n\t\t\t\t// get registered callback for attribute name and fire\n\t\t\t\tvar callback = viewCallbacks.attr(name);\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(el, {\n\t\t\t\t\t\tattributeName: name,\n\t\t\t\t\t\tscope: scope,\n\t\t\t\t\t\toptions: options\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// remove key found in new attrs from old attrs\n\t\t\tdelete oldAttrs[name];\n\t\t}\n\t\t// any attrs left at this point are not set on the element now,\n\t\t// so remove them.\n\t\tfor (name in oldAttrs) {\n\t\t\tdomMutateNode.removeAttribute.call(el, name);\n\t\t}\n\t\toldAttrs = newAttrs;\n\t}\n\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\t// register that the handler changes the parent element\n\t\tcanReflect.assignSymbols(liveAttrsUpdate, {\n\t\t\t\"can.getChangesDependencyRecord\": function() {\n\t\t\t\tvar s = new Set();\n\t\t\t\ts.add(el);\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: s\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(liveAttrsUpdate, \"name\", {\n\t\t\tvalue: \"live.attrs update::\"+canReflect.getName(compute),\n\t\t});\n\t\tcanReflectDeps.addMutatedBy(el, compute);\n\t}\n\t//!steal-remove-end\n\n\t// set attributes on any change to the compute\n\tcanReflect.onValue(compute, liveAttrsUpdate,\"domUI\");\n\n\tvar removalDisposal;\n\tvar teardownHandler = function() {\n\t\tcanReflect.offValue(compute, liveAttrsUpdate,\"domUI\");\n\t\tif (removalDisposal) {\n\t\t\tremovalDisposal();\n\t\t\tremovalDisposal = undefined;\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tcanReflectDeps.deleteMutatedBy(el, compute);\n\t\t}\n\t\t//!steal-remove-end\n\t};\n\t// unbind on element removal\n\tremovalDisposal = domMutate.onNodeRemoval(el, function () {\n\t\tvar doc = el.ownerDocument;\n\t\tvar ownerNode = doc.contains ? doc : doc.documentElement;\n\t\tif (!ownerNode.contains(el)) {\n\t\t\tteardownHandler();\n\t\t}\n\t});\n\n\t// set up a current attribute set and assign to oldAttrs\n\tliveAttrsUpdate(canReflect.getValue(compute));\n};\n","\"use strict\";\nvar live = require('./core');\nvar nodeLists = require('can-view-nodelist');\nvar makeFrag = require('can-fragment');\nvar childNodes = require('can-child-nodes');\nvar canReflect = require('can-reflect');\nvar canSymbol = require(\"can-symbol\");\nvar queues = require(\"can-queues\");\nvar viewInsertSymbol = canSymbol.for(\"can.viewInsert\");\n\n\nfunction updateNodeList(data, frag, nodeListUpdatedByFn) {\n\tif(data.nodeList.isUnregistered !== true) {\n\t\t// We need to keep oldNodes up to date with the last fragment so if this\n\t\t// function runs again, we can replace the oldNodes with frag\n\t\tvar newChildren = canReflect.toArray(childNodes(frag));\n\t\tif(!nodeListUpdatedByFn) {\n\t\t\tnodeLists.update(data.nodeList, newChildren, data.oldNodes);\n\t\t}\n\t\tvar oldNodes = data.oldNodes;\n\t\tdata.oldNodes = newChildren;\n\t\tnodeLists.replace(oldNodes, frag);\n\t}\n}\n\n/**\n * @function can-view-live.html html\n * @parent can-view-live\n * @release 2.0.4\n *\n * Live binds a compute's value to a collection of elements.\n *\n * @signature `live.html(el, compute, [parentNode])`\n *\n * `live.html` is used to setup incremental live-binding on a block of html.\n *\n * ```js\n * // a compute that changes its list\n * var greeting = compute(function(){\n *   return \"Welcome <i>\"+me.attr(\"name\")+\"</i>\"\n * });\n *\n * var placeholder = document.createTextNode(\" \");\n * $(\"#greeting\").append(placeholder);\n *\n * live.html(placeholder, greeting);\n * ```\n *\n * @param {HTMLElement} el An html element to replace with the live-section.\n *\n * @param {can.compute} compute A [can.compute] whose value is HTML.\n *\n * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is\n * a documentFragment.\n *\n *\n */\nlive.html = function(el, compute, parentNode, nodeListOrOptions) {\n\tvar data;\n\tvar makeAndPut;\n\tvar nodeList;\n\tvar nodes;\n\tvar options;\n\n\t// nodeListOrOptions can either be a NodeList or an object with a nodeList property\n\tif (nodeListOrOptions !== undefined) {\n\t\tif (Array.isArray(nodeListOrOptions)) {\n\t\t\tnodeList = nodeListOrOptions;\n\t\t} else {\n\t\t\tnodeList = nodeListOrOptions.nodeList;\n\t\t\toptions = nodeListOrOptions;\n\t\t}\n\t}\n\n\tvar meta = {reasonLog: \"live.html replace::\"+canReflect.getName(compute)};\n\t// prefer to manipulate el's actual parent over the supplied parent\n\tparentNode = live.getParentNode(el, parentNode);\n\n\tfunction liveHTMLUpdateHTML(newVal) {\n\t\t// the attachment point for the nodelist\n\t\tvar attached = nodeLists.first(nodes).parentNode;\n\t\t// update the nodes in the DOM with the new rendered value\n\t\tif (attached) {\n\t\t\tmakeAndPut(newVal, true);\n\t\t}\n\t\tvar pn = nodeLists.first(nodes).parentNode;\n\t\tdata.teardownCheck(pn);\n\t}\n\n\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\t// register that the handler changes the parent element\n\t\tcanReflect.assignSymbols(liveHTMLUpdateHTML, {\n\t\t\t\"can.getChangesDependencyRecord\": function() {\n\t\t\t\tvar s = new Set();\n\t\t\t\ts.add(parentNode);\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: s\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(liveHTMLUpdateHTML, \"name\", {\n\t\t\tvalue: \"live.html update::\"+canReflect.getName(compute),\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\n\tdata = live.listen(parentNode, compute, liveHTMLUpdateHTML);\n\n\t// Nodes registered to the live operation, either a list of nodes or a single element\n\tnodes = nodeList || [el];\n\tmakeAndPut = function(val, useQueue) {\n\t\t// ##### makeandput\n\t\t// Receives the compute output (must be some DOM representation, a function,\n\t\t// or an object with the can.viewInsert symbol)\n\n\t\t// If val has the can.viewInsert symbol, call it and get something usable for val back\n\t\tif (val && typeof val[viewInsertSymbol] === \"function\") {\n\t\t\tval = val[viewInsertSymbol](options);\n\t\t}\n\n\t\tvar isFunction = typeof val === \"function\";\n\n\t\t// translate val into a document fragment if it's DOM-like\n\t\tvar frag = makeFrag(isFunction ? \"\" : val);\n\n\t\t// Add a placeholder textNode if necessary.\n\t\tlive.addTextNodeIfNoChildren(frag);\n\n\t\t// Mark each node as belonging to the node list.\n\n\t\t// DOM replace old nodes with new frag (which might contain some old nodes)\n\t\tif(useQueue === true) {\n\t\t\t// unregister all children immediately\n\t\t\tdata.oldNodes = nodeLists.unregisterChildren(nodes, true);\n\n\t\t\tvar nodeListUpdatedByFn = false;\n\t\t\t// allow\n\t\t\tif (isFunction) {\n\t\t\t\tval(frag.firstChild);\n\t\t\t\t// see if nodes has already been updated\n\t\t\t\tnodeListUpdatedByFn = nodeLists.first(nodes) === frag.firstChild;\n\t\t\t}\n\t\t\tqueues.domUIQueue.enqueue(updateNodeList, null, [data, frag, nodeListUpdatedByFn], meta);\n\t\t} else {\n\t\t\t// this is initialization, update right away.\n\t\t\tdata.oldNodes = nodeLists.update(nodes, childNodes(frag));\n\t\t\tif (isFunction) {\n\t\t\t\tval(frag.firstChild);\n\t\t\t}\n\t\t\tnodeLists.replace(data.oldNodes, frag);\n\t\t}\n\n\t};\n\n\tdata.nodeList = nodes;\n\n\t// register the span so nodeLists knows the parentNodeList\n\tif (!nodeList) {\n\t\tnodeLists.register(nodes, data.teardownCheck);\n\t} else {\n\t\tnodeList.unregistered = data.teardownCheck;\n\t}\n\t// Finally give the subtree an initial value\n\tmakeAndPut(canReflect.getValue(compute));\n};\n","\"use strict\";\nvar SimpleObservable = require(\"can-simple-observable\");\nvar canReflect = require(\"can-reflect\");\n\nfunction SetObservable(initialValue, setter) {\n\tthis.setter = setter;\n\n\tSimpleObservable.call(this, initialValue);\n}\n\nSetObservable.prototype = Object.create(SimpleObservable.prototype);\nSetObservable.prototype.constructor = SetObservable;\nSetObservable.prototype.set = function(newVal) {\n\tthis.setter(newVal);\n};\n\n\ncanReflect.assignSymbols(SetObservable.prototype, {\n\t\"can.setValue\": SetObservable.prototype.set\n});\n\nmodule.exports = SetObservable;\n","\"use strict\";\nvar live = require('./core');\n\nvar nodeLists = require('can-view-nodelist');\n\nvar frag = require('can-fragment');\nvar childNodes = require('can-child-nodes');\nvar domMutateNode = require('can-dom-mutate/node');\nvar canReflect = require(\"can-reflect\");\n\n\nvar canSymbol = require(\"can-symbol\");\n\nvar canReflectDeps = require(\"can-reflect-dependencies\");\n\nvar SimpleObservable = require(\"can-simple-observable\");\nvar SetObservable = require(\"./set-observable\");\nvar Patcher = require(\"can-diff/patcher/patcher\");\n\nvar splice = [].splice;\n\n// #### renderAndAddToNodeLists\n// a helper function that renders something and adds its nodeLists to newNodeLists\n// in the right way for stache.\nvar renderAndAddToNodeLists = function(newNodeLists, parentNodeList, render, context, args) {\n\t\tvar itemNodeList = [];\n\n\t\tif (parentNodeList) {\n\t\t\t// With a supplied parent list, \"directly\" register the new nodeList\n\t\t\t//  as a child.\n\t\t\tnodeLists.register(itemNodeList, null, true, true);\n\t\t\titemNodeList.parentList = parentNodeList;\n\t\t\titemNodeList.expression = \"#each SUBEXPRESSION\";\n\t\t}\n\n\t\t// call the renderer, passing in the new nodeList as the last argument\n\t\tvar itemHTML = render.apply(context, args.concat([itemNodeList])),\n\t\t\t// and put the output into a document fragment\n\t\t\titemFrag = frag(itemHTML);\n\n\t\t// get all the direct children of the frag\n\t\tvar children = canReflect.toArray(childNodes(itemFrag));\n\t\tif (parentNodeList) {\n\t\t\t// if a parent list was supplied, children of the frag become the\n\t\t\t//  child nodeList items.\n\t\t\tnodeLists.update(itemNodeList, children);\n\t\t\tnewNodeLists.push(itemNodeList);\n\t\t} else {\n\t\t\t// If no parent nodeList, register the new array of frag children as a nodeList\n\t\t\t//  and push into the nodeLists\n\t\t\tnewNodeLists.push(nodeLists.register(children));\n\t\t}\n\t\treturn itemFrag;\n\t},\n\t// #### removeFromNodeList\n\t// a splicing helper for nodeLists, which removes sublists, including unregistering,\n\t//  for a contiguous slice of the master list.\n\tremoveFromNodeList = function(masterNodeList, index, length) {\n\t\tvar removedMappings = masterNodeList.splice(index + 1, length),\n\t\t\titemsToRemove = [];\n\t\tremovedMappings.forEach( function(nodeList) {\n\n\t\t\t// Unregister to free up event bindings.\n\t\t\tvar nodesToRemove = nodeLists.unregister(nodeList);\n\n\t\t\t// add items that we will remove all at once\n\t\t\t[].push.apply(itemsToRemove, nodesToRemove);\n\t\t});\n\t\treturn itemsToRemove;\n\t};\n\n\n\n\nvar onPatchesSymbol = canSymbol.for(\"can.onPatches\");\nvar offPatchesSymbol = canSymbol.for(\"can.offPatches\");\n\nfunction ListDOMPatcher(el, compute, render, context, parentNode, nodeList, falseyRender) {\n\tthis.patcher = new Patcher(compute);\n\n\t// argument cleanup\n\tparentNode = live.getParentNode(el, parentNode);\n\n\t// function callback binding\n\n\t// argument saving -----\n\tthis.value = compute;\n\tthis.render = render;\n\tthis.context = context;\n\tthis.parentNode = parentNode;\n\tthis.falseyRender = falseyRender;\n\t// A nodeList of all elements this live-list manages.\n\t// This is here so that if this live list is within another section\n\t// that section is able to remove the items in this list.\n\tthis.masterNodeList = nodeList || nodeLists.register([el], null, true);\n\tthis.placeholder = el;\n\n\t// A mapping of items to their indices\n\tthis.indexMap = [];\n\n\tthis.isValueLike = canReflect.isValueLike(this.value);\n\tthis.isObservableLike = canReflect.isObservableLike(this.value);\n\n\t// Setup binding and teardown to add and remove events\n\tthis.onPatches = this.onPatches.bind(this);\n\tvar data = this.data = live.setup(\n\t\tparentNode,\n\t\tthis.setupValueBinding.bind(this),\n\t\tthis.teardownValueBinding.bind(this)\n\t);\n\n\tthis.masterNodeList.unregistered = function() {\n\t\tdata.teardownCheck();\n\t\t//isTornDown = true;\n\t};\n\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tObject.defineProperty(this.onPatches, \"name\", {\n\t\t\tvalue: \"live.list update::\"+canReflect.getName(compute),\n\t\t});\n\t}\n\t//!steal-remove-end\n}\n\nvar onPatchesSymbol = canSymbol.for(\"can.onPatches\");\nvar offPatchesSymbol = canSymbol.for(\"can.offPatches\");\n\nListDOMPatcher.prototype = {\n\tsetupValueBinding: function() {\n\t\tthis.patcher[onPatchesSymbol](this.onPatches, \"domUI\");\n\t\tif (this.patcher.currentList && this.patcher.currentList.length) {\n\t\t\tthis.onPatches([{\n\t\t\t\tinsert: this.patcher.currentList,\n\t\t\t\tindex: 0,\n\t\t\t\tdeleteCount: 0\n\t\t\t}]);\n\t\t} else {\n\t\t\tthis.addFalseyIfEmpty();\n\t\t}\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tcanReflectDeps.addMutatedBy(this.parentNode, this.patcher.observableOrList);\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\tteardownValueBinding: function() {\n\t\tthis.patcher[offPatchesSymbol](this.onPatches, \"domUI\");\n\t\tthis.exit = true;\n\t\tthis.remove({\n\t\t\tlength: this.patcher.currentList.length\n\t\t}, 0, true);\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tcanReflectDeps.deleteMutatedBy(this.parentNode, this.patcher.observableOrList);\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\tonPatches: function ListDOMPatcher_onPatches(patches) {\n\t\tif (this.exit) {\n\t\t\treturn;\n\t\t}\n\t\tfor (var i = 0, patchLen = patches.length; i < patchLen; i++) {\n\t\t\tvar patch = patches[i];\n\t\t\tif (patch.type === \"move\") {\n\t\t\t\tthis.move(patch.toIndex, patch.fromIndex);\n\t\t\t} else {\n\t\t\t\tif (patch.deleteCount) {\n\t\t\t\t\t// Remove any items scheduled for deletion from the patch.\n\t\t\t\t\tthis.remove({\n\t\t\t\t\t\tlength: patch.deleteCount\n\t\t\t\t\t}, patch.index, true);\n\t\t\t\t}\n\t\t\t\tif (patch.insert && patch.insert.length) {\n\t\t\t\t\t// Insert any new items at the index\n\t\t\t\t\tthis.add(patch.insert, patch.index);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\tadd: function(items, index) {\n\t\t//if (!afterPreviousEvents) {\n\t\t//\treturn;\n\t\t//}\n\t\t// Collect new html and mappings\n\t\tvar frag = this.placeholder.ownerDocument.createDocumentFragment(),\n\t\t\tnewNodeLists = [],\n\t\t\tnewIndicies = [],\n\t\t\tmasterNodeList = this.masterNodeList,\n\t\t\trender = this.render,\n\t\t\tcontext = this.context;\n\t\t// For each new item,\n\t\titems.forEach( function(item, key) {\n\n\t\t\tvar itemIndex = new SimpleObservable(key + index),\n\t\t\t\titemCompute = new SetObservable(item, function(newVal) {\n\t\t\t\t\tcanReflect.setKeyValue(this.patcher.currentList, itemIndex.get(), newVal );\n\t\t\t\t}.bind(this)),\n\t\t\t\titemFrag = renderAndAddToNodeLists(newNodeLists, masterNodeList, render, context, [itemCompute, itemIndex]);\n\n\t\t\t// Hookup the fragment (which sets up child live-bindings) and\n\t\t\t// add it to the collection of all added elements.\n\t\t\tfrag.appendChild(itemFrag);\n\t\t\t// track indicies;\n\t\t\tnewIndicies.push(itemIndex);\n\t\t}, this);\n\t\t// The position of elements is always after the initial text placeholder node\n\t\tvar masterListIndex = index + 1;\n\n\t\t// remove falsey if there's something there\n\t\tif (!this.indexMap.length) {\n\t\t\t// remove all leftover things\n\t\t\tvar falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);\n\t\t\tnodeLists.remove(falseyItemsToRemove);\n\t\t}\n\n\t\t// Check if we are adding items at the end\n\t\tif (!masterNodeList[masterListIndex]) {\n\t\t\tnodeLists.after(masterListIndex === 1 ? [this.placeholder] : [nodeLists.last(this.masterNodeList[masterListIndex - 1])], frag);\n\t\t} else {\n\t\t\t// Add elements before the next index's first element.\n\t\t\tvar el = nodeLists.first(masterNodeList[masterListIndex]);\n\t\t\tdomMutateNode.insertBefore.call(el.parentNode, frag, el);\n\t\t}\n\t\tsplice.apply(this.masterNodeList, [\n\t\t\tmasterListIndex,\n\t\t\t0\n\t\t].concat(newNodeLists));\n\n\t\t// update indices after insert point\n\t\tsplice.apply(this.indexMap, [\n\t\t\tindex,\n\t\t\t0\n\t\t].concat(newIndicies));\n\n\t\tfor (var i = index + newIndicies.length, len = this.indexMap.length; i < len; i++) {\n\t\t\tthis.indexMap[i].set(i);\n\t\t}\n\t},\n\tremove: function(items, index) {\n\t\t//if (!afterPreviousEvents) {\n\t\t//\treturn;\n\t\t//}\n\n\t\t// If this is because an element was removed, we should\n\t\t// check to make sure the live elements are still in the page.\n\t\t// If we did this during a teardown, it would cause an infinite loop.\n\t\t//if (!duringTeardown && this.data.teardownCheck(this.placeholder.parentNode)) {\n\t\t//\treturn;\n\t\t//}\n\t\tif (index < 0) {\n\t\t\tindex = this.indexMap.length + index;\n\t\t}\n\t\tvar itemsToRemove = removeFromNodeList(this.masterNodeList, index, items.length);\n\t\tvar indexMap = this.indexMap;\n\t\t// update indices after remove point\n\t\tindexMap.splice(index, items.length);\n\t\tfor (var i = index, len = indexMap.length; i < len; i++) {\n\t\t\tindexMap[i].set(i);\n\t\t}\n\n\t\t// don't remove elements during teardown.  Something else will probably be doing that.\n\t\tif (!this.exit) {\n\t\t\t// adds the falsey section if the list is empty\n\t\t\tthis.addFalseyIfEmpty();\n\t\t\tnodeLists.remove(itemsToRemove);\n\t\t} else {\n\t\t\tnodeLists.unregister(this.masterNodeList);\n\t\t}\n\t},\n\t// #### addFalseyIfEmpty\n\t// Add the results of redering the \"falsey\" or inverse case render to the\n\t// master nodeList and the DOM if the live list is empty\n\taddFalseyIfEmpty: function() {\n\t\tif (this.falseyRender && this.indexMap.length === 0) {\n\t\t\t// If there are no items ... we should render the falsey template\n\t\t\tvar falseyNodeLists = [];\n\t\t\tvar falseyFrag = renderAndAddToNodeLists(falseyNodeLists, this.masterNodeList, this.falseyRender, this.currentList, [this.currentList]);\n\n\t\t\t// put the frag after the reference element in the associated nodeList\n\t\t\tnodeLists.after([this.masterNodeList[0]], falseyFrag);\n\t\t\t// and push the first element onto the master list\n\t\t\tthis.masterNodeList.push(falseyNodeLists[0]);\n\t\t}\n\t},\n\tmove: function move(newIndex, currentIndex) {\n\t\t//if (!afterPreviousEvents) {\n\t\t//\treturn;\n\t\t//}\n\t\t// The position of elements is always after the initial text\n\t\t// placeholder node\n\t\tnewIndex = newIndex + 1;\n\t\tcurrentIndex = currentIndex + 1;\n\t\tvar masterNodeList = this.masterNodeList,\n\t\t\tindexMap = this.indexMap;\n\t\tvar referenceNodeList = masterNodeList[newIndex];\n\t\tvar movedElements = frag(nodeLists.flatten(masterNodeList[currentIndex]));\n\t\tvar referenceElement;\n\n\t\t// If we're moving forward in the list, we want to be placed before\n\t\t// the item AFTER the target index since removing the item from\n\t\t// the currentIndex drops the referenceItem's index. If there is no\n\t\t// nextSibling, insertBefore acts like appendChild.\n\t\tif (currentIndex < newIndex) {\n\t\t\treferenceElement = nodeLists.last(referenceNodeList).nextSibling;\n\t\t} else {\n\t\t\treferenceElement = nodeLists.first(referenceNodeList);\n\t\t}\n\n\t\tvar parentNode = masterNodeList[0].parentNode;\n\n\t\t// Move the DOM nodes into the proper location\n\t\tparentNode.insertBefore(movedElements, referenceElement);\n\n\t\t// Now, do the same for the masterNodeList. We need to keep it\n\t\t// in sync with the DOM.\n\n\t\t// Save a reference to the \"node\" that we're manually moving\n\t\tvar temp = masterNodeList[currentIndex];\n\n\t\t// Remove the movedItem from the masterNodeList\n\t\t[].splice.apply(masterNodeList, [currentIndex, 1]);\n\n\t\t// Move the movedItem to the correct index in the masterNodeList\n\t\t[].splice.apply(masterNodeList, [newIndex, 0, temp]);\n\n\t\t// Convert back to a zero-based array index\n\t\tnewIndex = newIndex - 1;\n\t\tcurrentIndex = currentIndex - 1;\n\n\t\t// Grab the index compute from the `indexMap`\n\t\tvar indexCompute = indexMap[currentIndex];\n\n\t\t// Remove the index compute from the `indexMap`\n\t\t[].splice.apply(indexMap, [currentIndex, 1]);\n\n\t\t// Move the index compute to the correct index in the `indexMap`\n\t\t[].splice.apply(indexMap, [newIndex, 0, indexCompute]);\n\n\t\tvar i = Math.min(currentIndex, newIndex);\n\t\tvar len = indexMap.length;\n\n\t\tfor (i, len; i < len; i++) {\n\t\t\t// set each compute to have its current index in the map as its value\n\t\t\tindexMap[i].set(i);\n\t\t}\n\t},\n\tset: function(newVal, index) {\n\t\tthis.remove({\n\t\t\tlength: 1\n\t\t}, index, true);\n\t\tthis.add([newVal], index);\n\t}\n};\n\n\n\n/**\n * @function can-view-live.list list\n * @parent can-view-live\n * @release 2.0.4\n *\n * @signature `live.list(el, list, render, context, [parentNode])`\n *\n * Live binds a compute's list incrementally.\n *\n * ```js\n * // a compute that change's it's list\n * var todos = compute(function(){\n *   return new Todo.List({page: can.route.attr(\"page\")})\n * })\n *\n * var placeholder = document.createTextNode(\" \");\n * $(\"ul#todos\").append(placeholder);\n *\n * can.view.live.list(\n *   placeholder,\n *   todos,\n *   function(todo, index){\n *     return \"<li>\"+todo.attr(\"name\")+\"</li>\"\n *   });\n * ```\n *\n * @param {HTMLElement} el An html element to replace with the live-section.\n *\n * @param {Object} list An observable value or list type. If an observable value, it should contain\n * a falsey value or a list type.\n *\n * @param {function(this:*,*,index):String} render(index, index) A function that when called with\n * the incremental item to render and the index of the item in the list.\n *\n * @param {Object} context The `this` the `render` function will be called with.\n *\n * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is\n * a documentFragment.\n *\n * @body\n *\n * ## How it works\n *\n * If `list` is an observable value, `live.list` listens to changes in in that\n * observable value.  It will generally change from one list type (often a list type that implements `onPatches`)\n * to another.  When the value changes, a diff will be performed and the DOM updated.  Also, `live.list`\n * will listen to `.onPatches` on the new list and apply any patches emitted from it.\n *\n *\n */\nlive.list = function(el, list, render, context, parentNode, nodeList, falseyRender) {\n\tif (el.nodeType !== Node.TEXT_NODE) {\n\t\tvar textNode;\n\t\tif (!nodeList) {\n\t\t\ttextNode = document.createTextNode(\"\");\n\t\t\tel.parentNode.replaceChild(textNode, el);\n\t\t\tel = textNode;\n\t\t} else {\n\t\t\ttextNode = document.createTextNode(\"\");\n\t\t\tnodeLists.replace(nodeList, textNode);\n\t\t\tnodeLists.update(nodeList, [textNode]);\n\t\t\tel = textNode;\n\t\t}\n\t}\n\tnew ListDOMPatcher(el, list, render, context, parentNode, nodeList, falseyRender);\n};\n","\"use strict\";\nvar live = require('./core');\nvar nodeLists = require('can-view-nodelist');\nvar canReflect = require('can-reflect');\n\n/**\n * @function can-view-live.text text\n * @parent can-view-live\n * @release 2.0.4\n *\n * @signature `live.text(el, compute, [parentNode], [nodeList])`\n *\n * Replaces one element with some content while keeping [can-view-live.nodeLists nodeLists] data correct.\n */\nlive.text = function(el, compute, parentNode, nodeList) {\n\t// TODO: we can remove this at some point\n\tif (el.nodeType !== Node.TEXT_NODE) {\n\t\tvar textNode;\n\t\tif (!nodeList) {\n\t\t\ttextNode = document.createTextNode(\"\");\n\t\t\tel.parentNode.replaceChild(textNode, el);\n\t\t\tel = textNode;\n\t\t} else {\n\t\t\ttextNode = document.createTextNode(\"\");\n\t\t\tnodeLists.replace(nodeList, textNode);\n\t\t\tnodeLists.update(nodeList, [textNode]);\n\t\t\tel = textNode;\n\t\t}\n\t}\n\n\tvar parent = live.getParentNode(el, parentNode);\n\t// setup listening right away so we don't have to re-calculate value\n\n\t// Create a new text node from the compute value\n\tel.nodeValue = live.makeString(canReflect.getValue(compute));\n\n\tfunction liveTextUpdateTextNode(newVal) {\n\t\tel.nodeValue = live.makeString(newVal);\n\t}\n\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\t// register that the handler changes the parent element\n\t\tcanReflect.assignSymbols(liveTextUpdateTextNode, {\n\t\t\t\"can.getChangesDependencyRecord\": function() {\n\t\t\t\tvar s = new Set();\n\t\t\t\ts.add(parent);\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: s\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(liveTextUpdateTextNode, \"name\", {\n\t\t\tvalue: \"live.text update::\"+canReflect.getName(compute),\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tvar data = live.listen(parent, compute, liveTextUpdateTextNode,\"domUI\");\n\n\tif(!nodeList) {\n\t\tnodeList = nodeLists.register([el], null, true);\n\t}\n\n\tnodeList.unregistered = data.teardownCheck;\n\tdata.nodeList = nodeList;\n};\n","\"use strict\";\nvar live = require(\"./lib/core\");\nrequire(\"./lib/attr\");\nrequire(\"./lib/attrs\");\nrequire(\"./lib/html\");\nrequire(\"./lib/list\");\nrequire(\"./lib/text\");\n\n\nmodule.exports = live;\n"],"names":["contains","parent","child","nodeType","Node","DOCUMENT_NODE","documentElement","parentNode","live","setup","el","bind","unbind","removalDisposal","data","tornDown","teardown","undefined","teardownCheck","domMutate","onNodeRemoval","ownerDocument","listen","compute","change","queueName","canReflect","onValue","process","env","NODE_ENV","canReflectDeps","addMutatedBy","offValue","deleteMutatedBy","nodeList","nodeLists","unregister","getAttributeParts","newVal","attr","attrs","parser","parseAttrs","attrStart","name","attrValue","value","attrEnd","isNode","obj","addTextNodeIfNoChildren","frag","firstChild","appendChild","createTextNode","replace","nodes","val","oldNodes","slice","makeFrag","register","update","childNodes","getParentNode","defaultParentNode","makeString","txt","attributeName","liveUpdateAttr","queues","domUIQueue","enqueue","set","assignSymbols","can.getChangesDependencyRecord","s","Set","add","valueDependencies","Object","defineProperty","getName","getValue","scope","options","isObservableLike","oldAttrs","liveAttrsUpdate","doc","domMutateNode","setAttribute","call","newAttrs","newValue","callback","viewCallbacks","removeAttribute","viewInsertSymbol","canSymbol","for","updateNodeList","nodeListUpdatedByFn","isUnregistered","newChildren","toArray","SetObservable","initialValue","setter","this","SimpleObservable","html","nodeListOrOptions","makeAndPut","Array","isArray","meta","reasonLog","liveHTMLUpdateHTML","first","pn","useQueue","isFunction","unregisterChildren","unregistered","prototype","create","constructor","can.setValue","splice","renderAndAddToNodeLists","newNodeLists","parentNodeList","render","context","args","itemNodeList","parentList","expression","itemHTML","apply","concat","itemFrag","children","push","removeFromNodeList","masterNodeList","index","length","removedMappings","itemsToRemove","forEach","nodesToRemove","onPatchesSymbol","offPatchesSymbol","ListDOMPatcher","falseyRender","patcher","Patcher","placeholder","indexMap","isValueLike","onPatches","setupValueBinding","teardownValueBinding","currentList","insert","deleteCount","addFalseyIfEmpty","observableOrList","exit","remove","patches","i","patchLen","patch","type","move","toIndex","fromIndex","items","createDocumentFragment","newIndicies","item","key","itemIndex","itemCompute","setKeyValue","get","masterListIndex","falseyItemsToRemove","insertBefore","after","last","len","falseyNodeLists","falseyFrag","newIndex","currentIndex","referenceElement","referenceNodeList","movedElements","flatten","nextSibling","temp","indexCompute","Math","min","list","textNode","TEXT_NODE","document","replaceChild","text","liveTextUpdateTextNode","nodeValue"],"mappings":"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"}