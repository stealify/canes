{"version":3,"file":"chunk-bb7c303b.js","sources":["../node_modules/can-diff/patcher/patcher.js"],"sourcesContent":["\n\n\"use strict\";\n\nvar canReflect = require(\"can-reflect\");\nvar KeyTree = require(\"can-key-tree\");\nvar canSymbol = require(\"can-symbol\");\nvar diff = require('../list/list');\nvar queues = require(\"can-queues\");\nvar canSymbol = require(\"can-symbol\");\n\nvar onValueSymbol = canSymbol.for(\"can.onValue\"),\n\toffValueSymbol = canSymbol.for(\"can.offValue\");\nvar onPatchesSymbol = canSymbol.for(\"can.onPatches\");\nvar offPatchesSymbol = canSymbol.for(\"can.offPatches\");\n\n// Patcher takes a observable that might wrap a list type.\n// When the observable changes, it will diff, and emit patches,\n// and if the list emits patches, it will emit those too.\n// It is expected that only `domUI` handlers are registered.\n/*\nvar observable = new SimpleObservable( new DefineList([ \"a\", \"b\", \"c\" ]) )\nvar patcher = new Patcher(observable)\ncanReflect.onPatches( patcher,function(patches){\n  console.log(patches) // a patch removing c, then a\n})\nvar newList = new DefineList([\"a\",\"b\"]);\nobservable.set(newList);\nnewList.unshift(\"X\");\n[\n    {type: \"splice\", index: 2, deleteCount: 1}\n]\nvar patches2 = [\n    {type: \"splice\", index: 0, deleteCount: 0, inserted: [\"X\"]}\n]\n */\nvar Patcher = function(observableOrList, priority) {\n\t// stores listeners for this patcher\n\tthis.handlers = new KeyTree([Object, Array], {\n\t\t// call setup when the first handler is bound\n\t\tonFirst: this.setup.bind(this),\n\t\t// call teardown when the last handler is removed\n\t\tonEmpty: this.teardown.bind(this)\n\t});\n\n\t// save this value observable or patch emitter (list)\n\tthis.observableOrList = observableOrList;\n\t// if we were passed an observable value that we need to read its array for changes\n\tthis.isObservableValue = canReflect.isValueLike(this.observableOrList) || canReflect.isObservableLike(this.observableOrList);\n\tif(this.isObservableValue) {\n\t    this.priority = canReflect.getPriority(observableOrList);\n\t} else {\n\t    this.priority = priority || 0;\n\t}\n\tthis.onList = this.onList.bind(this);\n\tthis.onPatchesNotify = this.onPatchesNotify.bind(this);\n\t// needs to be unique so the derive queue doesn't only add one.\n\tthis.onPatchesDerive = this.onPatchesDerive.bind(this);\n\n\t// stores patches that have happened between notification and\n\t// when we queue the  `onPatches` handlers in the `domUI` queue\n\tthis.patches = [];\n\n\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tObject.defineProperty(this.onList, \"name\", {\n\t\t\tvalue: \"live.list new list::\"+canReflect.getName(observableOrList),\n\t\t});\n\t\tObject.defineProperty(this.onPatchesNotify, \"name\", {\n\t\t\tvalue: \"live.list notify::\"+canReflect.getName(observableOrList),\n\t\t});\n\t\tObject.defineProperty(this.onPatchesDerive, \"name\", {\n\t\t\tvalue: \"live.list derive::\"+canReflect.getName(observableOrList),\n\t\t});\n\t}\n\t//!steal-remove-end\n};\n\n\nPatcher.prototype = {\n\tconstructor: Patcher,\n\tsetup: function() {\n\t\tif (this.observableOrList[onValueSymbol]) {\n\t\t\t// if we have an observable value, listen to when it changes to get a\n\t\t\t// new list.\n\t\t\tcanReflect.onValue(this.observableOrList, this.onList, \"notify\");\n\t\t\t// listen on the current value (which shoudl be a list) if there is one\n\t\t\tthis.setupList(canReflect.getValue(this.observableOrList));\n\t\t} else {\n\t\t\tthis.setupList(this.observableOrList);\n\t\t}\n\t},\n\tteardown: function() {\n\t\tif (this.observableOrList[offValueSymbol]) {\n\t\t\tcanReflect.offValue(this.observableOrList, this.onList, \"notify\");\n\t\t}\n\t},\n\t// listen to the list for patches\n\tsetupList: function(list) {\n\t\tthis.currentList = list;\n\t\tif (list && list[onPatchesSymbol]) {\n\t\t\t// If observable, set up bindings on list changes\n\t\t\tlist[onPatchesSymbol](this.onPatchesNotify, \"notify\");\n\t\t}\n\t},\n\t// when the list changes, teardown the old list bindings\n\t// and setup the new list\n\tonList: function onList(newList) {\n\t\tvar current = this.currentList || [];\n\t\tnewList = newList || [];\n\t\tif (current[offPatchesSymbol]) {\n\t\t\tcurrent[offPatchesSymbol](this.onPatchesNotify, \"notify\");\n\t\t}\n\t\tvar patches = diff(current, newList);\n\t\tthis.currentList = newList;\n\t\tthis.onPatchesNotify(patches);\n\t\tif (newList[onPatchesSymbol]) {\n\t\t\t// If observable, set up bindings on list changes\n\t\t\tnewList[onPatchesSymbol](this.onPatchesNotify, \"notify\");\n\t\t}\n\t},\n\t// This is when we get notified of patches on the underlying list.\n\t// Save the patches and queue up a `derive` task that will\n\t// call `domUI` updates.\n\tonPatchesNotify: function onPatchesNotify(patches) {\n\t\t// we are going to collect all patches\n\t\tthis.patches.push.apply(this.patches, patches);\n\t\t// TODO: share priority\n\t\tqueues.deriveQueue.enqueue(this.onPatchesDerive, this, [], {\n\t\t\tpriority: this.priority\n\t\t});\n\t},\n\t// Let handlers (which should only be registered in `domUI`) know about patches\n\t// that they can apply.\n\tonPatchesDerive: function onPatchesDerive() {\n\t\tvar patches = this.patches;\n\t\tthis.patches = [];\n\t\tqueues.enqueueByQueue(this.handlers.getNode([]), this.currentList, [patches, this.currentList], null,[\"Apply patches\", patches]);\n\t}\n};\n\ncanReflect.assignSymbols(Patcher.prototype, {\n\t\"can.onPatches\": function(handler, queue) {\n\t\tthis.handlers.add([queue || \"mutate\", handler]);\n\t},\n\t\"can.offPatches\": function(handler, queue) {\n\t\tthis.handlers.delete([queue || \"mutate\", handler]);\n\t}\n});\n\nmodule.exports = Patcher;\n"],"names":["onValueSymbol","canSymbol","for","offValueSymbol","onPatchesSymbol","offPatchesSymbol","Patcher","observableOrList","priority","this","handlers","KeyTree","Object","Array","onFirst","setup","bind","onEmpty","teardown","isObservableValue","canReflect","isValueLike","isObservableLike","getPriority","onList","onPatchesNotify","onPatchesDerive","patches","process","env","NODE_ENV","defineProperty","value","getName","prototype","constructor","onValue","setupList","getValue","offValue","list","currentList","newList","current","diff","push","apply","queues","deriveQueue","enqueue","enqueueByQueue","getNode","assignSymbols","can.onPatches","handler","queue","add","can.offPatches","delete"],"mappings":"2WAWA,IAAIA,cAAgBC,UAAUC,IAAI,eACjCC,eAAiBF,UAAUC,IAAI,gBAC5BE,gBAAkBH,UAAUC,IAAI,iBAChCG,iBAAmBJ,UAAUC,IAAI,kBAsBjCI,QAAU,SAASC,EAAkBC,GAExCC,KAAKC,SAAW,IAAIC,QAAQ,CAACC,OAAQC,OAAQ,CAE5CC,QAASL,KAAKM,MAAMC,KAAKP,MAEzBQ,QAASR,KAAKS,SAASF,KAAKP,QAI7BA,KAAKF,iBAAmBA,EAExBE,KAAKU,kBAAoBC,WAAWC,YAAYZ,KAAKF,mBAAqBa,WAAWE,iBAAiBb,KAAKF,kBACxGE,KAAKU,kBACJV,KAAKD,SAAWY,WAAWG,YAAYhB,GAEvCE,KAAKD,SAAWA,GAAY,EAEhCC,KAAKe,OAASf,KAAKe,OAAOR,KAAKP,MAC/BA,KAAKgB,gBAAkBhB,KAAKgB,gBAAgBT,KAAKP,MAEjDA,KAAKiB,gBAAkBjB,KAAKiB,gBAAgBV,KAAKP,MAIjDA,KAAKkB,QAAU,GAIa,eAAzBC,UAAQC,IAAIC,WACdlB,OAAOmB,eAAetB,KAAKe,OAAQ,OAAQ,CAC1CQ,MAAO,uBAAuBZ,WAAWa,QAAQ1B,KAElDK,OAAOmB,eAAetB,KAAKgB,gBAAiB,OAAQ,CACnDO,MAAO,qBAAqBZ,WAAWa,QAAQ1B,KAEhDK,OAAOmB,eAAetB,KAAKiB,gBAAiB,OAAQ,CACnDM,MAAO,qBAAqBZ,WAAWa,QAAQ1B,OAOlDD,QAAQ4B,UAAY,CACnBC,YAAa7B,QACbS,MAAO,WACFN,KAAKF,iBAAiBP,gBAGzBoB,WAAWgB,QAAQ3B,KAAKF,iBAAkBE,KAAKe,OAAQ,UAEvDf,KAAK4B,UAAUjB,WAAWkB,SAAS7B,KAAKF,oBAExCE,KAAK4B,UAAU5B,KAAKF,mBAGtBW,SAAU,WACLT,KAAKF,iBAAiBJ,iBACzBiB,WAAWmB,SAAS9B,KAAKF,iBAAkBE,KAAKe,OAAQ,WAI1Da,UAAW,SAASG,GACnB/B,KAAKgC,YAAcD,EACfA,GAAQA,EAAKpC,kBAEhBoC,EAAKpC,iBAAiBK,KAAKgB,gBAAiB,WAK9CD,OAAQ,SAAgBkB,GACvB,IAAIC,EAAUlC,KAAKgC,aAAe,GAClCC,EAAUA,GAAW,GACjBC,EAAQtC,mBACXsC,EAAQtC,kBAAkBI,KAAKgB,gBAAiB,UAEjD,IAAIE,EAAUiB,KAAKD,EAASD,GAC5BjC,KAAKgC,YAAcC,EACnBjC,KAAKgB,gBAAgBE,GACjBe,EAAQtC,kBAEXsC,EAAQtC,iBAAiBK,KAAKgB,gBAAiB,WAMjDA,gBAAiB,SAAyBE,GAEzClB,KAAKkB,QAAQkB,KAAKC,MAAMrC,KAAKkB,QAASA,GAEtCoB,OAAOC,YAAYC,QAAQxC,KAAKiB,gBAAiBjB,KAAM,GAAI,CAC1DD,SAAUC,KAAKD,YAKjBkB,gBAAiB,WAChB,IAAIC,EAAUlB,KAAKkB,QACnBlB,KAAKkB,QAAU,GACfoB,OAAOG,eAAezC,KAAKC,SAASyC,QAAQ,IAAK1C,KAAKgC,YAAa,CAACd,EAASlB,KAAKgC,aAAc,KAAK,CAAC,gBAAiBd,MAIzHP,WAAWgC,cAAc9C,QAAQ4B,UAAW,CAC3CmB,gBAAiB,SAASC,EAASC,GAClC9C,KAAKC,SAAS8C,IAAI,CAACD,GAAS,SAAUD,KAEvCG,iBAAkB,SAASH,EAASC,GACnC9C,KAAKC,SAASgD,OAAO,CAACH,GAAS,SAAUD,OAI3C,YAAiBhD"}