{"version":3,"file":"chunk-ce868a5a.js","sources":["../node_modules/can-compute/proto-compute.js","../node_modules/can-compute/can-compute.js"],"sourcesContent":["\"use strict\";\n// # can/compute/proto_compute (aka can.Compute)\n//\n// Allows the creation of observablue values. This\n// is a prototype based version of [can.compute](compute.html).\n//\n// can.Computes come in different flavors:\n//\n// - [Getter / Setter functional computes](#setup-getter-setter-functional-computes).\n// - [Property computes](#setup-property-computes).\n// - [Setter computes](#setup-setter-computes).\n// - [Async computes](#setup-async-computes).\n// - [Settings computes](#setup-settings-computes).\n// - [Simple value computes](#setup-simple-value-computes).\n//\n//\n// can.Computes have public `.get`, `.set`, `.on`, and `.off` methods that call\n// internal methods that are configured differently depending on what flavor of\n// compute is being created.  Those methods are:\n//\n// - `_on(updater)` - Called the first time the compute is bound. This should bind to\n//    any source observables.  When any of the source observables have changed, it should call\n//    `updater(newVal, oldVal, batchNum)`.\n//\n// - `_off(updater)` - Called when the compute has no more event handlers.  This should unbind to any source observables.\n// - `_get` - Called to get the current value of the compute.\n// - `_set` - Called to set the value of the compute.\n//\n//\n//\n// Other internal flags and values:\n// - `value` - the cached value\n// - `_setUpdates` - if calling `_set` will have updated the cached value itself so `_get` does not need to be called.\n// - `_canObserve` - if this compute can be observed.\n// - `hasDependencies` - if this compute has source observable values.\nvar Observation = require('can-observation');\nvar ObservationRecorder = require(\"can-observation-recorder\");\nvar eventQueue = require(\"can-event-queue/map/map\");\nvar observeReader = require(\"can-stache-key\");\nvar getObject = require('can-key/get/get');\n\nvar assign = require(\"can-assign\");\nvar canReflect = require(\"can-reflect\");\nvar singleReference = require(\"can-single-reference\");\n\n// ## can.Compute\n// Checks the arguments and calls different setup methods.\nvar Compute = function(getterSetter, context, eventName, bindOnce) {\n\tvar args = [];\n\n\tfor(var i = 0, arglen = arguments.length; i < arglen; i++) {\n\t\targs[i] = arguments[i];\n\t}\n\n\tvar contextType = typeof args[1];\n\n\tif (typeof args[0] === 'function') {\n\t\t// Getter/Setter functional computes.\n\t\t// `new can.Compute(function(){ ... })`\n\t\tthis._setupGetterSetterFn(args[0], args[1], args[2], args[3]);\n\t} else if (args[1] !== undefined) {\n\t\tif (contextType === 'string' || contextType === 'number') {\n\t\t\t// Property computes.\n\t\t\t// `new can.Compute(object, propertyName[, eventName])`\n\t\t\tvar isListLike = canReflect.isObservableLike(args[0]) && canReflect.isListLike(args[0]);\n\t\t\tvar isMapLike = canReflect.isObservableLike(args[0]) && canReflect.isMapLike(args[0]);\n\t\t\tif(isMapLike || isListLike) {\n\t\t\t\tvar map = args[0];\n\t\t\t\tvar propertyName = args[1];\n\t\t\t\tvar mapGetterSetter = function(newValue){\n\t\t\t\t\tif(arguments.length) {\n\t\t\t\t\t\tobserveReader.set(map,propertyName, newValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// forces length to be read\n\t\t\t\t\t\tif(isListLike) {\n\t\t\t\t\t\t\tobserveReader.get(map,\"length\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn observeReader.get(map,\"\"+propertyName);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis._setupGetterSetterFn(mapGetterSetter, args[1], args[2], args[3]);\n\t\t\t} else {\n\t\t\t\tthis._setupProperty(args[0], args[1], args[2]);\n\t\t\t}\n\n\t\t} else if(contextType === 'function') {\n\t\t\t// Setter computes.\n\t\t\t// `new can.Compute(initialValue, function(newValue){ ... })`\n\t\t\tthis._setupSetter(args[0], args[1], args[2]);\n\t\t} else {\n\n\t\t\tif(args[1] && args[1].fn) {\n\t\t\t\t// Async computes.\n\t\t\t\tthis._setupAsyncCompute(args[0], args[1]);\n\t\t\t} else {\n\t\t\t\t// Settings computes.\n\t\t\t\t//`new can.Compute(initialValue, {on, off, get, set})`\n\t\t\t\tthis._setupSettings(args[0], args[1]);\n\t\t\t}\n\n\t\t}\n\t} else {\n\t\t// Simple value computes.\n\t\t// `new can.Compute(initialValue)`\n\t\tthis._setupSimpleValue(args[0]);\n\t}\n\n\tthis._args = args;\n\tthis._primaryDepth = 0;\n\n\tthis.isComputed = true;\n\n};\n\n// ## Helpers\n\n// ## updateOnChange\n// A helper to trigger an event when a value changes\nvar updateOnChange = function(compute, newValue, oldValue, batchNum){\n\n\tvar valueChanged = newValue !== oldValue && !(newValue !== newValue && oldValue !== oldValue);\n\t// Only trigger event when value has changed\n\tif (valueChanged) {\n\t\tcompute.dispatch({type: \"change\", batchNum: batchNum}, [\n\t\t\tnewValue,\n\t\t\toldValue\n\t\t]);\n\t}\n};\n\n// ### setupComputeHandlers\n// A helper that creates an `_on` and `_off` function that\n// will bind on source observables and update the value of the compute.\nvar setupComputeHandlers = function(compute, func, context) {\n\tvar observation = new Observation(func, context, compute);\n\tvar updater = compute.updater.bind(compute);\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tObject.defineProperty(updater,\"name\",{\n\t\t\tvalue: canReflect.getName(compute) + \".updater\",\n\t\t});\n\t}\n\t//!steal-remove-end\n\tcompute.observation = observation;\n\treturn {\n\t\t// Call `onchanged` when any source observables change.\n\t\t_on: function() {\n\t\t\tcanReflect.onValue( observation, updater,\"notify\");\n\t\t\tif (observation.hasOwnProperty(\"_value\")) {// can-observation 4.1+\n\t\t\t\tcompute.value = observation._value;\n\t\t\t} else {// can-observation < 4.1\n\t\t\t\tcompute.value = observation.value;\n\t\t\t}\n\t\t},\n\t\t// Unbind `onchanged` from all source observables.\n\t\t_off: function() {\n\t\t\tcanReflect.offValue( observation, updater,\"notify\");\n\t\t},\n\t\tgetDepth: function() {\n\t\t\treturn observation.getDepth();\n\t\t}\n\t};\n};\neventQueue(Compute.prototype);\nassign(Compute.prototype, {\n\tsetPrimaryDepth: function(depth) {\n\t\tthis._primaryDepth = depth;\n\t},\n\n\t// ## Setup getter / setter functional computes\n\t// Uses the function as both a getter and setter.\n\t_setupGetterSetterFn: function(getterSetter, context, eventName) {\n\t\tthis._set = context ? getterSetter.bind(context) : getterSetter;\n\t\tthis._get = context ? getterSetter.bind(context) : getterSetter;\n\t\tthis._canObserve = eventName === false ? false : true;\n\t\t// The helper provides the on and off methods that use `getValueAndBind`.\n\t\tvar handlers = setupComputeHandlers(this, getterSetter, context || this);\n\n\t\tassign(this, handlers);\n\t},\n\t// ## Setup property computes\n\t// Listen to a property changing on an object.\n\t_setupProperty: function(target, propertyName, eventName) {\n\t\tvar self = this,\n\t\t\thandler;\n\n\n\t\t// This is objects that can be bound to with can.bind.\n\t\thandler = function () {\n\t\t\tself.updater(self._get(), self.value);\n\t\t};\n\t\tthis._get = function() {\n\t\t\treturn getObject(target, propertyName);\n\t\t};\n\t\tthis._set = function(value) {\n\t\t\t// allow setting properties n levels deep, if separated with dot syntax\n\t\t\tvar properties = propertyName.split(\".\"),\n\t\t\t\tleafPropertyName = properties.pop();\n\n\t\t\tif(properties.length) {\n\t\t\t\tvar targetProperty = getObject(target, properties.join('.'));\n\t\t\t\ttargetProperty[leafPropertyName] = value;\n\t\t\t} else {\n\t\t\t\ttarget[propertyName] = value;\n\t\t\t}\n\t\t};\n\n\t\tthis._on = function(update) {\n\t\t\teventQueue.on.call(target, eventName || propertyName, handler);\n\t\t\t// Set the cached value\n\t\t\tthis.value = this._get();\n\t\t};\n\t\tthis._off = function() {\n\t\t\treturn eventQueue.off.call( target, eventName || propertyName, handler);\n\t\t};\n\t},\n\t// ## Setup Setter Computes\n\t// Only a setter function is specified.\n\t_setupSetter: function(initialValue, setter, eventName) {\n\t\tthis.value = initialValue;\n\t\tthis._set = setter;\n\t\tassign(this, eventName);\n\t},\n\t// ## Setup settings computes\n\t// Use whatever `on`, `off`, `get`, `set` the users provided\n\t// as the internal methods.\n\t_setupSettings: function(initialValue, settings) {\n\n\t\tthis.value = initialValue;\n\n\t\tthis._set = settings.set || this._set;\n\t\tthis._get = settings.get || this._get;\n\n\t\t// This allows updater to be called without any arguments.\n\t\t// selfUpdater flag can be set by things that want to call updater themselves.\n\t\tif(!settings.__selfUpdater) {\n\t\t\tvar self = this,\n\t\t\t\toldUpdater = this.updater;\n\t\t\tthis.updater = function() {\n\t\t\t\toldUpdater.call(self, self._get(), self.value);\n\t\t\t};\n\t\t}\n\n\n\t\tthis._on = settings.on ? settings.on : this._on;\n\t\tthis._off = settings.off ? settings.off : this._off;\n\t},\n\t// ## Setup async computes\n\t// This is a special, non-documented form of a compute\n\t// rhat can asynchronously update its value.\n\t_setupAsyncCompute: function(initialValue, settings){\n\t\tvar self = this;\n\t\t// This is the async getter function.  Depending on how many arguments the function takes,\n\t\t// we setup bindings differently.\n\t\tvar getter = settings.fn;\n\t\tvar bindings;\n\n\t\tthis.value = initialValue;\n\n\t\t// This compute will call update with the new value itself.\n\t\tthis._setUpdates = true;\n\n\t\t// An \"async\" compute has a `lastSetValue` that represents\n\t\t// the last value `compute.set` was called with.\n\t\t// The following creates `lastSetValue` as a can.Compute so when\n\t\t//  `lastSetValue` is changed, the `getter` can see that change\n\t\t// and automatically update itself.\n\t\tthis.lastSetValue = new Compute(initialValue);\n\n\t\t// Wires up setting this compute to set `lastSetValue`.\n\t\t// If the new value matches the last setValue, do nothing.\n\t\tthis._set = function(newVal){\n\t\t\tif(newVal === self.lastSetValue.get()) {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\treturn self.lastSetValue.set(newVal);\n\t\t};\n\n\t\t// Wire up the get to pass the lastNewValue\n\t\tthis._get = function() {\n\t\t\treturn getter.call(settings.context, self.lastSetValue.get() );\n\t\t};\n\n\t\tif(getter.length === 0) {\n\t\t\t// If it takes no arguments, it should behave just like a Getter compute.\n\t\t\tbindings = setupComputeHandlers(this, getter, settings.context);\n\t\t} else if(getter.length === 1) {\n\t\t\t// If it has a single argument, pass it the last setValue.\n\t\t\tbindings = setupComputeHandlers(this, function() {\n\t\t\t\treturn getter.call(settings.context, self.lastSetValue.get() );\n\t\t\t}, settings);\n\n\t\t} else {\n\t\t\t// If the function takes 2 arguments, the second argument is a function\n\t\t\t// that should update the value of the compute (`setValue`). To make this we need\n\t\t\t// the \"normal\" updater function because we are about to overwrite it.\n\t\t\tvar oldUpdater = this.updater,\n\t\t\t\tresolve = ObservationRecorder.ignore(function(newVal) {\n\t\t\t\t\toldUpdater.call(self, newVal, self.value);\n\t\t\t\t});\n\n\t\t\t// Because `setupComputeHandlers` calls `updater` internally with its\n\t\t\t// observation._value as `oldValue` and that might not be up to date,\n\t\t\t// we overwrite updater to always use self.value.\n\t\t\tthis.updater = function(newVal) {\n\t\t\t\toldUpdater.call(self, newVal, self.value);\n\t\t\t};\n\n\n\t\t\tbindings = setupComputeHandlers(this, function() {\n\t\t\t\t// Call getter, and get new value\n\t\t\t\tvar res = getter.call(settings.context, self.lastSetValue.get(), resolve);\n\t\t\t\t// If undefined is returned, don't update the value.\n\t\t\t\treturn res !== undefined ? res : this.value;\n\t\t\t}, this);\n\t\t}\n\n\t\tassign(this, bindings);\n\t},\n\t// ## Setup simple value computes\n\t// Uses the default `_get`, `_set` behaviors.\n\t_setupSimpleValue: function(initialValue) {\n\t\tthis.value = initialValue;\n\t},\n\t// ## _bindsetup\n\t// When a compute is first bound, call the internal `this._on` method.\n\t// `can.__notObserve` makes sure if `_on` is listening to any observables,\n\t// they will not be observed by any outer compute.\n\t_eventSetup: ObservationRecorder.ignore(function () {\n\t\tthis.bound = true;\n\t\tthis._on(this.updater);\n\t}),\n\t// ## _bindteardown\n\t// When a compute has no other bindings, call the internal `this._off` method.\n\t_eventTeardown: function () {\n\t\tthis._off(this.updater);\n\t\tthis.bound = false;\n\t},\n\n\t// ## clone\n\t// Copies this compute, but for a different context.\n\t// This is mostly used for computes on a map's prototype.\n\tclone: function(context) {\n\t\tif(context && typeof this._args[0] === 'function') {\n\t\t\tthis._args[1] = context;\n\t\t} else if(context) {\n\t\t\tthis._args[2] = context;\n\t\t}\n\n\t\treturn new Compute(this._args[0], this._args[1], this._args[2], this._args[3]);\n\t},\n\t// ## _on and _off\n\t// Default _on and _off do nothing.\n\t_on: function(){},\n\t_off: function(){},\n\t// ## get\n\t// Returns the cached value if `bound`, otherwise, returns\n\t// the _get value.\n\tget: function() {\n\t\t// If an external compute is tracking observables and\n\t\t// this compute can be listened to by \"function\" based computes ....\n\t\tvar recordingObservation = ObservationRecorder.isRecording();\n\t\tif(recordingObservation && this._canObserve !== false) {\n\n\t\t\t// ... tell the tracking compute to listen to change on this computed.\n\t\t\tObservationRecorder.add(this, 'change');\n\t\t\t// ... if we are not bound, we should bind so that\n\t\t\t// we don't have to re-read to get the value of this compute.\n\t\t\tif (!this.bound) {\n\t\t\t\tCompute.temporarilyBind(this);\n\t\t\t}\n\t\t}\n\t\t// If computed is bound, use the cached value.\n\t\tif (this.bound) {\n\t\t\t// if it has dependencies ... it should do some stuff ...\n\t\t\tif(this.observation) {\n\t\t\t\treturn this.observation.get();\n\t\t\t} else {\n\t\t\t\treturn this.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._get();\n\t\t}\n\t},\n\t// ## _get\n\t// Returns the cached value.\n\t_get: function() {\n\t\treturn this.value;\n\t},\n\t// ## set\n\t// Sets the value of the compute.\n\t// Depending on the type of the compute and what `_set` returns, it might need to call `_get` after\n\t// `_set` to get the final value.\n\tset: function(newVal) {\n\n\t\tvar old = this.value;\n\n\t\t// Setter may return the value if setter\n\t\t// is for a value maintained exclusively by this compute.\n\t\tvar setVal = this._set(newVal, old);\n\n\t\t// If the setter updated this.value, just return that.\n\t\tif(this._setUpdates) {\n\t\t\treturn this.value;\n\t\t}\n\n\t\t// If the computed function has dependencies,\n\t\t// we should call the getter.\n\t\tif (this.hasDependencies) {\n\t\t\treturn this._get();\n\t\t}\n\n\t\t// Setting may not fire a change event, in which case\n\t\t// the value must be read\n\t\tthis.updater(setVal === undefined ? this._get() : setVal, old);\n\n\t\treturn this.value;\n\t},\n\t// ## _set\n\t// Updates the cached value.\n\t_set: function(newVal) {\n\t\treturn this.value = newVal;\n\t},\n\t// ## updater\n\t// Updates the cached value and fires an event if the value has changed.\n\tupdater: function(newVal, oldVal, batchNum) {\n\t\tthis.value = newVal;\n\t\tvar observation = this.observation;\n\t\tif (observation) {\n\t\t\t// it's possible the observation doesn't actually\n\t\t\t// have any dependencies\n\t\t\tif (observation.hasOwnProperty(\"_value\")) {// can-observation 4.1+\n\t\t\t\tobservation._value = newVal;\n\t\t\t} else {// can-observation < 4.1\n\t\t\t\tobservation.value = newVal;\n\t\t\t}\n\t\t}\n\t\tupdateOnChange(this, newVal, oldVal, batchNum);\n\t},\n\t// ## toFunction\n\t// Returns a proxy form of this compute.\n\ttoFunction: function() {\n\t\treturn this._computeFn.bind( this);\n\t},\n\t_computeFn: function(newVal) {\n\t\tif(arguments.length) {\n\t\t\treturn this.set(newVal);\n\t\t}\n\n\t\treturn this.get();\n\t}\n});\n\nCompute.prototype.on = Compute.prototype.bind = Compute.prototype.addEventListener;\nCompute.prototype.off = Compute.prototype.unbind = Compute.prototype.removeEventListener;\n\nvar hasDependencies = function hasDependencies() {\n\treturn this.observation && this.observation.hasDependencies();\n};\nObject.defineProperty(Compute.prototype, \"hasDependencies\", {\n\tget: hasDependencies\n});\n\n// ### temporarilyBind\n// Binds computes for a moment to cache their value and prevent re-calculating it.\nCompute.temporarilyBind = Observation.temporarilyBind;\n\n// ### async\n// A simple helper that makes an async compute a bit easier.\nCompute.async = function(initialValue, asyncComputer, context){\n\treturn new Compute(initialValue, {\n\t\tfn: asyncComputer,\n\t\tcontext: context\n\t});\n};\n\n// ### truthy\n// Wraps a compute with another compute that only changes when\n// the wrapped compute's `truthiness` changes.\nCompute.truthy = function(compute) {\n\treturn new Compute(function() {\n\t\tvar res = compute.get();\n\t\tif(typeof res === 'function') {\n\t\t\tres = res.get();\n\t\t}\n\t\treturn !!res;\n\t});\n};\n\ncanReflect.assignSymbols(Compute.prototype, {\n\t\"can.isValueLike\": true,\n\t\"can.isMapLike\": false,\n\t\"can.isListLike\": false,\n\t\"can.setValue\": Compute.prototype.set,\n\t\"can.getValue\": Compute.prototype.get,\n\t\"can.valueHasDependencies\": hasDependencies,\n\t\"can.onValue\": function onValue(handler, queue) {\n\t\tfunction translationHandler(ev, newValue, oldValue) {\n\t\t\thandler(newValue, oldValue);\n\t\t}\n\t\tsingleReference.set(handler, this, translationHandler);\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tObject.defineProperty(translationHandler, \"name\", {\n\t\t\t\tvalue: canReflect.getName(handler) + \"::onValue\"\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\t\tthis.addEventListener(\"change\", translationHandler, queue);\n\t},\n\t\"can.offValue\": function offValue(handler, queue) {\n\t\tthis.removeEventListener(\n\t\t\t\"change\",\n\t\t\tsingleReference.getAndDelete(handler, this),\n\t\t\tqueue\n\t\t);\n\t},\n\t\"can.getValueDependencies\": function getValueDependencies() {\n\t\tvar ret;\n\n\t\tif (this.observation) {\n\t\t\tret = {\n\t\t\t\tvalueDependencies: new Set([this.observation])\n\t\t\t};\n\t\t}\n\n\t\treturn ret;\n\t}\n});\n\nmodule.exports = exports = Compute;\n","\"use strict\";\n/* jshint maxdepth:7*/\n\n// # can.compute\n//\n// `can.compute` allows the creation of observable values in different forms.\n// This module is now just a facade around [proto_compute.js](proto_compute.html).\n// `proto_compute.js` provides `can.Compute` as a constructor function where this file,\n// `compute.js` wraps an instance of a `can.Compute` with a function.\n//\n// Other files:\n// - [get_value_and_bind.js](get_value_and_bind.js) provides the low-level utility for observing functions.\n// - [read.js](read.html) provides a helper that read properties and values in an observable way.\n\n\n\nvar Compute = require('./proto-compute');\nvar namespace = require('can-namespace');\nvar singleReference = require(\"can-single-reference\");\n\nvar canReflect = require('can-reflect/reflections/get-set/get-set');\nvar canSymbol = require('can-symbol');\nvar canOnValueSymbol = canSymbol.for(\"can.onValue\"),\n\tcanOffValueSymbol = canSymbol.for(\"can.offValue\"),\n\tcanGetValue = canSymbol.for(\"can.getValue\"),\n\tcanSetValue = canSymbol.for(\"can.setValue\"),\n\tisValueLike = canSymbol.for(\"can.isValueLike\"),\n\tisMapLike = canSymbol.for(\"can.isMapLike\"),\n\tisListLike = canSymbol.for(\"can.isListLike\"),\n\tisFunctionLike = canSymbol.for(\"can.isFunctionLike\"),\n\tcanValueHasDependencies = canSymbol.for(\"can.valueHasDependencies\"),\n\tcanGetValueDependencies = canSymbol.for(\"can.getValueDependencies\");\n\n// The `can.compute` generator function.\nvar addEventListener = function(ev, handler){\n\tvar compute = this;\n\tvar translationHandler;\n\tif(handler){\n\t\ttranslationHandler = function() {\n\t\t   handler.apply(compute, arguments);\n\t   };\n\t   singleReference.set(handler, this, translationHandler);\n\t}\n\treturn compute.computeInstance.addEventListener(ev, translationHandler);\n};\n\nvar removeEventListener = function(ev, handler){\n\t\tvar args = [];\n\t\tif (typeof ev !== 'undefined') {\n\t\t\targs.push(ev);\n\t\t\tif (typeof handler !== 'undefined') {\n\t\t\t\targs.push(singleReference.getAndDelete(handler, this));\n\t\t\t}\n\t\t}\n\t\treturn this.computeInstance.removeEventListener.apply(this.computeInstance, args);\n};\nvar onValue = function(handler, queue){\n\t\treturn this.computeInstance[canOnValueSymbol](handler, queue);\n\t},\n\toffValue = function(handler, queue){\n\t\treturn this.computeInstance[canOffValueSymbol](handler, queue);\n\t},\n\tgetValue = function(){\n\t\treturn this.computeInstance.get();\n\t},\n\tsetValue = function(value){\n\t\treturn this.computeInstance.set(value);\n\t},\n\thasDependencies = function(){\n\t\treturn this.computeInstance.hasDependencies;\n\t},\n\tgetDependencies = function() {\n\t\treturn this.computeInstance[canGetValueDependencies]();\n\t};\n\n\nvar COMPUTE = function (getterSetter, context, eventName, bindOnce) {\n\n\tfunction compute(val) {\n\t\tif(arguments.length) {\n\t\t\treturn compute.computeInstance.set(val);\n\t\t}\n\n\t\treturn compute.computeInstance.get();\n\t}\n\n\t// Create an internal `can.Compute`.\n\tcompute.computeInstance = new Compute(getterSetter, context, eventName, bindOnce);\n\n\tcompute.on = compute.bind = compute.addEventListener = addEventListener;\n\tcompute.off = compute.unbind = compute.removeEventListener = removeEventListener;\n\tcompute.isComputed = compute.computeInstance.isComputed;\n\n\tcompute.clone = function(ctx) {\n\t\tif(typeof getterSetter === 'function') {\n\t\t\tcontext = ctx;\n\t\t}\n\t\treturn COMPUTE(getterSetter, context, ctx, bindOnce);\n\t};\n\n\t// forward on and off to the computeInstance as this doesn't matter\n\tcanReflect.set(compute, canOnValueSymbol, onValue);\n\tcanReflect.set(compute, canOffValueSymbol, offValue);\n\tcanReflect.set(compute, canGetValue, getValue);\n\tcanReflect.set(compute, canSetValue, setValue);\n\tcanReflect.set(compute, isValueLike, true);\n\tcanReflect.set(compute, isMapLike, false);\n\tcanReflect.set(compute, isListLike, false);\n\tcanReflect.set(compute, isFunctionLike, false);\n\tcanReflect.set(compute, canValueHasDependencies, hasDependencies);\n\tcanReflect.set(compute, canGetValueDependencies, getDependencies);\n\treturn compute;\n};\n\n// ## Helpers\n\n// ### truthy\n// Wraps a compute with another compute that only changes when\n// the wrapped compute's `truthiness` changes.\nCOMPUTE.truthy = function (compute) {\n\treturn COMPUTE(function () {\n\t\tvar res = compute();\n\t\treturn !!res;\n\t});\n};\n\n// ### async\n// A simple helper that makes an async compute a bit easier.\nCOMPUTE.async = function(initialValue, asyncComputer, context){\n\treturn COMPUTE(initialValue, {\n\t\tfn: asyncComputer,\n\t\tcontext: context\n\t});\n};\n\n// ### compatability\n// Setting methods that should not be around in 3.0.\nCOMPUTE.temporarilyBind = Compute.temporarilyBind;\n\nmodule.exports = namespace.compute = COMPUTE;\n"],"names":["Compute","getterSetter","context","eventName","bindOnce","args","i","arglen","arguments","length","contextType","this","_setupGetterSetterFn","undefined","isListLike","canReflect","isObservableLike","isMapLike","map","propertyName","newValue","observeReader","get","set","_setupProperty","_setupSetter","fn","_setupAsyncCompute","_setupSettings","_setupSimpleValue","_args","_primaryDepth","isComputed","setupComputeHandlers","compute","func","observation","Observation","updater","bind","process","env","NODE_ENV","Object","defineProperty","value","getName","_on","onValue","hasOwnProperty","_value","_off","offValue","getDepth","eventQueue","prototype","assign","setPrimaryDepth","depth","_set","_get","_canObserve","handlers","target","handler","self","getObject","properties","split","leafPropertyName","pop","join","update","on","call","off","initialValue","setter","settings","__selfUpdater","oldUpdater","bindings","getter","_setUpdates","lastSetValue","newVal","resolve","ObservationRecorder","ignore","res","_eventSetup","bound","_eventTeardown","clone","isRecording","add","temporarilyBind","old","setVal","hasDependencies","oldVal","batchNum","oldValue","dispatch","type","updateOnChange","toFunction","_computeFn","addEventListener","unbind","removeEventListener","async","asyncComputer","truthy","assignSymbols","can.isValueLike","can.isMapLike","can.isListLike","can.setValue","can.getValue","can.valueHasDependencies","can.onValue","queue","translationHandler","ev","singleReference","can.offValue","getAndDelete","can.getValueDependencies","ret","valueDependencies","Set","module","canOnValueSymbol","canSymbol","for","canOffValueSymbol","canGetValue","canSetValue","isValueLike","isFunctionLike","canValueHasDependencies","canGetValueDependencies","apply","computeInstance","push","getValue","setValue","getDependencies","COMPUTE","val","ctx","namespace"],"mappings":"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"}