{"version":3,"file":"chunk-5f1245ff.js","sources":["../node_modules/can-reflect/reflections/helpers.js","../node_modules/can-reflect/reflections/type/type.js","../node_modules/can-reflect/reflections/call/call.js","../node_modules/can-reflect/reflections/get-set/get-set.js","../node_modules/can-reflect/reflections/observe/observe.js","../node_modules/can-reflect/reflections/shape/shape.js","../node_modules/can-reflect/reflections/shape/schema/schema.js","../node_modules/can-reflect/reflections/get-name/get-name.js","../node_modules/can-reflect/types/map.js","../node_modules/can-reflect/types/set.js","../node_modules/can-reflect/can-reflect.js"],"sourcesContent":["\"use strict\";\nvar canSymbol = require(\"can-symbol\");\n\nmodule.exports = {\n\tmakeGetFirstSymbolValue: function(symbolNames){\n\t\tvar symbols = symbolNames.map(function(name){\n\t\t\treturn canSymbol.for(name);\n\t\t});\n\t\tvar length = symbols.length;\n\n\t\treturn function getFirstSymbol(obj){\n\t\t\tvar index = -1;\n\n\t\t\twhile (++index < length) {\n\t\t\t\tif(obj[symbols[index]] !== undefined) {\n\t\t\t\t\treturn obj[symbols[index]];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t},\n\t// The `in` check is from jQueryâ€™s fix for an iOS 8 64-bit JIT object length bug:\n\t// https://github.com/jquery/jquery/pull/2185\n\thasLength: function(list){\n\t\tvar type = typeof list;\n\t\tif(type === \"string\" || Array.isArray(list)) {\n\t\t\treturn true;\n\t\t}\n\t\tvar length = list && (type !== 'boolean' && type !== 'number' && \"length\" in list) && list.length;\n\n\t\t// var length = \"length\" in obj && obj.length;\n\t\treturn typeof list !== \"function\" &&\n\t\t\t( length === 0 || typeof length === \"number\" && length > 0 && ( length - 1 ) in list );\n\t}\n};\n","\"use strict\";\nvar canSymbol = require(\"can-symbol\");\nvar helpers = require(\"../helpers\");\n\nvar plainFunctionPrototypePropertyNames = Object.getOwnPropertyNames((function(){}).prototype);\nvar plainFunctionPrototypeProto = Object.getPrototypeOf( (function(){}).prototype );\n/**\n * @function can-reflect.isConstructorLike isConstructorLike\n * @parent can-reflect/type\n *\n * @description Test if a value looks like a constructor function.\n *\n * @signature `isConstructorLike(func)`\n *\n * Return `true` if `func` is a function and has a non-empty prototype, or implements\n *  [can-symbol/symbols/new `@@@@can.new`]; `false` otherwise.\n *\n * ```js\n * canReflect.isConstructorLike(function() {}); // -> false\n *\n * function Construct() {}\n * Construct.prototype = { foo: \"bar\" };\n * canReflect.isConstructorLike(Construct); // -> true\n *\n * canReflect.isConstructorLike({}); // -> false\n * !!canReflect.isConstructorLike({ [canSymbol.for(\"can.new\")]: function() {} }); // -> true\n * ```\n *\n * @param  {*}  func maybe a function\n * @return {Boolean} `true` if a constructor; `false` if otherwise.\n */\nfunction isConstructorLike(func){\n\t/* jshint unused: false */\n\t// if you can new it ... it's a constructor\n\tvar value = func[canSymbol.for(\"can.new\")];\n\tif(value !== undefined) {\n\t\treturn value;\n\t}\n\n\tif(typeof func !== \"function\") {\n\t\treturn false;\n\t}\n\t// If there are any properties on the prototype that don't match\n\t// what is normally there, assume it's a constructor\n\tvar prototype = func.prototype;\n\tif(!prototype) {\n\t\treturn false;\n\t}\n\t// Check if the prototype's proto doesn't point to what it normally would.\n\t// If it does, it means someone is messing with proto chains\n\tif( plainFunctionPrototypeProto !== Object.getPrototypeOf( prototype ) ) {\n\t\treturn true;\n\t}\n\n\tvar propertyNames = Object.getOwnPropertyNames(prototype);\n\tif(propertyNames.length === plainFunctionPrototypePropertyNames.length) {\n\t\tfor(var i = 0, len = propertyNames.length; i < len; i++) {\n\t\t\tif(propertyNames[i] !== plainFunctionPrototypePropertyNames[i]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\n/**\n * @function can-reflect.isFunctionLike isFunctionLike\n * @parent can-reflect/type\n * @description Test if a value looks like a function.\n * @signature `isFunctionLike(obj)`\n *\n *  Return `true` if `func` is a function, or implements\n *  [can-symbol/symbols/new `@@@@can.new`] or [can-symbol/symbols/apply `@@@@can.apply`]; `false` otherwise.\n *\n * ```js\n * canReflect.isFunctionLike(function() {}); // -> true\n * canReflect.isFunctionLike({}); // -> false\n * canReflect.isFunctionLike({ [canSymbol.for(\"can.apply\")]: function() {} }); // -> true\n * ```\n *\n * @param  {*}  obj maybe a function\n * @return {Boolean}\n */\nvar getNewOrApply = helpers.makeGetFirstSymbolValue([\"can.new\",\"can.apply\"]);\nfunction isFunctionLike(obj){\n\tvar result,\n\t\tsymbolValue = !!obj && obj[canSymbol.for(\"can.isFunctionLike\")];\n\n\tif (symbolValue !== undefined) {\n\t\treturn symbolValue;\n\t}\n\n\tresult = getNewOrApply(obj);\n\tif(result !== undefined) {\n\t\treturn !!result;\n\t}\n\n\treturn typeof obj === \"function\";\n}\n\n/**\n * @function can-reflect.isPrimitive isPrimitive\n * @parent can-reflect/type\n * @description Test if a value is a JavaScript primitive.\n * @signature `isPrimitive(obj)`\n *\n * Return `true` if `obj` is not a function nor an object via `typeof`, or is null; `false` otherwise.\n *\n * ```js\n * canReflect.isPrimitive(null); // -> true\n * canReflect.isPrimitive({}); // -> false\n * canReflect.isPrimitive(undefined); // -> true\n * canReflect.isPrimitive(1); // -> true\n * canReflect.isPrimitive([]); // -> false\n * canReflect.isPrimitive(function() {}); // -> false\n * canReflect.isPrimitive(\"foo\"); // -> true\n *\n * ```\n *\n * @param  {*}  obj maybe a primitive value\n * @return {Boolean}\n */\nfunction isPrimitive(obj){\n\tvar type = typeof obj;\n\tif(obj == null || (type !== \"function\" && type !== \"object\") ) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nvar coreHasOwn = Object.prototype.hasOwnProperty;\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(obj) {\n\t// Must be an Object.\n\t// Because of IE, we also have to check the presence of the constructor property.\n\t// Make sure that DOM nodes and window objects don't pass through, as well\n\tif (!obj || typeof obj !== 'object' ) {\n\t\treturn false;\n\t}\n\tvar proto = Object.getPrototypeOf(obj);\n\tif(proto === Object.prototype || proto === null) {\n\t\treturn true;\n\t}\n\t// partially inspired by lodash: https://github.com/lodash/lodash\n\tvar Constructor = coreHasOwn.call(proto, 'constructor') && proto.constructor;\n\treturn typeof Constructor === 'function' && Constructor instanceof Constructor &&\n    \tfuncToString.call(Constructor) === objectCtorString;\n}\n\n/**\n * @function can-reflect.isBuiltIn isBuiltIn\n * @parent can-reflect/type\n * @description Test if a value is a JavaScript built-in type.\n * @signature `isBuiltIn(obj)`\n *\n * Return `true` if `obj` is some type of JavaScript native built-in; `false` otherwise.\n *\n * ```js\n * canReflect.isBuiltIn(null); // -> true\n * canReflect.isBuiltIn({}); // -> true\n * canReflect.isBuiltIn(1); // -> true\n * canReflect.isBuiltIn([]); // -> true\n * canReflect.isBuiltIn(function() {}); // -> true\n * canReflect.isBuiltIn(\"foo\"); // -> true\n * canReflect.isBuiltIn(new Date()); // -> true\n * canReflect.isBuiltIn(/[foo].[bar]/); // -> true\n * canReflect.isBuiltIn(new DefineMap); // -> false\n *\n * ```\n *\n * Not supported in browsers that have implementations of Map/Set where\n * `toString` is not properly implemented to return `[object Map]`/`[object Set]`.\n *\n * @param  {*}  obj maybe a built-in value\n * @return {Boolean}\n */\nfunction isBuiltIn(obj) {\n\n\t// If primitive, array, or POJO return true. Also check if\n\t// it is not a POJO but is some type like [object Date] or\n\t// [object Regex] and return true.\n\tif (isPrimitive(obj) ||\n\t\tArray.isArray(obj) ||\n\t\tisPlainObject(obj) ||\n\t\t(Object.prototype.toString.call(obj) !== '[object Object]' &&\n\t\t\tObject.prototype.toString.call(obj).indexOf('[object ') !== -1)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\n/**\n * @function can-reflect.isValueLike isValueLike\n * @parent can-reflect/type\n * @description Test if a value represents a single value (as opposed to several values).\n *\n * @signature `isValueLike(obj)`\n *\n * Return `true` if `obj` is a primitive or implements [can-symbol/symbols/getValue `@@can.getValue`],\n * `false` otherwise.\n *\n * ```js\n * canReflect.isValueLike(null); // -> true\n * canReflect.isValueLike({}); // -> false\n * canReflect.isValueLike(function() {}); // -> false\n * canReflect.isValueLike({ [canSymbol.for(\"can.isValueLike\")]: true}); // -> true\n * canReflect.isValueLike({ [canSymbol.for(\"can.getValue\")]: function() {} }); // -> true\n * canReflect.isValueLike(canCompute()); // -> true\n * canReflect.isValueLike(new DefineMap()); // -> false\n *\n * ```\n *\n * @param  {*}  obj maybe a primitive or an object that yields a value\n * @return {Boolean}\n */\nfunction isValueLike(obj) {\n\tvar symbolValue;\n\tif(isPrimitive(obj)) {\n\t\treturn true;\n\t}\n\tsymbolValue = obj[canSymbol.for(\"can.isValueLike\")];\n\tif( typeof symbolValue !== \"undefined\") {\n\t\treturn symbolValue;\n\t}\n\tvar value = obj[canSymbol.for(\"can.getValue\")];\n\tif(value !== undefined) {\n\t\treturn !!value;\n\t}\n}\n\n/**\n * @function can-reflect.isMapLike isMapLike\n * @parent can-reflect/type\n *\n * @description Test if a value represents multiple values.\n *\n * @signature `isMapLike(obj)`\n *\n * Return `true` if `obj` is _not_ a primitive, does _not_ have a falsy value for\n * [can-symbol/symbols/isMapLike `@@@@can.isMapLike`], or alternately implements\n * [can-symbol/symbols/getKeyValue `@@@@can.getKeyValue`]; `false` otherwise.\n *\n * ```js\n * canReflect.isMapLike(null); // -> false\n * canReflect.isMapLike(1); // -> false\n * canReflect.isMapLike(\"foo\"); // -> false\n * canReflect.isMapLike({}); // -> true\n * canReflect.isMapLike(function() {}); // -> true\n * canReflect.isMapLike([]); // -> false\n * canReflect.isMapLike({ [canSymbol.for(\"can.isMapLike\")]: false }); // -> false\n * canReflect.isMapLike({ [canSymbol.for(\"can.getKeyValue\")]: null }); // -> false\n * canReflect.isMapLike(canCompute()); // -> false\n * canReflect.isMapLike(new DefineMap()); // -> true\n *\n * ```\n *\n * @param  {*}  obj maybe a Map-like\n * @return {Boolean}\n */\nfunction isMapLike(obj) {\n\tif(isPrimitive(obj)) {\n\t\treturn false;\n\t}\n\tvar isMapLike = obj[canSymbol.for(\"can.isMapLike\")];\n\tif(typeof isMapLike !== \"undefined\") {\n\t\treturn !!isMapLike;\n\t}\n\tvar value = obj[canSymbol.for(\"can.getKeyValue\")];\n\tif(value !== undefined) {\n\t\treturn !!value;\n\t}\n\t// everything else in JS is MapLike\n\treturn true;\n}\n\n/**\n * @function can-reflect.isObservableLike isObservableLike\n * @parent can-reflect/type\n * @description Test if a value (or its keys) can be observed for changes.\n *\n * @signature `isObservableLike(obj)`\n *\n * Return  `true` if `obj` is _not_ a primitive and implements any of\n * [can-symbol/symbols/onValue `@@@@can.onValue`], [can-symbol/symbols/onKeyValue `@@@@can.onKeyValue`], or\n * [can-symbol/symbols/onPatches `@@@@can.onKeys`]; `false` otherwise.\n *\n * ```js\n * canReflect.isObservableLike(null); // -> false\n * canReflect.isObservableLike({}); // -> false\n * canReflect.isObservableLike([]); // -> false\n * canReflect.isObservableLike(function() {}); // -> false\n * canReflect.isObservableLike({ [canSymbol.for(\"can.onValue\")]: function() {} }); // -> true\n * canReflect.isObservableLike({ [canSymbol.for(\"can.onKeyValue\")]: function() {} }); // -> true\n * canReflect.isObservableLike(canCompute())); // -> true\n * canReflect.isObservableLike(new DefineMap())); // -> true\n * ```\n *\n * @param  {*}  obj maybe an observable\n * @return {Boolean}\n */\n\n// Specially optimized\nvar onValueSymbol = canSymbol.for(\"can.onValue\"),\n\tonKeyValueSymbol = canSymbol.for(\"can.onKeyValue\"),\n\tonPatchesSymbol = canSymbol.for(\"can.onPatches\");\nfunction isObservableLike( obj ) {\n\tif(isPrimitive(obj)) {\n\t\treturn false;\n\t}\n\treturn Boolean(obj[onValueSymbol] || obj[onKeyValueSymbol] || obj[onPatchesSymbol]);\n}\n\n/**\n * @function can-reflect.isListLike isListLike\n * @parent can-reflect/type\n *\n * @description Test if a value looks like a constructor function.\n *\n * @signature `isListLike(list)`\n *\n * Return `true` if `list` is a `String`, <br>OR `list` is _not_ a primitive and implements `@@@@iterator`,\n * <br>OR `list` is _not_ a primitive and returns `true` for `Array.isArray()`, <br>OR `list` is _not_ a primitive and has a\n * numerical length and is either empty (`length === 0`) or has a last element at index `length - 1`; <br>`false` otherwise\n *\n * ```js\n * canReflect.isListLike(null); // -> false\n * canReflect.isListLike({}); // -> false\n * canReflect.isListLike([]); // -> true\n * canReflect.isListLike(\"foo\"); // -> true\n * canReflect.isListLike(1); // -> false\n * canReflect.isListLike({ [canSymbol.for(\"can.isListLike\")]: true }); // -> true\n * canReflect.isListLike({ [canSymbol.iterator]: function() {} }); // -> true\n * canReflect.isListLike({ length: 0 }); // -> true\n * canReflect.isListLike({ length: 3 }); // -> false\n * canReflect.isListLike({ length: 3, \"2\": true }); // -> true\n * canReflect.isListLike(new DefineMap()); // -> false\n * canReflect.isListLike(new DefineList()); // -> true\n * ```\n *\n * @param  {*}  list maybe a List-like\n * @return {Boolean}\n */\nfunction isListLike( list ) {\n\tvar symbolValue,\n\t\ttype = typeof list;\n\tif(type === \"string\") {\n\t\treturn true;\n\t}\n\tif( isPrimitive(list) ) {\n\t\treturn false;\n\t}\n\tsymbolValue = list[canSymbol.for(\"can.isListLike\")];\n\tif( typeof symbolValue !== \"undefined\") {\n\t\treturn symbolValue;\n\t}\n\tvar value = list[canSymbol.iterator];\n\tif(value !== undefined) {\n\t\treturn !!value;\n\t}\n\tif(Array.isArray(list)) {\n\t\treturn true;\n\t}\n\treturn helpers.hasLength(list);\n}\n\n/**\n * @function can-reflect.isSymbolLike isSymbolLike\n * @parent can-reflect/type\n *\n * @description Test if a value is a symbol or a [can-symbol].\n *\n * @signature `isSymbolLike(symbol)`\n *\n * Return `true` if `symbol` is a native Symbol, or evaluates to a String with a prefix\n * equal to that of CanJS's symbol polyfill; `false` otherwise.\n *\n * ```js\n * /* ES6 *\\/ canReflect.isSymbolLike(Symbol.iterator); // -> true\n * canReflect.isSymbolLike(canSymbol.for(\"foo\")); // -> true\n * canReflect.isSymbolLike(\"@@symbol.can.isSymbol\"); // -> true (due to polyfill for non-ES6)\n * canReflect.isSymbolLike(\"foo\"); // -> false\n * canReflect.isSymbolLike(null); // -> false\n * canReflect.isSymbolLike(1); // -> false\n * canReflect.isSymbolLike({}); // -> false\n * canReflect.isSymbolLike({ toString: function() { return \"@@symbol.can.isSymbol\"; } }); // -> true\n * ```\n *\n * @param  {*}  symbol maybe a symbol\n * @return {Boolean}\n */\n\nvar supportsSymbols = typeof Symbol !== \"undefined\" && typeof Symbol.for === \"function\";\nvar isSymbolLike;\nif(supportsSymbols) {\n\tisSymbolLike = function(symbol) {\n\t\treturn typeof symbol === \"symbol\";\n\t};\n} else {\n\tvar symbolStart = \"@@symbol\";\n\tisSymbolLike = function(symbol) {\n\t\tif(typeof symbol === \"object\" && !Array.isArray(symbol)){\n\t\t\treturn symbol.toString().substr(0, symbolStart.length) === symbolStart;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n}\n\nmodule.exports = {\n\tisConstructorLike: isConstructorLike,\n\tisFunctionLike: isFunctionLike,\n\tisListLike: isListLike,\n\tisMapLike: isMapLike,\n\tisObservableLike: isObservableLike,\n\tisPrimitive: isPrimitive,\n\tisBuiltIn: isBuiltIn,\n\tisValueLike: isValueLike,\n\tisSymbolLike: isSymbolLike,\n\t/**\n\t * @function can-reflect.isMoreListLikeThanMapLike isMoreListLikeThanMapLike\n\t * @parent can-reflect/type\n\t *\n\t * @description Test if a value should be treated as a list instead of a map.\n\t *\n\t * @signature `isMoreListLikeThanMapLike(obj)`\n\t *\n\t * Return  `true` if `obj` is an Array, declares itself to be more ListLike with\n\t * `@@@@can.isMoreListLikeThanMapLike`, or self-reports as ListLike but not as MapLike; `false` otherwise.\n\t *\n\t * ```js\n\t * canReflect.isMoreListLikeThanMapLike([]); // -> true\n\t * canReflect.isMoreListLikeThanMapLike(null); // -> false\n\t * canReflect.isMoreListLikeThanMapLike({}); // -> false\n\t * canReflect.isMoreListLikeThanMapLike(new DefineList()); // -> true\n\t * canReflect.isMoreListLikeThanMapLike(new DefineMap()); // -> false\n\t * canReflect.isMoreListLikeThanMapLike(function() {}); // -> false\n\t * ```\n\t *\n\t * @param  {Object}  obj the object to test for ListLike against MapLike traits.\n\t * @return {Boolean}\n\t */\n\tisMoreListLikeThanMapLike: function(obj){\n\t\tif(Array.isArray(obj)) {\n\t\t\treturn true;\n\t\t}\n\t\tif(obj instanceof Array) {\n\t\t\treturn true;\n\t\t}\n\t\tif( obj == null ) {\n\t\t\treturn false;\n\t\t}\n\t\tvar value = obj[canSymbol.for(\"can.isMoreListLikeThanMapLike\")];\n\t\tif(value !== undefined) {\n\t\t\treturn value;\n\t\t}\n\t\tvar isListLike = this.isListLike(obj),\n\t\t\tisMapLike = this.isMapLike(obj);\n\t\tif(isListLike && !isMapLike) {\n\t\t\treturn true;\n\t\t} else if(!isListLike && isMapLike) {\n\t\t\treturn false;\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.isIteratorLike isIteratorLike\n\t * @parent can-reflect/type\n\t * @description Test if a value looks like an iterator.\n\t * @signature `isIteratorLike(obj)`\n\t *\n\t * Return `true` if `obj` has a key `\"next\"` pointing to a zero-argument function; `false` otherwise\n\t *\n\t * ```js\n\t * canReflect.isIteratorLike([][Symbol.iterator]()); // -> true\n\t * canReflect.isIteratorLike(new DefineList()[canSymbol.iterator]()); // -> true\n\t * canReflect.isIteratorLike(new DefineMap()[canSymbol.iterator]()); // -> true\n\t * canReflect.isIteratorLike(null); // -> false\n\t * canReflect.isIteratorLike({ next: function() {} }); // -> true\n\t * canReflect.isIteratorLike({ next: function(foo) {} }); // -> false (iterator nexts do not take arguments)\n\t * ```\n\t *\n\t * @param  {Object}  obj the object to test for Iterator traits\n\t * @return {Boolean}\n\t */\n\tisIteratorLike: function(obj){\n\t\treturn obj &&\n\t\t\ttypeof obj === \"object\" &&\n\t\t\ttypeof obj.next === \"function\" &&\n\t\t\tobj.next.length === 0;\n\t},\n\t/**\n\t * @function can-reflect.isPromise isPromise\n\t * @parent can-reflect/type\n\t * @description Test if a value is a promise.\n\t *\n\t * @signature `isPromise(obj)`\n\t *\n\t * Return `true` if `obj` is an instance of promise or `.toString` returns `\"[object Promise]\"`.\n\t *\n\t * ```js\n\t * canReflect.isPromise(Promise.resolve()); // -> true\n\t * ```\n\t *\n\t * @param  {*}  obj the object to test for Promise traits.\n\t * @return {Boolean}\n\t */\n\tisPromise: function(obj){\n\t\treturn (obj instanceof Promise || (Object.prototype.toString.call(obj) === '[object Promise]'));\n\t},\n\t/**\n\t * @function can-reflect.isPlainObject isPlainObject\n\t * @parent can-reflect/type\n\t * @description Test if a value is an object created with `{}` or `new Object()`.\n\t *\n\t * @signature `isPlainObject(obj)`\n\t *\n\t * Attempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`. The following are not plain objects:\n\t *\n\t * 1. Objects with prototypes (created using the `new` keyword).\n\t * 2. Booleans.\n\t * 3. Numbers.\n\t * 4. NaN.\n\t *\n\t * ```js\n\t * var isPlainObject = require(\"can-reflect\").isPlainObject;\n\t *\n\t * // Created with {}\n\t * console.log(isPlainObject({})); // -> true\n\t *\n\t * // new Object\n\t * console.log(isPlainObject(new Object())); // -> true\n\t *\n\t * // Custom object\n\t * var Ctr = function(){};\n\t * var obj = new Ctr();\n\t *\n\t * console.log(isPlainObject(obj)); // -> false\n\t * ```\n\t *\n\t * @param  {Object}  obj the object to test.\n\t * @return {Boolean}\n\t */\n\tisPlainObject: isPlainObject\n};\n","\"use strict\";\nvar canSymbol = require(\"can-symbol\");\nvar typeReflections = require(\"../type/type\");\n\nmodule.exports = {\n\t/**\n\t * @function {function(...), Object, ...} can-reflect/call.call call\n\t * @parent can-reflect/call\n\t * @description  Call a callable, with a context object and parameters\n\t *\n\t * @signature `call(func, context, ...rest)`\n\t *\n\t * Call the callable `func` as if it were a function, bound to `context` and with any additional parameters\n\t * occurring after `context` set to the positional parameters.\n\t *\n\t * Note that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@@@can.apply],\n\t * or have a callable `apply` property to work with `canReflect.call`\n\t *\n\t * ```js\n\t * var compute = canCompute(\"foo\");\n\t *\n\t * canReflect.call(compute, null, \"bar\");\n\t * canReflect.call(compute, null); // -> \"bar\"\n\t * ```\n\t *\n\t * @param  {function(...)} func the function to call with the supplied arguments\n\t * @param  {Object} context the context object to set as `this` on the function call\n\t * @param  {*} rest any arguments after `context` will be passed to the function call\n\t * @return {*}  return types and values are determined by the call to `func`\n\t */\n\tcall: function(func, context){\n\t\tvar args = [].slice.call(arguments, 2);\n\t\tvar apply = func[canSymbol.for(\"can.apply\")];\n\t\tif(apply) {\n\t\t\treturn apply.call(func, context, args);\n\t\t} else {\n\t\t\treturn func.apply(context, args);\n\t\t}\n\t},\n\t/**\n\t * @function {function(...), Object, ...} can-reflect/call.apply apply\n\t * @parent can-reflect/call\n\t * @description  Call a callable, with a context object and a list of parameters\n\t *\n\t * @signature `apply(func, context, args)`\n\t *\n\t * Call the callable `func` as if it were a function, bound to `context` and with any additional parameters\n\t * contained in the Array-like `args`\n\t *\n\t * Note that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@@@can.apply],\n\t * or have a callable `apply` property to work with `canReflect.apply`\n\t *\n\t * ```js\n\t * var compute = canCompute(\"foo\");\n\t *\n\t * canReflect.apply(compute, null, [\"bar\"]);\n\t * canReflect.apply(compute, null, []); // -> \"bar\"\n\t * ```\n\t *\n\t * @param  {function(...)} func the function to call\n\t * @param  {Object} context the context object to set as `this` on the function call\n\t * @param  {*} args arguments to be passed to the function call\n\t * @return {*}  return types and values are determined by the call to `func`\n\t */\n\tapply: function(func, context, args){\n\t\tvar apply = func[canSymbol.for(\"can.apply\")];\n\t\tif(apply) {\n\t\t\treturn apply.call(func, context, args);\n\t\t} else {\n\t\t\treturn func.apply(context, args);\n\t\t}\n\t},\n\t/**\n\t * @function {function(...), ...} can-reflect/call.new new\n\t * @parent can-reflect/call\n\t * @description  Construct a new instance of a callable constructor\n\t *\n\t * @signature `new(func, ...rest)`\n\t *\n\t * Call the callable `func` as if it were a function, bound to a new instance of `func`, and with any additional\n\t * parameters occurring after `func` set to the positional parameters.\n\t *\n\t * Note that `func` *must* either implement [can-symbol/symbols/new @@@@can.new],\n\t * or have a callable `apply` property *and* a prototype to work with `canReflect.new`\n\t *\n\t * ```js\n\t * canReflect.new(DefineList, [\"foo\"]); // -> [\"foo\"]<DefineList>\n\t * ```\n\t *\n\t * @param  {function(...)} func a constructor\n\t * @param  {*} rest arguments to be passed to the constructor\n\t * @return {Object}  if `func` returns an Object, that returned Object; otherwise a new instance of `func`\n\t */\n\t\"new\": function(func){\n\t\tvar args = [].slice.call(arguments, 1);\n\t\tvar makeNew = func[canSymbol.for(\"can.new\")];\n\t\tif(makeNew) {\n\t\t\treturn makeNew.apply(func, args);\n\t\t} else {\n\t\t\tvar context = Object.create(func.prototype);\n\t\t\tvar ret = func.apply(context, args);\n\t\t\tif(typeReflections.isPrimitive(ret)) {\n\t\t\t\treturn context;\n\t\t\t} else {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n};\n","\"use strict\";\nvar canSymbol = require(\"can-symbol\");\nvar typeReflections = require(\"../type/type\");\n\nvar setKeyValueSymbol = canSymbol.for(\"can.setKeyValue\"),\n\tgetKeyValueSymbol = canSymbol.for(\"can.getKeyValue\"),\n\tgetValueSymbol = canSymbol.for(\"can.getValue\"),\n\tsetValueSymbol = canSymbol.for(\"can.setValue\");\n\nvar reflections = {\n\t/**\n\t * @function {Object, String, *} can-reflect.setKeyValue setKeyValue\n\t * @parent can-reflect/get-set\n\t * @description Set the value of a named property on a MapLike object.\n\t *\n\t * @signature `setKeyValue(obj, key, value)`\n\t *\n\t * Set the property on Map-like `obj`, identified by the String, Symbol or Object value `key`, to the value `value`.\n\t * The default behavior can be overridden on `obj` by implementing [can-symbol/symbols/setKeyValue @@@@can.setKeyValue],\n\t * otherwise native named property access is used for string keys, and `Object.defineProperty` is used to set symbols.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * canReflect.setKeyValue(foo, \"bar\", \"quux\");\n\t * foo[bar]; // -> \"quux\"\n\t * ```\n\t * @param  {Object} obj   the object to set on\n\t * @param  {String} key   the key for the property to set\n\t * @param  {*} value      the value to set on the object\n\t */\n\tsetKeyValue: function(obj, key, value){\n\t\tif( typeReflections.isSymbolLike(key) ) {\n\t\t\tif(typeof key === \"symbol\") {\n\t\t\t\tobj[key] = value;\n\t\t\t} else {\n\t\t\t\tObject.defineProperty(obj, key, {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\twritable: true\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tvar setKeyValue = obj[setKeyValueSymbol];\n\t\tif(setKeyValue !== undefined) {\n\t\t\treturn setKeyValue.call(obj, key, value);\n\t\t} else {\n\t\t\tobj[key] = value;\n\t\t}\n\t},\n\t/**\n\t * @function {Object, String} can-reflect.getKeyValue getKeyValue\n\t * @parent can-reflect/get-set\n\t * @description Get the value of a named property on a MapLike object.\n\t *\n\t * @signature `getKeyValue(obj, key)`\n\t *\n\t * Retrieve the property on Map-like `obj` identified by the String or Symbol value `key`.  The default behavior\n\t * can be overridden on `obj` by implementing [can-symbol/symbols/getKeyValue @@@@can.getKeyValue],\n\t * otherwise native named property access is used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * canReflect.getKeyValue(foo, \"bar\"); // -> \"baz\"\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to get from\n\t * @param  {String} key   the key of the property to get\n\t */\n\tgetKeyValue: function(obj, key) {\n\t\tvar getKeyValue = obj[getKeyValueSymbol];\n\t\tif(getKeyValue) {\n\t\t\treturn getKeyValue.call(obj, key);\n\t\t}\n\t\treturn obj[key];\n\t},\n\t/**\n\t * @function {Object, String} can-reflect.deleteKeyValue deleteKeyValue\n\t * @parent can-reflect/get-set\n\t * @description Delete a named property from a MapLike object.\n\t *\n\t * @signature `deleteKeyValue(obj, key)`\n\t *\n\t * Remove the property identified by the String or Symbol `key` from the Map-like object `obj`, if possible.\n\t * Property definitions may interfere with deleting key values; the behavior on `obj` if `obj[key]` cannot\n\t * be deleted is undefined.  The default use of the native `delete` keyword can be overridden by `obj` if it\n\t * implements [can-symbol/symbols/deleteKeyValue @@@@can.deleteKeyValue].\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t * var quux = new CanMap({ thud: \"jeek\" });\n\t *\n\t * canReflect.deleteKeyValue(foo, \"bar\");\n\t * canReflect.deleteKeyValue(quux, \"thud\");\n\t *\n\t * \"bar\" in foo; // ->  true  -- DefineMaps use property defs which cannot be un-defined\n\t * foo.bar // -> undefined    --  but set values to undefined when deleting\n\t *\n\t * \"thud\" in quux; // -> false\n\t * quux.thud; // -> undefined\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to delete on\n\t * @param  {String} key   the key for the property to delete\n\t */\n\tdeleteKeyValue: function(obj, key) {\n\t\tvar deleteKeyValue = obj[canSymbol.for(\"can.deleteKeyValue\")];\n\t\tif(deleteKeyValue) {\n\t\t\treturn deleteKeyValue.call(obj, key);\n\t\t}\n\t\tdelete obj[key];\n\t},\n\t/**\n\t * @function {Object} can-reflect.getValue getValue\n\t * @parent can-reflect/get-set\n\t * @description Get the value of an object with a gettable value\n\t *\n\t * @signature `getValue(obj)`\n\t *\n\t * Return the value of the Value-like object `obj`.  Unless `obj` implements\n\t * [can-symbol/symbols/getValue @@@@can.getValue], the result of `getValue` on\n\t * `obj` will always be `obj`.  Observable Map-like objects may want to implement\n\t * `@@@@can.getValue` to return non-observable or plain representations of themselves.\n\t *\n\t * ```js\n\t * var compute = canCompute(\"foo\");\n\t * var primitive = \"bar\";\n\t *\n\t * canReflect.getValue(compute); // -> \"foo\"\n\t * canReflect.getValue(primitive); // -> \"bar\"\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to get from\n\t * @return {*} the value of the object via `@@can.getValue`, or the value itself.\n\t */\n\tgetValue: function(value){\n\t\tif(typeReflections.isPrimitive(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tvar getValue = value[getValueSymbol];\n\t\tif(getValue) {\n\t\t\treturn getValue.call(value);\n\t\t}\n\t\treturn value;\n\t},\n\t/**\n\t * @function {Object, *} can-reflect.setValue setValue\n\t * @parent can-reflect/get-set\n\t * @description Set the value of a mutable object.\n\t *\n\t * @signature `setValue(obj, value)`\n\t *\n\t * Set the value of a Value-like object `obj` to the value `value`.  `obj` *must* implement\n\t * [can-symbol/symbols/setValue @@@@can.setValue] to be used with `canReflect.setValue`.\n\t * Map-like objects may want to implement `@@@@can.setValue` to merge objects of properties\n\t * into themselves.\n\t *\n\t * ```js\n\t * var compute = canCompute(\"foo\");\n\t * var plain = {};\n\t *\n\t * canReflect.setValue(compute, \"bar\");\n\t * compute(); // -> bar\n\t *\n\t * canReflect.setValue(plain, { quux: \"thud\" }); // throws \"can-reflect.setValue - Can not set value.\"\n\t * ```\n\t *\n\t * @param  {Object} obj   the object to set on\n\t * @param  {*} value      the value to set for the object\n\t */\n\tsetValue: function(item, value){\n\t\tvar setValue = item && item[setValueSymbol];\n\t\tif(setValue) {\n\t\t\treturn setValue.call(item, value);\n\t\t} else {\n\t\t\tthrow new Error(\"can-reflect.setValue - Can not set value.\");\n\t\t}\n\t},\n\n\tsplice: function(obj, index, removing, adding){\n\t\tvar howMany;\n\t\tif(typeof removing !== \"number\") {\n\t\t\tvar updateValues = obj[canSymbol.for(\"can.updateValues\")];\n\t\t\tif(updateValues) {\n\t\t\t\treturn updateValues.call(obj, index, removing, adding);\n\t\t\t}\n\t\t\thowMany = removing.length;\n\t\t} else {\n\t\t\thowMany = removing;\n\t\t}\n\n\t\tif(arguments.length <= 3){\n\t\t\tadding = [];\n\t\t}\n\n\t\tvar splice = obj[canSymbol.for(\"can.splice\")];\n\t\tif(splice) {\n\t\t\treturn splice.call(obj, index, howMany, adding);\n\t\t}\n\t\treturn [].splice.apply(obj, [index, howMany].concat(adding) );\n\t},\n\taddValues: function(obj, adding, index) {\n\t\tvar add = obj[canSymbol.for(\"can.addValues\")];\n\t\tif(add) {\n\t\t\treturn add.call(obj, adding, index);\n\t\t}\n\t\tif(Array.isArray(obj) && index === undefined) {\n\t\t\treturn obj.push.apply(obj, adding);\n\t\t}\n\t\treturn reflections.splice(obj, index, [], adding);\n\t},\n\tremoveValues: function(obj, removing, index) {\n\t\tvar removeValues = obj[canSymbol.for(\"can.removeValues\")];\n\t\tif(removeValues) {\n\t\t\treturn removeValues.call(obj, removing, index);\n\t\t}\n\t\tif(Array.isArray(obj) && index === undefined) {\n\t\t\tremoving.forEach(function(item){\n\t\t\t\tvar index = obj.indexOf(item);\n\t\t\t\tif(index >=0) {\n\t\t\t\t\tobj.splice(index, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\treturn reflections.splice(obj, index, removing, []);\n\t}\n};\n/**\n * @function {Object, String} can-reflect.get get\n * @hide\n * @description an alias for [can-reflect.getKeyValue getKeyValue]\n */\nreflections.get = reflections.getKeyValue;\n/**\n * @function {Object, String} can-reflect.set set\n * @hide\n * @description an alias for [can-reflect.setKeyValue setKeyValue]\n */\nreflections.set = reflections.setKeyValue;\n/**\n * @function {Object, String} can-reflect.delete delete\n * @hide\n * @description an alias for [can-reflect.deleteKeyValue deleteKeyValue]\n */\nreflections[\"delete\"] = reflections.deleteKeyValue;\n\nmodule.exports = reflections;\n","\"use strict\";\nvar canSymbol = require(\"can-symbol\");\n\nvar slice = [].slice;\n\nfunction makeFallback(symbolName, fallbackName) {\n\treturn function(obj, event, handler, queueName){\n\t\tvar method = obj[canSymbol.for(symbolName)];\n\t\tif(method !== undefined) {\n\t\t\treturn method.call(obj, event, handler, queueName);\n\t\t}\n\t\treturn this[fallbackName].apply(this, arguments);\n\t};\n}\n\nfunction makeErrorIfMissing(symbolName, errorMessage){\n\treturn function(obj){\n\t\tvar method = obj[canSymbol.for(symbolName)];\n\t\tif(method !== undefined) {\n\t\t\tvar args = slice.call(arguments, 1);\n\t\t\treturn method.apply(obj, args);\n\t\t}\n\t\tthrow new Error(errorMessage);\n\t};\n}\n\nmodule.exports = {\n\t// KEY\n\t/**\n\t * @function {Object, String, function(*, *), String} can-reflect/observe.onKeyValue onKeyValue\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, based on a key change\n\t *\n\t * @signature `onKeyValue(obj, key, handler, [queueName])`\n\t *\n\t * Register a handler on the Map-like object `obj` to trigger when the property key `key` changes.\n\t * `obj` *must* implement [can-symbol/symbols/onKeyValue @@@@can.onKeyValue] to be compatible with\n\t * can-reflect.onKeyValue.  The function passed as `handler` will receive the new value of the property\n\t * as the first argument, and the previous value of the property as the second argument.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onKeyValue(obj, \"foo\", function(newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * });\n\t *\n\t * obj.foo = \"baz\";  // -> logs \"foo is now baz , was bar\"\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {String} key  the key to listen to\n\t * @param {function(*, *)} handler a callback function that recieves the new value\n\t * @param {String} [queueName]  the queue to dispatch events to\n\t */\n\tonKeyValue: makeFallback(\"can.onKeyValue\", \"onEvent\"),\n\t/**\n\t * @function {Object, String, function(*), String} can-reflect/observe.offKeyValue offKeyValue\n\t * @parent can-reflect/observe\n\t * @description  Unregister an event handler on a MapLike object, based on a key change\n\t *\n\t * @signature `offKeyValue(obj, key, handler, [queueName])`\n\t *\n\t * Unregister a handler from the Map-like object `obj` that had previously been registered with\n\t * [can-reflect/observe.onKeyValue onKeyValue]. The function passed as `handler` will no longer be called\n\t * when the value of `key` on `obj` changes.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * var handler = function(newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * };\n\t *\n\t * canReflect.onKeyValue(obj, \"foo\", handler);\n\t * canReflect.offKeyValue(obj, \"foo\", handler);\n\t *\n\t * obj.foo = \"baz\";  // -> nothing is logged\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {String} key  the key to stop listening to\n\t * @param {function(*)} handler the callback function that should be removed from the event handlers for `key`\n\t * @param {String} [queueName]  the queue that the handler was set to receive events from\n\t */\n\toffKeyValue: makeFallback(\"can.offKeyValue\",\"offEvent\"),\n\n\t/**\n\t * @function {Object, function(Array)} can-reflect/observe.onKeys onKeys\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, triggered on the key set changing\n\t *\n\t * @signature `onKeys(obj, handler)`\n\t *\n\t * Register an event handler on the Map-like object `obj` to trigger when `obj`'s keyset changes.\n\t * `obj` *must* implement [can-symbol/symbols/onKeys @@@@can.onKeys] to be compatible with\n\t * can-reflect.onKeys.  The function passed as `handler` will receive an Array of object diffs (see\n\t * [can-util/js/diff-object/diff-object diffObject] for the format) as its one argument.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onKeys(obj, function(diffs) {\n\t * \tconsole.log(diffs);\n\t * });\n\t *\n\t * obj.set(\"baz\", \"quux\");  // -> logs '[{\"property\": \"baz\", \"type\": \"add\", \"value\": \"quux\"}]'\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {function(Array)} handler the callback function to receive the diffs in the key set\n\t */\n\t// any key change (diff would normally happen)\n\tonKeys: makeErrorIfMissing(\"can.onKeys\",\"can-reflect: can not observe an onKeys event\"),\n\t/**\n\t * @function {Object, function(Array)} can-reflect/observe.onKeysAdded onKeysAdded\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, triggered on new keys being added.\n\t *\n\t * @signature `onKeysAdded(obj, handler)`\n\t *\n\t * Register an event handler on the Map-like object `obj` to trigger when a new key or keys are set on\n\t * `obj`. `obj` *must* implement [can-symbol/symbols/onKeysAdded @@@@can.onKeysAdded] to be compatible with\n\t * can-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of Strings as its one\n\t * argument.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onKeysAded(obj, function(newKeys) {\n\t * \tconsole.log(newKeys);\n\t * });\n\t *\n\t * foo.set(\"baz\", \"quux\");  // -> logs '[\"baz\"]'\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {function(Array)} handler the callback function to receive the array of added keys\n\t */\n\t// keys added at a certain point {key: 1}, index\n\tonKeysAdded: makeErrorIfMissing(\"can.onKeysAdded\",\"can-reflect: can not observe an onKeysAdded event\"),\n\t/**\n\t * @function {Object, function(Array)} can-reflect/observe.onKeysRemoved onKeysRemoved\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on a MapLike object, triggered on keys being deleted.\n\t *\n\t * @signature `onKeysRemoved(obj, handler)`\n\t *\n\t * Register an event handler on the Map-like object `obj` to trigger when a key or keys are removed from\n\t * `obj`'s keyset. `obj` *must* implement [can-symbol/symbols/onKeysRemoved @@@@can.onKeysRemoved] to be\n\t * compatible with can-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of\n\t * Strings as its one argument.\n\t *\n\t * ```js\n\t * var obj = new CanMap({ foo: \"bar\" });\n\t * canReflect.onKeys(obj, function(diffs) {\n\t * \tconsole.log(JSON.stringify(diffs));\n\t * });\n\t *\n\t * foo.removeAttr(\"foo\");  // -> logs '[\"foo\"]'\n\t * ```\n\t *\n\t * @param {Object} obj an observable MapLike that can listen to changes in named properties.\n\t * @param {function(Array)} handler the callback function to receive the array of removed keys\n\t */\n\tonKeysRemoved: makeErrorIfMissing(\"can.onKeysRemoved\",\"can-reflect: can not unobserve an onKeysRemoved event\"),\n\n\t/**\n\t * @function {Object, String} can-reflect/observe.getKeyDependencies getKeyDependencies\n\t * @parent can-reflect/observe\n\t * @description  Return the observable objects that compute to the value of a named property on an object\n\t *\n\t * @signature `getKeyDependencies(obj, key)`\n\t *\n\t * Return the observable objects that provide input values to generate the computed value of the\n\t * property `key` on Map-like object `obj`.  If `key` does not have dependencies on `obj`, returns `undefined`.\n\t * Otherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that\n\t * maps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a\n\t * [can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/getKeyDependencies @@@@can.getKeyDependencies] to work with\n\t * `canReflect.getKeyDependencies`.\n\t *\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" })\n\t * var obj = new (DefineMap.extend({\n\t * \t baz: {\n\t * \t   get: function() {\n\t * \t     return foo.bar;\n\t * \t   }\n\t * \t }\n\t * }))();\n\t *\n\t * canReflect.getKeyDependencies(obj, \"baz\");  // -> { valueDependencies: CIDSet }\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for key dependencies\n\t * @param {String} key the key on the object to check\n\t * @return {Object} the observable values that this keyed value depends on\n\t */\n\tgetKeyDependencies: makeErrorIfMissing(\"can.getKeyDependencies\", \"can-reflect: can not determine dependencies\"),\n\n\t/**\n\t * @function {Object, String} can-reflect/observe.getWhatIChange getWhatIChange\n\t * @hide\n\t * @parent can-reflect/observe\n\t * @description Return the observable objects that derive their value from the\n\t * obj, passed in.\n\t *\n\t * @signature `getWhatIChange(obj, key)`\n\t *\n\t * `obj` *must* implement `@@@@can.getWhatIChange` to work with\n\t * `canReflect.getWhatIChange`.\n\t *\n\t * @param {Object} obj the object to check for what it changes\n\t * @param {String} [key] the key on the object to check\n\t * @return {Object} the observable values that derive their value from `obj`\n\t */\n\tgetWhatIChange: makeErrorIfMissing(\n\t\t\"can.getWhatIChange\",\n\t\t\"can-reflect: can not determine dependencies\"\n\t),\n\n\t/**\n\t * @function {Function} can-reflect/observe.getChangesDependencyRecord getChangesDependencyRecord\n\t * @hide\n\t * @parent can-reflect/observe\n\t * @description Return the observable objects that are mutated by the handler\n\t * passed in as argument.\n\t *\n\t * @signature `getChangesDependencyRecord(handler)`\n\t *\n\t * `handler` *must* implement `@@@@can.getChangesDependencyRecord` to work with\n\t * `canReflect.getChangesDependencyRecord`.\n\t *\n\t * ```js\n\t * var one = new SimpleObservable(\"one\");\n\t * var two = new SimpleObservable(\"two\");\n\t *\n\t * var handler = function() {\n\t *\ttwo.set(\"2\");\n\t * };\n\t *\n\t * canReflect.onValue(one, handler);\n\t * canReflect.getChangesDependencyRecord(handler); // -> { valueDependencies: new Set([two]) }\n\t * ```\n\t *\n\t * @param {Function} handler the event handler to check for what it changes\n\t * @return {Object} the observable values that are mutated by the handler\n\t */\n\tgetChangesDependencyRecord: function getChangesDependencyRecord(handler) {\n\t\tvar fn = handler[canSymbol.for(\"can.getChangesDependencyRecord\")];\n\n\t\tif (typeof fn === \"function\") {\n\t\t\treturn fn();\n\t\t}\n\t},\n\n\t/**\n\t * @function {Object, String} can-reflect/observe.keyHasDependencies keyHasDependencies\n\t * @parent can-reflect/observe\n\t * @description  Determine whether the value for a named property on an object is bound to other events\n\t *\n\t * @signature `keyHasDependencies(obj, key)`\n\t *\n\t * Returns `true` if the computed value of the property `key` on Map-like object `obj` derives from other values.\n\t * Returns `false` if `key` is computed on `obj` but does not have dependencies on other objects. If `key` is not\n\t * a computed value on `obj`, returns `undefined`.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/keyHasDependencies @@@@can.keyHasDependencies] to work with\n\t * `canReflect.keyHasDependencies`.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" })\n\t * var obj = new (DefineMap.extend({\n\t * \t baz: {\n\t * \t   get: function() {\n\t * \t     return foo.bar;\n\t * \t   }\n\t * \t },\n\t * \t quux: {\n\t * \t \t get: function() {\n\t * \t \t   return \"thud\";\n\t * \t \t }\n\t * \t }\n\t * }))();\n\t *\n\t * canReflect.keyHasDependencies(obj, \"baz\");  // -> true\n\t * canReflect.keyHasDependencies(obj, \"quux\");  // -> false\n\t * canReflect.keyHasDependencies(foo, \"bar\");  // -> undefined\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for key dependencies\n\t * @param {String} key the key on the object to check\n\t * @return {Boolean} `true` if there are other objects that may update the keyed value; `false` otherwise\n\t *\n\t */\n\t// TODO: use getKeyDeps once we know what that needs to look like\n\tkeyHasDependencies: makeErrorIfMissing(\"can.keyHasDependencies\",\"can-reflect: can not determine if this has key dependencies\"),\n\n\t// VALUE\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.onValue onValue\n\t * @parent can-reflect/observe\n\t * @description  Register an event handler on an observable ValueLike object, based on a change in its value\n\t *\n\t * @signature `onValue(handler, [queueName])`\n\t *\n\t * Register an event handler on the Value-like object `obj` to trigger when its value changes.\n\t * `obj` *must* implement [can-symbol/symbols/onValue @@@@can.onValue] to be compatible with\n\t * can-reflect.onKeyValue.  The function passed as `handler` will receive the new value of `obj`\n\t * as the first argument, and the previous value of `obj` as the second argument.\n\t *\n\t * ```js\n\t * var obj = canCompute(\"foo\");\n\t * canReflect.onValue(obj, function(newVal, oldVal) {\n\t * \tconsole.log(\"compute is now\", newVal, \", was\", oldVal);\n\t * });\n\t *\n\t * obj(\"bar\");  // -> logs \"compute is now bar , was foo\"\n\t * ```\n\t *\n\t * @param {*} obj  any object implementing @@can.onValue\n\t * @param {function(*, *)} handler  a callback function that receives the new and old values\n\t */\n\tonValue: makeErrorIfMissing(\"can.onValue\",\"can-reflect: can not observe value change\"),\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.offValue offValue\n\t * @parent can-reflect/observe\n\t * @description  Unregister an value change handler from an observable ValueLike object\n\t *\n\t * @signature `offValue(handler, [queueName])`\n\t *\n\t * Unregister an event handler from the Value-like object `obj` that had previously been registered with\n\t * [can-reflect/observe.onValue onValue]. The function passed as `handler` will no longer be called\n\t * when the value of `obj` changes.\n\t *\n\t * ```js\n\t * var obj = canCompute( \"foo\" );\n\t * var handler = function(newVal, oldVal) {\n\t * \tconsole.log(\"compute is now\", newVal, \", was\", oldVal);\n\t * };\n\t *\n\t * canReflect.onKeyValue(obj, handler);\n\t * canReflect.offKeyValue(obj, handler);\n\t *\n\t * obj(\"baz\");  // -> nothing is logged\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @param {function(*)} handler\n\t */\n\toffValue: makeErrorIfMissing(\"can.offValue\",\"can-reflect: can not unobserve value change\"),\n\n\t/**\n\t * @function {Object} can-reflect/observe.getValueDependencies getValueDependencies\n\t * @parent can-reflect/observe\n\t * @description  Return all the events that bind to the value of an observable, Value-like object\n\t *\n\t * @signature `getValueDependencies(obj)`\n\t *\n\t * Return the observable objects that provide input values to generate the computed value of the\n\t * Value-like object `obj`.  If `obj` does not have dependencies, returns `undefined`.\n\t * Otherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that\n\t * maps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a\n\t * [can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/getValueDependencies @@@@can.getValueDependencies] to work with\n\t * `canReflect.getValueDependencies`.\n\t *\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" })\n\t * var obj = canCompute(function() {\n\t * \t return foo.bar;\n\t * });\n\t *\n\t * canReflect.getValueDependencies(obj);  // -> { valueDependencies: CIDSet } because `obj` is internally backed by\n\t * a [can-observation]\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for value dependencies\n\t * @return {Object} the observable objects that `obj`'s value depends on\n\t *\n\t */\n\tgetValueDependencies: makeErrorIfMissing(\"can.getValueDependencies\",\"can-reflect: can not determine dependencies\"),\n\n\t/**\n\t * @function {Object} can-reflect/observe.valueHasDependencies valueHasDependencies\n\t * @parent can-reflect/observe\n\t * @description  Determine whether the value of an observable object is bound to other events\n\t *\n\t * @signature `valueHasDependencies(obj)`\n\t *\n\t * Returns `true` if the computed value of the Value-like object `obj` derives from other values.\n\t * Returns `false` if `obj` is computed but does not have dependencies on other objects. If `obj` is not\n\t * a computed value, returns `undefined`.\n\t *\n\t * `obj` *must* implement [can-symbol/symbols/valueHasDependencies @@@@can.valueHasDependencies] to work with\n\t * `canReflect.valueHasDependencies`.\n\t *\n\t * ```js\n\t * var foo = canCompute( \"bar\" );\n\t * var baz = canCompute(function() {\n\t * \t return foo();\n\t * });\n\t * var quux = \"thud\";\n\t * var jeek = canCompute(function(plonk) {\n\t * \t if(argument.length) {\n\t * \t \t  quux = plonk;\n\t * \t }\n\t * \t return quux;\n\t * });\n\t *\n\t * canReflect.valueHasDependencies(baz);  // -> true\n\t * canReflect.valueHasDependencies(jeek);  // -> false\n\t * canReflect.valueHasDependencies(foo);  // -> undefined\n\t * ```\n\t *\n\t * @param {Object} obj the object to check for dependencies\n\t * @return {Boolean} `true` if there are other dependencies that may update the object's value; `false` otherwise\n\t *\n\t */\n\tvalueHasDependencies: makeErrorIfMissing(\"can.valueHasDependencies\",\"can-reflect: can not determine if value has dependencies\"),\n\n\t// PATCHES\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.onPatches onPatches\n\t * @parent can-reflect/observe\n\t * @description  Register an handler on an observable that listens to any key changes\n\t *\n\t * @signature `onPatches(obj, handler, [queueName])`\n\t *\n\t * Register an event handler on the object `obj` that fires when anything changes on an object: a key value is added,\n\t * an existing key has is value changed, or a key is deleted from the object.\n\t *\n\t * If object is an array-like and the changed property includes numeric indexes, patch sets will include array-specific\n\t * patches in addition to object-style patches\n\t *\n\t * For more on the patch formats, see [can-util/js/diff-object/diff-object] and [can-util/js/diff-array/diff-array].\n\t *\n\t * ```js\n\t * var obj = new DefineMap({});\n\t * var handler = function(patches) {\n\t * \tconsole.log(patches);\n\t * };\n\t *\n\t * canReflect.onPatches(obj, handler);\n\t * obj.set(\"foo\", \"bar\");  // logs [{ type: \"add\", property: \"foo\", value: \"bar\" }]\n\t * obj.set(\"foo\", \"baz\");  // logs [{ type: \"set\", property: \"foo\", value: \"baz\" }]\n\t *\n\t * var arr = new DefineList([]);\n\t * canReflect.onPatches(arr, handler);\n\t * arr.push(\"foo\");  // logs [{type: \"add\", property:\"0\", value: \"foo\"},\n\t *                            {index: 0, deleteCount: 0, insert: [\"foo\"]}]\n   * arr.pop();  // logs [{type: \"remove\", property:\"0\"},\n\t *                            {index: 0, deleteCount: 1, insert: []}]\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @param {function(*)} handler\n\t * @param {String} [queueName] the name of a queue in [can-queues]; dispatches to `handler` will happen on this queue\n\t */\n\tonPatches: makeErrorIfMissing(\"can.onPatches\", \"can-reflect: can not observe patches on object\"),\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.offPatches offPatches\n\t * @parent can-reflect/observe\n\t * @description  Unregister an object patches handler from an observable object\n\t *\n\t * @signature `offPatches(obj, handler, [queueName])`\n\t *\n\t * Unregister an event handler from the object `obj` that had previously been registered with\n\t * [can-reflect/observe.onPatches onPatches]. The function passed as `handler` will no longer be called\n\t * when `obj` has key or index changes.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({});\n\t * var handler = function(patches) {\n\t * \tconsole.log(patches);\n\t * };\n\t *\n\t * canReflect.onPatches(obj, handler);\n\t * canReflect.offPatches(obj, handler);\n\t *\n\t * obj.set(\"foo\", \"bar\");  // nothing is logged\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @param {function(*)} handler\n\t * @param {String} [queueName] the name of the queue in [can-queues] the handler was registered under\n\t */\n\toffPatches: makeErrorIfMissing(\"can.offPatches\", \"can-reflect: can not unobserve patches on object\"),\n\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.onInstancePatches onInstancePatches\n\t * @parent can-reflect/observe\n\t *\n\t * @description Registers a handler that listens to patch events on any instance\n\t *\n\t * @signature `onInstancePatches(Type, handler(instance, patches))`\n\t *\n\t * Listens to patch changes on any instance of `Type`. This is used by [can-connect]\n\t * to know when a potentially `unbound` instance's `id` changes. If the `id` changes,\n\t * the instance can be moved into the store while it is being saved. E.g:\n\t *\n\t * ```js\n\t * canReflect.onInstancePatches(Map, function onInstancePatches(instance, patches) {\n\t *\tpatches.forEach(function(patch) {\n\t *\t\tif (\n\t *\t\t\t(patch.type === \"add\" || patch.type === \"set\") &&\n\t *\t\t\tpatch.key === connection.idProp &&\n\t *\t\t\tcanReflect.isBound(instance)\n\t *\t\t) {\n\t *\t\t\tconnection.addInstanceReference(instance);\n\t *\t\t}\n\t *\t});\n\t *});\n\t * ```\n\t *\n\t * @param {*} Type\n\t * @param {function(*)} handler\n\t */\n\tonInstancePatches: makeErrorIfMissing(\n\t\t\"can.onInstancePatches\",\n\t\t\"can-reflect: can not observe onInstancePatches on Type\"\n\t),\n\n\t/**\n\t * @function {Object, function(*)} can-reflect/observe.offInstancePatches offInstancePatches\n\t * @parent can-reflect/observe\n\t *\n\t * @description Unregisters a handler registered through [can-reflect/observe.onInstancePatches]\n\t *\n\t * @signature `offInstancePatches(Type, handler(instance, patches))`\n\t *\n\t * ```js\n\t * canReflect.offInstancePatches(Map, onInstancePatches);\n\t * ```\n\t *\n\t * @param {*} Type\n\t * @param {function(*)} handler\n\t */\n\toffInstancePatches: makeErrorIfMissing(\n\t\t\"can.offInstancePatches\",\n\t\t\"can-reflect: can not unobserve onInstancePatches on Type\"\n\t),\n\n\t// HAS BINDINGS VS DOES NOT HAVE BINDINGS\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.onInstanceBoundChange onInstanceBoundChange\n\t * @parent can-reflect/observe\n\t * @description Listen to when observables of a type are bound and unbound.\n\t *\n\t * @signature `onInstanceBoundChange(Type, handler, [queueName])`\n\t *\n\t * Register an event handler on the object `Type` that fires when instances of the type become bound (the first handler is added)\n\t * or unbound (the last remaining handler is removed). The function passed as `handler` will be called\n\t * with the `instance` as the first argument and `true` as the second argument when `instance` gains its first binding,\n\t * and called with `false` when `instance` loses its\n\t * last binding.\n\t *\n\t * ```js\n\t * Person = DefineMap.extend({ ... });\n\t *\n\t * var person = Person({});\n\t * var handler = function(instance, newVal) {\n\t * \tconsole.log(instance, \"bound state is now\", newVal);\n\t * };\n\t * var keyHandler = function() {};\n\t *\n\t * canReflect.onInstanceBoundChange(Person, handler);\n\t * canReflect.onKeyValue(obj, \"name\", keyHandler);  // logs person Bound state is now true\n\t * canReflect.offKeyValue(obj, \"name\", keyHandler);  // logs person Bound state is now false\n\t * ```\n\t *\n\t * @param {function} Type A constructor function\n\t * @param {function(*,Boolean)} handler(instance,isBound) A function called with the `instance` whose bound status changed and the state of the bound status.\n\t * @param {String} [queueName] the name of a queue in [can-queues]; dispatches to `handler` will happen on this queue\n\t */\n\tonInstanceBoundChange: makeErrorIfMissing(\"can.onInstanceBoundChange\", \"can-reflect: can not observe bound state change in instances.\"),\n\t/**\n\t * @function {Object, function(*), String} can-reflect/observe.offInstanceBoundChange offInstanceBoundChange\n\t * @parent can-reflect/observe\n\t * @description Stop listening to when observables of a type are bound and unbound.\n\t *\n\t * @signature `offInstanceBoundChange(Type, handler, [queueName])`\n\t *\n\t * Unregister an event handler from the type `Type` that had previously been registered with\n\t * [can-reflect/observe.onInstanceBoundChange onInstanceBoundChange]. The function passed as `handler` will no longer be called\n\t * when instances of `Type` gains its first or loses its last binding.\n\t *\n\t * ```js\n\t * Person = DefineMap.extend({ ... });\n\t *\n\t * var person = Person({});\n\t * var handler = function(instance, newVal) {\n\t * \tconsole.log(instance, \"bound state is now\", newVal);\n\t * };\n\t * var keyHandler = function() {};\n\t *\n\t * canReflect.onInstanceBoundChange(Person, handler);\n\t * canReflect.offInstanceBoundChange(Person, handler);\n\t * canReflect.onKeyValue(obj, \"name\", keyHandler);  // nothing is logged\n\t * canReflect.offKeyValue(obj, \"name\", keyHandler); // nothing is logged\n\t * ```\n\t *\n\t * @param {function} Type A constructor function\n\t * @param {function(*,Boolean)} handler(instance,isBound) The `handler` passed to `canReflect.onInstanceBoundChange`.\n\t * @param {String} [queueName] the name of the queue in [can-queues] the handler was registered under\n\t */\n\toffInstanceBoundChange: makeErrorIfMissing(\"can.offInstanceBoundChange\", \"can-reflect: can not unobserve bound state change\"),\n\t/**\n\t * @function {Object} can-reflect/observe.isBound isBound\n\t * @parent can-reflect/observe\n\t * @description  Determine whether any listeners are bound to the observable object\n\t *\n\t * @signature `isBound(obj)`\n\t *\n\t * `isBound` queries an observable object to find out whether any listeners have been set on it using\n\t * [can-reflect/observe.onKeyValue onKeyValue] or [can-reflect/observe.onValue onValue]\n\t *\n\t * ```js\n\t * var obj = new DefineMap({});\n\t * var handler = function() {};\n\t * canReflect.isBound(obj); // -> false\n\t * canReflect.onKeyValue(obj, \"foo\", handler);\n\t * canReflect.isBound(obj); // -> true\n\t * canReflect.offKeyValue(obj, \"foo\", handler);\n\t * canReflect.isBound(obj); // -> false\n\t * ```\n\t *\n\t * @param {*} obj\n\t * @return {Boolean} `true` if obj has at least one key-value or value listener, `false` otherwise\n\t */\n\tisBound: makeErrorIfMissing(\"can.isBound\", \"can-reflect: cannot determine if object is bound\"),\n\n\t// EVENT\n\t/**\n\t * @function {Object, String, function(*)} can-reflect/observe.onEvent onEvent\n\t * @parent can-reflect/observe\n\t * @description  Register a named event handler on an observable object\n\t *\n\t * @signature `onEvent(obj, eventName, callback)`\n\t *\n\t *\n\t * Register an event handler on the object `obj` to trigger when the event `eventName` is dispatched.\n\t * `obj` *must* implement [can-symbol/symbols/onKeyValue @@@@can.onEvent] or `.addEventListener()` to be compatible\n\t * with can-reflect.onKeyValue.  The function passed as `callback` will receive the event descriptor as the first\n\t * argument, and any data passed to the event dispatch as subsequent arguments.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * canReflect.onEvent(obj, \"foo\", function(ev, newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * });\n\t *\n\t * canEvent.dispatch.call(obj, \"foo\", [\"baz\", \"quux\"]);  // -> logs \"foo is now baz , was quux\"\n\t * ```\n\t *\n\t * @param {Object} obj the object to bind a new event handler to\n\t * @param {String} eventName the name of the event to bind the handler to\n\t * @param {function(*)} callback  the handler function to bind to the event\n\t */\n\tonEvent: function(obj, eventName, callback, queue){\n\t\tif(obj) {\n\t\t\tvar onEvent = obj[canSymbol.for(\"can.onEvent\")];\n\t\t\tif(onEvent !== undefined) {\n\t\t\t\treturn onEvent.call(obj, eventName, callback, queue);\n\t\t\t} else if(obj.addEventListener) {\n\t\t\t\tobj.addEventListener(eventName, callback, queue);\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * @function {Object, String, function(*)} can-reflect/observe.offValue offEvent\n\t * @parent can-reflect/observe\n\t * @description  Unregister an event handler on a MapLike object, based on a key change\n\t *\n\t * @signature `offEvent(obj, eventName, callback)`\n\t *\n\t * Unregister an event handler from the object `obj` that had previously been registered with\n\t * [can-reflect/observe.onEvent onEvent]. The function passed as `callback` will no longer be called\n\t * when the event named `eventName` is dispatched on `obj`.\n\t *\n\t * ```js\n\t * var obj = new DefineMap({ foo: \"bar\" });\n\t * var handler = function(ev, newVal, oldVal) {\n\t * \tconsole.log(\"foo is now\", newVal, \", was\", oldVal);\n\t * };\n\t *\n\t * canReflect.onEvent(obj, \"foo\", handler);\n\t * canReflect.offEvent(obj, \"foo\", handler);\n\t *\n\t * canEvent.dispatch.call(obj, \"foo\", [\"baz\", \"quux\"]);  // -> nothing is logged\n\t * ```\n\t *\n\t * @param {Object} obj the object to unbind an event handler from\n\t * @param {String} eventName the name of the event to unbind the handler from\n\t * @param {function(*)} callback the handler function to unbind from the event\n\t */\n\toffEvent: function(obj, eventName, callback, queue){\n\t\tif(obj) {\n\t\t\tvar offEvent = obj[canSymbol.for(\"can.offEvent\")];\n\t\t\tif(offEvent !== undefined) {\n\t\t\t\treturn offEvent.call(obj, eventName, callback, queue);\n\t\t\t}  else if(obj.removeEventListener) {\n\t\t\t\tobj.removeEventListener(eventName, callback, queue);\n\t\t\t}\n\t\t}\n\n\t},\n\t/**\n\t * @function {function} can-reflect/setPriority setPriority\n\t * @parent can-reflect/observe\n\t * @description  Provide a priority for when an observable that derives its\n\t * value should be re-evaluated.\n\t *\n\t * @signature `setPriority(obj, priority)`\n\t *\n\t * Calls an underlying `@@can.setPriority` symbol on `obj` if it exists with `priorty`.\n\t * Returns `true` if a priority was set, `false` if otherwise.\n\t *\n\t * Lower priorities (`0` being the lowest), will be an indication to run earlier than\n\t * higher priorities.\n\t *\n\t * ```js\n\t * var obj = canReflect.assignSymbols({},{\n\t *   \"can.setPriority\": function(priority){\n\t *     return this.priority = priority;\n\t *   }\n\t * });\n\t *\n\t * canReflect.setPriority(obj, 0) //-> true\n\t * obj.priority //-> 0\n\t *\n\t * canReflect.setPriority({},20) //-> false\n\t * ```\n\t *\n\t * @param {Object} obj An observable that will update its priority.\n\t * @param {Number} priority The priority number.  Lower priorities (`0` being the lowest),\n\t * indicate to run earlier than higher priorities.\n\t * @return {Boolean} `true` if a priority was able to be set, `false` if otherwise.\n\t *\n\t * @body\n\t *\n\t * ## Use\n\t *\n\t * There's often a need to specify the order of re-evaluation for\n\t * __observables__ that derive (or compute) their value from other observables.\n\t *\n\t * This is needed by templates to avoid unnecessary re-evaluation.  Say we had the following template:\n\t *\n\t * ```js\n\t * {{#if value}}\n\t *   {{value}}\n\t * {{/if}}\n\t * ```\n\t *\n\t * If `value` became falsey, we'd want the `{{#if}}` to be aware of it before\n\t * the `{{value}}` magic tags updated. We can do that by setting priorities:\n\t *\n\t * ```js\n\t * canReflect.setPriority(magicIfObservable, 0);\n\t * canReflect.setPriority(magicValueObservable,1);\n\t * ```\n\t *\n\t * Internally, those observables will use that `priority` to register their\n\t * re-evaluation with the `derive` queue in [can-queues].\n\t *\n\t */\n\tsetPriority: function(obj, priority) {\n\t\tif(obj) {\n\t\t\tvar setPriority =  obj[canSymbol.for(\"can.setPriority\")];\n\t\t\tif(setPriority !== undefined) {\n\t\t\t\tsetPriority.call(obj, priority);\n\t\t\t \treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\t/**\n\t * @function {function} can-reflect/getPriority getPriority\n\t * @parent can-reflect/observe\n\t * @description  Read the priority for an observable that derives its\n\t * value.\n\t *\n\t * @signature `getPriority(obj)`\n\t *\n\t * Calls an underlying `@@can.getPriority` symbol on `obj` if it exists\n\t * and returns its value. Read [can-reflect/setPriority] for more information.\n\t *\n\t *\n\t *\n\t * @param {Object} obj An observable.\n\t * @return {Undefined|Number} Returns the priority number if\n\t * available, undefined if this object does not support the `can.getPriority`\n\t * symbol.\n\t *\n\t * @body\n\t *\n\t */\n\tgetPriority: function(obj) {\n\t\tif(obj) {\n\t\t\tvar getPriority =  obj[canSymbol.for(\"can.getPriority\")];\n\t\t\tif(getPriority !== undefined) {\n\t\t\t\treturn getPriority.call(obj);\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n};\n","\"use strict\";\nvar canSymbol = require(\"can-symbol\");\nvar getSetReflections = require(\"../get-set/get-set\");\nvar typeReflections = require(\"../type/type\");\nvar helpers = require(\"../helpers\");\n\n\n// IE-remove-start\nvar getPrototypeOfWorksWithPrimitives = true;\ntry {\n\tObject.getPrototypeOf(1);\n} catch(e) {\n\tgetPrototypeOfWorksWithPrimitives = false;\n}\n// IE-remove-end\n\nvar ArrayMap;\nif(typeof Map === \"function\") {\n\tArrayMap = Map;\n} else {\n\t// IE-remove-start\n\tvar isEven = function isEven(num) {\n\t\treturn num % 2 === 0;\n\t};\n\n\t// A simple map that stores items in an array.\n\t// like [key, value]\n\t// You can find the value by searching for the key and then +1.\n\tArrayMap = function(){\n\t\tthis.contents = [];\n\t};\n\n\tArrayMap.prototype = {\n\t\t/**\n\t\t * Get an index of a key. Because we store boths keys and values in\n\t\t * a flat array, we ensure we are getting a key by checking that it is an\n\t\t * even number index (all keys are even number indexed).\n\t\t **/\n\t\t_getIndex: function(key) {\n\t\t\tvar idx;\n\t\t\tdo {\n\t\t\t\tidx = this.contents.indexOf(key, idx);\n\t\t\t} while(idx !== -1 && !isEven(idx));\n\t\t\treturn idx;\n\t\t},\n\t\thas: function(key){\n\t\t\treturn this._getIndex(key) !== -1;\n\t\t},\n\t\tget: function(key){\n\t\t\tvar idx = this._getIndex(key);\n\t\t\tif(idx !== -1) {\n\t\t\t\treturn this.contents[idx + 1];\n\t\t\t}\n\t\t},\n\t\tset: function(key, value){\n\t\t\tvar idx = this._getIndex(key);\n\t\t\tif(idx !== -1) {\n\t\t\t\t// Key already exists, replace the value.\n\t\t\t\tthis.contents[idx + 1] = value;\n\t\t\t} else {\n\t\t\t\tthis.contents.push(key);\n\t\t\t\tthis.contents.push(value);\n\t\t\t}\n\t\t},\n\t\t\"delete\": function(key){\n\t\t\tvar idx = this._getIndex(key);\n\t\t\tif(idx !== -1) {\n\t\t\t\t// Key already exists, replace the value.\n\t\t\t\tthis.contents.splice(idx, 2);\n\t\t\t}\n\t\t}\n\t};\n\t// IE-remove-end\n}\n\nvar shapeReflections;\n\nvar shiftFirstArgumentToThis = function(func){\n\treturn function(){\n\t\tvar args = [this];\n\t\targs.push.apply(args, arguments);\n\t\treturn func.apply(null,args);\n\t};\n};\n\nvar getKeyValueSymbol = canSymbol.for(\"can.getKeyValue\");\nvar shiftedGetKeyValue = shiftFirstArgumentToThis(getSetReflections.getKeyValue);\nvar setKeyValueSymbol = canSymbol.for(\"can.setKeyValue\");\nvar shiftedSetKeyValue = shiftFirstArgumentToThis(getSetReflections.setKeyValue);\n\nvar sizeSymbol = canSymbol.for(\"can.size\");\n\nvar hasUpdateSymbol = helpers.makeGetFirstSymbolValue([\"can.updateDeep\",\"can.assignDeep\",\"can.setKeyValue\"]);\nvar shouldUpdateOrAssign = function(obj){\n\treturn typeReflections.isPlainObject(obj) || Array.isArray(obj) || !!hasUpdateSymbol(obj);\n};\n\n// is the value itself its serialized value\nfunction isSerializedHelper(obj){\n\tif (typeReflections.isPrimitive(obj)) {\n\t\treturn true;\n\t}\n\tif(hasUpdateSymbol(obj)) {\n\t\treturn false;\n\t}\n\treturn typeReflections.isBuiltIn(obj) && !typeReflections.isPlainObject(obj) && !Array.isArray(obj);\n}\n\n// IE11 doesn't support primitives\nvar Object_Keys;\ntry{\n\tObject.keys(1);\n\tObject_Keys = Object.keys;\n} catch(e) {\n\tObject_Keys = function(obj){\n\t\tif(typeReflections.isPrimitive(obj)) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\treturn Object.keys(obj);\n\t\t}\n\t};\n}\n\nfunction createSerializeMap(Type) {\n\tvar MapType = Type || ArrayMap;\n\treturn {\n\t\tunwrap: new MapType(),\n\t\tserialize: new MapType() ,\n\t\tisSerializing: {\n\t\t\tunwrap: new MapType(),\n\t\t\tserialize: new MapType()\n\t\t},\n\t\tcircularReferenceIsSerializing: {\n\t\t\tunwrap: new MapType(),\n\t\t\tserialize: new MapType()\n\t\t}\n\t};\n}\n\nfunction makeSerializer(methodName, symbolsToCheck){\n\t// A local variable that is shared with all operations that occur withing a single\n\t// outer call to serialize()\n\tvar serializeMap = null;\n\n\t// Holds the value of running serialize(), preserving the same map for all\n\t// internal instances.\n\tfunction SerializeOperation(MapType) {\n\t\tthis.first = !serializeMap;\n\n\t\tif(this.first) {\n\t\t\tserializeMap = createSerializeMap(MapType);\n\t\t}\n\n\t\tthis.map = serializeMap;\n\t\tthis.result = null;\n\t}\n\n\tSerializeOperation.prototype.end = function(){\n\t\t// If this is the first, outer call, clean up the serializeMap.\n\t\tif(this.first) {\n\t\t\tserializeMap = null;\n\t\t}\n\t\treturn this.result;\n\t};\n\n\treturn function serializer(value, MapType){\n\t\tif (isSerializedHelper(value)) {\n\t\t\treturn value;\n\t\t}\n\n\t\tvar operation = new SerializeOperation(MapType);\n\n\t\tif(typeReflections.isValueLike(value)) {\n\t\t\toperation.result = this[methodName](getSetReflections.getValue(value));\n\n\t\t} else {\n\t\t\t// Date, RegEx and other Built-ins are handled above\n\t\t\t// only want to do something if it's intended to be serialized\n\t\t\t// or do nothing for a POJO\n\n\t\t\tvar isListLike = typeReflections.isIteratorLike(value) || typeReflections.isMoreListLikeThanMapLike(value);\n\t\t\toperation.result = isListLike ? [] : {};\n\n\t\t\t// handle maping to what is serialized\n\t\t\tif( operation.map[methodName].has(value) ) {\n\t\t\t\t// if we are in the process of serializing the first time, setup circular reference detection.\n\t\t\t\tif(operation.map.isSerializing[methodName].has(value)) {\n\t\t\t\t\toperation.map.circularReferenceIsSerializing[methodName].set(value, true);\n\t\t\t\t}\n\t\t\t\treturn operation.map[methodName].get(value);\n\t\t\t} else {\n\t\t\t\toperation.map[methodName].set(value, operation.result);\n\t\t\t}\n\n\t\t\tfor(var i = 0, len = symbolsToCheck.length ; i< len;i++) {\n\t\t\t\tvar serializer = value[symbolsToCheck[i]];\n\t\t\t\tif(serializer) {\n\t\t\t\t\t// mark that we are serializing\n\t\t\t\t\toperation.map.isSerializing[methodName].set(value, true);\n\t\t\t\t\tvar oldResult = operation.result;\n\t\t\t\t\toperation.result = serializer.call(value, oldResult);\n\t\t\t\t\toperation.map.isSerializing[methodName].delete(value);\n\n\t\t\t\t\t// if the result differs, but this was circular, blow up.\n\t\t\t\t\tif(operation.result !== oldResult) {\n\t\t\t\t\t\t// jshint -W073\n\t\t\t\t\t\tif(operation.map.circularReferenceIsSerializing[methodName].has(value)) {\n\t\t\t\t\t\t\t// Circular references should use a custom serializer\n\t\t\t\t\t\t\t// that sets the serialized value on the object\n\t\t\t\t\t\t\t// passed to it as the first argument e.g.\n\t\t\t\t\t\t\t// function(proto){\n\t\t\t\t\t\t\t//   return proto.a = canReflect.serialize(this.a);\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\toperation.end();\n\t\t\t\t\t\t\tthrow new Error(\"Cannot serialize cirular reference!\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\toperation.map[methodName].set(value, operation.result);\n\t\t\t\t\t}\n\t\t\t\t\treturn operation.end();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof obj ==='function') {\n\t\t\t\toperation.map[methodName].set(value, value);\n\n\t\t\t\toperation.result = value;\n\t\t\t} else if( isListLike ) {\n\t\t\t\tthis.eachIndex(value,function(childValue, index){\n\t\t\t\t\toperation.result[index] = this[methodName](childValue);\n\t\t\t\t},this);\n\t\t\t} else {\n\t\t\t\tthis.eachKey(value,function(childValue, prop){\n\t\t\t\t\toperation.result[prop] = this[methodName](childValue);\n\t\t\t\t},this);\n\t\t\t}\n\t\t}\n\n\t\treturn operation.end();\n\t};\n}\n\n// returns a Map type of the keys mapped to true\nvar makeMap;\nif(typeof Map !== \"undefined\") {\n\tmakeMap = function(keys) {\n\t\tvar map = new Map();\n\t\tshapeReflections.eachIndex(keys, function(key){\n\t\t\tmap.set(key, true);\n\t\t});\n\t\treturn map;\n\t};\n} else {\n\tmakeMap = function(keys) {\n\t\tvar map = {};\n\t\tkeys.forEach(function(key){\n\t\t\tmap[key] = true;\n\t\t});\n\n\t\treturn {\n\t\t\tget: function(key){\n\t\t\t\treturn map[key];\n\t\t\t},\n\t\t\tset: function(key, value) {\n\t\t\t\tmap[key] = value;\n\t\t\t},\n\t\t\tkeys: function(){\n\t\t\t\treturn keys;\n\t\t\t}\n\t\t};\n\t};\n}\n\n// creates an optimized hasOwnKey lookup.\n// If the object has hasOwnKey, then we just use that.\n// Otherwise, try to put all keys in a map.\nvar fastHasOwnKey = function(obj){\n\tvar hasOwnKey = obj[canSymbol.for(\"can.hasOwnKey\")];\n\tif(hasOwnKey) {\n\t\treturn hasOwnKey.bind(obj);\n\t} else {\n\t\tvar map = makeMap( shapeReflections.getOwnEnumerableKeys(obj) );\n\t\treturn function(key) {\n\t\t\treturn map.get(key);\n\t\t};\n\t}\n};\n\n\n// combines patches if it makes sense\nfunction addPatch(patches, patch) {\n\tvar lastPatch = patches[patches.length -1];\n\tif(lastPatch) {\n\t\t// same number of deletes and counts as the index is back\n\t\tif(lastPatch.deleteCount === lastPatch.insert.length && (patch.index - lastPatch.index === lastPatch.deleteCount) ) {\n\t\t\tlastPatch.insert.push.apply(lastPatch.insert, patch.insert);\n\t\t\tlastPatch.deleteCount += patch.deleteCount;\n\t\t\treturn;\n\t\t}\n\t}\n\tpatches.push(patch);\n}\n\nfunction updateDeepList(target, source, isAssign) {\n\tvar sourceArray = this.toArray(source); // jshint ignore:line\n\n\tvar patches = [],\n\t\tlastIndex = -1;\n\tthis.eachIndex(target, function(curVal, index){ // jshint ignore:line\n\t\tlastIndex = index;\n\t\t// If target has more items than the source.\n\t\tif(index >= sourceArray.length) {\n\t\t\tif(!isAssign) {\n\t\t\t\t// add a patch that removes the last items\n\t\t\t\taddPatch(patches, {index: index, deleteCount: target.length - index + 1, insert: []});\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tvar newVal = sourceArray[index];\n\t\tif( typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {\n\t\t\taddPatch(patches, {index: index, deleteCount: 1, insert: [newVal]});\n\t\t} else {\n\t\t\tif(isAssign === true) {\n\t\t\t\tthis.assignDeep(curVal, newVal);\n\t\t\t} else {\n\t\t\t\tthis.updateDeep(curVal, newVal);\n\t\t\t}\n\n\t\t}\n\t}, this); // jshint ignore:line\n\t// add items at the end\n\tif(sourceArray.length > lastIndex) {\n\t\taddPatch(patches, {index: lastIndex+1, deleteCount: 0, insert: sourceArray.slice(lastIndex+1)});\n\t}\n\tfor(var i = 0, patchLen = patches.length; i < patchLen; i++) {\n\t\tvar patch = patches[i];\n\t\tgetSetReflections.splice(target, patch.index, patch.deleteCount, patch.insert);\n\t}\n\treturn target;\n}\n\nshapeReflections = {\n\t/**\n\t * @function {Object, function(*), [Object]} can-reflect.each each\n\t * @parent can-reflect/shape\n\t * @description  Iterate a List-like or Map-like, calling `callback` on each keyed or indexed property\n\t *\n\t * @signature `each(obj, callback, context)`\n\t *\n\t * If `obj` is a List-like or an Iterator-like, `each` functions as [can-reflect.eachIndex eachIndex],\n\t * iterating over numeric indexes from 0 to `obj.length - 1` and calling `callback` with each property and\n\t * index, optionally with `context` as `this` (defaulting to `obj`).  If not, `each` functions as\n\t * [can-reflect.eachKey eachKey],\n\t * iterating over every key on `obj` and calling `callback` on each one.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t * var quux = new DefineList([ \"thud\", \"jeek\" ]);\n\t *\n\t * canReflect.each(foo, console.log, console); // -> logs 'baz bar {foo}'\n\t * canReflect.each(quux, console.log, console); // -> logs 'thud 0 {quux}'; logs 'jeek 1 {quux}'\n\t * ```\n\t *\n\t * @param  {Object}   obj     The object to iterate over\n\t * @param  {Function(*, ValueLike)} callback a function that receives each item in the ListLike or MapLike\n\t * @param  {[Object]}   context  an optional `this` context for calling the callback\n\t * @return {Array} the result of calling [can-reflect.eachIndex `eachIndex`] if `obj` is a ListLike,\n\t * or [can-reflect.eachKey `eachKey`] if a MapLike.\n\t */\n\teach: function(obj, callback, context){\n\n\t\t// if something is more \"list like\" .. use eachIndex\n\t\tif(typeReflections.isIteratorLike(obj) || typeReflections.isMoreListLikeThanMapLike(obj) ) {\n\t\t\treturn shapeReflections.eachIndex(obj,callback,context);\n\t\t} else {\n\t\t\treturn shapeReflections.eachKey(obj,callback,context);\n\t\t}\n\t},\n\n\t/**\n\t * @function {ListLike, function(*), [Object]} can-reflect.eachIndex eachIndex\n\t * @parent can-reflect/shape\n\t * @description  Iterate a ListLike calling `callback` on each numerically indexed element\n\t *\n\t * @signature `eachIndex(list, callback, context)`\n\t *\n\t * For each numeric index from 0 to `list.length - 1`, call `callback`, passing the current\n\t * property value, the current index, and `list`, and optionally setting `this` as `context`\n\t * if specified (otherwise use the current property value).\n\t *\n\t * ```js\n\t * var foo = new DefineList([ \"bar\", \"baz\" ]);\n\t *\n\t * canReflect.eachIndex(foo, console.log, console); // -> logs 'bar 0 {foo}'; logs 'baz 1 {foo}'\n\t * ```\n\t *\n\t * @param  {ListLike}   list     The list to iterate over\n\t * @param  {Function(*, Number)} callback a function that receives each item\n\t * @param  {[Object]}   context  an optional `this` context for calling the callback\n\t * @return {ListLike}   the original list\n\t */\n\teachIndex: function(list, callback, context){\n\t\t// each index in something list-like. Uses iterator if it has it.\n\t\tif(Array.isArray(list)) {\n\t\t\treturn shapeReflections.eachListLike(list, callback, context);\n\t\t} else {\n\t\t\tvar iter, iterator = list[canSymbol.iterator];\n\t\t\tif(typeReflections.isIteratorLike(list)) {\n\t\t\t\t// we are looping through an iterator\n\t\t\t\titer = list;\n\t\t\t} else if(iterator) {\n\t\t\t\titer = iterator.call(list);\n\t\t\t}\n\t\t\t// fast-path arrays\n\t\t\tif(iter) {\n\t\t\t\tvar res, index = 0;\n\n\t\t\t\twhile(!(res = iter.next()).done) {\n\t\t\t\t\tif( callback.call(context || list, res.value, index++, list) === false ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tshapeReflections.eachListLike(list, callback, context);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t},\n\teachListLike: function(list, callback, context){\n\t\tvar index = -1;\n\t\tvar length = list.length;\n\t\tif( length === undefined ) {\n\t\t\tvar size = list[sizeSymbol];\n\t\t\tif(size) {\n\t\t\t\tlength = size.call(list);\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"can-reflect: unable to iterate.\");\n\t\t\t}\n\t\t}\n\n\t\twhile (++index < length) {\n\t\t\tvar item = list[index];\n\t\t\tif (callback.call(context || item, item, index, list) === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t},\n\t/**\n\t * @function can-reflect.toArray toArray\n\t * @parent can-reflect/shape\n\t * @description  convert the values of any MapLike or ListLike into an array\n\t *\n\t * @signature `toArray(obj)`\n\t *\n\t * Convert the values of any Map-like or List-like into a JavaScript Array.  If a Map-like,\n\t * key data is discarded and only value data is preserved.\n\t *\n\t * ```js\n\t * var foo = new DefineList([\"bar\", \"baz\"]);\n\t * var quux = new DefineMap({ thud: \"jeek\" });\n\t * ```\n\t *\n\t * canReflect.toArray(foo); // -> [\"bar\", \"baz\"]\n\t * canReflect.toArray(quux): // -> [\"jeek\"]\n\t *\n\t * @param  {Object} obj Any object, whether MapLike or ListLike\n\t * @return {Array}  an array of the values of `obj`\n\t */\n\ttoArray: function(obj){\n\t\tvar arr = [];\n\t\tshapeReflections.each(obj, function(value){\n\t\t\tarr.push(value);\n\t\t});\n\t\treturn arr;\n\t},\n\t/**\n\t * @function can-reflect.eachKey eachKey\n\t * @parent can-reflect/shape\n\t * @description Iterate over a MapLike, calling `callback` on each enumerable property\n\t *\n\t * @signature `eachKey(obj, callback, context)`\n\t *\n\t * Iterate all own enumerable properties on Map-like `obj`\n\t * (using [can-reflect/shape/getOwnEnumerableKeys canReflect.getOwnEnumerableKeys]), and call\n\t * `callback` with the property value, the property key, and `obj`, and optionally setting\n\t * `this` on the callback as `context` if provided, `obj` otherwise.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * canReflect.eachKey(foo, console.log, console); // logs 'baz bar {foo}'\n\t * ```\n\t *\n\t * @param  {Object}   obj   The object to iterate over\n\t * @param  {Function(*, String)} callback The callback to call on each enumerable property value\n\t * @param  {[Object]}   context  an optional `this` context for calling `callback`\n\t * @return {Array}    the enumerable keys of `obj` as an Array\n\t */\n\teachKey: function(obj, callback, context){\n\t\t// each key in something map like\n\t\t// eachOwnEnumerableKey\n\t\tif(obj) {\n\t\t\tvar enumerableKeys = shapeReflections.getOwnEnumerableKeys(obj);\n\n\t\t\t// cache getKeyValue method if we can\n\t\t\tvar getKeyValue = obj[getKeyValueSymbol] || shiftedGetKeyValue;\n\n\t\t\treturn shapeReflections.eachIndex(enumerableKeys, function(key){\n\t\t\t\tvar value = getKeyValue.call(obj, key);\n\t\t\t\treturn callback.call(context || obj, value, key, obj);\n\t\t\t});\n\t\t}\n\t\treturn obj;\n\t},\n\t/**\n\t * @function can-reflect.hasOwnKey hasOwnKey\n\t * @parent can-reflect/shape\n\t * @description  Determine whether an object contains a key on itself, not only on its prototype chain\n\t *\n\t * @signature `hasOwnKey(obj, key)`\n\t *\n\t * Return `true` if an object's own properties include the property key `key`, `false` otherwise.\n\t * An object may implement [can-symbol/symbols/hasOwnKey @@@@can.hasOwnKey] to override default behavior.\n\t * By default, `canReflect.hasOwnKey` will first look for\n\t * [can-symbol/symbols/getOwnKey @@@@can.getOwnKey] on `obj`. If present, it will call `@@@@can.getOwnKey` and\n\t * test `key` against the returned Array of keys.  If absent, `Object.prototype.hasOwnKey()` is used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" });\n\t *\n\t * canReflect.hasOwnKey(foo, \"bar\"); // -> true\n\t * canReflect.hasOwnKey(foo, \"each\"); // -> false\n\t * foo.each // -> function each() {...}\n\t * ```\n\t *\n\t * @param  {Object} obj Any MapLike object\n\t * @param  {String} key The key to look up on `obj`\n\t * @return {Boolean} `true` if `obj`'s key set contains `key`, `false` otherwise\n\t */\n\t\"hasOwnKey\": function(obj, key){\n\t\t// if a key or index\n\t\t// like has own property\n\t\tvar hasOwnKey = obj[canSymbol.for(\"can.hasOwnKey\")];\n\t\tif(hasOwnKey) {\n\t\t\treturn hasOwnKey.call(obj, key);\n\t\t}\n\t\tvar getOwnKeys = obj[canSymbol.for(\"can.getOwnKeys\")];\n\t\tif( getOwnKeys ) {\n\t\t\tvar found = false;\n\t\t\tshapeReflections.eachIndex(getOwnKeys.call(obj), function(objKey){\n\t\t\t\tif(objKey === key) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn found;\n\t\t}\n\t\treturn obj.hasOwnProperty(key);\n\t},\n\t/**\n\t * @function can-reflect.getOwnEnumerableKeys getOwnEnumerableKeys\n\t * @parent can-reflect/shape\n\t * @description Return the list of keys which can be iterated over on an object\n\t *\n\t * @signature `getOwnEnumerableKeys(obj)`\n\t *\n\t * Return all keys on `obj` which have been defined as enumerable, either from explicitly setting\n\t * `enumerable` on the property descriptor, or by using `=` to set the value of the property without\n\t * a key descriptor, but excluding properties that only exist on `obj`'s prototype chain.  The\n\t * default behavior can be overridden by implementing\n\t * [can-symbol/symbols/getOwnEnumerableKeys @@@@can.getOwnEnumerableKeys] on `obj`.  By default,\n\t * `canReflect.getOwnEnumerableKeys` will use [can-symbol/symbols/getOwnKeys @@@@can.getOwnKeys] to\n\t * retrieve the set of keys and [can-symbol/symbols/getOwnKeyDescriptor @@@@can.getOwnKeyDescriptor]\n\t * to filter for those which are enumerable.  If either symbol is absent from `obj`, `Object.keys`\n\t * is used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\", [canSymbol.for(\"quux\")]: \"thud\" });\n\t * Object.defineProperty(foo, \"jeek\", {\n\t *   enumerable: true,\n\t *   value: \"plonk\"\n\t * });\n\t *\n\t * canReflect.getOwnEnumerableKeys(foo); // -> [\"bar\", \"jeek\"]\n\t * ```\n\t *\n\t * @param  {Object} obj Any Map-like object\n\t * @return {Array} the Array of all enumerable keys from the object, either using\n\t * [can-symbol/symbols/getOwnEnumerableKeys `@@@@can.getOwnEnumerableKeys`] from `obj`, or filtering\n\t * `obj`'s own keys for those which are enumerable.\n\t */\n\tgetOwnEnumerableKeys: function(obj){\n\t\t// own enumerable keys (aliased as keys)\n\t\tvar getOwnEnumerableKeys = obj[canSymbol.for(\"can.getOwnEnumerableKeys\")];\n\t\tif(getOwnEnumerableKeys) {\n\t\t\treturn getOwnEnumerableKeys.call(obj);\n\t\t}\n\t\tif( obj[canSymbol.for(\"can.getOwnKeys\")] && obj[canSymbol.for(\"can.getOwnKeyDescriptor\")] ) {\n\t\t\tvar keys = [];\n\t\t\tshapeReflections.eachIndex(shapeReflections.getOwnKeys(obj), function(key){\n\t\t\t\tvar descriptor =  shapeReflections.getOwnKeyDescriptor(obj, key);\n\t\t\t\tif(descriptor.enumerable) {\n\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\treturn keys;\n\t\t} /*else if(obj[canSymbol.iterator]){\n\t\t\tvar iter = obj[canSymbol.iterator](obj);\n\t\t\tvar index = 0;\n\t\t\tvar keys;\n\t\t\treturn {\n\t\t\t\tnext: function(){\n\t\t\t\t\tvar res = iter.next();\n\t\t\t\t\tif(index++)\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!().done) {\n\n\t\t\t\tif( callback.call(context || list, res.value, index++, list) === false ){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/ else {\n\t\t\treturn Object_Keys(obj);\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.getOwnKeys getOwnKeys\n\t * @parent can-reflect/shape\n\t * @description Return the list of keys on an object, whether or not they can be iterated over\n\t *\n\t * @signature `getOwnKeys(obj)`\n\t *\n\t * Return the Array of all String (not Symbol) keys from `obj`, whether they are enumerable or not.  If\n\t * [can-symbol/symbols/getOwnKeys @@@@can.getOwnKeys] exists on `obj`, it is called to return\n\t * the keys; otherwise, `Object.getOwnPropertyNames()` is used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\", [canSymbol.for(\"quux\")]: \"thud\" });\n\t * Object.defineProperty(foo, \"jeek\", {\n\t *   enumerable: false,\n\t *   value: \"plonk\"\n\t * });\n\t *\n\t * canReflect.getOwnKeys(foo); // -> [\"bar\", \"jeek\"]\n\t * ```\n\t *\n\t * @param  {Object} obj Any MapLike object\n\t * @return {Array} the Array of all String keys from the object.\n\t */\n\tgetOwnKeys: function(obj){\n\t\t// own enumerable&non-enumerable keys (Object.getOwnPropertyNames)\n\t\tvar getOwnKeys = obj[canSymbol.for(\"can.getOwnKeys\")];\n\t\tif(getOwnKeys) {\n\t\t\treturn getOwnKeys.call(obj);\n\t\t} else {\n\t\t\treturn Object.getOwnPropertyNames(obj);\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.getOwnKeyDescriptor getOwnKeyDescriptor\n\t * @parent can-reflect/shape\n\t * @description Return a property descriptor for a named property on an object.\n\t *\n\t * @signature `getOwnKeyDescriptor(obj, key)`\n\t *\n\t *\tReturn the key descriptor for the property key `key` on the Map-like object `obj`. A key descriptor\n\t *\tis specified in ECMAScript 5 and contains keys for the property's `configurable` and `enumerable` states,\n\t *\tas well as either `value` and `writable` for value properties, or `get` and `set` for getter/setter properties.\n\t *\n\t * The default behavior can be overridden by implementing [can-symbol/symbols/getOwnKeyDescriptor @@@@can.getOwnKeyDescriptor]\n\t * on `obj`; otherwise the default is to call `Object.getOwnKeyDescriptor()`.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ bar: \"baz\" });\n\t *\n\t * getOwnKeyDescriptor(foo, \"bar\"); // -> {configurable: true, writable: true, enumerable: true, value: \"baz\"}\n\t * ```\n\t *\n\t * @param  {Object} obj Any object with named properties\n\t * @param  {String} key The property name to look up on `obj`\n\t * @return {Object}   A key descriptor object\n\t */\n\tgetOwnKeyDescriptor: function(obj, key){\n\t\tvar getOwnKeyDescriptor = obj[canSymbol.for(\"can.getOwnKeyDescriptor\")];\n\t\tif(getOwnKeyDescriptor) {\n\t\t\treturn getOwnKeyDescriptor.call(obj, key);\n\t\t} else {\n\t\t\treturn Object.getOwnPropertyDescriptor(obj, key);\n\t\t}\n\t},\n\t/**\n\t * @function can-reflect.unwrap unwrap\n\t * @parent can-reflect/shape\n\t * @description Unwraps a map-like or array-like value into an object or array.\n\t *\n\t *\n\t * @signature `unwrap(obj)`\n\t *\n\t * Recursively unwraps a map-like or list-like object.\n\t *\n\t * ```js\n\t * import canReflect from \"can-reflect\";\n\t *\n\t * var map = new DefineMap({foo: \"bar\"});\n\t * canReflect.unwrap(map) //-> {foo: \"bar\"}\n\t * ```\n\t *\n\t * `unwrap` is similar to [can-reflect.serialize] except it does not try to provide `JSON.stringify()`-safe\n\t * objects.  For example, an object with a `Date` instance property value will not be expected to\n\t * serialize the date instance:\n\t *\n\t * ```js\n\t * var date = new Date();\n\t * var map = new DefineMap({date: date});\n\t * canReflect.unwrap(map) //-> {date: date}\n\t * ```\n\t *\n\t * @param {Object} obj A map-like or array-like object.\n\t * @return {Object} Returns objects and arrays.\n\t */\n\tunwrap: makeSerializer(\"unwrap\",[canSymbol.for(\"can.unwrap\")]),\n\t/**\n\t * @function can-reflect.serialize serialize\n\t * @parent can-reflect/shape\n\t * @description Serializes an object to a value that can be passed to JSON.stringify.\n\t *\n\t *\n\t * @signature `serialize(obj)`\n\t *\n\t * Recursively serializes a map-like or list-like object.\n\t *\n\t * ```js\n\t * import canReflect from \"can-reflect\";\n\t * canReflect.serialize({foo: \"bar\"}) //-> {foo: \"bar\"}\n\t * ```\n\t *\n\t * It does this by recursively:\n\t *\n\t *  - Checking if `obj` is a primitive, if it is, returns the value.\n\t *  - If `obj` is an object:\n\t *    - calling the `@can.serialize` property on the value if it exists.\n\t *    - If the `@can.serialize` value doesn't exist, walks through every key-value\n\t *      on `obj` and copy to a new object.\n\t *\n\t * @param {Object} obj A map-like or array-like object.\n\t * @return {Object} Returns a plain object or array.\n\t */\n\tserialize: makeSerializer(\"serialize\",[canSymbol.for(\"can.serialize\"), canSymbol.for(\"can.unwrap\")]),\n\n\tassignMap: function(target, source) {\n\t\t// read each key and set it on target\n\t\tvar hasOwnKey = fastHasOwnKey(target);\n\t\tvar getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\t\tshapeReflections.eachKey(source,function(value, key){\n\t\t\t// if the target doesn't have this key or the keys are not the same\n\t\t\tif(!hasOwnKey(key) || getKeyValue.call(target, key) !==  value) {\n\t\t\t\tsetKeyValue.call(target, key, value);\n\t\t\t}\n\t\t});\n\t\treturn target;\n\t},\n\tassignList: function(target, source) {\n\t\tvar inserting = shapeReflections.toArray(source);\n\t\tgetSetReflections.splice(target, 0, inserting, inserting );\n\t\treturn target;\n\t},\n\t/**\n\t * @function can-reflect.assign assign\n\t * @parent can-reflect/shape\n\t * @description Assign one objects values to another\n\t *\n\t * @signature `.assign(target, source)`\n\t *\n\t * Copies the values (and properties if map-like) from `source` onto `target`.\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {};\n\t * var source = {key : \"value\"};\n\t * var restult = canReflect.assign(target, source);\n\t * result === target //-> true\n\t * target //-> {key : \"value\"}\n\t * ```\n\t *\n\t * For Arrays, enumerated values are copied over, but the length of the array will not be\n\t * trunkated.  Use [can-reflect.update] for trunkating.\n\t *\n\t * ```js\n\t * var target = [\"a\",\"b\",\"c\"];\n\t * var source = [\"A\",\"B\"];\n\t * canReflect.assign(target, source);\n\t * target //-> [\"A\",\"B\",\"c\"]\n\t * ```\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tassign: function(target, source) {\n\t\tif(typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// copy to array and add these keys in place\n\t\t\tshapeReflections.assignList(target, source);\n\t\t} else {\n\t\t\tshapeReflections.assignMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\tassignDeepMap: function(target, source) {\n\n\t\tvar hasOwnKey = fastHasOwnKey(target);\n\t\tvar getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\n\t\tshapeReflections.eachKey(source, function(newVal, key){\n\t\t\tif(!hasOwnKey(key)) {\n\t\t\t\t// set no matter what\n\t\t\t\tgetSetReflections.setKeyValue(target, key, newVal);\n\t\t\t} else {\n\t\t\t\tvar curVal = getKeyValue.call(target, key);\n\n\t\t\t\t// if either was primitive, no recursive update possible\n\t\t\t\tif(newVal === curVal) {\n\t\t\t\t\t// do nothing\n\t\t\t\t} else if(typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {\n\t\t\t\t\tsetKeyValue.call(target, key, newVal);\n\t\t\t\t} else {\n\t\t\t\t\tshapeReflections.assignDeep(curVal, newVal);\n\t\t\t\t}\n\t\t\t}\n\t\t}, this);\n\t\treturn target;\n\t},\n\tassignDeepList: function(target, source) {\n\t\treturn updateDeepList.call(this, target, source, true);\n\t},\n\t/**\n\t * @function can-reflect.assignDeep assignDeep\n\t * @parent can-reflect/shape\n\t * @description Assign one objects values to another, and performs the same action for all child values.\n\t *\n\t * @signature `.assignDeep(target, source)`\n\t *\n\t * Copies the values (and properties if map-like) from `source` onto `target` and repeates for all child\n\t * values.\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {name: {first: \"Justin\"}};\n\t * var source = {name: {last: \"Meyer\"}};\n\t * var restult = canReflect.assignDeep(target, source);\n\t * target //->  {name: {first: \"Justin\", last: \"Meyer\"}}\n\t * ```\n\t *\n\t * An object can control the behavior of `assignDeep` using the [can-symbol/symbols/assignDeep] symbol.\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tassignDeep: function(target, source){\n\t\tvar assignDeep = target[canSymbol.for(\"can.assignDeep\")];\n\t\tif(assignDeep) {\n\t\t\tassignDeep.call(target, source);\n\t\t} else if( typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// list-like\n\t\t\tshapeReflections.assignDeepList(target, source);\n\t\t} else {\n\t\t\t// map-like\n\t\t\tshapeReflections.assignDeepMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\tupdateMap: function(target, source) {\n\t\tvar sourceKeyMap = makeMap( shapeReflections.getOwnEnumerableKeys(source) );\n\n\t\tvar sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\n\t\tshapeReflections.eachKey(target, function(curVal, key){\n\t\t\tif(!sourceKeyMap.get(key)) {\n\t\t\t\tgetSetReflections.deleteKeyValue(target, key);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsourceKeyMap.set(key, false);\n\t\t\tvar newVal = sourceGetKeyValue.call(source, key);\n\n\t\t\t// if either was primitive, no recursive update possible\n\t\t\tif(newVal !== curVal) {\n\t\t\t\ttargetSetKeyValue.call(target, key, newVal);\n\t\t\t}\n\t\t}, this);\n\n\t\tshapeReflections.eachIndex(sourceKeyMap.keys(), function(key){\n\t\t\tif(sourceKeyMap.get(key)) {\n\t\t\t\ttargetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key) );\n\t\t\t}\n\t\t});\n\n\t\treturn target;\n\t},\n\tupdateList: function(target, source) {\n\t\tvar inserting = shapeReflections.toArray(source);\n\n\t\tgetSetReflections.splice(target, 0, target, inserting );\n\t\treturn target;\n\t},\n\t/**\n\t * @function can-reflect.update update\n\t * @parent can-reflect/shape\n\t * @description Updates the values of an object match the values of an other object.\n\t *\n\t * @signature `.update(target, source)`\n\t *\n\t * Updates the values (and properties if map-like) of `target` to match the values of `source`.\n\t * Properties of `target` that are not on `source` will be removed. This does\n\t * not recursively update.  For that, use [can-reflect.updateDeep].\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {name: {first: \"Justin\"}, age: 34};\n\t * var source = {name: {last: \"Meyer\"}};\n\t * var result = canReflect.update(target, source);\n\t * target //->  {name: {last: \"Meyer\"}}\n\t * ```\n\t *\n\t * With Arrays all items of the source will be replaced with the new items.\n\t *\n\t * ```js\n\t * var target = [\"a\",\"b\",\"c\"];\n\t * var source = [\"A\",\"B\"];\n\t * canReflect.update(target, source);\n\t * target //-> [\"A\",\"B\"]\n\t * ```\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tupdate: function(target, source) {\n\t\tif(typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// copy to array and add these keys in place\n\t\t\tshapeReflections.updateList(target, source);\n\t\t} else {\n\t\t\tshapeReflections.updateMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\tupdateDeepMap: function(target, source) {\n\t\tvar sourceKeyMap = makeMap( shapeReflections.getOwnEnumerableKeys(source) );\n\n\t\tvar sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;\n\t\tvar targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;\n\n\t\tshapeReflections.eachKey(target, function(curVal, key){\n\n\t\t\tif(!sourceKeyMap.get(key)) {\n\t\t\t\tgetSetReflections.deleteKeyValue(target, key);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsourceKeyMap.set(key, false);\n\t\t\tvar newVal = sourceGetKeyValue.call(source, key);\n\n\t\t\t// if either was primitive, no recursive update possible\n\t\t\tif(typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {\n\t\t\t\ttargetSetKeyValue.call(target, key, newVal);\n\t\t\t} else {\n\t\t\t\tshapeReflections.updateDeep(curVal, newVal);\n\t\t\t}\n\n\t\t}, this);\n\n\t\tshapeReflections.eachIndex(sourceKeyMap.keys(), function(key){\n\t\t\tif(sourceKeyMap.get(key)) {\n\t\t\t\ttargetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key) );\n\t\t\t}\n\t\t});\n\t\treturn target;\n\t},\n\tupdateDeepList: function(target, source) {\n\t\treturn updateDeepList.call(this,target, source);\n\t},\n\t/**\n\t * @function can-reflect.updateDeep updateDeep\n\t * @parent can-reflect/shape\n\t * @description Makes the values of an object match the values of an other object including all children values.\n\t *\n\t * @signature `.updateDeep(target, source)`\n\t *\n\t * Updates the values (and properties if map-like) of `target` to match the values of `source`.\n\t * Removes properties from `target` that are not on `source`.\n\t *\n\t * For map-like objects, every enumerable property on `target` is copied:\n\t *\n\t * ```js\n\t * var target = {name: {first: \"Justin\"}, age: 34};\n\t * var source = {name: {last: \"Meyer\"}};\n\t * var result = canReflect.updateDeep(target, source);\n\t * target //->  {name: {last: \"Meyer\"}}\n\t * ```\n\t *\n\t * An object can control the behavior of `updateDeep` using the [can-symbol/symbols/updateDeep] symbol.\n\t *\n\t * For list-like objects, a diff and patch strategy is used.  This attempts to limit the number of changes.\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s values.\n\t * @param  {Object} source A source of values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tupdateDeep: function(target, source){\n\t\tvar updateDeep = target[canSymbol.for(\"can.updateDeep\")];\n\t\tif(updateDeep) {\n\t\t\tupdateDeep.call(target, source);\n\t\t} else if( typeReflections.isMoreListLikeThanMapLike(source) ) {\n\t\t\t// list-like\n\t\t\tshapeReflections.updateDeepList(target, source);\n\t\t} else {\n\t\t\t// map-like\n\t\t\tshapeReflections.updateDeepMap(target, source);\n\t\t}\n\t\treturn target;\n\t},\n\t// walks up the whole prototype chain\n\t/**\n\t * @function can-reflect.hasKey hasKey\n\t * @parent can-reflect/shape\n\t * @description Determine whether an object contains a key on itself or its prototype chain\n\t *\n\t * @signature `hasKey(obj, key)`\n\t *\n\t * Return `true` if an object's properties include the property key `key` or an object on its prototype\n\t * chain's properties include the key `key`, `false` otherwise.\n\t * An object may implement [can-symbol/symbols/hasKey @@@@can.hasKey] to override default behavior.\n\t * By default, `canReflect.hasKey` will use [can-reflect.hasOwnKey] and return true if the key is present.\n\t * If `hasOwnKey` returns false, the [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in in Operator] will be used.\n\t *\n\t * ```js\n\t * var foo = new DefineMap({ \"bar\": \"baz\" });\n\t *\n\t * canReflect.in(foo, \"bar\"); // -> true\n\t * canReflect.in(foo, \"each\"); // -> true\n\t * foo.each // -> function each() {...}\n\t * ```\n\t *\n\t * @param  {Object} obj Any MapLike object\n\t * @param  {String} key The key to look up on `obj`\n\t * @return {Boolean} `true` if `obj`'s key set contains `key` or an object on its prototype chain's key set contains `key`, `false` otherwise\n\t */\n\thasKey: function(obj, key) {\n\t\tif( obj == null ) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeReflections.isPrimitive(obj)) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tvar proto;\n\t\t\t\tif(getPrototypeOfWorksWithPrimitives) {\n\t\t\t\t\tproto = Object.getPrototypeOf(obj);\n\t\t\t\t} else {\n\t\t\t\t\t// IE-remove-start\n\t\t\t\t\tproto = obj.__proto__; // jshint ignore:line\n\t\t\t\t\t// IE-remove-end\n\t\t\t\t}\n\t\t\t\tif(proto !== undefined) {\n\t\t\t\t\treturn key in proto;\n\t\t\t\t} else {\n\t\t\t\t\t// IE-remove-start\n\t\t\t\t\treturn obj[key] !== undefined;\n\t\t\t\t\t// IE-remove-end\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar hasKey = obj[canSymbol.for(\"can.hasKey\")];\n\t\tif(hasKey) {\n\t\t\treturn hasKey.call(obj, key);\n\t\t}\n\n\t\tvar found = shapeReflections.hasOwnKey(obj, key);\n\n\t\treturn found || key in obj;\n\t},\n\tgetAllEnumerableKeys: function(){},\n\tgetAllKeys: function(){},\n\t/**\n\t * @function can-reflect.assignSymbols assignSymbols\n\t * @parent can-reflect/shape\n\t * @description Assign well known symbols and values to an object.\n\t *\n\t * @signature `.assignSymbols(target, source)`\n\t *\n\t * Converts each property name on the `source` object to a [can-symbol.for well known symbol]\n\t * and uses that symbol to set the corresponding value on target.\n\t *\n\t * This is used to easily set symbols correctly even when symbol isn't natively supported.\n\t *\n\t * ```js\n\t * canReflect.assignSymbols(Map.prototype, {\n\t *   \"can.getKeyValue\": Map.prototype.get\n\t * })\n\t * ```\n\t *\n\t * If a `source` property name matches a symbol on `Symbol` (like `iterator` on `Symbol.iterator`),\n\t * that symbol will be used:\n\t *\n\t * ```js\n\t * canReflect.assignSymbols(ArrayLike.prototype, {\n\t *   \"iterator\": function() { ... }\n\t * })\n\t * ArrayLike.prototype[Symbol.iterator] = function(){ ... }\n\t * ```\n\t *\n\t * @param  {Object} target The value that will be updated with `source`'s symbols and values.\n\t * @param  {Object<name,value>} source A source of symbol names and values to copy to `target`.\n\t * @return {Object} The target.\n\t */\n\tassignSymbols: function(target, source){\n\t\tshapeReflections.eachKey(source, function(value, key){\n\t\t\tvar symbol = typeReflections.isSymbolLike(canSymbol[key]) ? canSymbol[key] : canSymbol.for(key);\n\t\t\tgetSetReflections.setKeyValue(target, symbol, value);\n\t\t});\n\t\treturn target;\n\t},\n\tisSerialized: isSerializedHelper,\n\t/**\n\t * @function can-reflect.size size\n\t * @parent can-reflect/shape\n\t * @description Return the number of items in the collection.\n\t *\n\t * @signature `.size(target)`\n\t *\n\t * Returns the number of items contained in `target`. Target can\n\t * provide the size using the [can-symbol/symbols/size] symbol.\n\t *\n\t * If the `target` has a numeric `length` property that is greater than or equal to 0, that\n\t * `length` will be returned.\n\t *\n\t * ```js\n\t * canReflect.size([1,2,3]) //-> 3\n\t * ```\n\t *\n\t * If the `target` is [can-reflect.isListLike], the values of the list will be counted.\n\t *\n\t * If the `target` is a plain JS object, the number of enumerable properties will be returned.\n\t *\n\t * ```js\n\t * canReflect.size({foo:\"bar\"}) //-> 1\n\t * ```\n\t *\n\t * If the `target` is anything else, `undefined` is returned.\n\t *\n\t * @param  {Object} target The container object.\n\t * @return {Number} The number of values in the target.\n\t */\n\tsize: function(obj){\n\t\tif(obj == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tvar size = obj[sizeSymbol];\n\t\tvar count = 0;\n\t\tif(size) {\n\t\t\treturn size.call(obj);\n\t\t}\n\t\telse if(helpers.hasLength(obj)){\n\t\t\treturn obj.length;\n\t\t}\n\t\telse if(typeReflections.isListLike(obj)){\n\n\t\t\tshapeReflections.eachIndex(obj, function(){\n\t\t\t\tcount++;\n\t\t\t});\n\t\t\treturn count;\n\t\t}\n\t\telse if( obj ) {\n\t\t\treturn shapeReflections.getOwnEnumerableKeys(obj).length;\n\t\t}\n\t\telse {\n\t\t\treturn undefined;\n\t\t}\n\t},\n\t/**\n\t * @function {Function, String|Symbol, Object} can-reflect.defineInstanceKey defineInstanceKey\n\t * @parent can-reflect/shape\n\t * @description Create a key for all instances of a constructor.\n\t *\n\t * @signature `defineInstanceKey(cls, key, properties)`\n\t *\n\t * Define the property `key` on the prototype of the constructor `cls` using the symbolic\n\t * property [can-symbol/symbols/defineInstanceKey @@can.defineInstanceKey] if it exists; otherwise\n\t * use `Object.defineProperty()` to define the property.  The property definition\n\t *\n\t * @param  {Function} cls  a Constructor function\n\t * @param  {String} key     the String or Symbol key to set.\n\t * @param  {Object} properties a JavaScript property descriptor\n\t */\n\tdefineInstanceKey: function(cls, key, properties) {\n\t\tvar defineInstanceKey = cls[canSymbol.for(\"can.defineInstanceKey\")];\n\t\tif(defineInstanceKey) {\n\t\t\treturn defineInstanceKey.call(cls, key, properties);\n\t\t}\n\t\tvar proto = cls.prototype;\n\t\tdefineInstanceKey = proto[canSymbol.for(\"can.defineInstanceKey\")];\n\t\tif(defineInstanceKey) {\n\t\t\tdefineInstanceKey.call(proto, key, properties);\n\t\t} else {\n\t\t\tObject.defineProperty(\n\t\t\t\tproto,\n\t\t\t\tkey,\n\t\t\t\tshapeReflections.assign({\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: !typeReflections.isSymbolLike(key),\n\t\t\t\t\twritable: true\n\t\t\t\t}, properties)\n\t\t\t);\n\t\t}\n\t}\n};\n\nshapeReflections.isSerializable = shapeReflections.isSerialized;\nshapeReflections.keys = shapeReflections.getOwnEnumerableKeys;\nmodule.exports = shapeReflections;\n","\"use strict\";\nvar canSymbol = require(\"can-symbol\");\nvar typeReflections = require(\"../../type/type\");\nvar getSetReflections = require(\"../../get-set/get-set\");\nvar shapeReflections = require(\"../shape\");\n\nvar getSchemaSymbol = canSymbol.for(\"can.getSchema\"),\n    isMemberSymbol = canSymbol.for(\"can.isMember\"),\n    newSymbol = canSymbol.for(\"can.new\");\n\nfunction comparator(a, b) {\n    return a.localeCompare(b);\n}\n\nfunction sort(obj) {\n    if(typeReflections.isPrimitive(obj)) {\n        return obj;\n    }\n    var out;\n    if (typeReflections.isListLike(obj)) {\n        out = [];\n        shapeReflections.eachKey(obj, function(item){\n            out.push(sort(item));\n        });\n        return out;\n    }\n    if( typeReflections.isMapLike(obj) ) {\n\n        out = {};\n\n        shapeReflections.getOwnKeys(obj).sort(comparator).forEach(function (key) {\n            out[key] = sort( getSetReflections.getKeyValue(obj, key) );\n        });\n\n        return out;\n    }\n\n\n    return obj;\n}\n\nfunction isPrimitiveConverter(Type){\n    return Type === Number || Type === String || Type === Boolean;\n}\n\nvar schemaReflections =  {\n    /**\n\t * @function can-reflect.getSchema getSchema\n\t * @parent can-reflect/shape\n\t * @description Returns the schema for a type or value.\n\t *\n\t * @signature `getSchema(valueOrType)`\n\t *\n     * Calls the `@can.getSchema` property on the `valueOrType` argument. If it's not available and\n     * `valueOrType` has a `constructor` property, calls the `constructor[@can.getSchema]`\n     * and returns the result.\n     *\n     * ```js\n     * import canReflect from \"can-reflect\";\n     *\n     * var Type = DefineMap.extend({\n     *   name: \"string\",\n     *   id: \"number\"\n     * });\n     *\n     * canReflect.getSchema( Type ) //-> {\n     * //   type: \"map\",\n     * //   keys: {\n     * //     name: MaybeString\n     * //     id: MaybeNumber\n     * //   }\n     * // }\n     * ```\n\t *\n\t *\n\t * @param  {Object|Function} valueOrType A value, constructor function, or class to get the schema from.\n\t * @return {Object} A schema. A schema for a [can-reflect.isMapLike] looks like:\n     *\n     *\n     * ```js\n     * {\n     *   type: \"map\",\n     *   identity: [\"id\"],\n     *   keys: {\n     *     id: Number,\n     *     name: String,\n     *     complete: Boolean,\n     *     owner: User\n     *   }\n     * }\n     * ```\n     *\n     * A schema for a list looks like:\n     *\n     * ```js\n     * {\n     *   type: \"list\",\n     *   values: String\n     *   keys: {\n     *     count: Number\n     *   }\n     * }\n     * ```\n     *\n\t */\n    getSchema: function(type){\n        if (type === undefined) {\n            return undefined;\n        }\n        var getSchema = type[getSchemaSymbol];\n        if(getSchema === undefined ) {\n            type = type.constructor;\n            getSchema = type && type[getSchemaSymbol];\n        }\n        return getSchema !== undefined ? getSchema.call(type) : undefined;\n    },\n    /**\n\t * @function can-reflect.getIdentity getIdentity\n\t * @parent can-reflect/shape\n\t * @description Get a unique primitive representing an object.\n\t *\n\t * @signature `getIdentity( object [,schema] )`\n\t *\n\t * This uses the object's schema, or the provided schema to return a unique string or number that\n     * represents the object.\n     *\n     * ```js\n     * import canReflect from \"can-reflect\";\n     *\n     * canReflect.getIdentity({id: 5}, {identity: [\"id\"]}) //-> 5\n     * ```\n     *\n     * If the schema has multiple identity keys, the identity keys and values\n     * are return stringified (and sorted):\n     *\n     * ```js\n     * canReflect.getIdentity(\n     *   {z: \"Z\", a: \"A\", foo: \"bar\"},\n     *   {identity: [\"a\",\"b\"]}) //-> '{\"a\":\"A\",\"b\":\"B\"}'\n     * ```\n\t *\n\t * @param  {Object|Function} object A map-like object.\n     * @param {Object} [schema] A schema object with an `identity` array of the unique\n     * keys of the object like:\n     *   ```js\n     *   {identity: [\"id\"]}\n     *   ```\n\t * @return {Number|String} A value that uniquely represents the object.\n\t */\n    getIdentity: function(value, schema){\n        schema = schema || schemaReflections.getSchema(value);\n        if(schema === undefined) {\n            throw new Error(\"can-reflect.getIdentity - Unable to find a schema for the given value.\");\n        }\n\n        var identity = schema.identity;\n        if(!identity || identity.length === 0) {\n            throw new Error(\"can-reflect.getIdentity - Provided schema lacks an identity property.\");\n        } else if(identity.length === 1) {\n            return getSetReflections.getKeyValue(value, identity[0]);\n        } else {\n            var id = {};\n            identity.forEach(function(key){\n                id[key] = getSetReflections.getKeyValue(value, key);\n            });\n            return JSON.stringify(schemaReflections.cloneKeySort(id));\n        }\n    },\n    /**\n\t * @function can-reflect.cloneKeySort cloneKeySort\n\t * @parent can-reflect/shape\n\t * @description Copy a value while sorting its keys.\n\t *\n\t * @signature `cloneKeySort(value)`\n\t *\n     * `cloneKeySort` returns a copy of `value` with its [can-reflect.isMapLike]\n     * key values sorted. If you just want a copy of a value,\n     * use [can-reflect.serialize].\n     *\n     * ```js\n     * import canRefect from \"can-reflect\";\n     *\n     * canReflect.cloneKeySort({z: \"Z\", a: \"A\"}) //-> {a:\"A\",z:\"Z\"}\n     * ```\n     *\n     * Nested objects are also sorted.\n\t *\n     * This is useful if you need to store a representation of an object that can be used as a\n     * key.\n\t *\n\t * @param  {Object} value An object or array.\n\t * @return {Object} A copy of the object with its keys sorted.\n\t */\n    cloneKeySort: function(obj) {\n        return sort(obj);\n    },\n    /**\n\t * @function can-reflect.convert convert\n\t * @parent can-reflect/shape\n\t * @description Convert one value to another type.\n\t *\n\t * @signature `convert(value, Type)`\n\t *\n     * `convert` attempts to convert `value` to the type specified by `Type`.\n     *\n     * ```js\n     * import canRefect from \"can-reflect\";\n     *\n     * canReflect.convert(\"1\", Number) //-> 1\n     * ```\n     *\n     * `convert` works by performing the following logic:\n     *\n     * 1. If the `Type` is a primitive like `Number`, `String`, `Boolean`, the\n     *    `value` will be passed to the `Type` function and the result returned.\n     *    ```js\n     *    return Type(value);\n     *    ```\n     * 2. The value will be checked if it is already an instance of the type\n     *    by performing the following:\n     *    1. If the `Type` has a `can.isMember` symbol value, that value will be used\n     *       to determine if the `value` is already an instance.\n     *    2. If the `Type` is a [can-reflect.isConstructorLike] function, `instanceof Type`\n     *       will be used to check if `value` is already an instance.\n     * 3. If `value` is already an instance, `value` will be returned.\n     * 4. If `Type` has a `can.new` symbol, `value` will be passed to it and the result\n     *    returned.\n     * 5. If `Type` is a [can-reflect.isConstructorLike] function, `new Type(value)` will be\n     *    called the the result returned.\n     * 6. If `Type` is a regular function, `Type(value)` will be called and the result returned.\n     * 7. If a value hasn't been returned, an error is thrown.\n\t *\n\t * @param  {Object|Primitive} value A value to be converted.\n     * @param  {Object|Function} Type A constructor function or an object that implements the\n     * necessary symbols.\n\t * @return {Object} The `value` converted to a member of `Type`.\n\t */\n    convert: function(value, Type){\n        if(isPrimitiveConverter(Type)) {\n            return Type(value);\n        }\n        // check if value is already a member\n        var isMemberTest = Type[isMemberSymbol],\n            isMember = false,\n            type = typeof Type,\n            createNew = Type[newSymbol];\n        if(isMemberTest !== undefined) {\n            isMember = isMemberTest.call(Type, value);\n        } else if(type === \"function\") {\n            if(typeReflections.isConstructorLike(Type)) {\n                isMember = (value instanceof Type);\n            }\n        }\n        if(isMember) {\n            return value;\n        }\n        if(createNew !== undefined) {\n            return createNew.call(Type, value);\n        } else if(type === \"function\") {\n            if(typeReflections.isConstructorLike(Type)) {\n                return new Type(value);\n            } else {\n                // call it like a normal function\n                return Type(value);\n            }\n        } else {\n            throw new Error(\"can-reflect: Can not convert values into type. Type must provide `can.new` symbol.\");\n        }\n    }\n};\nmodule.exports = schemaReflections;\n","\"use strict\";\nvar canSymbol = require(\"can-symbol\");\nvar typeReflections = require(\"../type/type\");\n\nvar getNameSymbol = canSymbol.for(\"can.getName\");\n\n/**\n * @function {Object, String} can-reflect.setName setName\n * @parent can-reflect/shape\n * @description Set a human-readable name of an object.\n *\n * @signature `setName(obj, value)`\n *\n * ```js\n * var f = function() {};\n *\n * canReflect.setName(f, \"myFunction\")\n * f.name //-> \"myFunction\"\n * ```\n *\n * @param {Object} obj   the object to set on\n * @param {String} value the value to set for the object\n */\nfunction setName(obj, nameGetter) {\n\tif (typeof nameGetter !== \"function\") {\n\t\tvar value = nameGetter;\n\t\tnameGetter = function() {\n\t\t\treturn value;\n\t\t};\n\t}\n\n\tObject.defineProperty(obj, getNameSymbol, {\n\t\tvalue: nameGetter\n\t});\n}\n\n/**\n * @function {Object} can-reflect.getName getName\n * @parent can-reflect/shape\n * @description Get the name of an object.\n *\n * @signature `getValue(obj)`\n *\n * @body\n *\n * The [@@@can.getName](can-symbol/symbols/getName.html) symbol is used to\n * provide objects human readable names; the main goal of these names is to help\n * users get a glance of what the object does and what it is used for.\n *\n * There are no hard rules to define names but CanJS uses the following convention\n * for consistent names across its observable types:\n *\n * - The name starts with the observable constructor name\n * - The constructor name is decorated with the following characters based on its type:\n *\t\t- `<>`: for [value-like](can-reflect.isValueLike.html) observables, e.g: `SimpleObservable<>`\n *\t\t- `[]`: for [list-like](can-reflect.isListLike.html) observables, e.g: `DefineList[]`\n *\t\t- `{}`: for [map-like](can-reflect.isMapLike.html) observables, e.g: `DefineMap{}`\n * - Any property that makes the instance unique (like ids) are printed inside\n *    the chars mentioned before.\n *\n * The example below shows how to implement [@@@can.getName](can-symbol/symbols/getName.html),\n * in a value-like observable (similar to [can-simple-observable]).\n *\n * ```js\n * var canReflect = require(\"can-reflect\");\n *\n * function MySimpleObservable(value) {\n *\t\tthis.value = value;\n * }\n *\n * canReflect.assignSymbols(MySimpleObservable.prototype, {\n *\t\t\"can.getName\": function() {\n *\t\t\t//!steal-remove-start\n *\t\t\tif (process.env.NODE_ENV !== 'production') {\n *\t\t\t\tvar value = JSON.stringify(this.value);\n *\t\t\t\treturn canReflect.getName(this.constructor) + \"<\" + value + \">\";\n *\t\t\t}\n *\t\t\t//!steal-remove-end\n *\t\t}\n * });\n * ```\n *\n * With that in place, `MySimpleObservable` can be used like this:\n *\n * ```js\n * var one = new MySimpleObservable(1);\n * canReflect.getName(one); // MySimpleObservable<1>\n * ```\n *\n * @param  {Object} obj The object to get from\n * @return {String} The human-readable name of the object\n */\nvar anonymousID = 0;\nfunction getName(obj) {\n\tvar type = typeof obj;\n\tif(obj === null || (type !== \"object\" && type !== \"function\")) {\n\t\treturn \"\"+obj;\n\t}\n\tvar nameGetter = obj[getNameSymbol];\n\tif (nameGetter) {\n\t\treturn nameGetter.call(obj);\n\t}\n\n\tif (type === \"function\") {\n\t\tif (!(\"name\" in obj)) {\n\t\t\t// IE doesn't support function.name natively\n\t\t\tobj.name = \"functionIE\" + anonymousID++;\n\t\t}\n\t\treturn obj.name;\n\t}\n\n\tif (obj.constructor && obj !== obj.constructor) {\n\t\tvar parent = getName(obj.constructor);\n\t\tif (parent) {\n\t\t\tif (typeReflections.isValueLike(obj)) {\n\t\t\t\treturn parent + \"<>\";\n\t\t\t}\n\n\t\t\tif (typeReflections.isMoreListLikeThanMapLike(obj)) {\n\t\t\t\treturn parent + \"[]\";\n\t\t\t}\n\n\t\t\tif (typeReflections.isMapLike(obj)) {\n\t\t\t\treturn parent + \"{}\";\n\t\t\t}\n\t\t}\n\t}\n\n\treturn undefined;\n}\n\nmodule.exports = {\n\tsetName: setName,\n\tgetName: getName\n};\n","\"use strict\";\nvar shape = require(\"../reflections/shape/shape\");\nvar CanSymbol = require(\"can-symbol\");\n\nfunction keysPolyfill() {\n  var keys = [];\n  var currentIndex = 0;\n\n  this.forEach(function(val, key) { // jshint ignore:line\n    keys.push(key);\n  });\n\n  return {\n    next: function() {\n      return {\n        value: keys[currentIndex],\n        done: (currentIndex++ === keys.length)\n      };\n    }\n  };\n}\n\nif (typeof Map !== \"undefined\") {\n  shape.assignSymbols(Map.prototype, {\n    \"can.getOwnEnumerableKeys\": Map.prototype.keys,\n    \"can.setKeyValue\": Map.prototype.set,\n    \"can.getKeyValue\": Map.prototype.get,\n    \"can.deleteKeyValue\": Map.prototype[\"delete\"],\n    \"can.hasOwnKey\": Map.prototype.has\n  });\n\n  if (typeof Map.prototype.keys !== \"function\") {\n    Map.prototype.keys = Map.prototype[CanSymbol.for(\"can.getOwnEnumerableKeys\")] = keysPolyfill;\n  }\n}\n\nif (typeof WeakMap !== \"undefined\") {\n  shape.assignSymbols(WeakMap.prototype, {\n    \"can.getOwnEnumerableKeys\": function() {\n      throw new Error(\"can-reflect: WeakMaps do not have enumerable keys.\");\n    },\n    \"can.setKeyValue\": WeakMap.prototype.set,\n    \"can.getKeyValue\": WeakMap.prototype.get,\n    \"can.deleteKeyValue\": WeakMap.prototype[\"delete\"],\n    \"can.hasOwnKey\": WeakMap.prototype.has\n  });\n}\n","\"use strict\";\nvar shape = require(\"../reflections/shape/shape\");\nvar CanSymbol = require(\"can-symbol\");\n\nif (typeof Set !== \"undefined\") {\n  shape.assignSymbols(Set.prototype, {\n    \"can.isMoreListLikeThanMapLike\": true,\n    \"can.updateValues\": function(index, removing, adding) {\n      if (removing !== adding) {\n        shape.each(\n          removing,\n          function(value) {\n            this.delete(value);\n          },\n          this\n        );\n      }\n      shape.each(\n        adding,\n        function(value) {\n          this.add(value);\n        },\n        this\n      );\n    },\n    \"can.size\": function() {\n      return this.size;\n    }\n  });\n\n  // IE11 doesn't support Set.prototype[@@iterator]\n  if (typeof Set.prototype[CanSymbol.iterator] !== \"function\") {\n\t  Set.prototype[CanSymbol.iterator] = function() {\n\t\t  var arr = [];\n\t\t  var currentIndex = 0;\n\n\t\t  this.forEach(function(val) {\n\t\t\t  arr.push(val);\n\t\t  });\n\n\t\t  return {\n\t\t\t  next: function() {\n\t\t\t\t  return {\n\t\t\t\t\t  value: arr[currentIndex],\n\t\t\t\t\t  done: (currentIndex++ === arr.length)\n\t\t\t\t  };\n\t\t\t  }\n\t\t  };\n\t  };\n  }\n}\nif (typeof WeakSet !== \"undefined\") {\n  shape.assignSymbols(WeakSet.prototype, {\n    \"can.isListLike\": true,\n    \"can.isMoreListLikeThanMapLike\": true,\n    \"can.updateValues\": function(index, removing, adding) {\n      if (removing !== adding) {\n        shape.each(\n          removing,\n          function(value) {\n            this.delete(value);\n          },\n          this\n        );\n      }\n      shape.each(\n        adding,\n        function(value) {\n          this.add(value);\n        },\n        this\n      );\n    },\n    \"can.size\": function() {\n      throw new Error(\"can-reflect: WeakSets do not have enumerable keys.\");\n    }\n  });\n}\n","\"use strict\";\nvar functionReflections = require(\"./reflections/call/call\");\nvar getSet = require(\"./reflections/get-set/get-set\");\nvar observe = require(\"./reflections/observe/observe\");\nvar shape = require(\"./reflections/shape/shape\");\nvar schema = require(\"./reflections/shape/schema/schema\");\nvar type = require(\"./reflections/type/type\");\nvar getName = require(\"./reflections/get-name/get-name\");\nvar namespace = require(\"can-namespace\");\n\nvar reflect = {};\n[\n\tfunctionReflections,\n\tgetSet,\n\tobserve,\n\tshape,\n\ttype,\n\tgetName,\n\tschema\n].forEach(function(reflections){\n\tfor(var prop in reflections) {\n\t\treflect[prop] = reflections[prop];\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tif(typeof reflections[prop] === \"function\") {\n\t\t\t\tvar propDescriptor = Object.getOwnPropertyDescriptor(reflections[prop], 'name');\n\t\t\t\tif (!propDescriptor || propDescriptor.writable && propDescriptor.configurable) {\n\t\t\t\t\tObject.defineProperty(reflections[prop],\"name\",{\n\t\t\t\t\t\tvalue: \"canReflect.\"+prop\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t}\n});\n\nrequire(\"./types/map\");\nrequire(\"./types/set\");\n\nmodule.exports = namespace.Reflect = reflect;\n"],"names":["makeGetFirstSymbolValue","symbolNames","symbols","map","name","canSymbol","for","length","obj","index","undefined","hasLength","list","type","Array","isArray","plainFunctionPrototypePropertyNames","Object","getOwnPropertyNames","prototype","plainFunctionPrototypeProto","getPrototypeOf","isConstructorLike","func","value","propertyNames","i","len","getNewOrApply","helpers","isFunctionLike","result","symbolValue","isPrimitive","coreHasOwn","hasOwnProperty","funcToString","Function","toString","objectCtorString","call","isPlainObject","proto","Constructor","constructor","isBuiltIn","indexOf","isValueLike","isMapLike","onValueSymbol","onKeyValueSymbol","onPatchesSymbol","isObservableLike","Boolean","isListLike","iterator","isSymbolLike","supportsSymbols","Symbol","symbol","symbolStart","substr","isMoreListLikeThanMapLike","this","isIteratorLike","next","isPromise","Promise","context","args","slice","arguments","apply","new","makeNew","create","ret","typeReflections","setKeyValueSymbol","getKeyValueSymbol","getValueSymbol","setValueSymbol","reflections","setKeyValue","key","defineProperty","enumerable","configurable","writable","getKeyValue","deleteKeyValue","getValue","setValue","item","Error","splice","removing","adding","howMany","updateValues","concat","addValues","add","push","removeValues","forEach","get","set","makeFallback","symbolName","fallbackName","event","handler","queueName","method","makeErrorIfMissing","errorMessage","ArrayMap","shapeReflections","onKeyValue","offKeyValue","onKeys","onKeysAdded","onKeysRemoved","getKeyDependencies","getWhatIChange","getChangesDependencyRecord","fn","keyHasDependencies","onValue","offValue","getValueDependencies","valueHasDependencies","onPatches","offPatches","onInstancePatches","offInstancePatches","onInstanceBoundChange","offInstanceBoundChange","isBound","onEvent","eventName","callback","queue","addEventListener","offEvent","removeEventListener","setPriority","priority","getPriority","getPrototypeOfWorksWithPrimitives","Map","isEven","num","contents","_getIndex","idx","has","delete","Object_Keys","makeMap","shiftFirstArgumentToThis","shiftedGetKeyValue","getSetReflections","shiftedSetKeyValue","sizeSymbol","hasUpdateSymbol","shouldUpdateOrAssign","isSerializedHelper","keys","e","createSerializeMap","Type","MapType","unwrap","serialize","isSerializing","circularReferenceIsSerializing","makeSerializer","methodName","symbolsToCheck","serializeMap","SerializeOperation","first","end","operation","serializer","oldResult","eachIndex","childValue","eachKey","prop","fastHasOwnKey","hasOwnKey","bind","getOwnEnumerableKeys","addPatch","patches","patch","lastPatch","deleteCount","insert","updateDeepList","target","source","isAssign","sourceArray","toArray","lastIndex","curVal","newVal","assignDeep","updateDeep","patchLen","each","eachListLike","iter","res","done","size","arr","enumerableKeys","getOwnKeys","found","objKey","getOwnKeyDescriptor","getOwnPropertyDescriptor","assignMap","assignList","inserting","assign","assignDeepMap","assignDeepList","updateMap","sourceKeyMap","sourceGetKeyValue","targetSetKeyValue","updateList","update","updateDeepMap","hasKey","__proto__","getAllEnumerableKeys","getAllKeys","assignSymbols","isSerialized","count","defineInstanceKey","cls","properties","isSerializable","getSchemaSymbol","isMemberSymbol","newSymbol","comparator","a","b","localeCompare","sort","out","isPrimitiveConverter","Number","String","schemaReflections","getSchema","getIdentity","schema","identity","id","JSON","stringify","cloneKeySort","convert","isMemberTest","isMember","createNew","getNameSymbol","setName","nameGetter","anonymousID","getName","parent","keysPolyfill","currentIndex","val","shape","can.getOwnEnumerableKeys","can.setKeyValue","can.getKeyValue","can.deleteKeyValue","can.hasOwnKey","CanSymbol","WeakMap","Set","can.isMoreListLikeThanMapLike","can.updateValues","can.size","WeakSet","can.isListLike","reflect","functionReflections","getSet","observe","process","env","NODE_ENV","propDescriptor","namespace","Reflect"],"mappings":"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"}