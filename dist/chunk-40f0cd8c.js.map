{"version":3,"file":"chunk-40f0cd8c.js","sources":["../node_modules/can-view-parser/can-view-parser.js"],"sourcesContent":["\"use strict\";\n/* jshint maxdepth:7,node:true, latedef:false */\nvar namespace = require('can-namespace'),\n\tdev = require('can-log/dev/dev'),\n\tencoder = require('can-attribute-encoder');\n\nfunction each(items, callback){\n\tfor ( var i = 0; i < items.length; i++ ) {\n\t\tcallback(items[i], i);\n\t}\n}\n\nfunction makeMap(str){\n\tvar obj = {}, items = str.split(\",\");\n\teach(items, function(name){\n\t\tobj[name] = true;\n\t});\n\treturn obj;\n}\n\nfunction handleIntermediate(intermediate, handler){\n\tfor(var i = 0, len = intermediate.length; i < len; i++) {\n\t\tvar item = intermediate[i];\n\t\thandler[item.tokenType].apply(handler, item.args);\n\t}\n\treturn intermediate;\n}\n\n//!steal-remove-start\nif (process.env.NODE_ENV !== 'production') {\n\t//assign the function to a var to avoid jshint\n\t//\"Function declarations should not be placed in blocks\"\n\tvar countLines = function countLines(input) {\n\t\t// TODO: optimize?\n\t\treturn input.split('\\n').length - 1;\n\t};\n}\n//!steal-remove-end\n\nvar alphaNumeric = \"A-Za-z0-9\",\n\talphaNumericHU = \"-:_\"+alphaNumeric,\n\tmagicStart = \"{{\",\n\tendTag = new RegExp(\"^<\\\\/([\"+alphaNumericHU+\"]+)[^>]*>\"),\n\tmagicMatch = new RegExp(\"\\\\{\\\\{(![\\\\s\\\\S]*?!|[\\\\s\\\\S]*?)\\\\}\\\\}\\\\}?\",\"g\"),\n\tspace = /\\s/,\n\talphaRegex = new RegExp('['+ alphaNumeric + ']'),\n\tattributeRegexp = new RegExp(\"[\"+alphaNumericHU+\"]+\\s*=\\s*(\\\"[^\\\"]*\\\"|'[^']*')\");\n\n// Empty Elements - HTML 5\nvar empty = makeMap(\"area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed\");\n\n// Elements for which tag case matters - shouldn't be lowercased.\nvar caseMattersElements = makeMap(\"altGlyph,altGlyphDef,altGlyphItem,animateColor,animateMotion,animateTransform,clipPath,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,foreignObject,glyphRef,linearGradient,radialGradient,textPath\");\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar closeSelf = makeMap(\"colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr\");\n\n// Special Elements (can contain anything)\nvar special = makeMap(\"script\");\n\n// Callback names on `handler`.\nvar tokenTypes = \"start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done\".split(\",\");\n\n//maps end characters to start characters\nvar startOppositesMap = {\"{\": \"}\", \"(\":\")\"};\n\nvar fn = function(){};\n\nvar HTMLParser = function (html, handler, returnIntermediate) {\n\tif(typeof html === \"object\") {\n\t\treturn handleIntermediate(html, handler);\n\t}\n\n\tvar intermediate = [];\n\thandler = handler || {};\n\tif(returnIntermediate) {\n\t\t// overwrite handlers so they add to intermediate\n\t\teach(tokenTypes, function(name){\n\t\t\tvar callback = handler[name] || fn;\n\t\t\thandler[name] = function(){\n\t\t\t\tif( callback.apply(this, arguments) !== false ) {\n\t\t\t\t\tvar end = arguments.length;\n\n\t\t\t\t\t// the intermediate is stringified in the compiled stache templates\n\t\t\t\t\t// so we want to trim the last item if it is the line number\n\t\t\t\t\tif (arguments[end - 1] === undefined) {\n\t\t\t\t\t\tend = arguments.length - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\t// but restore line number in dev mode\n\t\t\t\t\t\tend = arguments.length;\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\tintermediate.push({\n\t\t\t\t\t\ttokenType: name,\n\t\t\t\t\t\targs: [].slice.call(arguments, 0, end),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tfunction parseStartTag(tag, tagName, rest, unary) {\n\t\ttagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();\n\n\t\tif (closeSelf[tagName] && stack.last() === tagName) {\n\t\t\tparseEndTag(\"\", tagName);\n\t\t}\n\n\t\tunary = empty[tagName] || !!unary;\n\t\thandler.start(tagName, unary, lineNo);\n\t\tif (!unary) {\n\t\t\tstack.push(tagName);\n\t\t}\n\n\t\t// find attribute or special\n\t\tHTMLParser.parseAttrs(rest, handler, lineNo);\n\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tlineNo += countLines(tag);\n\t\t}\n\t\t//!steal-remove-end\n\n\n\t\thandler.end(tagName, unary, lineNo);\n\n\t}\n\n\tfunction parseEndTag(tag, tagName) {\n\t\t// If no tag name is provided, clean shop\n\t\tvar pos;\n\t\tif (!tagName) {\n\t\t\tpos = 0;\n\t\t}\n\t\t// Find the closest opened tag of the same type\n\t\telse {\n\t\t\ttagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();\n\t\t\tfor (pos = stack.length - 1; pos >= 0; pos--) {\n\t\t\t\tif (stack[pos] === tagName) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tif (typeof tag === 'undefined') {\n\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\tif (handler.filename) {\n\t\t\t\t\t\tdev.warn(handler.filename + \": expected closing tag </\" + stack[pos] + \">\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdev.warn(\"expected closing tag </\" + stack[pos] + \">\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (pos < 0 || pos !== stack.length - 1) {\n\t\t\t\tif (stack.length > 0) {\n\t\t\t\t\tif (handler.filename) {\n\t\t\t\t\t\tdev.warn(handler.filename + \":\" + lineNo + \": unexpected closing tag \" + tag + \" expected </\" + stack[stack.length - 1] + \">\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdev.warn(lineNo + \": unexpected closing tag \" + tag + \" expected </\" + stack[stack.length - 1] + \">\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (handler.filename) {\n\t\t\t\t\t\tdev.warn(handler.filename + \":\" + lineNo + \": unexpected closing tag \" + tag);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdev.warn(lineNo + \": unexpected closing tag \" + tag);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\tif (pos >= 0) {\n\t\t\t// Close all the open elements, up the stack\n\t\t\tfor (var i = stack.length - 1; i >= pos; i--) {\n\t\t\t\tif (handler.close) {\n\t\t\t\t\thandler.close(stack[i], lineNo);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the open elements from the stack\n\t\t\tstack.length = pos;\n\t\t}\n\t}\n\n\tfunction parseMustache(mustache, inside){\n\t\tif(handler.special){\n\t\t\thandler.special(inside, lineNo);\n\t\t}\n\t}\n\n\tvar callChars = function(){\n\t\tif(charsText) {\n\t\t\tif(handler.chars) {\n\t\t\t\thandler.chars(charsText, lineNo);\n\t\t\t}\n\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tlineNo += countLines(charsText);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t}\n\n\t\tcharsText = \"\";\n\t};\n\n\tvar index,\n\t\tchars,\n\t\tmatch,\n\t\tlineNo,\n\t\tstack = [],\n\t\tlast = html,\n\t\t// an accumulating text for the next .chars callback\n\t\tcharsText = \"\";\n\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tlineNo = 1;\n\t}\n\t//!steal-remove-end\n\n\tstack.last = function () {\n\t\treturn this[this.length - 1];\n\t};\n\n\twhile (html) {\n\n\t\tchars = true;\n\n\t\t// Make sure we're not in a script or style element\n\t\tif (!stack.last() || !special[stack.last()]) {\n\n\t\t\t// Comment\n\t\t\tif (html.indexOf(\"<!--\") === 0) {\n\t\t\t\tindex = html.indexOf(\"-->\");\n\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\tif (handler.comment) {\n\t\t\t\t\t\thandler.comment(html.substring(4, index), lineNo);\n\t\t\t\t\t}\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\tlineNo += countLines(html.substring(0, index + 3));\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\thtml = html.substring(index + 3);\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t\t// end tag\n\t\t\t} else if (html.indexOf(\"</\") === 0) {\n\t\t\t\tmatch = html.match(endTag);\n\n\t\t\t\tif (match) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\tmatch[0].replace(endTag, parseEndTag);\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\tlineNo += countLines(html.substring(0, match[0].length));\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\thtml = html.substring(match[0].length);\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t\t// start tag\n\t\t\t} else if (html.indexOf(\"<\") === 0) {\n\t\t\t\tvar res = HTMLParser.searchStartTag(html);\n\n\t\t\t\tif(res) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\tparseStartTag.apply(null, res.match);\n\n\t\t\t\t\thtml = res.html;\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\n\t\t\t\t// magic tag\n\t\t\t} else if (html.indexOf(magicStart) === 0 ) {\n\t\t\t\tmatch = html.match(magicMatch);\n\n\t\t\t\tif (match) {\n\t\t\t\t\tcallChars();\n\t\t\t\t\tmatch[0].replace(magicMatch, parseMustache);\n\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\tlineNo += countLines(html.substring(0, match[0].length));\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\n\t\t\t\t\thtml = html.substring(match[0].length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (chars) {\n\t\t\t\tindex = findBreak(html, magicStart);\n\t\t\t\tif(index === 0 && html === last) {\n\t\t\t\t\tcharsText += html.charAt(0);\n\t\t\t\t\thtml = html.substr(1);\n\t\t\t\t\tindex = findBreak(html, magicStart);\n\t\t\t\t}\n\n\t\t\t\tvar text = index < 0 ? html : html.substring(0, index);\n\t\t\t\thtml = index < 0 ? \"\" : html.substring(index);\n\n\t\t\t\tif (text) {\n\t\t\t\t\tcharsText += text;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\thtml = html.replace(new RegExp(\"([\\\\s\\\\S]*?)<\\/\" + stack.last() + \"[^>]*>\"), function (all, text) {\n\t\t\t\ttext = text.replace(/<!--([\\s\\S]*?)-->|<!\\[CDATA\\[([\\s\\S]*?)]]>/g, \"$1$2\");\n\t\t\t\tif (handler.chars) {\n\t\t\t\t\thandler.chars(text, lineNo);\n\t\t\t\t}\n\n\t\t\t\t//!steal-remove-start\n\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tlineNo += countLines(text);\n\t\t\t\t}\n\t\t\t\t//!steal-remove-end\n\n\t\t\t\treturn \"\";\n\t\t\t});\n\n\t\t\tparseEndTag(\"\", stack.last());\n\t\t}\n\n\t\tif (html === last) {\n\t\t\tthrow new Error(\"Parse Error: \" + html);\n\t\t}\n\n\t\tlast = html;\n\t}\n\tcallChars();\n\t// Clean up any remaining tags\n\tparseEndTag();\n\n\n\thandler.done(lineNo);\n\treturn intermediate;\n};\n\nvar callAttrStart = function(state, curIndex, handler, rest, lineNo){\n\tvar attrName = rest.substring(typeof state.nameStart === \"number\" ? state.nameStart : curIndex, curIndex),\n\t\tnewAttrName = encoder.encode(attrName);\n\n\tstate.attrStart = newAttrName;\n\thandler.attrStart(state.attrStart, lineNo);\n\tstate.inName = false;\n};\n\nvar callAttrEnd = function(state, curIndex, handler, rest, lineNo){\n\tif(state.valueStart !== undefined && state.valueStart < curIndex) {\n\t\tvar val = rest.substring(state.valueStart, curIndex);\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tvar quotedVal, closedQuote;\n\t\t\tquotedVal = rest.substring(state.valueStart - 1, curIndex + 1);\n\t\t\tquotedVal = quotedVal.trim();\n\t\t\tclosedQuote = quotedVal.charAt(quotedVal.length - 1);\n\t\t\t\n\t\t\tif (state.inQuote !== closedQuote) {\n\t\t\t\tif (handler.filename) {\n\t\t\t\t\tdev.warn(handler.filename + \":\" + lineNo + \": End quote is missing for \" + val);\n\t\t\t\t} else {\n\t\t\t\t\tdev.warn(lineNo + \": End quote is missing for \" + val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t\thandler.attrValue(val, lineNo);\n\t}\n\t// if this never got to be inValue, like `DISABLED` then send a attrValue\n\t// else if(!state.inValue){\n\t// \thandler.attrValue(state.attrStart, lineNo);\n\t// }\n\n\thandler.attrEnd(state.attrStart, lineNo);\n\tstate.attrStart = undefined;\n\tstate.valueStart = undefined;\n\tstate.inValue = false;\n\tstate.inName = false;\n\tstate.lookingForEq = false;\n\tstate.inQuote = false;\n\tstate.lookingForName = true;\n};\n\nvar findBreak = function(str, magicStart) {\n\tvar magicLength = magicStart.length;\n\tfor(var i = 0, len = str.length; i < len; i++) {\n\t\tif(str[i] === \"<\" || str.substr(i, magicLength) === magicStart) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\nHTMLParser.parseAttrs = function(rest, handler, lineNo){\n\tif(!rest) {\n\t\treturn;\n\t}\n\n\tvar i = 0;\n\tvar curIndex;\n\tvar state = {\n\t\tinName: false,\n\t\tnameStart: undefined,\n\t\tinValue: false,\n\t\tvalueStart: undefined,\n\t\tinQuote: false,\n\t\tattrStart: undefined,\n\t\tlookingForName: true,\n\t\tlookingForValue: false,\n\t\tlookingForEq : false\n\t};\n\n\twhile(i < rest.length) {\n\t\tcurIndex = i;\n\t\tvar cur = rest.charAt(i);\n\t\ti++;\n\n\t\tif(magicStart === rest.substr(curIndex, magicStart.length) ) {\n\t\t\tif(state.inValue && curIndex > state.valueStart) {\n\t\t\t\thandler.attrValue(rest.substring(state.valueStart, curIndex), lineNo);\n\t\t\t}\n\t\t\t// `{{#foo}}DISABLED{{/foo}}`\n\t\t\telse if(state.inName && state.nameStart < curIndex) {\n\t\t\t\tcallAttrStart(state, curIndex, handler, rest, lineNo);\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\t\t\t// foo={{bar}}\n\t\t\telse if(state.lookingForValue){\n\t\t\t\tstate.inValue = true;\n\t\t\t}\n\t\t\t// a {{bar}}\n\t\t\telse if(state.lookingForEq && state.attrStart) {\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\n\t\t\tmagicMatch.lastIndex = curIndex;\n\t\t\tvar match = magicMatch.exec(rest);\n\t\t\tif(match) {\n\t\t\t\thandler.special(match[1], lineNo);\n\t\t\t\t// i is already incremented\n\t\t\t\ti = curIndex + (match[0].length);\n\t\t\t\tif(state.inValue) {\n\t\t\t\t\tstate.valueStart = curIndex+match[0].length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(state.inValue) {\n\t\t\tif(state.inQuote) {\n\t\t\t\tif(cur === state.inQuote) {\n\t\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(space.test(cur)) {\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\t\t}\n\t\t// if we hit an = outside a value\n\t\telse if(cur === \"=\" && (state.lookingForEq || state.lookingForName || state.inName)) {\n\t\t\t// if we haven't yet started this attribute `{{}}=foo` case:\n\t\t\tif(!state.attrStart) {\n\t\t\t\tcallAttrStart(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\t\t\tstate.lookingForValue = true;\n\t\t\tstate.lookingForEq = false;\n\t\t\tstate.lookingForName = false;\n\t\t}\n\t\t// if we are currently in a name:\n\t\t//  when the name starts with `{` or `(`\n\t\t//  it isn't finished until the matching end character is found\n\t\t//  otherwise, a space finishes the name\n\t\telse if(state.inName) {\n\t\t\tvar started = rest[ state.nameStart ],\n\t\t\t\t\totherStart, otherOpposite;\n\t\t\tif(startOppositesMap[started] === cur) {\n\t\t\t\t//handle mismatched brackets: `{(})` or `({)}`\n\t\t\t\totherStart = started === \"{\" ? \"(\" : \"{\";\n\t\t\t\totherOpposite = startOppositesMap[otherStart];\n\n\t\t\t\tif(rest[curIndex+1] === otherOpposite){\n\t\t\t\t\tcallAttrStart(state, curIndex+2, handler, rest, lineNo);\n\t\t\t\t\ti++;\n\t\t\t\t}else{\n\t\t\t\t\tcallAttrStart(state, curIndex+1, handler, rest, lineNo);\n\t\t\t\t}\n\n\t\t\t\tstate.lookingForEq = true;\n\t\t\t}\n\t\t\telse if(space.test(cur) && started !== \"{\" && started !== \"(\") {\n\t\t\t\t\tcallAttrStart(state, curIndex, handler, rest, lineNo);\n\t\t\t\t\tstate.lookingForEq = true;\n\t\t\t}\n\t\t}\n\t\telse if(state.lookingForName) {\n\t\t\tif(!space.test(cur)) {\n\t\t\t\t// might have just started a name, we need to close it\n\t\t\t\tif(state.attrStart) {\n\t\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t\t}\n\t\t\t\tstate.nameStart = curIndex;\n\t\t\t\tstate.inName = true;\n\t\t\t}\n\t\t}\n\t\telse if(state.lookingForValue) {\n\t\t\tif(!space.test(cur)) {\n\t\t\t\tstate.lookingForValue = false;\n\t\t\t\tstate.inValue = true;\n\t\t\t\tif(cur === \"'\" || cur === '\"') {\n\t\t\t\t\tstate.inQuote = cur;\n\t\t\t\t\tstate.valueStart = curIndex+1;\n\t\t\t\t} else {\n\t\t\t\t\tstate.valueStart = curIndex;\n\t\t\t\t}\n\t\t\t\t// if we are looking for a value\n\t\t\t\t// at the end of the loop we need callAttrEnd\n\t\t\t} else if (i === rest.length){\n\t\t\t\tcallAttrEnd(state, curIndex, handler, rest, lineNo);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(state.inName) {\n\t\tcallAttrStart(state, curIndex+1, handler, rest, lineNo);\n\t\tcallAttrEnd(state, curIndex+1, handler, rest, lineNo);\n\t} else if(state.lookingForEq || state.lookingForValue || state.inValue) {\n\t\tcallAttrEnd(state, curIndex+1, handler, rest, lineNo);\n\t}\n\tmagicMatch.lastIndex = 0;\n};\n\nHTMLParser.searchStartTag = function (html) {\n\tvar closingIndex = html.indexOf('>');\n\n\t// The first closing bracket we find might be in an attribute value.\n\t// Move through the attributes by regexp.\n\tvar attributeRange = attributeRegexp.exec(html.substring(1));\n\tvar afterAttributeOffset = 1;\n\t// if the closing index is after the next attribute...\n\twhile(attributeRange && closingIndex >= afterAttributeOffset + attributeRange.index) {\n\n\t\t// prepare to move to the attribute after this one by increasing the offset\n\t\tafterAttributeOffset += attributeRange.index + attributeRange[0].length;\n\t\t// if the closing index is before the new offset, then this closing index is inside\n\t\t//  an attribute value and should be ignored.  Find the *next* closing character.\n\t\twhile(closingIndex < afterAttributeOffset) {\n\t\t\tclosingIndex += html.substring(closingIndex + 1).indexOf('>') + 1;\n\t\t}\n\n\t\t// find the next attribute by starting from the new offset.\n\t\tattributeRange = attributeRegexp.exec(html.substring(afterAttributeOffset));\n\t}\n\n\t// if there is no closing bracket\n\t// <input class=\n\t// or if the tagName does not start with alphaNumer character\n\t// <_iaois>\n\t// it is not a startTag\n\tif(closingIndex === -1 || !(alphaRegex.test(html[1]))){\n\t\treturn null;\n\t}\n\n\tvar tagName, tagContent, match, rest = '', unary = '';\n\tvar startTag = html.substring(0, closingIndex + 1);\n\tvar isUnary = startTag[startTag.length-2] === '/';\n\tvar spaceIndex = startTag.search(space);\n\n\tif(isUnary){\n\t\tunary = '/';\n\t\ttagContent = startTag.substring(1, startTag.length-2).trim();\n\t} else {\n\t\ttagContent = startTag.substring(1, startTag.length-1).trim();\n\t}\n\n\tif(spaceIndex === -1){\n\t\ttagName = tagContent;\n\t} else {\n\t\t//spaceIndex needs to shift one to the left\n\t\tspaceIndex--;\n\t\ttagName = tagContent.substring(0, spaceIndex);\n\t\trest = tagContent.substring(spaceIndex);\n\t}\n\n\tmatch = [startTag, tagName, rest, unary];\n\n\treturn {\n\t\tmatch: match,\n\t\thtml: html.substring(startTag.length),\n\t};\n\n\n};\n\nmodule.exports = namespace.HTMLParser = HTMLParser;\n"],"names":["each","items","callback","i","length","makeMap","str","obj","split","name","handleIntermediate","intermediate","handler","len","item","tokenType","apply","args","process","env","NODE_ENV","countLines","input","alphaNumeric","alphaNumericHU","magicStart","endTag","RegExp","magicMatch","space","alphaRegex","attributeRegexp","empty","caseMattersElements","closeSelf","special","tokenTypes","startOppositesMap","{","(","fn","HTMLParser","html","returnIntermediate","parseStartTag","tag","tagName","rest","unary","toLowerCase","stack","last","parseEndTag","start","lineNo","push","parseAttrs","end","pos","filename","dev","warn","close","parseMustache","mustache","inside","this","arguments","undefined","slice","call","index","chars","match","callChars","charsText","replace","all","text","indexOf","comment","substring","res","searchStartTag","findBreak","charAt","substr","Error","done","callAttrStart","state","curIndex","attrName","nameStart","newAttrName","encoder","encode","attrStart","inName","callAttrEnd","valueStart","quotedVal","closedQuote","val","trim","inQuote","attrValue","attrEnd","inValue","lookingForEq","lookingForName","magicLength","lookingForValue","cur","lastIndex","exec","test","otherOpposite","started","closingIndex","attributeRange","afterAttributeOffset","tagContent","startTag","isUnary","spaceIndex","search","namespace"],"mappings":"gPAMA,SAASA,KAAKC,EAAOC,GACpB,IAAM,IAAIC,EAAI,EAAGA,EAAIF,EAAMG,OAAQD,IAClCD,EAASD,EAAME,GAAIA,GAIrB,SAASE,QAAQC,GAChB,IAAIC,EAAM,GAIV,OAHAP,KADsBM,EAAIE,MAAM,KACpB,SAASC,GACpBF,EAAIE,IAAQ,IAENF,EAGR,SAASG,mBAAmBC,EAAcC,GACzC,IAAI,IAAIT,EAAI,EAAGU,EAAMF,EAAaP,OAAQD,EAAIU,EAAKV,IAAK,CACvD,IAAIW,EAAOH,EAAaR,GACxBS,EAAQE,EAAKC,WAAWC,MAAMJ,EAASE,EAAKG,MAE7C,OAAON,EAIR,GAA6B,eAAzBO,UAAQC,IAAIC,SAGf,IAAIC,WAAa,SAAoBC,GAEpC,OAAOA,EAAMd,MAAM,MAAMJ,OAAS,GAKpC,IAAImB,aAAe,YAClBC,eAAiB,MAAMD,aACvBE,WAAa,KACbC,OAAS,IAAIC,OAAO,UAAUH,eAAe,aAC7CI,WAAa,IAAID,OAAO,4CAA4C,KACpEE,MAAQ,KACRC,WAAa,IAAIH,OAAO,IAAKJ,aAAe,KAC5CQ,gBAAkB,IAAIJ,OAAO,IAAIH,eAAe,+BAG7CQ,MAAQ3B,QAAQ,8EAGhB4B,oBAAsB5B,QAAQ,2bAI9B6B,UAAY7B,QAAQ,oDAGpB8B,QAAU9B,QAAQ,UAGlB+B,WAAa,yEAAyE5B,MAAM,KAG5F6B,kBAAoB,CAACC,IAAK,IAAKC,IAAI,KAEnCC,GAAK,aAELC,WAAa,SAAUC,EAAM9B,EAAS+B,GACzC,GAAmB,iBAATD,EACT,OAAOhC,mBAAmBgC,EAAM9B,GAGjC,IAAID,EAAe,GAgCnB,SAASiC,EAAcC,EAAKC,EAASC,EAAMC,GAC1CF,EAAUb,oBAAoBa,GAAWA,EAAUA,EAAQG,cAEvDf,UAAUY,IAAYI,EAAMC,SAAWL,GAC1CM,EAAY,GAAIN,GAGjBE,EAAQhB,MAAMc,MAAcE,EAC5BpC,EAAQyC,MAAMP,EAASE,EAAOM,GACzBN,GACJE,EAAMK,KAAKT,GAIZL,WAAWe,WAAWT,EAAMnC,EAAS0C,GAGR,eAAzBpC,UAAQC,IAAIC,WACfkC,GAAUjC,WAAWwB,IAKtBjC,EAAQ6C,IAAIX,EAASE,EAAOM,GAI7B,SAASF,EAAYP,EAAKC,GAEzB,IAAIY,EACJ,GAAKZ,EAMJ,IADAA,EAAUb,oBAAoBa,GAAWA,EAAUA,EAAQG,cACtDS,EAAMR,EAAM9C,OAAS,EAAGsD,GAAO,GAC/BR,EAAMQ,KAASZ,EADmBY,UALvCA,EAAM,EA2CP,GA9B6B,eAAzBxC,UAAQC,IAAIC,gBACI,IAARyB,EACNK,EAAM9C,OAAS,IACdQ,EAAQ+C,SACXC,IAAIC,KAAKjD,EAAQ+C,SAAW,4BAA8BT,EAAMQ,GAAO,KAGvEE,IAAIC,KAAK,0BAA4BX,EAAMQ,GAAO,OAG1CA,EAAM,GAAKA,IAAQR,EAAM9C,OAAS,KACxC8C,EAAM9C,OAAS,EACdQ,EAAQ+C,SACXC,IAAIC,KAAKjD,EAAQ+C,SAAW,IAAML,EAAS,4BAA8BT,EAAM,eAAiBK,EAAMA,EAAM9C,OAAS,GAAK,KAG1HwD,IAAIC,KAAKP,EAAS,4BAA8BT,EAAM,eAAiBK,EAAMA,EAAM9C,OAAS,GAAK,KAG9FQ,EAAQ+C,SACXC,IAAIC,KAAKjD,EAAQ+C,SAAW,IAAML,EAAS,4BAA8BT,GAGzEe,IAAIC,KAAKP,EAAS,4BAA8BT,KAOhDa,GAAO,EAAG,CAEb,IAAK,IAAIvD,EAAI+C,EAAM9C,OAAS,EAAGD,GAAKuD,EAAKvD,IACpCS,EAAQkD,OACXlD,EAAQkD,MAAMZ,EAAM/C,GAAImD,GAK1BJ,EAAM9C,OAASsD,GAIjB,SAASK,EAAcC,EAAUC,GAC7BrD,EAAQuB,SACVvB,EAAQuB,QAAQ8B,EAAQX,GAxH1B1C,EAAUA,GAAW,GAClB+B,GAEF3C,KAAKoC,WAAY,SAAS3B,GACzB,IAAIP,EAAWU,EAAQH,IAAS+B,GAChC5B,EAAQH,GAAQ,WACf,IAAwC,IAApCP,EAASc,MAAMkD,KAAMC,WAAuB,CAC/C,IAAIV,EAAMU,UAAU/D,YAIOgE,IAAvBD,UAAUV,EAAM,KACnBA,EAAMU,UAAU/D,OAAS,GAIG,eAAzBc,UAAQC,IAAIC,WAEfqC,EAAMU,UAAU/D,QAIjBO,EAAa4C,KAAK,CACjBxC,UAAWN,EACXQ,KAAM,GAAGoD,MAAMC,KAAKH,UAAW,EAAGV,SAoGvC,IAgBIc,EACHC,EACAC,EACAnB,EAnBGoB,EAAY,WACZC,IACC/D,EAAQ4D,OACV5D,EAAQ4D,MAAMG,EAAWrB,GAIG,eAAzBpC,UAAQC,IAAIC,WACfkC,GAAUjC,WAAWsD,KAKvBA,EAAY,IAOZzB,EAAQ,GACRC,EAAOT,EAEPiC,EAAY,GAYb,IAT6B,eAAzBzD,UAAQC,IAAIC,WACfkC,EAAS,GAIVJ,EAAMC,KAAO,WACZ,OAAOe,KAAKA,KAAK9D,OAAS,IAGpBsC,GAAM,CAKZ,GAHA8B,GAAQ,EAGHtB,EAAMC,QAAWhB,QAAQe,EAAMC,QAuFnCT,EAAOA,EAAKkC,QAAQ,IAAIjD,OAAO,iBAAoBuB,EAAMC,OAAS,UAAW,SAAU0B,EAAKC,GAY3F,OAXAA,EAAOA,EAAKF,QAAQ,8CAA+C,QAC/DhE,EAAQ4D,OACX5D,EAAQ4D,MAAMM,EAAMxB,GAIQ,eAAzBpC,UAAQC,IAAIC,WACfkC,GAAUjC,WAAWyD,IAIf,KAGR1B,EAAY,GAAIF,EAAMC,YAtGsB,CAG5C,GAA6B,IAAzBT,EAAKqC,QAAQ,YAChBR,EAAQ7B,EAAKqC,QAAQ,YAER,IACZL,IACI9D,EAAQoE,SACXpE,EAAQoE,QAAQtC,EAAKuC,UAAU,EAAGV,GAAQjB,GAId,eAAzBpC,UAAQC,IAAIC,WACfkC,GAAUjC,WAAWqB,EAAKuC,UAAU,EAAGV,EAAQ,KAIhD7B,EAAOA,EAAKuC,UAAUV,EAAQ,GAC9BC,GAAQ,QAIH,GAA2B,IAAvB9B,EAAKqC,QAAQ,OACvBN,EAAQ/B,EAAK+B,MAAM/C,WAGlBgD,IACAD,EAAM,GAAGG,QAAQlD,OAAQ0B,GAGI,eAAzBlC,UAAQC,IAAIC,WACfkC,GAAUjC,WAAWqB,EAAKuC,UAAU,EAAGR,EAAM,GAAGrE,UAIjDsC,EAAOA,EAAKuC,UAAUR,EAAM,GAAGrE,QAC/BoE,GAAQ,QAIH,GAA0B,IAAtB9B,EAAKqC,QAAQ,KAAY,CACnC,IAAIG,EAAMzC,WAAW0C,eAAezC,GAEjCwC,IACFR,IACA9B,EAAc5B,MAAM,KAAMkE,EAAIT,OAE9B/B,EAAOwC,EAAIxC,KACX8B,GAAQ,QAI8B,IAA7B9B,EAAKqC,QAAQtD,cACvBgD,EAAQ/B,EAAK+B,MAAM7C,eAGlB8C,IACAD,EAAM,GAAGG,QAAQhD,WAAYmC,GAGA,eAAzB7C,UAAQC,IAAIC,WACfkC,GAAUjC,WAAWqB,EAAKuC,UAAU,EAAGR,EAAM,GAAGrE,UAIjDsC,EAAOA,EAAKuC,UAAUR,EAAM,GAAGrE,SAIjC,GAAIoE,EAAO,CAEG,KADbD,EAAQa,UAAU1C,EAAMjB,cACNiB,IAASS,IAC1BwB,GAAajC,EAAK2C,OAAO,GACzB3C,EAAOA,EAAK4C,OAAO,GACnBf,EAAQa,UAAU1C,EAAMjB,aAGzB,IAAIqD,EAAOP,EAAQ,EAAI7B,EAAOA,EAAKuC,UAAU,EAAGV,GAChD7B,EAAO6B,EAAQ,EAAI,GAAK7B,EAAKuC,UAAUV,GAEnCO,IACHH,GAAaG,IAuBhB,GAAIpC,IAASS,EACZ,MAAM,IAAIoC,MAAM,gBAAkB7C,GAGnCS,EAAOT,EAQR,OANAgC,IAEAtB,IAGAxC,EAAQ4E,KAAKlC,GACN3C,GAGJ8E,cAAgB,SAASC,EAAOC,EAAU/E,EAASmC,EAAMO,GAC5D,IAAIsC,EAAW7C,EAAKkC,UAAqC,iBAApBS,EAAMG,UAAyBH,EAAMG,UAAYF,EAAUA,GAC/FG,EAAcC,QAAQC,OAAOJ,GAE9BF,EAAMO,UAAYH,EAClBlF,EAAQqF,UAAUP,EAAMO,UAAW3C,GACnCoC,EAAMQ,QAAS,GAGZC,YAAc,SAAST,EAAOC,EAAU/E,EAASmC,EAAMO,GAC1D,QAAwBc,IAArBsB,EAAMU,YAA4BV,EAAMU,WAAaT,EAAU,CACjE,IAGKU,EAAWC,EAHZC,EAAMxD,EAAKkC,UAAUS,EAAMU,WAAYT,GAE3C,GAA6B,eAAzBzE,UAAQC,IAAIC,SAIfkF,GADAD,GADAA,EAAYtD,EAAKkC,UAAUS,EAAMU,WAAa,EAAGT,EAAW,IACtCa,QACEnB,OAAOgB,EAAUjG,OAAS,GAE9CsF,EAAMe,UAAYH,IACjB1F,EAAQ+C,SACXC,IAAIC,KAAKjD,EAAQ+C,SAAW,IAAML,EAAS,8BAAgCiD,GAE3E3C,IAAIC,KAAKP,EAAS,8BAAgCiD,IAKrD3F,EAAQ8F,UAAUH,EAAKjD,GAOxB1C,EAAQ+F,QAAQjB,EAAMO,UAAW3C,GACjCoC,EAAMO,eAAY7B,EAClBsB,EAAMU,gBAAahC,EACnBsB,EAAMkB,SAAU,EAChBlB,EAAMQ,QAAS,EACfR,EAAMmB,cAAe,EACrBnB,EAAMe,SAAU,EAChBf,EAAMoB,gBAAiB,GAGpB1B,UAAY,SAAS9E,EAAKmB,GAE7B,IADA,IAAIsF,EAActF,EAAWrB,OACrBD,EAAI,EAAGU,EAAMP,EAAIF,OAAQD,EAAIU,EAAKV,IACzC,GAAc,MAAXG,EAAIH,IAAcG,EAAIgF,OAAOnF,EAAG4G,KAAiBtF,EACnD,OAAOtB,EAGT,OAAQ,GAGTsC,WAAWe,WAAa,SAAST,EAAMnC,EAAS0C,GAC/C,GAAIP,EAAJ,CAkBA,IAdA,IACI4C,EADAxF,EAAI,EAEJuF,EAAQ,CACXQ,QAAQ,EACRL,eAAWzB,EACXwC,SAAS,EACTR,gBAAYhC,EACZqC,SAAS,EACTR,eAAW7B,EACX0C,gBAAgB,EAChBE,iBAAiB,EACjBH,cAAe,GAGV1G,EAAI4C,EAAK3C,QAAQ,CACtBuF,EAAWxF,EACX,IAAI8G,EAAMlE,EAAKsC,OAAOlF,GAGtB,GAFAA,IAEGsB,aAAesB,EAAKuC,OAAOK,EAAUlE,WAAWrB,QAAU,CACzDsF,EAAMkB,SAAWjB,EAAWD,EAAMU,WACpCxF,EAAQ8F,UAAU3D,EAAKkC,UAAUS,EAAMU,WAAYT,GAAWrC,GAGvDoC,EAAMQ,QAAUR,EAAMG,UAAYF,GACzCF,cAAcC,EAAOC,EAAU/E,EAASmC,EAAMO,GAC9C6C,YAAYT,EAAOC,EAAU/E,EAASmC,EAAMO,IAGrCoC,EAAMsB,gBACbtB,EAAMkB,SAAU,EAGTlB,EAAMmB,cAAgBnB,EAAMO,WACnCE,YAAYT,EAAOC,EAAU/E,EAASmC,EAAMO,GAG7C1B,WAAWsF,UAAYvB,EACvB,IAAIlB,EAAQ7C,WAAWuF,KAAKpE,GACzB0B,IACF7D,EAAQuB,QAAQsC,EAAM,GAAInB,GAE1BnD,EAAIwF,EAAYlB,EAAM,GAAS,OAC5BiB,EAAMkB,UACRlB,EAAMU,WAAaT,EAASlB,EAAM,GAAGrE,cAInC,GAAGsF,EAAMkB,QACVlB,EAAMe,QACLQ,IAAQvB,EAAMe,SAChBN,YAAYT,EAAOC,EAAU/E,EAASmC,EAAMO,GAGtCzB,MAAMuF,KAAKH,IAClBd,YAAYT,EAAOC,EAAU/E,EAASmC,EAAMO,QAIzC,GAAW,MAAR2D,IAAgBvB,EAAMmB,cAAgBnB,EAAMoB,gBAAkBpB,EAAMQ,QAEvER,EAAMO,WACTR,cAAcC,EAAOC,EAAU/E,EAASmC,EAAMO,GAE/CoC,EAAMsB,iBAAkB,EACxBtB,EAAMmB,cAAe,EACrBnB,EAAMoB,gBAAiB,OAMnB,GAAGpB,EAAMQ,OAAQ,CACrB,IACcmB,EADVC,EAAUvE,EAAM2C,EAAMG,WAEvBxD,kBAAkBiF,KAAaL,GAGjCI,EAAgBhF,kBADS,MAAZiF,EAAkB,IAAM,KAGlCvE,EAAK4C,EAAS,KAAO0B,GACvB5B,cAAcC,EAAOC,EAAS,EAAG/E,EAASmC,EAAMO,GAChDnD,KAEAsF,cAAcC,EAAOC,EAAS,EAAG/E,EAASmC,EAAMO,GAGjDoC,EAAMmB,cAAe,GAEdhF,MAAMuF,KAAKH,IAAoB,MAAZK,GAA+B,MAAZA,IAC5C7B,cAAcC,EAAOC,EAAU/E,EAASmC,EAAMO,GAC9CoC,EAAMmB,cAAe,QAGhBnB,EAAMoB,eACTjF,MAAMuF,KAAKH,KAEXvB,EAAMO,WACRE,YAAYT,EAAOC,EAAU/E,EAASmC,EAAMO,GAE7CoC,EAAMG,UAAYF,EAClBD,EAAMQ,QAAS,GAGTR,EAAMsB,kBACTnF,MAAMuF,KAAKH,GAWJ9G,IAAM4C,EAAK3C,QACrB+F,YAAYT,EAAOC,EAAU/E,EAASmC,EAAMO,IAX5CoC,EAAMsB,iBAAkB,EACxBtB,EAAMkB,SAAU,EACL,MAARK,GAAuB,MAARA,GACjBvB,EAAMe,QAAUQ,EAChBvB,EAAMU,WAAaT,EAAS,GAE5BD,EAAMU,WAAaT,IAUpBD,EAAMQ,QACRT,cAAcC,EAAOC,EAAS,EAAG/E,EAASmC,EAAMO,GAChD6C,YAAYT,EAAOC,EAAS,EAAG/E,EAASmC,EAAMO,KACrCoC,EAAMmB,cAAgBnB,EAAMsB,iBAAmBtB,EAAMkB,UAC9DT,YAAYT,EAAOC,EAAS,EAAG/E,EAASmC,EAAMO,GAE/C1B,WAAWsF,UAAY,IAGxBzE,WAAW0C,eAAiB,SAAUzC,GAQrC,IAPA,IAAI6E,EAAe7E,EAAKqC,QAAQ,KAI5ByC,EAAiBzF,gBAAgBoF,KAAKzE,EAAKuC,UAAU,IACrDwC,EAAuB,EAErBD,GAAkBD,GAAgBE,EAAuBD,EAAejD,OAAO,CAMpF,IAHAkD,GAAwBD,EAAejD,MAAQiD,EAAe,GAAGpH,OAG3DmH,EAAeE,GACpBF,GAAgB7E,EAAKuC,UAAUsC,EAAe,GAAGxC,QAAQ,KAAO,EAIjEyC,EAAiBzF,gBAAgBoF,KAAKzE,EAAKuC,UAAUwC,IAQtD,IAAqB,IAAlBF,IAAyBzF,WAAWsF,KAAK1E,EAAK,IAChD,OAAO,KAGR,IAAII,EAAS4E,EAAmB3E,EAAO,GAAIC,EAAQ,GAC/C2E,EAAWjF,EAAKuC,UAAU,EAAGsC,EAAe,GAC5CK,EAA0C,MAAhCD,EAASA,EAASvH,OAAO,GACnCyH,EAAaF,EAASG,OAAOjG,OAoBjC,OAlBG+F,GACF5E,EAAQ,IACR0E,EAAaC,EAAS1C,UAAU,EAAG0C,EAASvH,OAAO,GAAGoG,QAEtDkB,EAAaC,EAAS1C,UAAU,EAAG0C,EAASvH,OAAO,GAAGoG,QAGpC,IAAhBqB,EACF/E,EAAU4E,GAGVG,IACA/E,EAAU4E,EAAWzC,UAAU,EAAG4C,GAClC9E,EAAO2E,EAAWzC,UAAU4C,IAKtB,CACNpD,MAHO,CAACkD,EAAU7E,EAASC,EAAMC,GAIjCN,KAAMA,EAAKuC,UAAU0C,EAASvH,4BAMf2H,UAAUtF,WAAaA"}