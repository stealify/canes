{"version":3,"file":"chunk-615ab838.js","sources":["../node_modules/can-stache/src/key-observable.js","../node_modules/can-stache/src/utils.js","../node_modules/can-stache/expressions/arg.js","../node_modules/can-stache/expressions/literal.js","../node_modules/can-simple-observable/setter/setter.js","../node_modules/can-stache/src/expression-helpers.js","../node_modules/can-stache/expressions/hashes.js","../node_modules/can-stache/expressions/bracket.js","../node_modules/can-stache/src/set-identifier.js","../node_modules/can-stache/expressions/call.js","../node_modules/can-stache/expressions/helper.js","../node_modules/can-stache/expressions/lookup.js","../node_modules/can-stache/src/expression.js"],"sourcesContent":["\"use strict\";\nvar SettableObservable = require(\"can-simple-observable/settable/settable\");\nvar stacheKey = require(\"can-stache-key\");\n\n\nfunction KeyObservable(root, key){\n    key = \"\"+key;\n    this.key = key;\n    this.root = root;\n    SettableObservable.call(this, function(){\n        return stacheKey.get(this,key);\n    }, root);\n}\n\nKeyObservable.prototype = Object.create(SettableObservable.prototype);\n\nKeyObservable.prototype.set = function(newVal) {\n    stacheKey.set(this.root,this.key, newVal);\n};\n\n\nmodule.exports = KeyObservable;\n","\"use strict\";\nvar Scope = require('can-view-scope');\nvar ObservationRecorder = require('can-observation-recorder');\nvar observationReader = require('can-stache-key');\nvar canReflect = require('can-reflect');\nvar KeyObservable = require(\"./key-observable\");\n\nvar canSymbol = require(\"can-symbol\");\nvar isViewSymbol = canSymbol.for(\"can.isView\");\n\n// this creates a noop that marks that a renderer was called\n// this is for situations where a helper function calls a renderer\n// that was not provided such as\n// {{#if false}} ... {{/if}}\n// with no {{else}}\nvar createNoOpRenderer = function (metadata) {\n\treturn function noop() {\n\t\tif (metadata) {\n\t\t\tmetadata.rendered = true;\n\t\t}\n\t};\n};\n\nmodule.exports = {\n\tlast: function(arr){\n\t\treturn arr !=null && arr[arr.length-1];\n\t},\n\t// A generic empty function\n\temptyHandler: function(){},\n\t// Converts a string like \"1\" into 1. \"null\" into null, etc.\n\t// This doesn't have to do full JSON, so removing eval would be good.\n\tjsonParse: function(str){\n\t\t// if it starts with a quote, assume a string.\n\t\tif(str[0] === \"'\") {\n\t\t\treturn str.substr(1, str.length -2);\n\t\t} else if(str === \"undefined\") {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\treturn JSON.parse(str);\n\t\t}\n\t},\n\tmixins: {\n\t\tlast: function(){\n\t\t\treturn this.stack[this.stack.length - 1];\n\t\t},\n\t\tadd: function(chars){\n\t\t\tthis.last().add(chars);\n\t\t},\n\t\tsubSectionDepth: function(){\n\t\t\treturn this.stack.length - 1;\n\t\t}\n\t},\n\t// Sets .fn and .inverse on a helperOptions object and makes sure\n\t// they can reference the current scope and options.\n\tcreateRenderers: function(helperOptions, scope, nodeList, truthyRenderer, falseyRenderer, isStringOnly){\n\t\thelperOptions.fn = truthyRenderer ? this.makeRendererConvertScopes(truthyRenderer, scope, nodeList, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);\n\t\thelperOptions.inverse = falseyRenderer ? this.makeRendererConvertScopes(falseyRenderer, scope, nodeList, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);\n\t\thelperOptions.isSection = !!(truthyRenderer || falseyRenderer);\n\t},\n\t// Returns a new renderer function that makes sure any data or helpers passed\n\t// to it are converted to a can.view.Scope and a can.view.Options.\n\tmakeRendererConvertScopes: function (renderer, parentScope, nodeList, observeObservables, metadata) {\n\t\tvar convertedRenderer = function (newScope, newOptions, parentNodeList) {\n\t\t\t// prevent binding on fn.\n\t\t\t// If a non-scope value is passed, add that to the parent scope.\n\t\t\tif (newScope !== undefined && !(newScope instanceof Scope)) {\n\t\t\t\tif (parentScope) {\n\t\t\t\t\tnewScope = parentScope.add(newScope);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewScope = new Scope(newScope || {});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (metadata) {\n\t\t\t\tmetadata.rendered = true;\n\t\t\t}\n\n\t\t\tvar result = renderer(newScope || parentScope, parentNodeList || nodeList );\n\t\t\treturn result;\n\t\t};\n\t\treturn observeObservables ? convertedRenderer :\n\t\t\tObservationRecorder.ignore(convertedRenderer);\n\t},\n\tmakeView: function(renderer){\n\t\tvar view = ObservationRecorder.ignore(function(scope, nodeList){\n\t\t\tif(!(scope instanceof Scope)) {\n\t\t\t\tscope = new Scope(scope);\n\t\t\t}\n\t\t\treturn renderer(scope, nodeList);\n\t\t});\n\t\tview[isViewSymbol] = true;\n\t\treturn view;\n\t},\n\t// Calls the truthy subsection for each item in a list and returning them in a string.\n\tgetItemsStringContent: function(items, isObserveList, helperOptions){\n\t\tvar txt = \"\",\n\t\t\tlen = observationReader.get(items, 'length'),\n\t\t\tisObservable = canReflect.isObservableLike(items);\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar item = isObservable ? new KeyObservable(items, i) :items[i];\n\t\t\ttxt += helperOptions.fn(item);\n\t\t}\n\t\treturn txt;\n\t},\n\t// Calls the truthy subsection for each item in a list and returns them in a document Fragment.\n\tgetItemsFragContent: function(items, helperOptions, scope) {\n\t\tvar result = [],\n\t\t\tlen = observationReader.get(items, 'length'),\n\t\t\tisObservable = canReflect.isObservableLike(items),\n\t\t\thashExprs = helperOptions.exprData && helperOptions.exprData.hashExprs,\n\t\t\thashOptions;\n\n\t\t// Check if using hash\n\t\tif (canReflect.size(hashExprs) > 0) {\n\t\t\thashOptions = {};\n\t\t\tcanReflect.eachKey(hashExprs, function (exprs, key) {\n\t\t\t\thashOptions[exprs.key] = key;\n\t\t\t});\n\t\t}\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar aliases = {};\n\n\t\t\tvar item = isObservable ? new KeyObservable(items, i) :items[i];\n\n\t\t\tif (canReflect.size(hashOptions) > 0) {\n\t\t\t\tif (hashOptions.value) {\n\t\t\t\t\taliases[hashOptions.value] = item;\n\t\t\t\t}\n\t\t\t\tif (hashOptions.index) {\n\t\t\t\t\taliases[hashOptions.index] = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult.push(helperOptions.fn(\n\t\t\t\tscope\n\t\t\t\t.add(aliases, { notContext: true })\n\t\t\t\t.add({ index: i }, { special: true })\n\t\t\t\t.add(item))\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n};\n","\"use strict\";\n// ### Arg\n// `new Arg(Expression [,modifierOptions] )`\n// Used to identify an expression that should return a value.\nvar Arg = function(expression, modifiers){\n\tthis.expr = expression;\n\tthis.modifiers = modifiers || {};\n\tthis.isCompute = false;\n};\nArg.prototype.value = function(){\n\treturn this.expr.value.apply(this.expr, arguments);\n};\n//!steal-remove-start\nif (process.env.NODE_ENV !== 'production') {\n\tArg.prototype.sourceText = function(){\n\t\treturn (this.modifiers.compute ? \"~\" : \"\")+ this.expr.sourceText();\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Arg;\n","\"use strict\";\n// ### Literal\n// For inline static values like `{{\"Hello World\"}}`\nvar Literal = function(value){\n\tthis._value = value;\n};\nLiteral.prototype.value = function(){\n\treturn this._value;\n};\n//!steal-remove-start\nif (process.env.NODE_ENV !== 'production') {\n\tLiteral.prototype.sourceText = function(){\n\t\treturn JSON.stringify(this._value);\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Literal;\n","\"use strict\";\nvar canReflect = require(\"can-reflect\");\nvar Observation = require(\"can-observation\");\nvar SettableObservable = require(\"../settable/settable\");\nvar valueEventBindings = require(\"can-event-queue/value/value\");\n\n// SetterObservable's call a function when set. Their getter is backed up by an\n// observation.\nfunction SetterObservable(getter, setter) {\n\tthis.setter = setter;\n\tthis.observation = new Observation(getter);\n\tthis.handler = this.handler.bind(this);\n\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tcanReflect.assignSymbols(this, {\n\t\t\t\"can.getName\": function() {\n\t\t\t\treturn (\n\t\t\t\t\tcanReflect.getName(this.constructor) +\n\t\t\t\t\t\"<\" +\n\t\t\t\t\tcanReflect.getName(getter) +\n\t\t\t\t\t\">\"\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.handler, \"name\", {\n\t\t\tvalue: canReflect.getName(this) + \".handler\"\n\t\t});\n\t}\n\t//!steal-remove-end\n}\n\nSetterObservable.prototype = Object.create(SettableObservable.prototype);\nSetterObservable.prototype.constructor = SetterObservable;\nSetterObservable.prototype.set = function(newVal) {\n\tthis.setter(newVal);\n};\nSetterObservable.prototype.hasDependencies = function() {\n\treturn canReflect.valueHasDependencies(this.observation);\n};\ncanReflect.assignSymbols(SetterObservable.prototype, {\n\t\"can.setValue\": SetterObservable.prototype.set,\n\t\"can.valueHasDependencies\": SetterObservable.prototype.hasDependencies\n});\n\nmodule.exports = SetterObservable;\n","\"use strict\";\nvar Arg = require(\"../expressions/arg\");\nvar Literal = require(\"../expressions/literal\");\n\nvar canReflect = require(\"can-reflect\");\nvar stacheKey = require(\"can-stache-key\");\nvar canSymbol = require(\"can-symbol\");\nvar Observation = require(\"can-observation\");\nvar makeComputeLike = require(\"can-view-scope/make-compute-like\");\nvar SetterObservable = require(\"can-simple-observable/setter/setter\");\n\n// ## Helpers\n// Helper for getting a bound compute in the scope.\nfunction getObservableValue_fromKey(key, scope, readOptions) {\n\tvar data = scope.computeData(key, readOptions);\n\n\tObservation.temporarilyBind(data);\n\n\treturn data;\n}\n\nfunction computeHasDependencies(compute){\n\treturn compute[canSymbol.for(\"can.valueHasDependencies\")] ?\n\t\tcanReflect.valueHasDependencies(compute) : compute.computeInstance.hasDependencies;\n}\n\nfunction getObservableValue_fromDynamicKey_fromObservable(key, root, helperOptions, readOptions) {\n\t// This needs to return something similar to a ScopeKeyData with intialValue and parentHasKey\n\tvar getKeys = function(){\n\t\treturn stacheKey.reads((\"\" + canReflect.getValue(key)).replace(/\\./g, \"\\\\.\"));\n\t};\n\tvar parentHasKey;\n\tvar computeValue = new SetterObservable(function getDynamicKey() {\n\t\tvar readData = stacheKey.read( canReflect.getValue(root) , getKeys());\n\t\tparentHasKey = readData.parentHasKey;\n\t\treturn readData.value;\n\t}, function setDynamicKey(newVal){\n\t\tstacheKey.write(canReflect.getValue(root), getKeys(), newVal);\n\t});\n\tObservation.temporarilyBind(computeValue);\n\tcomputeValue.initialValue = canReflect.getValue(computeValue);\n\tcomputeValue.parentHasKey = parentHasKey;\n\treturn computeValue;\n}\n\n// If not a Literal or an Arg, convert to an arg for caching.\nfunction convertToArgExpression(expr) {\n\tif(!(expr instanceof Arg) && !(expr instanceof Literal)) {\n\t\treturn new Arg(expr);\n\t} else {\n\t\treturn expr;\n\t}\n}\n\nfunction toComputeOrValue(value) {\n\t// convert to non observable value\n\tif(canReflect.isObservableLike(value)) {\n\t\t// we only want to do this for things that `should` have dependencies, but dont.\n\t\tif(canReflect.isValueLike(value) && canReflect.valueHasDependencies(value) === false) {\n\t\t\treturn canReflect.getValue(value);\n\t\t}\n\t\t// if compute data\n\t\tif(value.compute) {\n\t\t\treturn value.compute;\n\t\t} else {\n\t\t\treturn makeComputeLike(value);\n\t\t}\n\t}\n\treturn value;\n}\n\n// try to make it a compute no matter what.  This is useful for\n// ~ operator.\nfunction toCompute(value) {\n\tif(value) {\n\n\t\tif(value.isComputed) {\n\t\t\treturn value;\n\t\t}\n\t\tif(value.compute) {\n\t\t\treturn value.compute;\n\t\t} else {\n\t\t\treturn makeComputeLike(value);\n\t\t}\n\t}\n\treturn value;\n}\n\nmodule.exports = {\n\tgetObservableValue_fromKey: getObservableValue_fromKey,\n\tcomputeHasDependencies: computeHasDependencies,\n\tgetObservableValue_fromDynamicKey_fromObservable: getObservableValue_fromDynamicKey_fromObservable,\n\tconvertToArgExpression: convertToArgExpression,\n\ttoComputeOrValue: toComputeOrValue,\n\ttoCompute: toCompute\n};\n","\"use strict\";\nvar canReflect = require(\"can-reflect\");\nvar Observation = require(\"can-observation\");\nvar expressionHelpers = require(\"../src/expression-helpers\");\n\nvar Hashes = function(hashes){\n\tthis.hashExprs = hashes;\n};\nHashes.prototype.value = function(scope, helperOptions){\n\tvar hash = {};\n\tfor(var prop in this.hashExprs) {\n\t\tvar val = expressionHelpers.convertToArgExpression(this.hashExprs[prop]),\n\t\t\tvalue = val.value.apply(val, arguments);\n\n\t\thash[prop] = {\n\t\t\tcall: !val.modifiers || !val.modifiers.compute,\n\t\t\tvalue: value\n\t\t};\n\t}\n\treturn new Observation(function(){\n\t\tvar finalHash = {};\n\t\tfor(var prop in hash) {\n\t\t\tfinalHash[prop] = hash[prop].call ? canReflect.getValue( hash[prop].value ) : expressionHelpers.toComputeOrValue( hash[prop].value );\n\t\t}\n\t\treturn finalHash;\n\t});\n};\n//!steal-remove-start\nif (process.env.NODE_ENV !== 'production') {\n\tHashes.prototype.sourceText = function(){\n\t\tvar hashes = [];\n\t\tcanReflect.eachKey(this.hashExprs, function(expr, prop){\n\t\t\thashes.push( prop+\"=\"+expr.sourceText() );\n\t\t});\n\t\treturn hashes.join(\" \");\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Hashes;\n","\"use strict\";\n//!steal-remove-start\nif (process.env.NODE_ENV !== 'production') {\n\tvar canSymbol = require('can-symbol');\n}\n//!steal-remove-end\nvar expressionHelpers = require(\"../src/expression-helpers\");\n\n// ### Bracket\n// For accessing properties using bracket notation like `foo[bar]`\nvar Bracket = function (key, root, originalKey) {\n\tthis.root = root;\n\tthis.key = key;\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tthis[canSymbol.for(\"can-stache.originalKey\")] = originalKey;\n\t}\n\t//!steal-remove-end\n};\nBracket.prototype.value = function (scope, helpers) {\n\tvar root = this.root ? this.root.value(scope, helpers) : scope.peek(\"this\");\n\treturn expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key.value(scope, helpers), root, scope, helpers, {});\n};\n//!steal-remove-start\nif (process.env.NODE_ENV !== 'production') {\n\tBracket.prototype.sourceText = function(){\n\t\tif(this.rootExpr) {\n\t\t\treturn this.rootExpr.sourceText()+\"[\"+this.key+\"]\";\n\t\t} else {\n\t\t\treturn \"[\"+this.key+\"]\";\n\t\t}\n\t};\n}\n//!steal-remove-end\n\nBracket.prototype.closingTag = function() {\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\treturn this[canSymbol.for('can-stache.originalKey')] || '';\n\t}\n\t//!steal-remove-end\n};\n\nmodule.exports = Bracket;\n","\"use strict\";\nmodule.exports = function SetIdentifier(value){\n\tthis.value = value;\n};\n","\"use strict\";\nvar Hashes = require('./hashes');\nvar SetIdentifier = require(\"../src/set-identifier\");\nvar canSymbol = require(\"can-symbol\");\n\nvar SetterObservable = require(\"can-simple-observable/setter/setter\");\nvar expressionHelpers = require(\"../src/expression-helpers\");\nvar canReflect = require(\"can-reflect\");\nvar assign = require('can-assign');\n\nvar sourceTextSymbol = canSymbol.for(\"can-stache.sourceText\");\nvar isViewSymbol = canSymbol.for(\"can.isView\");\n\n// ### Call\n// `new Call( new Lookup(\"method\"), [new ScopeExpr(\"name\")], {})`\n// A call expression like `method(arg1, arg2)` that, by default,\n// calls `method` with non compute values.\nvar Call = function(methodExpression, argExpressions){\n\tthis.methodExpr = methodExpression;\n\tthis.argExprs = argExpressions.map(expressionHelpers.convertToArgExpression);\n};\nCall.prototype.args = function(scope, ignoreArgLookup) {\n\tvar hashExprs = {};\n\tvar args = [];\n\tvar gotIgnoreFunction = typeof ignoreArgLookup === \"function\";\n\n\tfor (var i = 0, len = this.argExprs.length; i < len; i++) {\n\t\tvar arg = this.argExprs[i];\n\t\tif(arg.expr instanceof Hashes){\n\t\t\tassign(hashExprs, arg.expr.hashExprs);\n\t\t}\n\t\tif (!gotIgnoreFunction || !ignoreArgLookup(i)) {\n\t\t\tvar value = arg.value.apply(arg, arguments);\n\t\t\targs.push({\n\t\t\t\t// always do getValue unless compute is false\n\t\t\t\tcall: !arg.modifiers || !arg.modifiers.compute,\n\t\t\t\tvalue: value\n\t\t\t});\n\t\t}\n\t}\n\treturn function(doNotWrapArguments){\n\t\tvar finalArgs = [];\n\t\tif(canReflect.size(hashExprs) > 0){\n\t\t\tfinalArgs.hashExprs = hashExprs;\n\t\t}\n\t\tfor(var i = 0, len = args.length; i < len; i++) {\n\t\t\tif (doNotWrapArguments) {\n\t\t\t\tfinalArgs[i] = args[i].value;\n\t\t\t} else {\n\t\t\t\tfinalArgs[i] = args[i].call ?\n\t\t\t\t\tcanReflect.getValue( args[i].value ) :\n\t\t\t\t\texpressionHelpers.toCompute( args[i].value );\n\t\t\t}\n\t\t}\n\t\treturn finalArgs;\n\t};\n};\n\nCall.prototype.value = function(scope, helperOptions){\n\tvar callExpression = this;\n\n\t// proxyMethods must be false so that the `requiresOptionsArgument` and any\n\t// other flags stored on the function are preserved\n\tvar method = this.methodExpr.value(scope, { proxyMethods: false }),\n\t\tfunc = canReflect.getValue( method );\n\n\tvar getArgs = callExpression.args(scope , func && func.ignoreArgLookup);\n\n\tvar computeFn = function(newVal){\n\t\tvar func = canReflect.getValue( method );\n\n\t\tif(typeof func === \"function\") {\n\t\t\tvar args = getArgs(\n\t\t\t\tfunc.isLiveBound\n\t\t\t);\n\n\t\t\tif (func.requiresOptionsArgument) {\n\t\t\t\tif(args.hashExprs && helperOptions && helperOptions.exprData){\n\t\t\t\t\thelperOptions.exprData.hashExprs = args.hashExprs;\n\t\t\t\t}\n\t\t\t\t// For #581\n\t\t\t\tif(helperOptions !== undefined) {\n\t\t\t\t\targs.push(helperOptions);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(func[isViewSymbol] === true) {\n\t\t\t\targs.push(helperOptions.nodeList);\n\t\t\t}\n\t\t\tif(arguments.length) {\n\t\t\t\targs.unshift(new SetIdentifier(newVal));\n\t\t\t}\n\n\t\t\t// if this is a call like `foo.bar()` the method.thisArg will be set to `foo`\n\t\t\t// for a call like `foo()`, method.thisArg will not be set and we will default\n\t\t\t// to setting the scope as the context of the function\n\t\t\treturn func.apply(method.thisArg || scope.peek(\"this\"), args);\n\t\t}\n\t};\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tObject.defineProperty(computeFn, \"name\", {\n\t\t\tvalue: \"{{\" + this.sourceText() + \"}}\"\n\t\t});\n\t}\n\t//!steal-remove-end\n\n\tif (helperOptions && helperOptions.doNotWrapInObservation) {\n\t\treturn computeFn();\n\t} else {\n\t\tvar computeValue = new SetterObservable(computeFn, computeFn);\n\n\t\treturn computeValue;\n\t}\n};\n//!steal-remove-start\nif (process.env.NODE_ENV !== 'production') {\n\tCall.prototype.sourceText = function(){\n\t\tvar args = this.argExprs.map(function(arg){\n\t\t\treturn arg.sourceText();\n\t\t});\n\t\treturn this.methodExpr.sourceText()+\"(\"+args.join(\",\")+\")\";\n\t};\n}\n//!steal-remove-end\nCall.prototype.closingTag = function() {\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tif(this.methodExpr[sourceTextSymbol]) {\n\t\t\treturn this.methodExpr[sourceTextSymbol];\n\t\t}\n\t}\n\t//!steal-remove-end\n\treturn this.methodExpr.key;\n};\n\nmodule.exports = Call;\n","\"use strict\";\nvar Literal = require('./literal');\nvar Hashes = require('./hashes');\nvar assign = require('can-assign');\nvar dev = require(\"can-log/dev/dev\");\nvar expressionHelpers = require(\"../src/expression-helpers\");\nvar canReflect = require('can-reflect');\n\nvar Helper = function(methodExpression, argExpressions, hashExpressions){\n\tthis.methodExpr = methodExpression;\n\tthis.argExprs = argExpressions;\n\tthis.hashExprs = hashExpressions;\n\tthis.mode = null;\n};\nHelper.prototype.args = function(scope){\n\tvar args = [];\n\tfor(var i = 0, len = this.argExprs.length; i < len; i++) {\n\t\tvar arg = this.argExprs[i];\n\t\t// TODO: once we know the helper, we should be able to avoid compute conversion\n\t\targs.push( expressionHelpers.toComputeOrValue( arg.value.apply(arg, arguments) ) );\n\t}\n\treturn args;\n};\nHelper.prototype.hash = function(scope){\n\tvar hash = {};\n\tfor(var prop in this.hashExprs) {\n\t\tvar val = this.hashExprs[prop];\n\t\t// TODO: once we know the helper, we should be able to avoid compute conversion\n\t\thash[prop] = expressionHelpers.toComputeOrValue( val.value.apply(val, arguments) );\n\t}\n\treturn hash;\n};\n\nHelper.prototype.value = function(scope, helperOptions){\n\t// If a literal, this means it should be treated as a key. But helpers work this way for some reason.\n\t// TODO: fix parsing so numbers will also be assumed to be keys.\n\tvar methodKey = this.methodExpr instanceof Literal ?\n\t\t\"\" + this.methodExpr._value :\n\t\tthis.methodExpr.key,\n\t\thelperInstance = this,\n\t\t// proxyMethods must be false so that the `requiresOptionsArgument` and any\n\t\t// other flags stored on the function are preserved\n\t\thelperFn = expressionHelpers.getObservableValue_fromKey(methodKey, scope, { proxyMethods: false }),\n\t\tinitialValue = helperFn && helperFn.initialValue,\n\t\tthisArg = helperFn && helperFn.thisArg;\n\n\tif (typeof initialValue === \"function\") {\n\t\thelperFn = function helperFn() {\n\t\t\tvar args = helperInstance.args(scope),\n\t\t\t\thelperOptionArg = assign(assign({}, helperOptions), {\n\t\t\t\t\thash: helperInstance.hash(scope),\n\t\t\t\t\texprData: helperInstance\n\t\t\t\t});\n\n\t\t\targs.push(helperOptionArg);\n\n\t\t\treturn initialValue.apply(thisArg || scope.peek(\"this\"), args);\n\t\t};\n\t\t//!steal-remove-start\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\tObject.defineProperty(helperFn, \"name\", {\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: canReflect.getName(this)\n\t\t\t});\n\t\t}\n\t\t//!steal-remove-end\n\t}\n\t//!steal-remove-start\n\telse if (process.env.NODE_ENV !== 'production') {\n\t\tvar filename = scope.peek('scope.filename');\n\t\t\tvar lineNumber = scope.peek('scope.lineNumber');\n\t\t\tdev.warn(\n\t\t\t\t(filename ? filename + ':' : '') +\n\t\t\t\t(lineNumber ? lineNumber + ': ' : '') +\n\t\t\t\t'Unable to find helper \"' + methodKey + '\".');\n\t}\n\t//!steal-remove-end\n\n\treturn  helperFn;\n};\n\nHelper.prototype.closingTag = function() {\n\treturn this.methodExpr.key;\n};\n\n//!steal-remove-start\nif (process.env.NODE_ENV !== 'production') {\n\tHelper.prototype.sourceText = function(){\n\t\tvar text = [this.methodExpr.sourceText()];\n\t\tif(this.argExprs.length) {\n\t\t\ttext.push( this.argExprs.map(function(arg){\n\t\t\t\treturn arg.sourceText();\n\t\t\t}).join(\" \") );\n\t\t}\n\t\tif(canReflect.size(this.hashExprs) > 0){\n\t\t\ttext.push( Hashes.prototype.sourceText.call(this) );\n\t\t}\n\t\treturn text.join(\" \");\n\t};\n}\n//!steal-remove-end\nif (process.env.NODE_ENV !== 'production') {\n\tcanReflect.assignSymbols(Helper.prototype,{\n\t\t\"can.getName\": function() {\n\t\t\treturn canReflect.getName(this.constructor) + \"{{\" + (this.sourceText()) + \"}}\";\n\t\t}\n\t});\n}\n//!steal-remove-end\n\nmodule.exports = Helper;\n","\"use strict\";\nvar expressionHelpers = require(\"../src/expression-helpers\");\nvar canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\nvar sourceTextSymbol = canSymbol.for(\"can-stache.sourceText\");\nvar dev = require(\"can-log/dev/dev\");\nvar observeReader = require(\"can-stache-key\");\n\n// ### Lookup\n// `new Lookup(String, [Expression])`\n// Finds a value in the scope or a helper.\nvar Lookup = function(key, root, sourceText) {\n\tthis.key = key;\n\tthis.rootExpr = root;\n\tcanReflect.setKeyValue(this, sourceTextSymbol, sourceText);\n};\nLookup.prototype.value = function(scope, readOptions){\n\tvar value;\n\n\tif (this.rootExpr) {\n\t\tvalue = expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key, this.rootExpr.value(scope), scope, {}, {});\n\t} else {\n\t\tvalue = expressionHelpers.getObservableValue_fromKey(this.key, scope, readOptions);\n\t}\n\n\t//!steal-remove-start\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tif (typeof value.initialValue === 'undefined' && this.key !== \"debugger\" && !value.parentHasKey) {\n\t\t\tvar filename = scope.peek('scope.filename');\n\t\t\tvar lineNumber = scope.peek('scope.lineNumber');\n\n\t\t\tvar reads = observeReader.reads(this.key);\n\t\t\tvar firstKey = reads[0].key;\n\t\t\tvar key = reads.map(function(read) {\n\t\t\t\treturn read.key + (read.at ? \"()\" : \"\");\n\t\t\t}).join(\".\");\n\t\t\tvar pathsForKey = scope.getPathsForKey(firstKey);\n\t\t\tvar paths = Object.keys( pathsForKey );\n\n\t\t\tvar includeSuggestions = paths.length && !paths.includes(firstKey);\n\n\t\t\tvar warning = [\n\t\t\t\t(filename ? filename + ':' : '') +\n\t\t\t\t\t(lineNumber ? lineNumber + ': ' : '') +\n\t\t\t\t\t'Unable to find key \"' + key + '\".' +\n\t\t\t\t\t(\n\t\t\t\t\t\tincludeSuggestions ?\n\t\t\t\t\t\t\t\" Did you mean\" + (paths.length > 1 ? \" one of these\" : \"\") + \"?\\n\" :\n\t\t\t\t\t\t\t\"\\n\"\n\t\t\t\t\t)\n\t\t\t];\n\n\t\t\tif (includeSuggestions) {\n\t\t\t\tpaths.forEach(function(path) {\n\t\t\t\t\twarning.push('\\t\"' + path + '\" which will read from');\n\t\t\t\t\twarning.push(pathsForKey[path]);\n\t\t\t\t\twarning.push(\"\\n\");\n\t\t\t\t});\n\t\t\t}\n\n\t\t\twarning.push(\"\\n\");\n\n\t\t\tdev.warn.apply(dev,\n\t\t\t\twarning\n\t\t\t);\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\treturn value;\n};\n//!steal-remove-start\nif (process.env.NODE_ENV !== 'production') {\n\tLookup.prototype.sourceText = function(){\n\t\tif(this[sourceTextSymbol]) {\n\t\t\treturn this[sourceTextSymbol];\n\t\t} else if(this.rootExpr) {\n\t\t\treturn this.rootExpr.sourceText()+\".\"+this.key;\n\t\t} else {\n\t\t\treturn this.key;\n\t\t}\n\t};\n}\n//!steal-remove-end\n\nmodule.exports = Lookup;\n","\"use strict\";\n// ## Expression Types\n//\n// These expression types return a value. They are assembled by `expression.parse`.\nvar Arg = require(\"../expressions/arg\");\nvar Literal = require(\"../expressions/literal\");\nvar Hashes = require(\"../expressions/hashes\");\nvar Bracket = require(\"../expressions/bracket\");\nvar Call = require(\"../expressions/call\");\nvar Helper = require(\"../expressions/helper\");\nvar Lookup = require(\"../expressions/lookup\");\n\nvar SetIdentifier = require(\"./set-identifier\");\nvar expressionHelpers = require(\"../src/expression-helpers\");\n\nvar utils = require('./utils');\nvar assign = require('can-assign');\nvar last = utils.last;\nvar canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\n\nvar sourceTextSymbol = canSymbol.for(\"can-stache.sourceText\");\n\n// ### Hash\n// A placeholder. This isn't actually used.\nvar Hash = function(){ }; // jshint ignore:line\n\n// NAME - \\w\n// KEY - foo, foo.bar, foo@bar, %foo (special), &foo (references), ../foo, ./foo\n// ARG - ~KEY, KEY, CALLEXPRESSION, PRIMITIVE\n// CALLEXPRESSION = KEY(ARG,ARG, NAME=ARG)\n// HELPEREXPRESSION = KEY ARG ARG NAME=ARG\n// DOT .NAME\n// AT @NAME\n//\nvar keyRegExp = /[\\w\\.\\\\\\-_@\\/\\&%]+/,\n\ttokensRegExp = /('.*?'|\".*?\"|=|[\\w\\.\\\\\\-_@\\/*%\\$]+|[\\(\\)]|,|\\~|\\[|\\]\\s*|\\s*(?=\\[))/g,\n\tbracketSpaceRegExp = /\\]\\s+/,\n\tliteralRegExp = /^('.*?'|\".*?\"|-?[0-9]+\\.?[0-9]*|true|false|null|undefined)$/;\n\nvar isTokenKey = function(token){\n\treturn keyRegExp.test(token);\n};\n\nvar testDot = /^[\\.@]\\w/;\nvar isAddingToExpression = function(token) {\n\n\treturn isTokenKey(token) && testDot.test(token);\n};\n\nvar ensureChildren = function(type) {\n\tif(!type.children) {\n\t\ttype.children = [];\n\t}\n\treturn type;\n};\n\nvar Stack = function(){\n\n\tthis.root = {children: [], type: \"Root\"};\n\tthis.current = this.root;\n\tthis.stack = [this.root];\n};\nassign(Stack.prototype,{\n\ttop: function(){\n\t\treturn last(this.stack);\n\t},\n\tisRootTop: function(){\n\t\treturn this.top() === this.root;\n\t},\n\tpopTo: function(types){\n\t\tthis.popUntil(types);\n\t\tthis.pop();\n\t},\n\tpop: function() {\n\t\tif(!this.isRootTop()) {\n\t\t\tthis.stack.pop();\n\t\t}\n\t},\n\tfirst: function(types){\n\t\tvar curIndex = this.stack.length - 1;\n\t\twhile( curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1 ) {\n\t\t\tcurIndex--;\n\t\t}\n\t\treturn this.stack[curIndex];\n\t},\n\tfirstParent: function(types){\n\t\tvar curIndex = this.stack.length - 2;\n\t\twhile( curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1 ) {\n\t\t\tcurIndex--;\n\t\t}\n\t\treturn this.stack[curIndex];\n\t},\n\tpopUntil: function(types){\n\t\twhile( types.indexOf(this.top().type) === -1 && !this.isRootTop() ) {\n\t\t\tthis.stack.pop();\n\t\t}\n\t\treturn this.top();\n\t},\n\taddTo: function(types, type){\n\t\tvar cur = this.popUntil(types);\n\t\tensureChildren(cur).children.push(type);\n\t},\n\taddToAndPush: function(types, type){\n\t\tthis.addTo(types, type);\n\t\tthis.stack.push(type);\n\t},\n\tpush: function(type) {\n\t\tthis.stack.push(type);\n\t},\n\ttopLastChild: function(){\n\t\treturn last(this.top().children);\n\t},\n\treplaceTopLastChild: function(type){\n\t\tvar children = ensureChildren(this.top()).children;\n\t\tchildren.pop();\n\t\tchildren.push(type);\n\t\treturn type;\n\t},\n\treplaceTopLastChildAndPush: function(type) {\n\t\tthis.replaceTopLastChild(type);\n\t\tthis.stack.push(type);\n\t},\n\treplaceTopAndPush: function(type){\n\t\tvar children;\n\t\tif(this.top() === this.root) {\n\t\t\tchildren = ensureChildren(this.top()).children;\n\t\t} else {\n\t\t\tthis.stack.pop();\n\t\t\t// get parent and clean\n\t\t\tchildren = ensureChildren(this.top()).children;\n\t\t}\n\n\t\tchildren.pop();\n\t\tchildren.push(type);\n\t\tthis.stack.push(type);\n\t\treturn type;\n\t}\n});\n\n// converts\n// - \"../foo\" -> \"../@foo\",\n// - \"foo\" -> \"@foo\",\n// - \".foo\" -> \"@foo\",\n// - \"./foo\" -> \"./@foo\"\n// - \"foo.bar\" -> \"foo@bar\"\nvar convertKeyToLookup = function(key){\n\tvar lastPath = key.lastIndexOf(\"./\");\n\tvar lastDot = key.lastIndexOf(\".\");\n\tif(lastDot > lastPath) {\n\t\treturn key.substr(0, lastDot)+\"@\"+key.substr(lastDot+1);\n\t}\n\tvar firstNonPathCharIndex = lastPath === -1 ? 0 : lastPath+2;\n\tvar firstNonPathChar = key.charAt(firstNonPathCharIndex);\n\tif(firstNonPathChar === \".\" || firstNonPathChar === \"@\" ) {\n\t\treturn key.substr(0, firstNonPathCharIndex)+\"@\"+key.substr(firstNonPathCharIndex+1);\n\t} else {\n\t\treturn key.substr(0, firstNonPathCharIndex)+\"@\"+key.substr(firstNonPathCharIndex);\n\t}\n};\nvar convertToAtLookup = function(ast){\n\tif(ast.type === \"Lookup\") {\n\t\tcanReflect.setKeyValue(ast, sourceTextSymbol, ast.key);\n\t\tast.key = convertKeyToLookup(ast.key);\n\t}\n\treturn ast;\n};\n\nvar convertToHelperIfTopIsLookup = function(stack){\n\tvar top = stack.top();\n\t// if two scopes, that means a helper\n\tif(top && top.type === \"Lookup\") {\n\n\t\tvar base = stack.stack[stack.stack.length - 2];\n\t\t// That lookup shouldn't be part of a Helper already or\n\t\tif(base.type !== \"Helper\" && base) {\n\t\t\tstack.replaceTopAndPush({\n\t\t\t\ttype: \"Helper\",\n\t\t\t\tmethod: top\n\t\t\t});\n\t\t}\n\t}\n};\n\nvar expression = {\n\ttoComputeOrValue: expressionHelpers.toComputeOrValue,\n\tconvertKeyToLookup: convertKeyToLookup,\n\n\tLiteral: Literal,\n\tLookup: Lookup,\n\tArg: Arg,\n\tHash: Hash,\n\tHashes: Hashes,\n\tCall: Call,\n\tHelper: Helper,\n\tBracket: Bracket,\n\n\tSetIdentifier: SetIdentifier,\n\ttokenize: function(expression){\n\t\tvar tokens = [];\n\t\t(expression.trim() + ' ').replace(tokensRegExp, function (whole, arg) {\n\t\t\tif (bracketSpaceRegExp.test(arg)) {\n\t\t\t\ttokens.push(arg[0]);\n\t\t\t\ttokens.push(arg.slice(1));\n\t\t\t} else {\n\t\t\t\ttokens.push(arg);\n\t\t\t}\n\t\t});\n\t\treturn tokens;\n\t},\n\tlookupRules: {\n\t\t\"default\": function(ast, methodType, isArg){\n\t\t\treturn ast.type === \"Helper\" ? Helper : Lookup;\n\t\t},\n\t\t\"method\": function(ast, methodType, isArg){\n\t\t\treturn Lookup;\n\t\t}\n\t},\n\tmethodRules: {\n\t\t\"default\": function(ast){\n\t\t\treturn ast.type === \"Call\" ? Call : Helper;\n\t\t},\n\t\t\"call\": function(ast){\n\t\t\treturn Call;\n\t\t}\n\t},\n\t// ## expression.parse\n\t//\n\t// - {String} expressionString - A stache expression like \"abc foo()\"\n\t// - {Object} options\n\t//   - baseMethodType - Treat this like a Helper or Call.  Default to \"Helper\"\n\t//   - lookupRule - \"default\" or \"method\"\n\t//   - methodRule - \"default\" or \"call\"\n\tparse: function(expressionString, options){\n\t\toptions =  options || {};\n\t\tvar ast = this.ast(expressionString);\n\n\t\tif(!options.lookupRule) {\n\t\t\toptions.lookupRule = \"default\";\n\t\t}\n\t\tif(typeof options.lookupRule === \"string\") {\n\t\t\toptions.lookupRule = expression.lookupRules[options.lookupRule];\n\t\t}\n\t\tif(!options.methodRule) {\n\t\t\toptions.methodRule = \"default\";\n\t\t}\n\t\tif(typeof options.methodRule === \"string\") {\n\t\t\toptions.methodRule = expression.methodRules[options.methodRule];\n\t\t}\n\n\t\tvar expr = this.hydrateAst(ast, options, options.baseMethodType || \"Helper\");\n\n\t\treturn expr;\n\t},\n\thydrateAst: function(ast, options, methodType, isArg){\n\t\tvar hashes;\n\t\tif(ast.type === \"Lookup\") {\n\t\t\tvar LookupRule = options.lookupRule(ast, methodType, isArg);\n\t\t\tvar lookup = new LookupRule(ast.key, ast.root && this.hydrateAst(ast.root, options, methodType), ast[sourceTextSymbol] );\n\t\t\treturn lookup;\n\t\t}\n\t\telse if(ast.type === \"Literal\") {\n\t\t\treturn new Literal(ast.value);\n\t\t}\n\t\telse if(ast.type === \"Arg\") {\n\t\t\treturn new Arg(this.hydrateAst(ast.children[0], options, methodType, isArg),{compute: true});\n\t\t}\n\t\telse if(ast.type === \"Hash\") {\n\t\t\tthrow new Error(\"\");\n\t\t}\n\t\telse if(ast.type === \"Hashes\") {\n\t\t\thashes = {};\n\t\t\tast.children.forEach(function(hash){\n\t\t\t\thashes[hash.prop] = this.hydrateAst( hash.children[0], options, methodType, true );\n\t\t\t}, this);\n\t\t\treturn new Hashes(hashes);\n\t\t}\n\t\telse if(ast.type === \"Call\" || ast.type === \"Helper\") {\n\t\t\t//get all arguments and hashes\n\t\t\thashes = {};\n\t\t\tvar args = [],\n\t\t\t\tchildren = ast.children,\n\t\t\t\tExpressionType = options.methodRule(ast);\n\t\t\tif(children) {\n\t\t\t\tfor(var i = 0 ; i <children.length; i++) {\n\t\t\t\t\tvar child = children[i];\n\t\t\t\t\tif(child.type === \"Hashes\" && ast.type === \"Helper\" &&\n\t\t\t\t\t\t(ExpressionType !== Call)) {\n\n\t\t\t\t\t\tchild.children.forEach(function(hash){\n\t\t\t\t\t\t\thashes[hash.prop] = this.hydrateAst( hash.children[0], options, ast.type, true );\n\t\t\t\t\t\t}, this);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs.push( this.hydrateAst(child, options, ast.type, true) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\treturn new ExpressionType(this.hydrateAst(ast.method, options, ast.type),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\targs, hashes);\n\t\t} else if (ast.type === \"Bracket\") {\n\t\t\tvar originalKey;\n\t\t\t//!steal-remove-start\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\toriginalKey = ast[canSymbol.for(\"can-stache.originalKey\")];\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\treturn new Bracket(\n\t\t\t\tthis.hydrateAst(ast.children[0], options),\n\t\t\t\tast.root ? this.hydrateAst(ast.root, options) : undefined,\n\t\t\t\toriginalKey\n\t\t\t);\n\t\t}\n\t},\n\tast: function(expression){\n\t\tvar tokens = this.tokenize(expression);\n\t\treturn this.parseAst(tokens, {\n\t\t\tindex: 0\n\t\t});\n\t},\n\tparseAst: function(tokens, cursor) {\n\t\t// jshint maxdepth: 6\n\t\tvar stack = new Stack(),\n\t\t\ttop,\n\t\t\tfirstParent,\n\t\t\tlastToken;\n\n\t\twhile(cursor.index < tokens.length) {\n\t\t\tvar token = tokens[cursor.index],\n\t\t\t\tnextToken = tokens[cursor.index+1];\n\n\t\t\tcursor.index++;\n\n\t\t\t// Hash\n\t\t\tif(nextToken === \"=\") {\n\t\t\t\t//convertToHelperIfTopIsLookup(stack);\n\t\t\t\ttop = stack.top();\n\n\t\t\t\t// If top is a Lookup, we might need to convert to a helper.\n\t\t\t\tif(top && top.type === \"Lookup\") {\n\t\t\t\t\t// Check if current Lookup is part of a Call, Helper, or Hash\n\t\t\t\t\t// If it happens to be first within a Call or Root, that means\n\t\t\t\t\t// this is helper syntax.\n\t\t\t\t\tfirstParent = stack.firstParent([\"Call\",\"Helper\",\"Hash\"]);\n\t\t\t\t\tif(firstParent.type === \"Call\" || firstParent.type === \"Root\") {\n\n\t\t\t\t\t\tstack.popUntil([\"Call\"]);\n\t\t\t\t\t\ttop = stack.top();\n\t\t\t\t\t\tstack.replaceTopAndPush({\n\t\t\t\t\t\t\ttype: \"Helper\",\n\t\t\t\t\t\t\tmethod: top.type === \"Root\" ? last(top.children) : top\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfirstParent = stack.first([\"Call\",\"Helper\",\"Hashes\",\"Root\"]);\n\t\t\t\t// makes sure we are adding to Hashes if there already is one\n\t\t\t\t// otherwise we create one.\n\t\t\t\tvar hash = {type: \"Hash\", prop: token};\n\t\t\t\tif(firstParent.type === \"Hashes\") {\n\t\t\t\t\tstack.addToAndPush([\"Hashes\"], hash);\n\t\t\t\t} else {\n\t\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\",\"Root\"], {\n\t\t\t\t\t\ttype: \"Hashes\",\n\t\t\t\t\t\tchildren: [hash]\n\t\t\t\t\t});\n\t\t\t\t\tstack.push(hash);\n\t\t\t\t}\n\t\t\t\tcursor.index++;\n\n\t\t\t}\n\t\t\t// Literal\n\t\t\telse if(literalRegExp.test( token )) {\n\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\t\t\t\t// only add to hash if there's not already a child.\n\t\t\t\tfirstParent = stack.first([\"Helper\", \"Call\", \"Hash\", \"Bracket\"]);\n\t\t\t\tif(firstParent.type === \"Hash\" && (firstParent.children && firstParent.children.length > 0)) {\n\t\t\t\t\tstack.addTo([\"Helper\", \"Call\", \"Bracket\"], {type: \"Literal\", value: utils.jsonParse( token )});\n\t\t\t\t} else if(firstParent.type === \"Bracket\" && (firstParent.children && firstParent.children.length > 0)) {\n\t\t\t\t\tstack.addTo([\"Helper\", \"Call\", \"Hash\"], {type: \"Literal\", value: utils.jsonParse( token )});\n\t\t\t\t} else {\n\t\t\t\t\tstack.addTo([\"Helper\", \"Call\", \"Hash\", \"Bracket\"], {type: \"Literal\", value: utils.jsonParse( token )});\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// Lookup\n\t\t\telse if(keyRegExp.test(token)) {\n\t\t\t\tlastToken = stack.topLastChild();\n\t\t\t\tfirstParent = stack.first([\"Helper\", \"Call\", \"Hash\", \"Bracket\"]);\n\n\t\t\t\t// if we had `foo().bar`, we need to change to a Lookup that looks up from lastToken.\n\t\t\t\tif(lastToken && (lastToken.type === \"Call\" || lastToken.type === \"Bracket\" ) && isAddingToExpression(token)) {\n\t\t\t\t\tstack.replaceTopLastChildAndPush({\n\t\t\t\t\t\ttype: \"Lookup\",\n\t\t\t\t\t\troot: lastToken,\n\t\t\t\t\t\tkey: token.slice(1) // remove leading `.`\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if(firstParent.type === 'Bracket') {\n\t\t\t\t\t// a Bracket expression without children means we have\n\t\t\t\t\t// parsed `foo[` of an expression like `foo[bar]`\n\t\t\t\t\t// so we know to add the Lookup as a child of the Bracket expression\n\t\t\t\t\tif (!(firstParent.children && firstParent.children.length > 0)) {\n\t\t\t\t\t\tstack.addToAndPush([\"Bracket\"], {type: \"Lookup\", key: token});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// check if we are adding to a helper like `eq foo[bar] baz`\n\t\t\t\t\t\t// but not at the `.baz` of `eq foo[bar].baz xyz`\n\t\t\t\t\t\tif(stack.first([\"Helper\", \"Call\", \"Hash\", \"Arg\"]).type === 'Helper' && token[0] !== '.') {\n\t\t\t\t\t\t\tstack.addToAndPush([\"Helper\"], {type: \"Lookup\", key: token});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// otherwise, handle the `.baz` in expressions like `foo[bar].baz`\n\t\t\t\t\t\t\tstack.replaceTopAndPush({\n\t\t\t\t\t\t\t\ttype: \"Lookup\",\n\t\t\t\t\t\t\t\tkey: token.slice(1),\n\t\t\t\t\t\t\t\troot: firstParent\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// if two scopes, that means a helper\n\t\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\n\t\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\", \"Hash\", \"Arg\", \"Bracket\"], {type: \"Lookup\", key: token});\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// Arg\n\t\t\telse if(token === \"~\") {\n\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\", \"Hash\"], {type: \"Arg\", key: token});\n\t\t\t}\n\t\t\t// Call\n\t\t\t// foo[bar()]\n\t\t\telse if(token === \"(\") {\n\t\t\t\ttop = stack.top();\n\t\t\t\tif(top.type === \"Lookup\") {\n\t\t\t\t\tstack.replaceTopAndPush({\n\t\t\t\t\t\ttype: \"Call\",\n\t\t\t\t\t\tmethod: convertToAtLookup(top)\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Unable to understand expression \"+tokens.join(''));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// End Call\n\t\t\telse if(token === \")\") {\n\t\t\t\tstack.popTo([\"Call\"]);\n\t\t\t}\n\t\t\t// End Call argument\n\t\t\telse if(token === \",\") {\n\t\t\t\t// The {{let foo=zed, bar=car}} helper is not in a call\n\t\t\t\t// expression.\n\t\t\t\tvar call = stack.first([\"Call\"]);\n\t\t\t\tif(call.type !== \"Call\") {\n\t\t\t\t\tstack.popUntil([\"Hash\"]);\n\t\t\t\t} else {\n\t\t\t\t\tstack.popUntil([\"Call\"]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// Bracket\n\t\t\telse if(token === \"[\") {\n\t\t\t\ttop = stack.top();\n\t\t\t\tlastToken = stack.topLastChild();\n\n\t\t\t\tif (lastToken && (lastToken.type === \"Call\" || lastToken.type === \"Bracket\"  )  ) {\n\t\t\t\t\tstack.replaceTopAndPush({type: \"Bracket\", root: lastToken});\n\t\t\t\t} else if (top.type === \"Lookup\" || top.type === \"Bracket\") {\n\t\t\t\t\tvar bracket = {type: \"Bracket\", root: top};\n\t\t\t\t\t//!steal-remove-start\n\t\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\t\tcanReflect.setKeyValue(bracket, canSymbol.for(\"can-stache.originalKey\"), top.key);\n\t\t\t\t\t}\n\t\t\t\t\t//!steal-remove-end\n\t\t\t\t\tstack.replaceTopAndPush(bracket);\n\t\t\t\t} else if (top.type === \"Call\") {\n\t\t\t\t\tstack.addToAndPush([\"Call\"], { type: \"Bracket\" });\n\t\t\t\t} else if (top === \" \") {\n\t\t\t\t\tstack.popUntil([\"Lookup\", \"Call\"]);\n\t\t\t\t\tconvertToHelperIfTopIsLookup(stack);\n\t\t\t\t\tstack.addToAndPush([\"Helper\", \"Call\", \"Hash\"], {type: \"Bracket\"});\n\t\t\t\t} else {\n\t\t\t\t\tstack.replaceTopAndPush({type: \"Bracket\"});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// End Bracket\n\t\t\telse if(token === \"]\") {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\telse if(token === \" \") {\n\t\t\t\tstack.push(token);\n\t\t\t}\n\t\t}\n\t\treturn stack.root.children[0];\n\t}\n};\n\nmodule.exports = expression;\n"],"names":["KeyObservable","root","key","this","SettableObservable","call","stacheKey","get","prototype","Object","create","set","newVal","isViewSymbol","canSymbol","for","createNoOpRenderer","metadata","rendered","last","arr","length","emptyHandler","jsonParse","str","substr","JSON","parse","mixins","stack","add","chars","subSectionDepth","createRenderers","helperOptions","scope","nodeList","truthyRenderer","falseyRenderer","isStringOnly","fn","makeRendererConvertScopes","inverse","isSection","renderer","parentScope","observeObservables","convertedRenderer","newScope","newOptions","parentNodeList","undefined","Scope","ObservationRecorder","ignore","makeView","view","getItemsStringContent","items","isObserveList","txt","len","observationReader","isObservable","canReflect","isObservableLike","i","item","getItemsFragContent","hashOptions","result","hashExprs","exprData","size","eachKey","exprs","aliases","value","index","push","notContext","special","Arg","expression","modifiers","expr","isCompute","apply","arguments","process","env","NODE_ENV","sourceText","compute","Literal","_value","stringify","SetterObservable","getter","setter","observation","Observation","handler","bind","assignSymbols","can.getName","getName","constructor","defineProperty","hasDependencies","valueHasDependencies","can.setValue","can.valueHasDependencies","getObservableValue_fromKey","readOptions","data","computeData","temporarilyBind","computeHasDependencies","computeInstance","getObservableValue_fromDynamicKey_fromObservable","parentHasKey","getKeys","reads","getValue","replace","computeValue","readData","read","write","initialValue","convertToArgExpression","toComputeOrValue","isValueLike","makeComputeLike","toCompute","isComputed","Hashes","hashes","hash","prop","val","expressionHelpers","finalHash","join","require$$0","Bracket","originalKey","helpers","peek","rootExpr","closingTag","sourceTextSymbol","Call","methodExpression","argExpressions","methodExpr","argExprs","map","args","ignoreArgLookup","gotIgnoreFunction","arg","assign","doNotWrapArguments","finalArgs","method","proxyMethods","func","getArgs","computeFn","isLiveBound","requiresOptionsArgument","unshift","SetIdentifier","thisArg","doNotWrapInObservation","Helper","hashExpressions","mode","methodKey","helperInstance","helperFn","helperOptionArg","configurable","filename","lineNumber","dev","warn","text","Lookup","setKeyValue","observeReader","firstKey","at","pathsForKey","getPathsForKey","paths","keys","includeSuggestions","includes","warning","forEach","path","utils","Hash","keyRegExp","tokensRegExp","bracketSpaceRegExp","literalRegExp","isTokenKey","token","test","testDot","isAddingToExpression","ensureChildren","type","children","Stack","current","top","isRootTop","popTo","types","popUntil","pop","first","curIndex","indexOf","firstParent","addTo","cur","addToAndPush","topLastChild","replaceTopLastChild","replaceTopLastChildAndPush","replaceTopAndPush","convertKeyToLookup","lastPath","lastIndexOf","lastDot","firstNonPathCharIndex","firstNonPathChar","charAt","convertToAtLookup","ast","convertToHelperIfTopIsLookup","base","tokenize","tokens","trim","whole","slice","lookupRules","default","methodType","isArg","methodRules","expressionString","options","lookupRule","methodRule","hydrateAst","baseMethodType","Error","ExpressionType","child","parseAst","cursor","lastToken","nextToken","bracket"],"mappings":"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"}