{"version":3,"file":"chunk-91f0208e.js","sources":["../node_modules/can-bind/can-bind.js"],"sourcesContent":["\"use strict\";\nvar canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\nvar namespace = require(\"can-namespace\");\nvar queues = require(\"can-queues\");\nvar canAssign = require(\"can-assign\");\n\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\tvar canLog = require(\"can-log/dev/dev\");\n\tvar canReflectDeps = require(\"can-reflect-dependencies\");\n}\n//!steal-remove-end\n\n// Symbols\nvar getChangesSymbol = canSymbol.for(\"can.getChangesDependencyRecord\");\nvar getValueSymbol = canSymbol.for(\"can.getValue\");\nvar onValueSymbol = canSymbol.for(\"can.onValue\");\nvar setValueSymbol = canSymbol.for(\"can.setValue\");\n\n// Default implementations for setting the child and parent values\nfunction defaultSetValue(newValue, observable) {\n\tcanReflect.setValue(observable, newValue);\n}\n\n// Given an observable, stop listening to it and tear down the mutation dependencies\nfunction turnOffListeningAndUpdate(listenToObservable, updateObservable, updateFunction, queue) {\n\tif (listenToObservable[onValueSymbol]) {\n\t\tcanReflect.offValue(listenToObservable, updateFunction, queue);\n\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\n\t\t\t// The updateObservable is no longer mutated by listenToObservable\n\t\t\tcanReflectDeps.deleteMutatedBy(updateObservable, listenToObservable);\n\n\t\t\t// The updateFunction no longer mutates anything\n\t\t\tupdateFunction[getChangesSymbol] = function getChangesDependencyRecord() {\n\t\t\t};\n\n\t\t}\n\t\t//!steal-remove-end\n\t}\n}\n\n// Given an observable, start listening to it and set up the mutation dependencies\nfunction turnOnListeningAndUpdate(listenToObservable, updateObservable, updateFunction, queue) {\n\tif (listenToObservable[onValueSymbol]) {\n\t\tcanReflect.onValue(listenToObservable, updateFunction, queue);\n\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\n\t\t\t// The updateObservable is mutated by listenToObservable\n\t\t\tcanReflectDeps.addMutatedBy(updateObservable, listenToObservable);\n\n\t\t\t// The updateFunction mutates updateObservable\n\t\t\tupdateFunction[getChangesSymbol] = function getChangesDependencyRecord() {\n\t\t\t\tvar s = new Set();\n\t\t\t\ts.add(updateObservable);\n\t\t\t\treturn {\n\t\t\t\t\tvalueDependencies: s\n\t\t\t\t};\n\t\t\t};\n\n\t\t}\n\n\t\t//!steal-remove-end\n\t}\n}\n\n// Semaphores are used to keep track of updates to the child & parent\nfunction Semaphore() {\n\tthis.value = 0;\n}\ncanAssign(Semaphore.prototype, {\n\tdecrement: function() {\n\t\tthis.value -= 1;\n\t},\n\tincrement: function() {\n\t\tthis.value += 1;\n\t}\n});\n\nfunction Bind(options) {\n\tthis._options = options;\n\n\t// These parameters must be supplied\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tif (options.child === undefined) {\n\t\t\tthrow new TypeError(\"You must supply a child\");\n\t\t}\n\t\tif (options.parent === undefined) {\n\t\t\tthrow new TypeError(\"You must supply a parent\");\n\t\t}\n\t\tif (options.queue && [\"notify\", \"derive\", \"domUI\"].indexOf(options.queue) === -1) {\n\t\t\tthrow new RangeError(\"Invalid queue; must be one of notify, derive, or domUI\");\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\t// queue; by default, domUI\n\tif (options.queue === undefined) {\n\t\toptions.queue = \"domUI\";\n\t}\n\n\t// cycles: when an observable is set in a two-way binding, it can update the\n\t// other bound observable, which can then update the original observable the\n\t// “cycles” number of times. For example, a child is set and updates the parent;\n\t// with cycles: 0, the parent could not update the child;\n\t// with cycles: 1, the parent could update the child, which can update the parent\n\t// with cycles: 2, the parent can update the child again, and so on and so forth…\n\tif (options.cycles > 0 === false) {\n\t\toptions.cycles = 0;\n\t}\n\n\t// onInitDoNotUpdateChild is false by default\n\toptions.onInitDoNotUpdateChild =\n\t\ttypeof options.onInitDoNotUpdateChild === \"boolean\" ?\n\t\t\toptions.onInitDoNotUpdateChild\n\t\t\t: false;\n\n\t// onInitSetUndefinedParentIfChildIsDefined is true by default\n\toptions.onInitSetUndefinedParentIfChildIsDefined =\n\t\ttypeof options.onInitSetUndefinedParentIfChildIsDefined === \"boolean\" ?\n\t\t\toptions.onInitSetUndefinedParentIfChildIsDefined\n\t\t\t: true;\n\n\t// The way the cycles are tracked is through semaphores; currently, when\n\t// either the child or parent is updated, we increase their respective\n\t// semaphore so that if it’s two-way binding, then the “other” observable\n\t// will only update if the total count for both semaphores is less than or\n\t// equal to twice the number of cycles (because a cycle means two updates).\n\tvar childSemaphore = new Semaphore();\n\tvar parentSemaphore = new Semaphore();\n\n\t// Determine if this is a one-way or two-way binding; by default, accept\n\t// whatever options are passed in, but if they’re not defined, then check for\n\t// the getValue and setValue symbols on the child and parent values.\n\tvar childToParent = true;\n\tif (typeof options.childToParent === \"boolean\") {\n\t\t// Always let the option override any checks\n\t\tchildToParent = options.childToParent;\n\t} else if (options.child[getValueSymbol] == null) {\n\t\t// Child to parent won’t work if we can’t get the child’s value\n\t\tchildToParent = false;\n\t} else if (options.setParent === undefined && options.parent[setValueSymbol] == null) {\n\t\t// Child to parent won’t work if we can’t set the parent’s value\n\t\tchildToParent = false;\n\t}\n\tvar parentToChild = true;\n\tif (typeof options.parentToChild === \"boolean\") {\n\t\t// Always let the option override any checks\n\t\tparentToChild = options.parentToChild;\n\t} else if (options.parent[getValueSymbol] == null) {\n\t\t// Parent to child won’t work if we can’t get the parent’s value\n\t\tparentToChild = false;\n\t} else if (options.setChild === undefined && options.child[setValueSymbol] == null) {\n\t\t// Parent to child won’t work if we can’t set the child’s value\n\t\tparentToChild = false;\n\t}\n\tif (childToParent === false && parentToChild === false) {\n\t\tthrow new Error(\"Neither the child nor parent will be updated; this is a no-way binding\");\n\t}\n\tthis._childToParent = childToParent;\n\tthis._parentToChild = parentToChild;\n\n\t// Custom child & parent setters can be supplied; if they aren’t provided,\n\t// then create our own.\n\tif (options.setChild === undefined) {\n\t\toptions.setChild = defaultSetValue;\n\t}\n\tif (options.setParent === undefined) {\n\t\toptions.setParent = defaultSetValue;\n\t}\n\n\t// Set the observables’ priority\n\tif (options.priority !== undefined) {\n\t\tcanReflect.setPriority(options.child, options.priority);\n\t\tcanReflect.setPriority(options.parent, options.priority);\n\t}\n\n\t// These variables keep track of how many updates are allowed in a cycle.\n\t// cycles is multipled by two because one update is allowed for each side of\n\t// the binding, child and parent. One more update is allowed depending on the\n\t// sticky option; if it’s sticky, then one more update needs to be allowed.\n\tvar allowedUpdates = options.cycles * 2;\n\tvar allowedChildUpdates = allowedUpdates + (options.sticky === \"childSticksToParent\" ? 1 : 0);\n\tvar allowedParentUpdates = allowedUpdates + (options.sticky === \"parentSticksToChild\" ? 1 : 0);\n\n\t// This keeps track of whether we’re bound to the child and/or parent; this\n\t// allows startParent() to be called first and on() can be called later to\n\t// finish setting up the child binding. This is also checked when updating\n\t// values; if stop() has been called but updateValue() is called, then we\n\t// ignore the update.\n\tvar bindingState = this._bindingState = {\n\t\tchild: false,\n\t\tparent: false\n\t};\n\n\t// This is the listener that’s called when the parent changes\n\tthis._updateChild = function(newValue) {\n\t\tupdateValue({\n\t\t\tbindingState: bindingState,\n\t\t\tnewValue: newValue,\n\n\t\t\t// Some options used for debugging\n\t\t\tdebugObservableName: \"child\",\n\t\t\tdebugPartnerName: \"parent\",\n\n\t\t\t// Main observable values\n\t\t\tobservable: options.child,\n\t\t\tsetValue: options.setChild,\n\t\t\tsemaphore: childSemaphore,\n\n\t\t\t// If the sum of the semaphores is less than or equal to this number, then\n\t\t\t// it’s ok to update the child with the new value.\n\t\t\tallowedUpdates: allowedChildUpdates,\n\n\t\t\t// If options.sticky === \"parentSticksToChild\", then after the parent sets\n\t\t\t// the child, check to see if the child matches the parent; if not, then\n\t\t\t// set the parent to the child’s value. This is used in cases where the\n\t\t\t// child modifies its own value and the parent should be kept in sync with\n\t\t\t// the child.\n\t\t\tsticky: options.sticky === \"parentSticksToChild\",\n\n\t\t\t// Partner observable values\n\t\t\tpartner: options.parent,\n\t\t\tsetPartner: options.setParent,\n\t\t\tpartnerSemaphore: parentSemaphore\n\t\t});\n\t};\n\n\t// This is the listener that’s called when the child changes\n\tthis._updateParent = function(newValue) {\n\t\tupdateValue({\n\t\t\tbindingState: bindingState,\n\t\t\tnewValue: newValue,\n\n\t\t\t// Some options used for debugging\n\t\t\tdebugObservableName: \"parent\",\n\t\t\tdebugPartnerName: \"child\",\n\n\t\t\t// Main observable values\n\t\t\tobservable: options.parent,\n\t\t\tsetValue: options.setParent,\n\t\t\tsemaphore: parentSemaphore,\n\n\t\t\t// If the sum of the semaphores is less than or equal to this number, then\n\t\t\t// it’s ok to update the parent with the new value.\n\t\t\tallowedUpdates: allowedParentUpdates,\n\n\t\t\t// If options.sticky === \"childSticksToParent\", then after the child sets\n\t\t\t// the parent, check to see if the parent matches the child; if not, then\n\t\t\t// set the child to the parent’s value. This is used in cases where the\n\t\t\t// parent modifies its own value and the child should be kept in sync with\n\t\t\t// the parent.\n\t\t\tsticky: options.sticky === \"childSticksToParent\",\n\n\t\t\t// Partner observable values\n\t\t\tpartner: options.child,\n\t\t\tsetPartner: options.setChild,\n\t\t\tpartnerSemaphore: childSemaphore\n\t\t});\n\t};\n\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tif (options.updateChildName) {\n\t\t\tObject.defineProperty(this._updateChild, \"name\", {\n\t\t\t\tvalue: options.updateChildName\n\t\t\t});\n\t\t}\n\t\tif (options.updateParentName) {\n\t\t\tObject.defineProperty(this._updateParent, \"name\", {\n\t\t\t\tvalue: options.updateParentName\n\t\t\t});\n\t\t}\n\t}\n\t//!steal-remove-end\n\n}\n\nObject.defineProperty(Bind.prototype, \"parentValue\", {\n\tget: function() {\n\t\treturn canReflect.getValue(this._options.parent);\n\t}\n});\n\ncanAssign(Bind.prototype, {\n\n\t// Turn on any bindings that haven’t already been enabled;\n\t// also update the child or parent if need be.\n\tstart: function() {\n\t\tvar childValue;\n\t\tvar options = this._options;\n\t\tvar parentValue;\n\n\t\t// The tests don’t show that it matters which is bound first, but we’ll\n\t\t// bind to the parent first to stay consistent with how\n\t\t// can-stache-bindings did things.\n\t\tthis.startParent();\n\t\tthis.startChild();\n\n\t\t// Initialize the child & parent values\n\t\tif (this._childToParent === true && this._parentToChild === true) {\n\t\t\t// Two-way binding\n\t\t\tparentValue = canReflect.getValue(options.parent);\n\t\t\tif (parentValue === undefined) {\n\t\t\t\tchildValue = canReflect.getValue(options.child);\n\t\t\t\tif (childValue === undefined) {\n\t\t\t\t\t// Check if updating the child is allowed\n\t\t\t\t\tif (options.onInitDoNotUpdateChild === false) {\n\t\t\t\t\t\tthis._updateChild(parentValue);\n\t\t\t\t\t}\n\t\t\t\t} else if (options.onInitSetUndefinedParentIfChildIsDefined === true) {\n\t\t\t\t\tthis._updateParent(childValue);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Check if updating the child is allowed\n\t\t\t\tif (options.onInitDoNotUpdateChild === false) {\n\t\t\t\t\tthis._updateChild(parentValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else if (this._childToParent === true) {\n\t\t\t// One-way child -> parent, so update the parent\n\t\t\tchildValue = canReflect.getValue(options.child);\n\t\t\tthis._updateParent(childValue);\n\n\t\t} else if (this._parentToChild === true) {\n\t\t\t// One-way parent -> child, so update the child\n\t\t\t// Check if updating the child is allowed\n\t\t\tif (options.onInitDoNotUpdateChild === false) {\n\t\t\t\tparentValue = canReflect.getValue(options.parent);\n\t\t\t\tthis._updateChild(parentValue);\n\t\t\t}\n\t\t}\n\t},\n\n\t// Listen for changes to the child observable and update the parent\n\tstartChild: function() {\n\t\tif (this._bindingState.child === false && this._childToParent === true) {\n\t\t\tvar options = this._options;\n\t\t\tthis._bindingState.child = true;\n\t\t\tturnOnListeningAndUpdate(options.child, options.parent, this._updateParent, options.queue);\n\t\t}\n\t},\n\n\t// Listen for changes to the parent observable and update the child\n\tstartParent: function() {\n\t\tif (this._bindingState.parent === false && this._parentToChild === true) {\n\t\t\tvar options = this._options;\n\t\t\tthis._bindingState.parent = true;\n\t\t\tturnOnListeningAndUpdate(options.parent, options.child, this._updateChild, options.queue);\n\t\t}\n\t},\n\n\t// Turn off all the bindings\n\tstop: function() {\n\t\tvar bindingState = this._bindingState;\n\t\tvar options = this._options;\n\n\t\t// Turn off the parent listener\n\t\tif (bindingState.parent === true && this._parentToChild === true) {\n\t\t\tbindingState.parent = false;\n\t\t\tturnOffListeningAndUpdate(options.parent, options.child, this._updateChild, options.queue);\n\t\t}\n\n\t\t// Turn off the child listener\n\t\tif (bindingState.child === true && this._childToParent === true) {\n\t\t\tbindingState.child = false;\n\t\t\tturnOffListeningAndUpdate(options.child, options.parent, this._updateParent, options.queue);\n\t\t}\n\t}\n\n});\n\n// updateValue is a helper function that’s used by updateChild and updateParent\nfunction updateValue(args) {\n\n\t// Check to see whether the binding is active; ignore updates if it isn’t active\n\tvar bindingState = args.bindingState;\n\tif (bindingState.child === false && bindingState.parent === false) {\n\t\t// We don’t warn the user about this because it’s a common occurrence in\n\t\t// can-stache-bindings, e.g. {{#if value}}<input value:bind=\"value\"/>{{/if}}\n\t\treturn;\n\t}\n\n\t// Now check the semaphore; if this change is happening because the partner\n\t// observable was just updated, we only want to update this observable again\n\t// if the total count for both semaphores is less than or equal to the number\n\t// of allowed updates.\n\tvar semaphore = args.semaphore;\n\tif ((semaphore.value + args.partnerSemaphore.value) <= args.allowedUpdates) {\n\t\tqueues.batch.start();\n\n\t\t// Update the observable’s value; this uses either a custom function passed\n\t\t// in when the binding was initialized or canReflect.setValue.\n\t\targs.setValue(args.newValue, args.observable);\n\n\t\t// Increase the semaphore so that when the batch ends, if an update to the\n\t\t// partner observable’s value is made, then it won’t update this observable\n\t\t// again unless cycles are allowed.\n\t\tsemaphore.increment();\n\n\t\t// Decrease the semaphore after all other updates have occurred\n\t\tqueues.mutateQueue.enqueue(semaphore.decrement, semaphore, []);\n\n\t\tqueues.batch.stop();\n\n\t\t// Stickiness is used in cases where the call to args.setValue above might\n\t\t// have resulted in the observable being set to a different value than what\n\t\t// was passed into this function (args.newValue). If sticky:true, then set\n\t\t// the partner observable’s value so they’re kept in sync.\n\t\tif (args.sticky) {\n\t\t\tvar observableValue = canReflect.getValue(args.observable);\n\t\t\tif (observableValue !== canReflect.getValue(args.partner)) {\n\t\t\t\targs.setPartner(observableValue, args.partner);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\t// It’s natural for this “else” block to be hit in two-way bindings; as an\n\t\t// example, if a parent gets set and the child gets updated, the child’s\n\t\t// listener to update the parent will be called, but it’ll be ignored if we\n\t\t// don’t want cycles. HOWEVER, if this gets called and the parent is not the\n\t\t// same value as the child, then their values are going to be out of sync,\n\t\t// probably unintentionally. This is worth pointing out to developers\n\t\t// because it can cause unexpected behavior… some people call those bugs. :)\n\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production'){\n\t\t\tvar currentValue = canReflect.getValue(args.observable);\n\t\t\tif (currentValue !== args.newValue) {\n\t\t\t\tvar warningParts = [\n\t\t\t\t\t\"can-bind updateValue: attempting to update \" + args.debugObservableName + \" \" + canReflect.getName(args.observable) + \" to new value: %o\",\n\t\t\t\t\t\"…but the \" + args.debugObservableName + \" semaphore is at \" + semaphore.value + \" and the \" + args.debugPartnerName + \" semaphore is at \" + args.partnerSemaphore.value + \". The number of allowed updates is \" + args.allowedUpdates + \".\",\n\t\t\t\t\t\"The \" + args.debugObservableName + \" value will remain unchanged; it’s currently: %o\"\n\t\t\t\t];\n\t\t\t\tcanLog.warn(warningParts.join(\"\\n\"), args.newValue, currentValue);\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\t}\n}\n\nmodule.exports = namespace.Bind = Bind;\n"],"names":["process","env","NODE_ENV","canLog","require$$0","canReflectDeps","require$$1","getChangesSymbol","canSymbol","for","getValueSymbol","onValueSymbol","setValueSymbol","defaultSetValue","newValue","observable","canReflect","setValue","turnOffListeningAndUpdate","listenToObservable","updateObservable","updateFunction","queue","offValue","deleteMutatedBy","turnOnListeningAndUpdate","onValue","addMutatedBy","s","Set","add","valueDependencies","Semaphore","this","value","Bind","options","_options","undefined","child","TypeError","parent","indexOf","RangeError","cycles","onInitDoNotUpdateChild","onInitSetUndefinedParentIfChildIsDefined","childSemaphore","parentSemaphore","childToParent","setParent","parentToChild","setChild","Error","_childToParent","_parentToChild","priority","setPriority","allowedUpdates","allowedChildUpdates","sticky","allowedParentUpdates","bindingState","_bindingState","_updateChild","updateValue","debugObservableName","debugPartnerName","semaphore","partner","setPartner","partnerSemaphore","_updateParent","updateChildName","Object","defineProperty","updateParentName","args","queues","batch","start","increment","mutateQueue","enqueue","decrement","stop","observableValue","getValue","currentValue","warningParts","getName","warn","join","canAssign","prototype","get","childValue","parentValue","startParent","startChild","namespace"],"mappings":"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"}