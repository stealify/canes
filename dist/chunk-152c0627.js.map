{"version":3,"file":"chunk-152c0627.js","sources":["../node_modules/can-view-nodelist/can-view-nodelist.js"],"sourcesContent":["\"use strict\";\nvar namespace = require('can-namespace');\nvar domMutate = require('can-dom-mutate/node');\n\n// # can/view/node_lists/node_list.js\n//\n\n// ### What's a nodeList?\n//\n// A nodelist is an array of DOM nodes (elements text nodes and DOM elements) and/or other\n// nodeLists, along with non-array-indexed properties that manage relationships between lists.\n// These properties are:\n//\n// * deepChildren   children that couldn't be found by iterating over the nodeList when nesting\n// * nesting          nested level of a nodelist (parent's nesting plus 1)\n// * newDeepChildren  same as deepChildren but stored before registering with update()\n// * parentList   the direct parent nodeList of this nodeList\n// * replacements   an array of nodeLists meant to replace virtual nodes\n// * unregistered   a callback to call when unregistering a nodeList\n\n// ## Helpers\n// A mapping of element ids to nodeList id allowing us to quickly find an element\n// that needs to be replaced when updated.\nvar nodeMap = new Map(),\n\tsplice = [].splice,\n\tpush = [].push,\n\n\t// ## nodeLists.itemsInChildListTree\n\t// Given a nodeList return the number of child items in the provided\n\t// list and any child lists.\n\titemsInChildListTree = function(list){\n\t\tvar count = 0;\n\t\tfor(var i = 0, len = list.length ; i < len; i++){\n\t\t\tvar item = list[i];\n\t\t\t// If the item is an HTMLElement then increment the count by 1.\n\t\t\tif(item.nodeType) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\t// If the item is not an HTMLElement it is a list, so\n\t\t\t\t// increment the count by the number of items in the child\n\t\t\t\t// list.\n\t\t\t\tcount += itemsInChildListTree(item);\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t},\n\t// replacements is an array of nodeLists\n\t// makes a map of the first node in the replacement to the nodeList\n\treplacementMap = function(replacements){\n\t\tvar map = new Map();\n\t\tfor(var i = 0, len = replacements.length; i < len; i++){\n\t\t\tvar node = nodeLists.first(replacements[i]);\n\t\t\tmap.set(node, replacements[i]);\n\t\t}\n\t\treturn map;\n\t},\n\taddUnfoundAsDeepChildren = function(list, rMap){\n\t\trMap.forEach(function(replacement){\n\t\t\tlist.newDeepChildren.push(replacement);\n\t\t});\n\t};\n\n// ## Registering & Updating\n//\n// To keep all live-bound sections knowing which elements they are managing,\n// all live-bound elments are registered and updated when they change.\n//\n// For example, here's a template:\n//\n//     <div>\n//     \t{{#if items.length}}\n//     \t\tItems:\n//     \t\t{{#each items}}\n//     \t\t\t<label>{{.}}</label>\n//     \t\t{{/each}}\n//     \t{{/if}}\n//     </div>\n//\n//\n// the above template, when rendered with data like:\n//\n//     data = new can.Map({\n//         items: [\"first\",\"second\"]\n//     })\n//\n// This will first render the following content:\n//\n//     <div>\n//         <#text \"\">\n//     </div>\n//\n// The empty text node has a callback which, when called, will register it like:\n//\n//     var ifsNodes = [<#text \"\">]\n//     nodeLists.register(ifsNodes);\n//\n// And then render `{{if}}`'s contents and update `ifsNodes` with it:\n//\n//     nodeLists.update( ifsNodes, [<#text \"\\nItems:\\n\">, <#text \"\">] );\n//\n// Next, that final text node's callback is called which will regsiter it like:\n//\n//     var eachsNodes = [<#text \"\">];\n//     nodeLists.register(eachsNodes);\n//\n// And then it will render `{{#each}}`'s content and update `eachsNodes` with it:\n//\n//     nodeLists.update(eachsNodes, [<label>,<label>]);\n//\n// As `nodeLists` knows that `eachsNodes` is inside `ifsNodes`, it also updates\n// `ifsNodes`'s nodes to look like:\n//\n//     [<#text \"\\nItems:\\n\">,<label>,<label>]\n//\n// Now, if all items were removed, `{{#if}}` would be able to remove\n// all the `<label>` elements.\n//\n// When you regsiter a nodeList, you can also provide a callback to know when\n// that nodeList has been replaced by a parent nodeList.  This is\n// useful for tearing down live-binding.\nvar nodeLists = {\n\n   /**\n\t* @function can-view-nodelist.update update\n\t* @parent can-view-nodelist/methods\n\t*\n\t* @signature `nodeLists.update(nodeList, newNodes)`\n\t*\n\t* Updates a nodeList with new items, i.e. when values for the template have changed.\n\t*\n\t*   @param {can-view-nodelist/types/NodeList} nodeList The list to update with the new nodes.\n\t*   @param {can-view-nodelist/types/NodeList} newNodes The new nodes to update with.\n\t*\n\t*   @return {Array<Node>} The nodes that were removed from `nodeList`.\n\t*/\n\tupdate: function (nodeList, newNodes, oldNodes) {\n\t\t// Unregister all childNodeLists.\n\t\tif(!oldNodes) {\n\t\t\t// if oldNodes has been passed, we assume everything has already been unregistered.\n\t\t\toldNodes = nodeLists.unregisterChildren(nodeList);\n\t\t}\n\n\t\tvar arr = [];\n\t\tfor (var i = 0, ref = arr.length = newNodes.length; i < ref; i++) {\n \t\t\tarr[i] = newNodes[i];\n\t\t} // see https://jsperf.com/nodelist-to-array\n\t\tnewNodes = arr;\n\n\t\tvar oldListLength = nodeList.length;\n\n\t\t// Replace oldNodeLists's contents.\n\t\tsplice.apply(nodeList, [\n\t\t\t0,\n\t\t\toldListLength\n\t\t].concat(newNodes));\n\n\t\t// Replacements are nodes that have replaced the original element this is on.\n\t\t// We can't simply insert elements because stache does children before parents.\n\t\tif(nodeList.replacements){\n\t\t\tnodeLists.nestReplacements(nodeList);\n\t\t\tnodeList.deepChildren = nodeList.newDeepChildren;\n\t\t\tnodeList.newDeepChildren = [];\n\t\t} else {\n\t\t\tnodeLists.nestList(nodeList);\n\t\t}\n\n\t\treturn oldNodes;\n\t},\n   /**\n\t* @function can-view-nodelist.nestReplacements nestReplacements\n\t* @parent can-view-nodelist/methods\n\t* @signature `nodeLists.nestReplacements(list)`\n\t*\n\t* Goes through each node in the list. `[el1, el2, el3, ...]`\n\t* Finds the nodeList for that node in replacements.  el1's nodeList might look like `[el1, [el2]]`.\n\t* Replaces that element and any other elements in the node list with the\n\t* nodelist itself. resulting in `[ [el1, [el2]], el3, ...]`\n\t* If a replacement is not found, it was improperly added, so we add it as a deepChild.\n\t*\n\t* @param {can-view-nodelist/types/NodeList} list  The nodeList of nodes to go over\n\t*\n\t*/\n\tnestReplacements: function(list){\n\t\tvar index = 0,\n\t\t\t// replacements are in reverse order in the DOM\n\t\t\trMap = replacementMap(list.replacements),\n\t\t\trCount = list.replacements.length;\n\n\t\twhile(index < list.length && rCount) {\n\t\t\tvar node = list[index],\n\t\t\t\treplacement = rMap.get(node);\n\t\t\tif( replacement ) {\n\t\t\t\trMap[\"delete\"](node);\n\t\t\t\tlist.splice( index, itemsInChildListTree(replacement), replacement );\n\t\t\t\trCount--;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\t// Only do this if\n\t\tif(rCount) {\n\t\t\taddUnfoundAsDeepChildren(list, rMap );\n\t\t}\n\n\t\tlist.replacements = [];\n\t},\n\t/**\n\t * @function can-view-nodelist.nestList nestList\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.nestList(list)`\n\t *\n\t * If a given list does not exist in the nodeMap then create an lookup\n\t * id for it in the nodeMap and assign the list to it.\n\t * If the the provided does happen to exist in the nodeMap update the\n\t * elements in the list.\n\t *\n\t * @param {can-view-nodelist/types/NodeList} list The nodeList being nested.\n\t *\n\t */\n\tnestList: function(list){\n\t\tvar index = 0;\n\t\twhile(index < list.length) {\n\t\t\tvar node = list[index],\n\t\t\t\tchildNodeList = nodeMap.get(node);\n\n\n\t\t\tif(childNodeList) {\n\t\t\t\t// if this node is in another nodelist\n\t\t\t\tif(childNodeList !== list) {\n\t\t\t\t\t// update this nodeList to point to the childNodeList\n\t\t\t\t\tlist.splice( index, itemsInChildListTree(childNodeList), childNodeList );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Indicate the new nodes belong to this list.\n\t\t\t\tnodeMap.set(node, list);\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t},\n\n\t/**\n\t * @function can-view-nodelist.last last\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.last(nodeList)`\n\t *\n\t * Return the last HTMLElement in a nodeList; if the last\n\t * element is a nodeList, returns the last HTMLElement of\n\t * the child list, etc.\n\t *\n\t * @param {can-view-nodelist/types/NodeList} nodeList A nodeList.\n\t * @return {HTMLElement} The last element of the last list nested in this list.\n\t *\n\t */\n\tlast: function(nodeList){\n\t\tvar last = nodeList[nodeList.length - 1];\n\t\t// If the last node in the list is not an HTMLElement\n\t\t// it is a nodeList so call `last` again.\n\t\tif(last.nodeType) {\n\t\t\treturn last;\n\t\t} else {\n\t\t\treturn nodeLists.last(last);\n\t\t}\n\t},\n\n\t/**\n\t * @function can-view-nodelist.first first\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.first(nodeList)`\n\t *\n\t * Return the first HTMLElement in a nodeList; if the first\n\t * element is a nodeList, returns the first HTMLElement of\n\t * the child list, etc.\n\t *\n\t * @param {can-view-nodelist/types/NodeList} nodeList A nodeList.\n\t * @return {HTMLElement} The first element of the first list nested in this list.\n\t *\n\t *\n\t */\n\tfirst: function(nodeList) {\n\t\tvar first = nodeList[0];\n\t\t// If the first node in the list is not an HTMLElement\n\t\t// it is a nodeList so call `first` again.\n\t\tif(first.nodeType) {\n\t\t\treturn first;\n\t\t} else {\n\t\t\treturn nodeLists.first(first);\n\t\t}\n\t},\n\tflatten: function(nodeList){\n\t\tvar items = [];\n\t\tfor(var i = 0 ; i < nodeList.length; i++) {\n\t\t\tvar item = nodeList[i];\n\t\t\tif(item.nodeType) {\n\t\t\t\titems.push(item);\n\t\t\t} else {\n\t\t\t\titems.push.apply(items, nodeLists.flatten(item));\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t},\n\t/**\n\t * @function can-view-nodelist.register register\n\t * @parent can-view-nodelist/methods\n\t *\n\t * @signature `nodeLists.register(nodeList, unregistered, parent, directlyNested)`\n\t *\n\t * Registers a nodeList and returns the nodeList passed to register.\n\t *\n\t *   @param {can-view-nodelist/types/NodeList} nodeList A nodeList.\n\t *   @param {function()} unregistered A callback to call when the nodeList is unregistered.\n\t *   @param {can-view-nodelist/types/NodeList} parent The parent nodeList of this nodeList.\n\t *   @param {Boolean} directlyNested `true` if nodes in the nodeList are direct children of the parent.\n\t *   @return {can-view-nodelist/types/NodeList} The passed in nodeList.\n\t *\n\t */\n\tregister: function (nodeList, unregistered, parent, directlyNested) {\n\t\t// If a unregistered callback has been provided assign it to the nodeList\n\t\t// as a property to be called when the nodeList is unregistred.\n\t\tnodeList.unregistered = unregistered;\n\t\tnodeList.parentList = parent;\n\t\tnodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;\n\n\t\tif(parent) {\n\t\t\tnodeList.deepChildren = [];\n\t\t\tnodeList.newDeepChildren = [];\n\t\t\tnodeList.replacements = [];\n\t\t\tif(parent !== true) {\n\t\t\t\tif(directlyNested) {\n\t\t\t\t\tparent.replacements.push(nodeList);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent.newDeepChildren.push(nodeList);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tnodeLists.nestList(nodeList);\n\t\t}\n\n\n\t\treturn nodeList;\n\t},\n\n\t/**\n\t * @function can-view-nodelist.unregisterChildren unregisterChildren\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.unregisterChildren(nodeList)`\n\t *\n\t * Unregister all childen within the provided list and return the\n\t * unregistred nodes.\n\t *\n\t * @param {can-view-nodelist/types/NodeList} nodeList The nodeList of child nodes to unregister.\n\t * @return {Array} The list of all nodes that were unregistered.\n\t */\n\tunregisterChildren: function(nodeList){\n\t\tvar nodes = [];\n\t\t// For each node in the nodeList we want to compute it's id\n\t\t// and delete it from the nodeList's internal map.\n\t\tfor (var n = 0; n < nodeList.length; n++) {\n\t\t\tvar node = nodeList[n];\n\t\t\t// If the node does not have a nodeType it is an array of\n\t\t\t// nodes.\n\t\t\tif(node.nodeType) {\n\t\t\t\tif(!nodeList.replacements) {\n\t\t\t\t\tnodeMap[\"delete\"](node);\n\t\t\t\t}\n\n\t\t\t\tnodes.push(node);\n\t\t\t} else {\n\t\t\t\t// Recursively unregister each of the child lists in\n\t\t\t\t// the nodeList.\n\t\t\t\tpush.apply(nodes, nodeLists.unregister(node, true));\n\t\t\t}\n\t\t}\n\n\t\tvar deepChildren = nodeList.deepChildren;\n\t\tif (deepChildren) {\n\t\t\tfor (var l = 0; l < deepChildren.length; l++) {\n\t\t\t\tnodeLists.unregister(deepChildren[l], true);\n\t\t\t}\n\t\t}\n\n\t\treturn nodes;\n\t},\n\n\t/**\n\t\t@function can-view-nodelist.unregister unregister\n\t\t@parent can-view-nodelist/methods\n\t\t@signature `nodeLists.unregister(nodeList, isChild)`\n\t\t@param {ArrayLike} nodeList a nodeList to unregister from its parent\n\t\t@param {isChild}  true if the nodeList is a direct child, false if a deep child\n\t\t@return {Array}   a list of all nodes that were unregistered\n\n\t\tUnregister's a nodeList and returns the unregistered nodes.\n\t\tCall if the nodeList is no longer being updated. This will\n\t\talso unregister all child nodeLists.\n\t*/\n\tunregister: function (nodeList, isChild) {\n\t\tvar nodes = nodeLists.unregisterChildren(nodeList, true);\n\t\tnodeList.isUnregistered = true;\n\n\t\t// If an 'unregisted' function was provided during registration, remove\n\t\t// it from the list, and call the function provided.\n\t\tif (nodeList.unregistered) {\n\t\t\tvar unregisteredCallback = nodeList.unregistered;\n\t\t\tnodeList.replacements = nodeList.unregistered = null;\n\t\t\tif(!isChild) {\n\t\t\t\tvar deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;\n\t\t\t\tif(deepChildren) {\n\t\t\t\t\tvar index = deepChildren.indexOf(nodeList);\n\t\t\t\t\tif(index !== -1) {\n\t\t\t\t\t\tdeepChildren.splice(index,1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tunregisteredCallback();\n\t\t}\n\t\treturn nodes;\n\t},\n\t/**\n\t * @function can-view-nodelist.after after\n\t * @parent can-view-nodelist/methods\n\t * @hide\n\t * @signature `nodeLists.after(oldElements, newFrag)`\n\t *\n\t *   Inserts `newFrag` after `oldElements`.\n\t *\n\t *   @param {ArrayLike<Node>} oldElements The elements to use as reference.\n\t *   @param {DocumentFragment} newFrag The fragment to insert.\n\t *\n\t */\n\tafter: function (oldElements, newFrag) {\n\t\tvar last = oldElements[oldElements.length - 1];\n\t\t// Insert it in the `document` or `documentFragment`\n\t\tif (last.nextSibling) {\n\t\t\tdomMutate.insertBefore.call(last.parentNode, newFrag, last.nextSibling);\n\t\t} else {\n\t\t\tdomMutate.appendChild.call(last.parentNode, newFrag );\n\t\t}\n\t},\n\t/**\n\t * @function can-view-nodelist.replace replace\n\t * @hide\n\t * @parent can-view-nodelist/methods\n\t * @signature `nodeLists.replace(oldElements, newFrag)`\n\t *\n\t * Replaces `oldElements` with `newFrag`.\n\t *\n\t * @param {Array<Node>} oldElements the list elements to remove\n\t * @param {DocumentFragment} newFrag the fragment to replace the old elements\n\t *\n\t */\n\treplace: function (oldElements, newFrag) {\n\t\t// The following helps make sure that a selected <option> remains\n\t\t// the same by removing `selected` from the currently selected option\n\t\t// and adding selected to an option that has the same value.\n\t\tvar selectedValue,\n\t\t\tparentNode = oldElements[0].parentNode;\n\n\t\tif(parentNode.nodeName.toUpperCase() === \"SELECT\" && parentNode.selectedIndex >= 0) {\n\t\t\tselectedValue = parentNode.value;\n\t\t}\n\t\tif(oldElements.length === 1) {\n\t\t\tdomMutate.replaceChild.call(parentNode, newFrag, oldElements[0]);\n\t\t} else {\n\t\t\tnodeLists.after(oldElements, newFrag);\n\t\t\tnodeLists.remove(oldElements);\n\t\t}\n\n\t\tif(selectedValue !== undefined) {\n\t\t\tparentNode.value = selectedValue;\n\t\t}\n\t},\n\t/**\n\t * @function can-view-nodelist.remove remove\n\t * @parent can-view-nodelist/methods\n\t * @hide\n\t * @signature `nodeLists.remove(elementsToBeRemoved)`\n\t *\n\t * Remove all Nodes in `oldElements` from the DOM.\n\t *\n\t * @param {ArrayLike<Node>} oldElements the list of Elements to remove (must have a common parent)\n\t *\n\t */\n\tremove: function(elementsToBeRemoved){\n\t\tvar parent = elementsToBeRemoved[0] && elementsToBeRemoved[0].parentNode;\n\t\tfor (var i = 0; i < elementsToBeRemoved.length; i++) {\n\t\t\tdomMutate.removeChild.call(parent, elementsToBeRemoved[i]);\n\t\t}\n\t},\n\tnodeMap: nodeMap\n};\nmodule.exports = namespace.nodeLists = nodeLists;\n"],"names":["nodeMap","Map","splice","push","itemsInChildListTree","list","count","i","len","length","item","nodeType","replacementMap","replacements","map","node","nodeLists","first","set","addUnfoundAsDeepChildren","rMap","forEach","replacement","newDeepChildren","update","nodeList","newNodes","oldNodes","unregisterChildren","arr","ref","oldListLength","apply","concat","nestReplacements","deepChildren","nestList","index","rCount","get","childNodeList","last","flatten","items","register","unregistered","parent","directlyNested","parentList","nesting","nodes","n","unregister","l","isChild","isUnregistered","unregisteredCallback","indexOf","after","oldElements","newFrag","nextSibling","domMutate","insertBefore","call","parentNode","appendChild","replace","selectedValue","nodeName","toUpperCase","selectedIndex","value","replaceChild","remove","undefined","elementsToBeRemoved","removeChild","namespace"],"mappings":"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"}