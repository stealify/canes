{"version":3,"file":"chunk-b52ac488.js","sources":["../node_modules/can-memory-store/make-simple-store.js"],"sourcesContent":["var canReflect = require(\"can-reflect\");\n\n\nfunction getItems(data){\n\tif(Array.isArray(data)) {\n\t\treturn data;\n\t} else {\n\t\treturn data.data;\n\t}\n}\n\nfunction indexOf(records, identity, queryLogic ){\n\tvar schema = canReflect.getSchema( queryLogic );\n\tfor(var i = 0 ; i < records.length; i++) {\n\t\tif(identity === canReflect.getIdentity(records[i],  schema) ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n// update could remove all other records that would be in the set\nfunction makeSimpleStore(baseConnection) {\n    baseConnection.constructor = makeSimpleStore;\n    var behavior = Object.create(baseConnection);\n\n    // this stores data like:\n    // queries: {[queryKey]: {queryKey, query, recordIds}}\n    // records\n    return canReflect.assignMap(behavior, {\n        getRecordFromParams: function(record) {\n        \tvar id = canReflect.getIdentity(record, this.queryLogic.schema);\n        \treturn this.getRecord(id);\n        },\n\n        log: function(){\n\t\t\tthis._log = true;\n\t\t},\n\n        getSets: function(){\n\t\t\treturn this.getQueries();\n\t\t},\n\t\tgetQueries: function(){\n\t\t\treturn Promise.resolve(this.getQueriesSync());\n\t\t},\n\t\tgetQueriesSync: function(){\n\t\t\treturn this.getQueryDataSync().map(function(queryData){\n\t\t\t\treturn queryData.query;\n\t\t\t});\n\t\t},\n\n        getListData: function(query){\n        \tquery = query || {};\n        \tvar listData = this.getListDataSync(query);\n        \tif(listData) {\n        \t\treturn Promise.resolve(listData);\n        \t}\n        \treturn Promise.reject({\n        \t\ttitle: \"no data\",\n        \t\tstatus: \"404\",\n        \t\tdetail: \"No data available for this query.\\nAvailable queries: \"+\n        \t\t\tJSON.stringify(this.getQueriesSync())\n        \t});\n        },\n\t\tgetPaginatedListDataSync: function(superSetQueryData) {\n\t\t\tvar records = this.getAllRecords();\n\t\t\tvar queryWithoutPagination = this.queryLogic.removePagination(superSetQueryData.query);\n\t\t\tvar matchingSuperRecordsNoPagination = this.queryLogic.filterMembersAndGetCount(queryWithoutPagination, {}, records);\n\t\t\tvar startIndex = indexOf(matchingSuperRecordsNoPagination.data, superSetQueryData.startIdentity, this.queryLogic);\n\t\t\tvar matchingSuperRecords = matchingSuperRecordsNoPagination.data.slice(startIndex, startIndex+ this.queryLogic.count(superSetQueryData.query));\n\t\t\treturn {\n\t\t\t\tcount: matchingSuperRecordsNoPagination.data.length,\n\t\t\t\tdata: matchingSuperRecords\n\t\t\t};\n\t\t},\n        getListDataSync: function(query){\n\t\t\tvar queryData = this.getQueryDataSync(),\n\t\t\t\tsuperSetQueryData,\n\t\t\t\tisPaginated = this.queryLogic.isPaginated(query);\n\n\t\t\tfor(var i = 0; i < queryData.length; i++) {\n        \t\tvar checkSet = queryData[i].query;\n        \t\tif( this.queryLogic.isSubset(query, checkSet) ) {\n\t\t\t\t\tsuperSetQueryData = queryData[i];\n        \t\t}\n        \t}\n\t\t\tvar records = this.getAllRecords();\n\n\t\t\tif(isPaginated && this.queryLogic.isPaginated(superSetQueryData.query) ) {\n\t\t\t\tvar result = this.getPaginatedListDataSync(superSetQueryData);\n\t\t\t\treturn this.queryLogic.filterMembersAndGetCount(query, superSetQueryData.query, result.data);\n\t\t\t}\n\n            var matching = this.queryLogic.filterMembersAndGetCount(query, {}, records);\n            if(matching && matching.count) {\n                return matching;\n            }\n            // now check if we have a query  for it\n        \tif(superSetQueryData) {\n\t\t\t\treturn {count: 0, data: []};\n\t\t\t}\n        },\n\n        updateListData: function(data, query){\n\t\t\tvar queryData = this.getQueryDataSync();\n        \tquery = query || {};\n            var clonedData = canReflect.serialize(data);\n        \tvar records = getItems(clonedData);\n\t\t\t// Update or create all records\n\t\t\tthis.updateRecordsSync(records);\n\t\t\tvar isPaginated = this.queryLogic.isPaginated(query);\n\t\t\tvar identity = records.length ? canReflect.getIdentity(records[0],  this.queryLogic.schema) : undefined;\n\t\t\tif(isPaginated) {\n\t\t\t\t// we are going to merge with some paginated set\n\t\t\t\tfor(var i = 0; i < queryData.length; i++) {\n\t        \t\tvar checkSet = queryData[i].query;\n\t\t\t\t\tvar union = this.queryLogic.union(checkSet, query);\n\t\t\t\t\tif( this.queryLogic.isDefinedAndHasMembers(union)  ) {\n\t\t\t\t\t\tvar siblingRecords = this.getPaginatedListDataSync(queryData[i]);\n\t\t\t\t\t\tvar res = this.queryLogic.unionMembers(checkSet, query, siblingRecords.data, records );\n\t\t\t\t\t\tidentity = canReflect.getIdentity(res[0],  this.queryLogic.schema);\n\t\t\t\t\t\tqueryData[i] = {\n\t\t\t\t\t\t\tquery: union,\n\t\t\t\t\t\t\tstartIdentity: identity\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis.updateQueryDataSync(queryData);\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}\n\t        \t}\n\n\t\t\t\tqueryData.push({\n\t\t\t\t\tquery: query,\n\t\t\t\t\tstartIdentity: identity\n\t\t\t\t});\n\t\t\t\tthis.updateQueryDataSync(queryData);\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n            // we need to remove everything that would have matched this query before, but that's not in data\n            // but what if it's in another set -> we remove it\n            var allRecords = this.getAllRecords();\n            var curretMatching = this.queryLogic.filterMembers(query, allRecords);\n            if(curretMatching.length) {\n                var toBeDeleted = new Map();\n                curretMatching.forEach(function(record){\n                    toBeDeleted.set( canReflect.getIdentity(record, this.queryLogic.schema), record );\n                }, this);\n\n                // remove what's in records\n                records.forEach(function(record){\n                    toBeDeleted.delete( canReflect.getIdentity(record, this.queryLogic.schema) );\n                }, this);\n\n                this.destroyRecords( canReflect.toArray(toBeDeleted.values() ) );\n            }\n\n            // the queries that are not consumed by query\n            var allQueries = this.getQueryDataSync();\n            var notSubsets = allQueries.filter(function(existingQueryData){\n                    return !this.queryLogic.isSubset(existingQueryData.query, query);\n                }, this),\n                superSets = notSubsets.filter(function(existingQueryData){\n                    return this.queryLogic.isSubset(query, existingQueryData.query);\n                }, this);\n\n\t\t\t// would need to note the first record ... so we can do a query w/o pagination\n\t\t\t//\n\n            // if there are sets that are parents of query\n            if(superSets.length) {\n                this.updateQueryDataSync(notSubsets);\n            } else {\n                this.updateQueryDataSync(notSubsets.concat([{\n\t\t\t\t\tquery: query,\n\t\t\t\t\tstartIdentity:identity\n\t\t\t\t}]));\n            }\n\n        \t// setData.push({query: query, items: data});\n        \treturn Promise.resolve();\n        },\n\n        getData: function(params){\n        \tvar id = canReflect.getIdentity(params, canReflect.getSchema( this.queryLogic ) );\n        \tvar res = this.getRecord(id);\n        \tif(res){\n        \t\treturn Promise.resolve( res );\n        \t} else {\n        \t\treturn Promise.reject({\n        \t\t\ttitle: \"no data\",\n        \t\t\tstatus: \"404\",\n        \t\t\tdetail: \"No record with matching identity (\"+id+\").\"\n        \t\t});\n        \t}\n        },\n        createData: function(record){\n\t\t\tthis.updateRecordsSync([record]);\n\n\t\t\treturn Promise.resolve(canReflect.assignMap({}, this.getRecordFromParams(record) ));\n\t\t},\n\n\t\tupdateData: function(record){\n\n\t\t\tif(this.errorOnMissingRecord && !this.getRecordFromParams(record)) {\n\t\t\t\tvar id = canReflect.getIdentity(record, this.queryLogic.schema);\n\t\t\t\treturn Promise.reject({\n\t\t\t\t\ttitle: \"no data\",\n\t\t\t\t\tstatus: \"404\",\n\t\t\t\t\tdetail: \"No record with matching identity (\"+id+\").\"\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.updateRecordsSync([record]);\n\n\t\t\treturn Promise.resolve(canReflect.assignMap({},this.getRecordFromParams(record) ));\n\t\t},\n\n\t\tdestroyData: function(record){\n\t\t\tvar id = canReflect.getIdentity(record,  this.queryLogic.schema),\n\t\t\t\tsavedRecord = this.getRecordFromParams(record);\n\n\t\t\tif(this.errorOnMissingRecord && !savedRecord) {\n\n\t\t\t\treturn Promise.reject({\n\t\t\t\t\ttitle: \"no data\",\n\t\t\t\t\tstatus: \"404\",\n\t\t\t\t\tdetail: \"No record with matching identity (\"+id+\").\"\n\t\t\t\t});\n\t\t\t}\n            this.destroyRecords([record]);\n\t\t\treturn Promise.resolve(canReflect.assignMap({},savedRecord || record));\n\t\t}\n    });\n}\n\nmodule.exports = makeSimpleStore;\n"],"names":["getItems","data","Array","isArray","indexOf","records","identity","queryLogic","schema","canReflect","getSchema","i","length","getIdentity","makeSimpleStore","baseConnection","constructor","behavior","Object","create","assignMap","getRecordFromParams","record","id","this","getRecord","log","_log","getSets","getQueries","Promise","resolve","getQueriesSync","getQueryDataSync","map","queryData","query","getListData","listData","getListDataSync","reject","title","status","detail","JSON","stringify","getPaginatedListDataSync","superSetQueryData","getAllRecords","queryWithoutPagination","removePagination","matchingSuperRecordsNoPagination","filterMembersAndGetCount","startIndex","startIdentity","matchingSuperRecords","slice","count","isPaginated","checkSet","isSubset","result","matching","updateListData","serialize","updateRecordsSync","undefined","union","isDefinedAndHasMembers","siblingRecords","res","unionMembers","updateQueryDataSync","push","allRecords","curretMatching","filterMembers","toBeDeleted","Map","forEach","set","delete","destroyRecords","toArray","values","notSubsets","filter","existingQueryData","concat","getData","params","createData","updateData","errorOnMissingRecord","destroyData","savedRecord"],"mappings":"6EAGA,SAASA,SAASC,GACjB,OAAGC,MAAMC,QAAQF,GACTA,EAEAA,EAAKA,KAId,SAASG,QAAQC,EAASC,EAAUC,GAEnC,IADA,IAAIC,EAASC,WAAWC,UAAWH,GAC3BI,EAAI,EAAIA,EAAIN,EAAQO,OAAQD,IACnC,GAAGL,IAAaG,WAAWI,YAAYR,EAAQM,GAAKH,GACnD,OAAOG,EAGT,OAAQ,EAIT,SAASG,gBAAgBC,GACrBA,EAAeC,YAAcF,gBAC7B,IAAIG,EAAWC,OAAOC,OAAOJ,GAK7B,OAAON,WAAWW,UAAUH,EAAU,CAClCI,oBAAqB,SAASC,GAC7B,IAAIC,EAAKd,WAAWI,YAAYS,EAAQE,KAAKjB,WAAWC,QACxD,OAAOgB,KAAKC,UAAUF,IAGvBG,IAAK,WACVF,KAAKG,MAAO,GAGPC,QAAS,WACd,OAAOJ,KAAKK,cAEbA,WAAY,WACX,OAAOC,QAAQC,QAAQP,KAAKQ,mBAE7BA,eAAgB,WACf,OAAOR,KAAKS,mBAAmBC,IAAI,SAASC,GAC3C,OAAOA,EAAUC,SAIbC,YAAa,SAASD,GACrBA,EAAQA,GAAS,GACjB,IAAIE,EAAWd,KAAKe,gBAAgBH,GACpC,OAAGE,EACKR,QAAQC,QAAQO,GAEjBR,QAAQU,OAAO,CACrBC,MAAO,UACPC,OAAQ,MACRC,OAAQ,yDACPC,KAAKC,UAAUrB,KAAKQ,qBAG7Bc,yBAA0B,SAASC,GAClC,IAAI1C,EAAUmB,KAAKwB,gBACfC,EAAyBzB,KAAKjB,WAAW2C,iBAAiBH,EAAkBX,OAC5Ee,EAAmC3B,KAAKjB,WAAW6C,yBAAyBH,EAAwB,GAAI5C,GACxGgD,EAAajD,QAAQ+C,EAAiClD,KAAM8C,EAAkBO,cAAe9B,KAAKjB,YAClGgD,EAAuBJ,EAAiClD,KAAKuD,MAAMH,EAAYA,EAAY7B,KAAKjB,WAAWkD,MAAMV,EAAkBX,QACvI,MAAO,CACNqB,MAAON,EAAiClD,KAAKW,OAC7CX,KAAMsD,IAGFhB,gBAAiB,SAASH,GAK/B,IAJA,IACCW,EADGZ,EAAYX,KAAKS,mBAEpByB,EAAclC,KAAKjB,WAAWmD,YAAYtB,GAEnCzB,EAAI,EAAGA,EAAIwB,EAAUvB,OAAQD,IAAK,CACnC,IAAIgD,EAAWxB,EAAUxB,GAAGyB,MACxBZ,KAAKjB,WAAWqD,SAASxB,EAAOuB,KACzCZ,EAAoBZ,EAAUxB,IAGhC,IAAIN,EAAUmB,KAAKwB,gBAEnB,GAAGU,GAAelC,KAAKjB,WAAWmD,YAAYX,EAAkBX,OAAS,CACxE,IAAIyB,EAASrC,KAAKsB,yBAAyBC,GAC3C,OAAOvB,KAAKjB,WAAW6C,yBAAyBhB,EAAOW,EAAkBX,MAAOyB,EAAO5D,MAG/E,IAAI6D,EAAWtC,KAAKjB,WAAW6C,yBAAyBhB,EAAO,GAAI/B,GACnE,OAAGyD,GAAYA,EAASL,MACbK,EAGXf,EACD,CAACU,MAAO,EAAGxD,KAAM,SADnB,GAKD8D,eAAgB,SAAS9D,EAAMmC,GACpC,IAAID,EAAYX,KAAKS,mBACfG,EAAQA,GAAS,GACd,IACC/B,EAAUL,SADMS,WAAWuD,UAAU/D,IAG/CuB,KAAKyC,kBAAkB5D,GACvB,IAAIqD,EAAclC,KAAKjB,WAAWmD,YAAYtB,GAC1C9B,EAAWD,EAAQO,OAASH,WAAWI,YAAYR,EAAQ,GAAKmB,KAAKjB,WAAWC,aAAU0D,EAC9F,GAAGR,EAAa,CAEf,IAAI,IAAI/C,EAAI,EAAGA,EAAIwB,EAAUvB,OAAQD,IAAK,CACnC,IAAIgD,EAAWxB,EAAUxB,GAAGyB,MAC9B+B,EAAQ3C,KAAKjB,WAAW4D,MAAMR,EAAUvB,GAC5C,GAAIZ,KAAKjB,WAAW6D,uBAAuBD,GAAU,CACpD,IAAIE,EAAiB7C,KAAKsB,yBAAyBX,EAAUxB,IACzD2D,EAAM9C,KAAKjB,WAAWgE,aAAaZ,EAAUvB,EAAOiC,EAAepE,KAAMI,GAO7E,OANAC,EAAWG,WAAWI,YAAYyD,EAAI,GAAK9C,KAAKjB,WAAWC,QAC3D2B,EAAUxB,GAAK,CACdyB,MAAO+B,EACPb,cAAehD,GAEhBkB,KAAKgD,oBAAoBrC,GAClBL,QAAQC,WASjB,OALAI,EAAUsC,KAAK,CACdrC,MAAOA,EACPkB,cAAehD,IAEhBkB,KAAKgD,oBAAoBrC,GAClBL,QAAQC,UAKP,IAAI2C,EAAalD,KAAKwB,gBAClB2B,EAAiBnD,KAAKjB,WAAWqE,cAAcxC,EAAOsC,GAC1D,GAAGC,EAAe/D,OAAQ,CACtB,IAAIiE,EAAc,IAAIC,IACtBH,EAAeI,QAAQ,SAASzD,GAC5BuD,EAAYG,IAAKvE,WAAWI,YAAYS,EAAQE,KAAKjB,WAAWC,QAASc,IAC1EE,MAGHnB,EAAQ0E,QAAQ,SAASzD,GACrBuD,EAAYI,OAAQxE,WAAWI,YAAYS,EAAQE,KAAKjB,WAAWC,UACpEgB,MAEHA,KAAK0D,eAAgBzE,WAAW0E,QAAQN,EAAYO,WAIxD,IACIC,EADa7D,KAAKS,mBACMqD,OAAO,SAASC,GACpC,OAAQ/D,KAAKjB,WAAWqD,SAAS2B,EAAkBnD,MAAOA,IAC3DZ,MAmBV,OAlBmB6D,EAAWC,OAAO,SAASC,GACnC,OAAO/D,KAAKjB,WAAWqD,SAASxB,EAAOmD,EAAkBnD,QAC1DZ,MAMMZ,OACTY,KAAKgD,oBAAoBa,GAEzB7D,KAAKgD,oBAAoBa,EAAWG,OAAO,CAAC,CACvDpD,MAAOA,EACPkB,cAAchD,MAKHwB,QAAQC,WAGhB0D,QAAS,SAASC,GACjB,IAAInE,EAAKd,WAAWI,YAAY6E,EAAQjF,WAAWC,UAAWc,KAAKjB,aAC/D+D,EAAM9C,KAAKC,UAAUF,GACzB,OAAG+C,EACKxC,QAAQC,QAASuC,GAEjBxC,QAAQU,OAAO,CACrBC,MAAO,UACPC,OAAQ,MACRC,OAAQ,qCAAqCpB,EAAG,QAInDoE,WAAY,SAASrE,GAG1B,OAFAE,KAAKyC,kBAAkB,CAAC3C,IAEjBQ,QAAQC,QAAQtB,WAAWW,UAAU,GAAII,KAAKH,oBAAoBC,MAG1EsE,WAAY,SAAStE,GAEpB,GAAGE,KAAKqE,uBAAyBrE,KAAKH,oBAAoBC,GAAS,CAClE,IAAIC,EAAKd,WAAWI,YAAYS,EAAQE,KAAKjB,WAAWC,QACxD,OAAOsB,QAAQU,OAAO,CACrBC,MAAO,UACPC,OAAQ,MACRC,OAAQ,qCAAqCpB,EAAG,OAMlD,OAFAC,KAAKyC,kBAAkB,CAAC3C,IAEjBQ,QAAQC,QAAQtB,WAAWW,UAAU,GAAGI,KAAKH,oBAAoBC,MAGzEwE,YAAa,SAASxE,GACrB,IAAIC,EAAKd,WAAWI,YAAYS,EAASE,KAAKjB,WAAWC,QACxDuF,EAAcvE,KAAKH,oBAAoBC,GAExC,OAAGE,KAAKqE,uBAAyBE,EAEzBjE,QAAQU,OAAO,CACrBC,MAAO,UACPC,OAAQ,MACRC,OAAQ,qCAAqCpB,EAAG,QAGzCC,KAAK0D,eAAe,CAAC5D,IACvBQ,QAAQC,QAAQtB,WAAWW,UAAU,GAAG2E,GAAezE,QAKjE,sBAAiBR"}