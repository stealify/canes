{"version":3,"file":"chunk-3b983740.js","sources":["../node_modules/can-connect/constructor/callbacks-once/callbacks-once.js","../node_modules/can-connect/helpers/weak-reference-set.js","../node_modules/can-connect/constructor/store/store.js","../node_modules/can-connect/data/callbacks/callbacks.js","../node_modules/can-diff/index-by-identity/index-by-identity.js","../node_modules/can-connect/real-time/real-time.js"],"sourcesContent":["\"use strict\";\n/**\n * @module {function} can-connect/constructor/callbacks-once/callbacks-once constructor/callbacks-once\n * @parent can-connect.behaviors\n *\n * Prevents duplicate calls to the instance callback methods.\n *\n * @signature `callbacksOnce( baseConnection )`\n *\n *   Prevents duplicate calls to the instance callback methods by tracking the last data the methods were called with.\n *   If called with the same data again, it does not call the base connection's instance callback.\n *\n *   @param {{}} baseConnection `can-connect` connection object that is having the `callbacks-once` behavior added\n *   on to it. Should already contain the behaviors that provide the Instance Callbacks\n *   (e.g [can-connect/constructor/constructor]). If the `connect` helper is used to build the connection, the\n *   behaviors will automatically be ordered as required.\n *\n *   @return {Object} A `can-connect` connection containing the methods provided by `callbacks-once`.\n *\n */\nvar connect = require(\"../../can-connect\");\nvar sortedSetJSON = require(\"../../helpers/sorted-set-json\");\nvar forEach = [].forEach;\n\n// wires up the following methods\nvar callbacks = [\n\t/**\n\t * @function can-connect/constructor/callbacks-once/callbacks-once.createdInstance createdInstance\n\t * @parent can-connect/constructor/callbacks-once/callbacks-once\n\t *\n\t * `createdInstance` callback handler that prevents sequential calls with the same arguments.\n\t *\n\t * @signature `createdInstance(instance, data)`\n\t * Called with the instance created by [can-connect/constructor/constructor.save `connection.save`] and the response data of the\n\t * underlying request. Prevents sequential calls to the underlying `createdInstance` handlers with the same arguments.\n\t *\n\t * @param {} instance the instance created by `connection.save`\n\t * @param {} data the response data returned during `connection.save`\n\t */\n\t\"createdInstance\",\n\t/**\n\t * @function can-connect/constructor/callbacks-once/callbacks-once.updatedInstance updatedInstance\n\t * @parent can-connect/constructor/callbacks-once/callbacks-once\n\t *\n\t * `updatedInstance` callback handler that prevents sequential calls with the same arguments.\n\t *\n\t * @signature `updatedInstance(instance, data)`\n\t * Called with the instance updated by [can-connect/constructor/constructor.save`connection.save`] and the response data of the\n\t * underlying request. Prevents sequential calls to the underlying `updatedInstance` handlers with the same arguments.\n\t *\n\t * @param {} instance the instance created by `connection.save`\n\t * @param {} data the response data returned during `connection.save`\n\t */\n\t\"updatedInstance\",\n\t/**\n\t * @function can-connect/constructor/callbacks-once/callbacks-once.destroyedInstance destroyedInstance\n\t * @parent can-connect/constructor/callbacks-once/callbacks-once\n\t *\n\t * `destroyedInstance` callback handler that prevents sequential calls with the same arguments.\n\t *\n\t * @signature `destroyedInstance(instance, data)`\n\t * Called with the instance created by [can-connect/constructor/constructor.destroy `connection.destroy`] and the response data of the\n\t * underlying request. Prevents sequential calls to the underlying `destroyedInstance` handlers with the same arguments.\n\t *\n\t * @param {} instance the instance created by `connection.destroy`\n\t * @param {} data the response data returned during `connection.destroy`\n\t */\n\t\"destroyedInstance\"\n];\n\n\n\nvar callbacksOnceBehavior = connect.behavior(\"constructor/callbacks-once\",function(baseConnection){\n\n\tvar behavior = {};\n\n\tforEach.call(callbacks, function(name){\n\t\tbehavior[name] = function(instance, data ){\n\n\t\t\tvar lastSerialized = this.getInstanceMetaData(instance, \"last-data-\" + name);\n\n\t\t\tvar serialize = sortedSetJSON(data);\n\t\t\tif(lastSerialized !== serialize) {\n\t\t\t\tvar result =  baseConnection[name].apply(this, arguments);\n\t\t\t\tthis.addInstanceMetaData(instance, \"last-data-\" + name, serialize);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t});\n\n\treturn behavior;\n});\n\nmodule.exports = callbacksOnceBehavior;\n\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\tvar validate = require(\"../../helpers/validate\");\n\tmodule.exports = validate(callbacksOnceBehavior, callbacks);\n}\n//!steal-remove-end\n","var assign = require(\"can-reflect\").assignMap;\n\n\nvar WeakReferenceSet = function(){\n\tthis.set = [];\n};\n\n// if weakmap, we can add and never worry ...\n// otherwise, we need to have a count ...\n\nassign(WeakReferenceSet.prototype,{\n\n\thas: function(item){\n\t\treturn this._getIndex(item) !== -1;\n\t},\n\taddReference: function(item, referenceCount){\n\n\t\tvar index = this._getIndex(item);\n\t\tvar data = this.set[index];\n\n\t\tif(!data) {\n\t\t\tdata = {\n\t\t\t\titem: item,\n\t\t\t\treferenceCount: 0\n\t\t\t};\n\t\t\tthis.set.push(data);\n\t\t}\n\t\tdata.referenceCount += (referenceCount || 1);\n\t},\n\tdeleteReference: function(item){\n\t\tvar index = this._getIndex(item);\n\t\tvar data = this.set[index];\n\t\tif(data){\n\t\t\tdata.referenceCount--;\n\t\t\tif( data.referenceCount === 0 ) {\n\t\t\t\tthis.set.splice(index,1);\n\t\t\t}\n\t\t}\n\t},\n\tdelete: function(item){\n\t\tvar index = this._getIndex(item);\n\t\tif(index !== -1) {\n\t\t\tthis.set.splice(index,1);\n\t\t}\n\t},\n\tget: function(item){\n\t\tvar data = this.set[this._getIndex(item)];\n\t\tif(data) {\n\t\t\treturn data.item;\n\t\t}\n\t},\n\treferenceCount: function(item) {\n\t\tvar data = this.set[this._getIndex(item)];\n\t\tif(data) {\n\t\t\treturn data.referenceCount;\n\t\t}\n\t},\n\t_getIndex: function(item){\n\t\tvar index;\n\t\tthis.set.every(function(data, i){\n\t\t\tif(data.item === item) {\n\n\t\t\t\tindex = i;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn index !== undefined ? index : -1;\n\t},\n\t/**\n\t * @function can-connect/helpers/weak-reference-map.prototype.forEach forEach\n\t * @signature `weakReferenceMap.forEach(callback)`\n\t *\n\t *   Calls `callback` for every value in the store.\n\t *\n\t *   @param  {function(*,String)} callback(item,key) A callback handler.\n\t */\n\tforEach: function(cb){\n\t\treturn this.set.forEach(cb);\n\t}\n});\n\nmodule.exports = WeakReferenceSet;\n","\"use strict\";\n/**\n * @module {connect.Behavior} can-connect/constructor/store/store constructor/store\n * @parent can-connect.behaviors\n * @group can-connect/constructor/store/store.stores 0 stores\n * @group can-connect/constructor/store/store.callbacks 1 CRUD callbacks\n * @group can-connect/constructor/store/store.crud 2 CRUD methods\n * @group can-connect/constructor/store/store.hydrators 3 hydrators\n *\n * Adds support for keeping references to active lists and instances. Prevents different copies of an instance from\n * being used by the application at once. Allows other behaviors to look up instances currently active in the\n * application.\n *\n *\n * @signature `constructorStore( baseConnection )`\n *\n * Overwrites `baseConnection` so it contains a store for instances and lists.  This behavior:\n * - extends the [can-connect/constructor/store/store.hydrateInstance] and\n * [can-connect/constructor/store/store.hydrateList] methods to return instances or lists from the store, if available\n * - overwrites \"CRUD\" methods to make sure that while requests are pending, new lists and instances have references\n * kept in the store. This prevents duplicated instances from being created during concurrent requests.\n * - provides methods to add and remove items in the store by counting references\n *\n * @param {{}} baseConnection `can-connect` connection object that is having the `constructor/store` behavior added\n * on to it. Should already contain a behavior that provides the InstanceInteface\n * (e.g [can-connect/constructor/constructor]). If the `connect` helper is used to build the connection, the behaviors\n * will automatically be ordered as required.\n *\n * @return {Object} a `can-connect` connection containing the method implementations provided by `constructor/store`.\n *\n * @body\n *\n * ## Use\n *\n * The `constructor-store` behavior is used to:\n *  - provide a store of instances and lists in use by the client\n *  - prevent multiple instances from being generated for the same [can-connect/base/base.id] or multiple\n *    lists for the same [can-connect/base/base.listQuery].\n *\n * The store provides access to an instance by its [can-connect/base/base.id] or a list by its\n * [can-connect/base/base.listQuery]. This is used by other behaviors to lookup instances that should have changes applied.\n * Two examples, when there is a new instance that should be added to a list ([can-connect/real-time/real-time]) or\n * when newer data is available for a cached instance that is used in the page\n * ([can-connect/fall-through-cache/fall-through-cache]).\n *\n * Below you can see how `constructor-store`'s behavior be used to prevent multiple instances from being generated. This\n * example allows you to create multiple instances of a `todoEditor` that loads and edits a todo instance:\n *\n * @demo demos/can-connect/constructor-store.html\n *\n * You can see in this example that you can edit one todo and the other todos update.  This is because each `todoEditor`\n * is acting on same instance in memory. When it updates the todo's name here:\n *\n * ```\n * var updateData = function(newName) {\n *   todo.name = newName; // update name on todo instance\n *   ...\n * };\n * ```\n *\n * The other widgets update because they are bound to the same instance:\n *\n * ```\n * todo.on(\"name\", updateElement); // when todo name changes update input element\n * todosConnection.addInstanceReference(todo); // previous line is a new usage of todo, so increase reference count\n * ```\n *\n * Each `todoEditor` receives the same instance because it was added to the\n * [can-connect/constructor/store/store.instanceStore connnection.instanceStore] by\n * [can-connect/constructor/store/store.addInstanceReference]. During all instance retrievals, a connection using the\n * `constructor/store` behavior checks the [can-connect/constructor/store/store.instanceStore] for an instance with a\n * matching `id` and return that if it exists. This example always requests `id: 5`, so all the `todoEditor`s use the\n * same instance held in the [can-connect/constructor/store/store.instanceStore].\n *\n * This widget cleans itself up when it is removed by removing the listener on the `todo` instance and\n * [can-connect/constructor/store/store.deleteInstanceReference reducing the instance reference count]:\n *\n * ```\n * todo.off(\"name\", updateElement); // stop listening to todo name change\n * todosConnection.deleteInstanceReference(todo); // previous line removed a usage of todo, so reduce reference count\n * ```\n * This is done to prevent a memory leak produced by keeping instances in the `instanceStore` when they are no longer\n * needed by the application.\n *\n * **Note:** a hazard of sharing the same instance is that if new instance data is loaded from the server during\n * on-going editing of the instance, the new server data will replace the data that is edited but not yet saved.\n * This is because whenever data is loaded from the server, it is passed to\n * [can-connect/constructor/constructor.updatedInstance] which updates the shared instance properties with the new\n * server data.\n */\nvar connect = require(\"../../can-connect\");\nvar WeakReferenceMap = require(\"../../helpers/weak-reference-map\");\nvar WeakReferenceSet = require(\"../../helpers/weak-reference-set\");\nvar sortedSetJSON = require(\"../../helpers/sorted-set-json\");\nvar eventQueue = require(\"can-event-queue/map/map\");\n\n// shared across all connections\nvar pendingRequests = 0;\nvar noRequestsTimer = null;\nvar requests = {\n\tincrement: function(connection){\n\t\tpendingRequests++;\n\t\tclearTimeout(noRequestsTimer);\n\t},\n\tdecrement: function(connection){\n\t\tpendingRequests--;\n\t\tif(pendingRequests === 0) {\n\t\t\tnoRequestsTimer = setTimeout(function(){\n\t\t\t\trequests.dispatch(\"end\");\n\t\t\t},module.exports.requestCleanupDelay);\n\t\t}\n\t\tif(pendingRequests < 0) {\n\t\t\tpendingRequests = 0;\n\t\t}\n\t},\n\tcount: function(){\n\t\treturn pendingRequests;\n\t}\n};\neventQueue(requests);\n\n\nvar constructorStore = connect.behavior(\"constructor/store\",function(baseConnection){\n\n\tvar behavior = {\n\t\t/**\n\t\t * @property {can-connect/helpers/weak-reference-map} can-connect/constructor/store/store.instanceStore instanceStore\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * A mapping of instances keyed by their [can-connect/base/base.id].\n\t\t *\n\t\t * @type {can-connect/helpers/weak-reference-map}\n\t\t *\n\t\t * Stores instances by their [can-connect/base/base.id]. Holds instances based on reference counts which\n\t\t * are incremented by [can-connect/constructor/store/store.addInstanceReference] and decremented by\n\t\t * [can-connect/constructor/store/store.deleteInstanceReference]. Once a reference count is 0, the instance is no\n\t\t * longer held in the store. Once a reference count is greater than 0, the instance is added to the store.\n\t\t *\n\t\t * ```js\n\t\t * connection.addInstanceReference(todo5);\n\t\t * connection.instanceStore.get(\"5\") //-> todo5\n\t\t * ```\n\t\t */\n\t\tinstanceStore: new WeakReferenceMap(),\n\t\t// This really should be a set ... we just need it \"weak\" so we know how many references through binding\n\t\t// it has.\n\t\tnewInstanceStore: new WeakReferenceSet(),\n\t\t/**\n\t\t * @property {can-connect/helpers/weak-reference-map} can-connect/constructor/store/store.listStore listStore\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * A mapping of lists keyed by their [can-connect/base/base.listQuery].\n\t\t *\n\t\t * @type {can-connect/helpers/weak-reference-map}\n\t\t *\n\t\t * Stores lists by their [can-connect/base/base.listQuery]. Hold lists based on reference counts which are incremented\n\t\t * by [can-connect/constructor/store/store.addListReference] and decremented by\n\t\t * [can-connect/constructor/store/store.deleteListReference]. Once a reference count is 0, the list is no\n\t\t * longer held in the store. Once a reference count is greater than 0, the list is added to the store.\n\t\t *\n\t\t * ```js\n\t\t * connection.addInstanceReference(allTodos, {});\n\t\t * connection.instanceStore.get({}) //-> allTodos\n\t\t * ```\n\t\t */\n\t\tlistStore: new WeakReferenceMap(),\n\t\t // Set up the plain objects for tracking requested lists and instances for this connection,\n\t\t // and add a handler to the requests counter to flush list and instance references when all\n\t\t // requests have completed\n\t\t //\n\t\t // This function is called automatically when connect() is called on this behavior,\n\t\t // and should not need to be called manually.\n\t\tinit: function() {\n\t\t\tif(baseConnection.init) {\n\t\t\t\tbaseConnection.init.apply(this, arguments);\n\t\t\t}\n\n\t\t\tif(!this.hasOwnProperty(\"_requestInstances\")) {\n\t\t\t\tthis._requestInstances = {};\n\t\t\t}\n\t\t\tif(!this.hasOwnProperty(\"_requestLists\")) {\n\t\t\t\tthis._requestLists = {};\n\t\t\t}\n\n\t\t\trequests.on(\"end\", function onRequestsEnd_deleteStoreReferences(){\n\t\t\t\tvar id;\n\t\t\t\tfor(id in this._requestInstances) {\n\t\t\t\t\tthis.instanceStore.deleteReference(id);\n\t\t\t\t}\n\t\t\t\tthis._requestInstances = {};\n\t\t\t\tfor(id in this._requestLists) {\n\t\t\t\t\tthis.listStore.deleteReference(id);\n\t\t\t\t\tthis._requestLists[id].forEach(this.deleteInstanceReference.bind(this));\n\t\t\t\t}\n\t\t\t\tthis._requestLists = {};\n\t\t\t}.bind(this));\n\t\t},\n\t\t_finishedRequest: function(){\n\t\t\trequests.decrement(this);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.addInstanceReference addInstanceReference\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * Add a reference to the [can-connect/constructor/store/store.instanceStore] so an instance can be easily looked up.\n\t\t *\n\t\t * @signature `connection.addInstanceReference( instance )`\n\t\t * Adds a reference to an instance by [can-connect/base/base.id] to the [can-connect/constructor/store/store.instanceStore].\n\t\t * Keeps a count of the number of references, removing the instance from the store when the count reaches 0.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance to add\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * The [can-connect/constructor/store/store.instanceStore] contains a mapping of instances keyed by their\n\t\t * [can-connect/base/base.id]. The [can-connect/constructor/store/store.instanceStore] is used to prevent creating\n\t\t * the same instance multiple times, and for finding active instance for a given id.  Instances need to be added to\n\t\t * this store for this to work.  To do this, call `addInstanceReference`:\n\t\t *\n\t\t * ```\n\t\t * // a basic connection\n\t\t * var constructorStore = require(\"can-connect/constructor/store/\");\n\t\t * var constructor = require(\"can-connect/constructor/\");\n\t\t * var dataUrl = require(\"can-connect/data/url/\");\n\t\t * var todoConnection = connect([dataUrl, constructorStore, constructor], {\n\t\t *   url: \"/todos\"\n\t\t * });\n\t\t *\n\t\t * var originalTodo;\n\t\t *\n\t\t * // get a todo\n\t\t * todoConnection.get({id: 5}).then(function( todo ){\n\t\t *   // add it to the store\n\t\t *   todoConnection.addInstanceReference(todo);\n\t\t *   originalTodo = todo;\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * Now, if you were to retrieve the same data sometime later, it would be the same instance:\n\t\t *\n\t\t * ```\n\t\t * todoConnection.get({id: 5}).then(function( todo ){\n\t\t *   todo === originalTodo // true\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * The `.getData` response data (underlying the call to `todoConnection.get`) is passed, along with the existing todo\n\t\t * instance (`originalTodo`) to [can-connect/constructor/constructor.updatedInstance]. That updates the shared\n\t\t * instance with the newly retrieved data.\n\t\t *\n\t\t * All the referenced instances are held in memory.  Use\n\t\t * [can-connect/constructor/store/store.deleteInstanceReference] to remove them.\n\t\t *\n\t\t * Typically, `addInstanceReference` is called when something expresses interest in the instance, such\n\t\t * as an event binding, and `deleteInstanceReference` is called when the interest is removed.\n\t\t */\n\t\taddInstanceReference: function(instance, id) {\n\t\t\tvar ID = id || this.id(instance);\n\t\t\tif(ID === undefined) {\n\t\t\t\t// save in the newInstanceStore store temporarily.\n\t\t\t\tthis.newInstanceStore.addReference(instance);\n\t\t\t} else {\n\t\t\t\tthis.instanceStore.addReference( ID, instance );\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.callbacks.createdInstance createdInstance\n\t\t * @parent can-connect/constructor/store/store.callbacks\n\t\t *\n\t\t * Calls `createdInstance` on the underlying behavior and moves the new instance from the `newInstanceStore` to\n\t\t * `instanceStore` if needed.\n\t\t *\n\t\t * @signature `connection.createdInstance( instance, props )`\n\t\t * Calls the base behavior. Then calls [can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore]\n\t\t * to move any pre-creation instance references to the standard instance reference store.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance that was created\n\t\t * @param {Object} props the data returned from [can-connect/connection.createData]\n\t\t */\n\t\tcreatedInstance: function(instance, props){\n\t\t\t// when an instance is created, and it is in the newInstance store\n\t\t\t// transfer it to the instanceStore\n\t\t\tbaseConnection.createdInstance.apply(this, arguments);\n\t\t\tthis.moveCreatedInstanceToInstanceStore(instance);\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore moveCreatedInstanceToInstanceStore\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * Moves recently created instances into the [can-connect/constructor/store/store.instanceStore].\n\t\t *\n\t\t * @signature `moveCreatedInstanceToInstanceStore( instance )`\n\t\t * Checks if an instance has an `id` and is in the `newInstanceStore`. If so, it adds it into the\n\t\t * [can-connect/constructor/store/store.instanceStore] and removes it from the `newInstanceStore`.\n\t\t *\n\t\t * A new instances may have been added to the `newInstanceStore` if [can-connect/constructor/store/store.addInstanceReference]\n\t\t * is called on is before the instance has been saved. This is done so we can keep track of references for unsaved\n\t\t * instances and update the references to be keyed by `id` when one is available. Without this a request for a\n\t\t * currently referenced instance that was just saved for the first time will erroneously result in a new instance.\n\t\t *\n\t\t * @param {can-connect/Instance} instance an instance.  If it was \"referenced\" (bound to) prior to\n\t\t * being created, this will check for that condition and move this instance into the\n\t\t * [can-connect/constructor/store/store.instanceStore].\n\t\t */\n\t\tmoveCreatedInstanceToInstanceStore: function(instance){\n\t\t\tvar ID = this.id(instance);\n\t\t\tif(this.newInstanceStore.has(instance) && ID !== undefined) {\n\t\t\t\tvar referenceCount = this.newInstanceStore.referenceCount(instance);\n\t\t\t\tthis.newInstanceStore.delete(instance);\n\t\t\t\tthis.instanceStore.addReference( ID, instance, referenceCount );\n\t\t\t}\n\t\t},\n\t\taddInstanceMetaData: function(instance, name, value){\n\t\t\tvar data = this.instanceStore.set[this.id(instance)];\n\t\t\tif(data) {\n\t\t\t\tdata[name] = value;\n\t\t\t}\n\t\t},\n\t\tgetInstanceMetaData: function(instance, name){\n\t\t\tvar data = this.instanceStore.set[this.id(instance)];\n\t\t\tif(data) {\n\t\t\t\treturn data[name];\n\t\t\t}\n\t\t},\n\t\tdeleteInstanceMetaData: function(instance, name){\n\t\t\tvar data = this.instanceStore.set[this.id(instance)];\n\n\t\t\tdelete data[name];\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.deleteInstanceReference deleteInstanceReference\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * Remove a reference from the [can-connect/constructor/store/store.instanceStore] so an instance can be garbage\n\t\t * collected.\n\t\t *\n\t\t * @signature `connection.addInstanceReference( instance )`\n\t\t * Decrements the number of references to an instance in the [can-connect/constructor/store/store.instanceStore].\n\t\t * Removes the instance if there are no longer any references.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the instance to remove\n\t\t *\n\t\t * ### Usage\n\t\t *\n\t\t * `deleteInstanceReference` is called to remove references to instances in the\n\t\t * [can-connect/constructor/store/store.instanceStore] so that instances maybe garbage collected.  It's usually\n\t\t * called when the application or some part of the application no longer is interested in an instance.\n\t\t *\n\t\t * [can-connect/constructor/store/store.addInstanceReference] has an example of adding an instance to the store.\n\t\t * The following continues that example to remove the `originalTodo` instance from the store:\n\t\t *\n\t\t * ```\n\t\t * todoConnection.deleteInstanceReference(originalTodo);\n\t\t * ```\n\t\t *\n\t\t * Also see the [can-connect/constructor/store/store#Use usage example on the index page] for a more complete\n\t\t * example of the lifecycle of a reference.\n\t\t */\n\t\tdeleteInstanceReference: function(instance) {\n\t\t\tvar ID = this.id(instance);\n\t\t\tif(ID === undefined) {\n\t\t\t\t// if there is no id, remove this from the newInstanceStore\n\t\t\t\tthis.newInstanceStore.deleteReference(instance);\n\t\t\t} else {\n\t\t\t\tthis.instanceStore.deleteReference( this.id(instance), instance );\n\t\t\t}\n\n\t\t},\n\t\t/**\n\t\t * @property {WeakReferenceMap} can-connect/constructor/store/store.addListReference addListReference\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * Add a reference to the [can-connect/constructor/store/store.listStore] so a list can be easily looked up.\n\t\t *\n\t\t * @signature `connection.addListReference( list[, set] )`\n\t\t * Adds a reference to a list by `set` (or by [can-connect/base/base.listQuery]) to the\n\t\t * [can-connect/constructor/store/store.listStore].  Keeps a count of the number of references, removing the list\n\t\t * from the store when the count reaches 0.\n\t\t *\n\t\t * @param {can-connect.List} list The list to add.\n\t\t * @param {can-query-logic/query} [query] The set this list represents if it can't be identified with [can-connect/base/base.listQuery].\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * The [can-connect/constructor/store/store.listStore] contains a mapping of lists keyed by their `set`. The\n\t\t * [can-connect/constructor/store/store.listStore] is used to prevent creating the same list multiple times and for\n\t\t * identifying a list for a given set. Lists need to be added to this store for this to work.  To do this, call\n\t\t * `addListReference`:\n\t\t *\n\t\t * ```\n\t\t * // A basic connection:\n\t\t * var constructorStore = require(\"can-connect/constructor/store/\");\n\t\t * var constructor = require(\"can-connect/constructor/\");\n\t\t * var dataUrl = require(\"can-connect/data/url/\");\n\t\t * var todoConnection = connect([dataUrl, constructorStore, constructor], {\n\t\t *   url: \"/todos\"\n\t\t * });\n\t\t *\n\t\t * var dueToday;\n\t\t *\n\t\t * // get a todo list\n\t\t * todoConnection.getList({due: \"today\"}).then(function( todos ){\n\t\t *   // add it to the store\n\t\t *   todoConnection.addListReference(todos, {due: \"today\"});\n\t\t *   dueToday = todos;\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * Now, if you were to retrieve the same set of data sometime later, it would be the same list instance:\n\t\t *\n\t\t * ```\n\t\t * todoConnection.get({due: \"today\"}).then(function( todos ){\n\t\t *   todos === dueToday //-> true\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t * The `.getListData`  response data (underlying the call to `todoConnection.getList`) is passed, along with the\n\t\t * existing list (`dueToday`) to [can-connect/constructor/constructor.updatedList]. That updates the shared list\n\t\t * instance with the newly retrieved data.\n\t\t *\n\t\t * All the referenced lists stay in memory.  Use [can-connect/constructor/store/store.deleteListReference]\n\t\t * to remove them.\n\t\t *\n\t\t * Typically, `addListReference` is called when something expresses interest in the list, such\n\t\t * as an event binding, and `deleteListReference` is called when interest is removed.\n\t\t *\n\t\t */\n\t\taddListReference: function(list, set) {\n\t\t\tvar id = sortedSetJSON( set || this.listQuery(list) );\n\t\t\tif(id) {\n\t\t\t\tthis.listStore.addReference( id, list );\n\t\t\t\tlist.forEach(function(instance) {\n\t\t\t\t\tthis.addInstanceReference(instance);\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.deleteListReference deleteListReference\n\t\t * @parent can-connect/constructor/store/store.stores\n\t\t *\n\t\t * Removes a reference from the [can-connect/constructor/store/store.listStore] so a list can can be garbage\n\t\t * collected.\n\t\t *\n\t\t * @signature `connection.addInstanceReference( instance )`\n\t\t * Decrements the number of references to a list in the [can-connect/constructor/store/store.listStore].\n\t\t * Removes the list if there are no longer any references.\n\t\t *\n\t\t * @param {can-connect/Instance} list the list to remove\n\t\t *\n\t\t * ### Usage\n\t\t *\n\t\t * `deleteListReference` is called to remove references to instances in the\n\t\t * [can-connect/constructor/store/store.listStore] so that lists maybe garbage collected.  It's usually called when\n\t\t * the application or some part of the application no longer is interested in a list.\n\t\t *\n\t\t * [can-connect/constructor/store/store.addListReference] has an example of adding a list to the store.  The\n\t\t * following continues that example to remove the `dueToday` list from the store:\n\t\t *\n\t\t * ```\n\t\t * todoConnection.deleteListReference(dueToday);\n\t\t * ```\n\t\t *\n\t\t * Also see the [can-connect/constructor/store/store#Use usage example on the index page] for a more complete\n\t\t * example of the lifecycle of a reference.\n\t\t */\n\t\tdeleteListReference: function(list, set) {\n\t\t\tvar id = sortedSetJSON( set || this.listQuery(list) );\n\t\t\tif(id) {\n\t\t\t\tthis.listStore.deleteReference( id, list );\n\t\t\t\tlist.forEach(this.deleteInstanceReference.bind(this));\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.hydratedInstance hydratedInstance\n\t\t * @parent can-connect/constructor/store/store.hydrators\n\t\t *\n\t\t * Keeps new instances in the [can-connect/constructor/store/store.instanceStore] for the lifetime of any\n\t\t * concurrent requests.\n\t\t *\n\t\t * @signature `hydratedInstance(instance)`\n\t\t * Adds a reference for new instances for the lifetime of any concurrent requests. Called when a new instance is\n\t\t * created during [can-connect/constructor/store/store.hydrateInstance hydration]. This prevents concurrent requests\n\t\t * for the same data from returning different instances.\n\t\t *\n\t\t * @param {can-connect/Instance} instance the newly hydrated instance\n\t\t */\n\t\t// ## hydratedInstance\n\t\thydratedInstance: function(instance){\n\t\t\tif( requests.count() > 0) {\n\t\t\t\tvar id = this.id(instance);\n\t\t\t\tif(! this._requestInstances[id] ) {\n\t\t\t\t\tthis.addInstanceReference(instance);\n\t\t\t\t\tthis._requestInstances[id] = instance;\n\t\t\t\t}\n\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.hydrateInstance hydrateInstance\n\t\t * @parent can-connect/constructor/store/store.hydrators\n\t\t *\n\t\t * Returns an instance given raw data, returning it from the [can-connect/constructor/store/store.instanceStore] if\n\t\t * available.\n\t\t *\n\t\t * @signature `connection.hydrateInstance(props)`\n\t\t * Overwrites the base `hydrateInstance` so that if a matching instance is in the\n\t\t * [can-connect/constructor/store/store.instanceStore], that instance will be\n\t\t * [can-connect/constructor/constructor.updatedInstance updated] with `props` and returned.  If there isn't a\n\t\t * matching instance, the base `hydrateInstance` will be called.\n\t\t *\n\t\t * @param {Object} props the raw data used to create an instance\n\t\t * @return {can-connect/Instance} a typed instance either created or updated with the data from `props`.\n\t\t */\n\t\thydrateInstance: function(props){\n\t\t\tvar id = this.id(props);\n\t\t\tif((id || id === 0) && this.instanceStore.has(id) ) {\n\t\t\t\tvar storeInstance = this.instanceStore.get(id);\n\t\t\t\t// TODO: find a way to prevent this from being called so many times.\n\t\t\t\tthis.updatedInstance(storeInstance, props);\n\t\t\t\treturn storeInstance;\n\t\t\t}\n\t\t\tvar instance = baseConnection.hydrateInstance.call(this, props);\n\t\t\tthis.hydratedInstance(instance);\n\t\t\treturn instance;\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.hydratedList hydratedList\n\t\t * @parent can-connect/constructor/store/store.hydrators\n\t\t *\n\t\t * Keeps new lists in the [can-connect/constructor/store/store.listStore] for the lifetime of any concurrent\n\t\t * requests.\n\t\t *\n\t\t * @signature `hydratedList(list)`\n\t\t * Adds a reference for new lists for the lifetime of any concurrent requests. Called when a new list is\n\t\t * created during [can-connect/constructor/store/store.hydrateList hydration]. This prevents concurrent requests\n\t\t * for the same data from returning different instances.\n\t\t *\n\t\t * @param {can-connect.List} list the newly hydrated list\n\t\t */\n\t\thydratedList: function(list, set){\n\t\t\tif( requests.count() > 0) {\n\t\t\t\tvar id = sortedSetJSON( set || this.listQuery(list) );\n\t\t\t\tif(id) {\n\t\t\t\t\tif(! this._requestLists[id] ) {\n\t\t\t\t\t\tthis.addListReference(list, set);\n\t\t\t\t\t\tthis._requestLists[id] = list;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.hydrateList hydrateList\n\t\t * @parent can-connect/constructor/store/store.hydrators\n\t\t *\n\t\t * Returns a list given raw data, returning it from the [can-connect/constructor/store/store.listStore] if\n\t\t * available.\n\t\t *\n\t\t * @signature `connection.hydrateList( listData, set )`\n\t\t *\n\t\t *   Overwrites the base `hydrateList` so that if a matching list is in the\n\t\t *   [can-connect/constructor/store/store.listStore], that list will be\n\t\t *   [can-connect/constructor/constructor.updatedList updated] with `listData` and returned.\n\t\t *   If there isn't a matching list, the base `hydrateList` will be called.\n\t\t *\n\t\t *   @param {can-connect.listData} listData raw list data to hydrate into a list type\n\t\t *   @param {can-query-logic/query} query the parameters that represent the set of data in `listData`\n\t\t *   @return {List} a typed list from either created or updated with the data from `listData`\n\t\t */\n\t\thydrateList: function(listData, set){\n\t\t\tset = set || this.listQuery(listData);\n\t\t\tvar id = sortedSetJSON( set );\n\n\t\t\tif( id && this.listStore.has(id) ) {\n\t\t\t\tvar storeList = this.listStore.get(id);\n\t\t\t\tthis.updatedList(storeList, listData, set);\n\t\t\t\treturn storeList;\n\t\t\t}\n\t\t\tvar list = baseConnection.hydrateList.call(this, listData, set);\n\t\t\tthis.hydratedList(list, set);\n\t\t\treturn list;\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.getList getList\n\t\t * @parent can-connect/constructor/store/store.crud\n\t\t *\n\t\t * Extends the underlying [can-connect/connection.getList] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]\n\t\t * or [can-connect/constructor/store/store.hydrateList lists hydrated] during this request are kept in the store until\n\t\t * all the concurrent requests complete.\n\t\t *\n\t\t * @signature `connection.getList( set )`\n\t\t * Increments an internal request counter so instances hydrated during this request will be stored, and then\n\t\t * decrements the counter after the request is complete. This prevents concurrent requests for the same data from\n\t\t * returning different instances.\n\t\t *\n\t\t * @param {can-query-logic/query} listQuery parameters specifying the list to retrieve\n\t\t * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.getList]\n\t\t */\n\t\tgetList: function(listQuery) {\n\t\t\tvar self = this;\n\t\t\trequests.increment(this);\n\t\t\tvar promise = baseConnection.getList.call(this, listQuery);\n\n\t\t\tpromise.then(function(instances){\n\t\t\t\tself._finishedRequest();\n\t\t\t}, function(){\n\t\t\t\tself._finishedRequest();\n\t\t\t});\n\t\t\treturn promise;\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.get get\n\t\t * @parent can-connect/constructor/store/store.crud\n\t\t *\n\t\t * Extends the underlying [can-connect/connection.get] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]\n\t\t * during this request are kept in the store until all the concurrent requests complete.\n\t\t *\n\t\t * @signature `connection.get( params )`\n\t\t * Increments an internal request counter so instances hydrated during this request will be stored, and then\n\t\t * decrements the counter after the request is complete. This prevents concurrent requests for the same data from\n\t\t * returning different instances.\n\t\t *\n\t\t * @param {Object} params params used to specify which instance to retrieve.\n\t\t * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.get]\n\t\t */\n\t\tget: function(params) {\n\t\t\tvar self = this;\n\t\t\trequests.increment(this);\n\t\t\tvar promise = baseConnection.get.call(this, params);\n\n\t\t\tpromise.then(function(instance){\n\t\t\t\tself._finishedRequest();\n\t\t\t}, function(){\n\t\t\t\tself._finishedRequest();\n\t\t\t});\n\t\t\treturn promise;\n\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.save save\n\t\t * @parent can-connect/constructor/store/store.crud\n\t\t *\n\t\t * Extends the underlying [can-connect/connection.save] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]\n\t\t * during this request are kept in the store until all the concurrent requests complete.\n\t\t *\n\t\t * @signature `connection.save( instance )`\n\t\t *\n\t\t * Increments an internal request counter so instances hydrated during this request will be stored, and then\n\t\t * decrements the counter after the request is complete. This prevents concurrent requests for the same data from\n\t\t * returning different instances.\n\t\t *\n\t\t * @param {Object} instance a typed instance being saved\n\t\t * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.save]\n\t\t */\n\t\tsave: function(instance) {\n\t\t\tvar self = this;\n\t\t\trequests.increment(this);\n\n\t\t\tvar updating = !this.isNew(instance);\n\t\t\tif(updating) {\n\t\t\t\tthis.addInstanceReference(instance);\n\t\t\t}\n\n\t\t\tvar promise = baseConnection.save.call(this, instance);\n\n\t\t\tpromise.then(function(instances){\n\t\t\t\tif(updating) {\n\t\t\t\t\tself.deleteInstanceReference(instance);\n\t\t\t\t}\n\t\t\t\tself._finishedRequest();\n\t\t\t}, function(){\n\t\t\t\tself._finishedRequest();\n\t\t\t});\n\t\t\treturn promise;\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.destroy destroy\n\t\t * @parent can-connect/constructor/store/store.crud\n\t\t *\n\t\t * Extends the underlying [can-connect/connection.destroy] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]\n\t\t * during this request are kept in the store until all the concurrent requests complete.\n\t\t *\n\t\t * @signature `connection.destroy( instance )`\n\t\t * Increments an internal request counter so instances hydrated during this request will be stored, and then\n\t\t * decrements the counter after the request is complete. This prevents concurrent requests for the same data from\n\t\t * returning different instances.\n\t\t *\n\t\t * @param {Object} instance a typed instance being deleted\n\t\t * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.destroy]\n\t\t */\n\t\tdestroy: function(instance) {\n\t\t\tvar self = this;\n\t\t\t// Add to instance store, for the duration of the\n\t\t\t// destroy callback\n\t\t\tthis.addInstanceReference(instance);\n\t\t\trequests.increment(this);\n\t\t\tvar promise = baseConnection.destroy.call(this, instance);\n\n\t\t\tpromise.then(function(instance){\n\t\t\t\tself._finishedRequest();\n\t\t\t\tself.deleteInstanceReference(instance);\n\t\t\t}, function(){\n\t\t\t\tself._finishedRequest();\n\t\t\t});\n\t\t\treturn promise;\n\n\t\t},\n\t\t/**\n\t\t * @function can-connect/constructor/store/store.updatedList updatedList\n\t\t * @parent can-connect/constructor/store/store.callbacks\n\t\t *\n\t\t * Extends the underlying [can-connect/connection.updatedList] so any instances that have been added or removed\n\t\t * from the list have their reference counts updated accordingly.\n\t\t *\n\t\t * @signature `connection.updatedList( list, listData, set )`\n\t\t * Increments an internal request counter so instances on this list during this request will be stored, and decrements\n\t\t * the same counter for all items previously on the list (found in `listData.data`).\n\t\t *\n\t\t * @param {can-connect.List} list a typed list of instances being updated\n\t\t * @param {Object} listData an object representing the previous state of the list\n\t\t * @param {Object} set the retrieval set used to get the list\n\t\t */\n\t\tupdatedList: function(list, listData, set) {\n\t\t\tvar oldList = list.slice(0);\n\t\t\tif(!listData.data && typeof listData.length === \"number\") {\n\t\t\t\tlistData = { data: listData };\n\t\t\t}\n\t\t\tif(baseConnection.updatedList) {\n\t\t\t\tbaseConnection.updatedList.call(this, list, listData, set);\n\t\t\t\tlist.forEach(function(instance) {\n\t\t\t\t\tthis.addInstanceReference(instance);\n\t\t\t\t}.bind(this));\n\t\t\t} else if(listData.data) {\n\t\t\t\tlistData.data.forEach(function(instance) {\n\t\t\t\t\tthis.addInstanceReference(instance);\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t\toldList.forEach(this.deleteInstanceReference.bind(this));\n\t\t}\n\t};\n\n\treturn behavior;\n\n});\nconstructorStore.requests = requests;\n// The number of ms to wait after all known requests have finished,\n//  before starting request cleanup.\n// If a new request comes in before timeout, wait until that request\n//  has finished (+ delay) before starting cleanup.\n// This is configurable, for use cases where more waiting is desired,\n//  or for the can-connect tests which expect everything to clean up\n//  in 1ms.\nconstructorStore.requestCleanupDelay = 10;\n\nmodule.exports = constructorStore;\n\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\tvar validate = require(\"../../helpers/validate\");\n\tmodule.exports = validate(constructorStore, ['hydrateInstance', 'hydrateList', 'getList', 'get', 'save', 'destroy']);\n}\n//!steal-remove-end\n","\"use strict\";\n/**\n * @module can-connect/data/callbacks/callbacks data/callbacks\n * @parent can-connect.behaviors\n *\n * Extend [can-connect/DataInterface] methods to call callbacks with the raw response data.\n *\n * @signature `dataCallbacks( baseConnection )`\n *\n * Extends the [can-connect/DataInterface] create, update, read & delete methods to call 'callback' methods following\n * their execution. Callbacks are called with the data returned from the underlying behavior's [can-connect/DataInterface]\n * implementation.\n *\n * For example:\n * ```\n * var dataUrl = require(\"can-connect/data/url/\");\n * var dataCallbacks = require(\"can-connect/data/url\");\n * var logging = {\n *   createdData: function(responseData) {\n *     console.log('New Todo Saved: ', responseData);\n *     return responseData;\n *   }\n * };\n * var todoConnection = connect([dataUrl, dataCallbacks, logging}],  {\n *   url: '/todos'\n * });\n *\n * // create a new todo\n * todoConnection.createData({name: \"do the dishes\", completed: false}).then(function(responseData) {\n *   responseData; // {id: 5}\n * });\n *\n * // after create request is completed, following is logged by the \"logging\" createdData callback:\n * // > New Todo Saved: {id: 5}\n * ```\n *\n * @param {{}} baseConnection `can-connect` connection object that is having the `data/callbacks` behavior added\n * on to it. Should already contain a behavior that provides the DataInterface (e.g [can-connect/data/url/url]). If\n * the `connect` helper is used to build the connection, the behaviors will automatically be ordered as required.\n *\n * @return {{}} a `can-connect` connection containing the method implementations provided by `data/callbacks`.\n */\nvar connect = require(\"../../can-connect\");\nvar each = require(\"can-reflect\").each;\n\n// wires up the following methods\nvar pairs = {\n\t/**\n\t * @function can-connect/data/callbacks/callbacks.getListData getListData\n\t * @parent can-connect/data/callbacks/callbacks\n\t *\n\t * Call `gotListData` with the data returned from underlying behavior's implementation of\n\t * [can-connect/connection.gotListData].\n\t *\n\t * @signature `getListData(listQuery)`\n\t *\n\t *   Extends the underlying behavior's [can-connect/connection.getListData] to call `gotListData` with the returned\n\t *   response data. The result of the call to `gotListData` will be used as the new response data.\n\t *\n\t *   @param {Object} listQuery an object that represents the set of data to be loaded\n\t *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `gotListData`.\n\t */\n\tgetListData: \"gotListData\",\n\n\t/**\n\t * @function can-connect/data/callbacks/callbacks.createData createData\n\t * @parent can-connect/data/callbacks/callbacks\n\t *\n\t * Call `createdData` with the data returned from underlying behavior's implementation of\n\t * [can-connect/connection.createData].\n\t *\n\t * @signature `createData(instanceData, cid)`\n\t *\n\t *   Extends the underlying behavior's [can-connect/connection.createData] to call `createdData` with the returned\n\t *   response data. The result of the call to `createdData` will be used as the new response data.\n\t *\n\t *   @param {Object} instanceData the raw data of an instance\n\t *   @param {Number} cid unique id that represents the instance that is being created\n\t *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `createdData`.\n\t */\n\tcreateData: \"createdData\",\n\n\t/**\n\t * @function can-connect/data/callbacks/callbacks.updateData updatedData\n\t * @parent can-connect/data/callbacks/callbacks\n\t *\n\t * Call `updatedData` with the data returned from underlying behavior's implementation of\n\t * [can-connect/connection.updateData].\n\t *\n\t * @signature `updateData(instanceData)`\n\t *\n\t *   Extends the underlying behavior's [can-connect/connection.updateData] to call `updatedData` with the returned\n\t *   response data. The result of the call to `updatedData` will be used as the new response data.\n\t *\n\t *   @param {Object} instanceData the raw data of an instance\n\t *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `updatedData`.\n\t */\n\tupdateData: \"updatedData\",\n\n\t/**\n\t * @function can-connect/data/callbacks/callbacks.destroyData destroyData\n\t * @parent can-connect/data/callbacks/callbacks\n\t *\n\t * Call `destroyedData` with the data returned from underlying behavior's implementation of\n\t * [can-connect/connection.destroyData].\n\t *\n\t * @signature `destroyData(params, cid)`\n\t *\n\t *   Extends the underlying behavior's [can-connect/connection.destroyData] to call `destroyedData` with the returned\n\t *   response data. The result of the call to `destroyedData` will be used as the new response data.\n\t *\n\t *   @param {Object} instanceData the raw data of an instance\n\t *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `destroyedData`.\n\t */\n\tdestroyData: \"destroyedData\"\n};\n\nvar dataCallbackBehavior = connect.behavior(\"data/callbacks\",function(baseConnection){\n\n\tvar behavior = {\n\t};\n\n\t// overwrites createData to createdData\n\teach(pairs, function(callbackName, name){\n\n\t\tbehavior[name] = function(params, cid){\n\t\t\tvar self = this;\n\n\t\t\treturn baseConnection[name].call(this, params).then(function(data){\n\t\t\t\tif(self[callbackName]) {\n\t\t\t\t\treturn self[callbackName].call(self,data, params, cid );\n\t\t\t\t} else {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t});\n\treturn behavior;\n});\n\nmodule.exports = dataCallbackBehavior;\n\n//!steal-remove-start\nif(process.env.NODE_ENV !== 'production') {\n\tvar validate = require(\"../../helpers/validate\");\n\tmodule.exports = validate(dataCallbackBehavior, [\n\t\t\"getListData\", \"createData\", \"updateData\", \"destroyData\"\n\t]);\n}\n//!steal-remove-end\n","\"use strict\";\nvar canReflect = require(\"can-reflect\");\n\nmodule.exports = function(items, item, schema){\n    var length = canReflect.size(items);\n    if(!schema && length > 0) {\n        schema = canReflect.getSchema( items[0] );\n    }\n    if(!schema) {\n        schema = canReflect.getSchema( item );\n    }\n    if(!schema) {\n        throw new Error(\"No schema to use to get identity.\");\n    }\n\n\tvar id = canReflect.getIdentity(item, schema);\n\n\tfor(var i = 0; i < length; i++) {\n\t\tvar connId = canReflect.getIdentity(items[i], schema);\n        // this was ==\n\t\tif( id === connId) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n","\"use strict\";\n/**\n * @module can-connect/real-time/real-time real-time\n * @parent can-connect.behaviors\n * @group can-connect/real-time/real-time.methods 0 methods\n * @group can-connect/real-time/real-time.callbacks 1 data callbacks\n *\n * Update lists to include or exclude instances based\n * on set logic.\n *\n * @signature `realTime( baseConnection )`\n *\n *   Overwrites the \"data callback\" methods and provides\n *   [can-connect/real-time/real-time.createInstance],\n *   [can-connect/real-time/real-time.updateInstance], and\n *   [can-connect/real-time/real-time.destroyInstance] methods\n *   that\n *   update lists to include or exclude a created,\n *   updated, or destroyed instance.\n *\n *   An instance is put in a list if it is a\n *   [can-query-logic/queryLogic.prototype.isSubset]\n *   of the [can-connect/base/base.listQuery].  The item is inserted using [can-query-logic.prototype.index].\n *\n * @body\n *\n * ## Use\n *\n * To use `real-time`, create a connection with its dependent\n * behaviors like:\n *\n * ```js\n * var todoConnection = connect(\n *    [\"real-time\",\n *     \"constructor\",\n *     \"constructor-store\",\n *     \"constructor-callbacks-once\",\n *     \"data-url\"],{\n *   url: \"/todos\"\n * });\n * ```\n *\n * Next, use the connection to load lists and save those lists in the\n * store:\n *\n * ```js\n * todoConnection.getList({complete: false}).then(function(todos){\n *   todoConnection.addListReference(todos);\n * })\n * ```\n *\n * Finally, use one of the  [can-connect/real-time/real-time.createInstance],\n * [can-connect/real-time/real-time.updateInstance], and\n * [can-connect/real-time/real-time.destroyInstance] methods to tell the connection\n * that data has changed.  The connection will update (by calling splice)\n * each list accordingly.\n *\n *\n * ## Example\n *\n * The following demo shows two lists that use this connection.  The\n * \"Run Code\" button sends the connection data changes which the\n * connection will then update lists accordingly:\n *\n *\n * @demo demos/can-connect/real-time.html\n *\n * This example creates a `todoList` function and `todoItem` function\n * that manage the behavior of a list of todos and a single todo respectfully.\n * It uses [Object.observe](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe)\n * to observe changes in the todo list and individual todo data. Other\n * frameworks will typically provide their own observable system.\n *\n * ### todoList\n *\n * When `todoList` is created, it is passed the `set` of data to load.  It uses\n * this to get todos from the `todoConnection` like:\n *\n *\n * ```js\n * todosConnection.getList(set).then(function(retrievedTodos){\n * ```\n *\n * It then adds those `todos` to the [can-connect/constructor/store/store.listStore] so\n * they can be updated automatically.  And, it listens to changes in `todos` and calls an `update` function:\n *\n * ```js\n * todosConnection.addListReference(todos);\n * Object.observe(todos, update, [\"add\", \"update\", \"delete\"] );\n * ```\n *\n * The update function is able to inserted new `todoItem`s in the page when items are added\n * to or removed from `todos`.  We exploit that by calling `update` as if it just added\n * each todo in the list:\n *\n * ```js\n * update(todos.map(function(todo, i){\n *   return {\n *     type: \"add\",\n *     name: \"\"+i\n *   };\n * }));\n * ```\n *\n * ### todoItem\n *\n * The `todoItem` creates an element that updates with changes\n * in its `todo`.  It listens to changes in the `todo` and saves\n * the todo in the [can-connect/constructor/store/store.instanceStore] with the\n * following:\n *\n * ```js\n * Object.observe(todo, update, [\"add\", \"update\", \"delete\"] );\n * todosConnection.addInstanceReference(todo);\n * ```\n *\n * A `todoItem` needs to be able to stop listening on the `todo` and remove itself from the\n * `instanceStore` if the `todo` is removed from the page.  To provide this teardown\n * functionality, `todoItem` listens to a `\"removed\"` event on its element and\n * `unobserves` the todo and removes it from the `instanceStore`:\n *\n * ```js\n * $(li).bind(\"removed\", function(){\n *   Object.unobserve(todo, update, [\"add\", \"update\", \"delete\"] );\n *   todosConnection.deleteInstanceReference(todo);\n * });\n * ```\n */\nvar connect = require(\"../can-connect\");\nvar indexByIdentity = require(\"can-diff/index-by-identity/index-by-identity\");\nvar canDev = require('can-log/dev/dev');\nvar canSymbol = require(\"can-symbol\");\nvar canReflect = require(\"can-reflect\");\n\nvar spliceSymbol = canSymbol.for(\"can.splice\");\n\nfunction updateList(list, getRecord, currentIndex, newIndex) {\n\tif(currentIndex === -1) { // item is not in the list\n\n\t\tif(newIndex !== -1) { // item should be in the list\n\t\t\tcanReflect.splice(list, newIndex, 0, [getRecord()]);\n\t\t}\n\t}\n\telse { // item is already in the list\n\t\tif(newIndex === -1) { // item should be removed from the lists\n\t\t\tcanReflect.splice(list, currentIndex, 1, []);\n\t\t}\n\t\telse if(newIndex !== currentIndex){ // item needs to be moved\n\n\t\t\tif(currentIndex < newIndex) {\n\t\t\t\tcanReflect.splice(list, newIndex, 0, [getRecord()]);\n\t\t\t\tcanReflect.splice(list, currentIndex, 1, []);\n\t\t\t} else {\n\t\t\t\tcanReflect.splice(list, currentIndex,1, []);\n\t\t\t\tcanReflect.splice(list, newIndex, 0, [getRecord()]);\n\t\t\t}\n\t\t}\n\t\telse { // item in the same place\n\n\t\t}\n\t}\n}\n\n\nfunction updateListWithItem(list, recordData, currentIndex, newIndex, connection, set){\n\t// we are inserting right where we already are.\n\tif(currentIndex !== -1 && (newIndex === currentIndex + 1 || newIndex === currentIndex)) {\n\t\treturn;\n\t}\n\tif(list[spliceSymbol] !== undefined) {\n\t\tupdateList(list, function(){\n\t\t\treturn connection.hydrateInstance(recordData);\n\t\t},currentIndex, newIndex);\n\n\t} else {\n\t\tvar copy = connection.serializeList(list);\n\t\tupdateList(copy, function(){\n\t\t\treturn recordData;\n\t\t},currentIndex, newIndex);\n\t\tconnection.updatedList(list,  { data: copy }, set);\n\t}\n}\n\n\nmodule.exports = connect.behavior(\"real-time\",function(baseConnection){\n\n\tvar createPromise = Promise.resolve();\n\tvar behavior;\n\n\tbehavior = {\n\t\tcreateData: function(){\n\t\t\tvar promise = baseConnection.createData.apply(this, arguments);\n\t\t\tvar cleanPromise = promise.catch(function () { return ''; })\n\t\t\tcreatePromise = Promise.all([createPromise, cleanPromise]);\n\t\t\treturn promise;\n\t\t},\n\t\t/**\n\t\t * @function can-connect/real-time/real-time.createInstance createInstance\n\t\t * @parent can-connect/real-time/real-time.methods\n\t\t *\n\t\t * Programatically indicate a new instance has been created.\n\t\t *\n\t\t * @signature `connection.createInstance(props)`\n\t\t *\n\t\t *   If there is no instance in the [can-connect/constructor/store/store.instanceStore]\n\t\t *   for `props`'s [can-connect/base/base.id], an instance is [can-connect/constructor/constructor.hydrateInstance hydrated],\n\t\t *   added to the store, and then [can-connect/real-time/real-time.createdData] is called with\n\t\t *   `props` and the hydrated instance's serialized data. [can-connect/real-time/real-time.createdData]\n\t\t *   will add this instance to any lists the instance belongs to.\n\t\t *\n\t\t *   If this instance has already been created, calls\n\t\t *   [can-connect/real-time/real-time.updateInstance] with `props`.\n\t\t *\n\t\t *   @param {Object} props The raw properties of the instance was created.\n\t\t *\n\t\t *   @return {Promise<Instance>} A promise that resolves to the created instance.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * With a `real-time` connection, call `createInstance` when an instance is created that\n\t\t * the connection itself did not make.  For instance, the following might listen to\n\t\t * [socket.io](http://socket.io/) for when a `todo` is created and update the connection\n\t\t * accordingly:\n\t\t *\n\t\t * ```js\n\t\t * socket.on('todo created', function(todo){\n\t\t *   todoConnection.createInstance(todo);\n\t\t * });\n\t\t * ```\n\t\t *\n\t\t */\n\t\tcreateInstance: function(props){\n\t\t\tvar self = this;\n\t\t\treturn new Promise(function(resolve, reject){\n\t\t\t\t// Wait until all create promises are done\n\t\t\t\t// so that we can find data in the instance store\n\t\t\t\tcreatePromise.then(function(){\n\t\t\t\t\t// Allow time for the store to get hydrated\n\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\tvar id = self.id(props);\n\t\t\t\t\t\tvar instance = self.instanceStore.get(id);\n\t\t\t\t\t\tvar serialized;\n\n\t\t\t\t\t\tif( instance ) {\n\t\t\t\t\t\t\t// already created, lets update\n\t\t\t\t\t\t\tresolve(self.updateInstance(props));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinstance = self.hydrateInstance(props);\n\t\t\t\t\t\t\tserialized = self.serializeInstance(instance);\n\n\t\t\t\t\t\t\tself.addInstanceReference(instance);\n\n\t\t\t\t\t\t\tPromise.resolve( self.createdData(props, serialized) ).then(function(){\n\t\t\t\t\t\t\t\tself.deleteInstanceReference(instance);\n\t\t\t\t\t\t\t\tresolve(instance);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 1);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/real-time/real-time.createdData createdData\n\t\t * @parent can-connect/real-time/real-time.callbacks\n\t\t *\n\t\t * Called whenever instance data is created.\n\t\t *\n\t\t * @signature `connection.createdData(props, params, [cid])`\n\t\t *\n\t\t *   Updates lists with the created instance.\n\t\t *\n\t\t *   Gets the instance created for this request. Then, updates the instance with\n\t\t *   the response data `props`.\n\t\t *\n\t\t *   Next, it goes through every list in the [can-connect/constructor/store/store.listStore],\n\t\t *   test if the instance's data belongs in that list.  If it does,\n\t\t *   adds the instance's data to the serialized list data and\n\t\t *   [can-connect/constructor/constructor.updatedList updates the list].\n\t\t */\n\t\tcreatedData: function(props, params, cid){\n\t\t\tvar instance;\n\t\t\tif(cid !== undefined) {\n\t\t\t\tinstance = this.cidStore.get(cid);\n\t\t\t} else {\n\t\t\t\tinstance = this.instanceStore.get( this.id(props) );\n\t\t\t}\n\t\t\t// pre-register so everything else finds this even if it doesn't have an id\n\t\t\tthis.addInstanceReference(instance, this.id(props));\n\t\t\tthis.createdInstance(instance, props);\n\t\t\tcreate.call(this, this.serializeInstance(instance));\n\t\t\tthis.deleteInstanceReference(instance);\n\t\t\treturn undefined;\n\t\t},\n\n\t\t/**\n\t\t * @function can-connect/real-time/real-time.updatedData updatedData\n\t\t * @parent can-connect/real-time/real-time.callbacks\n\t\t *\n\t\t * Called whenever instance data is updated.\n\t\t *\n\t\t * @signature `connection.updatedData(props, params)`\n\t\t *\n\t\t *   Gets the instance that is updated, updates\n\t\t *   it with `props` and the adds or removes it to\n\t\t *   lists it belongs in.\n\t\t *\n\t\t *   @return {undefined} Returns `undefined` to prevent `.save` from calling `updatedInstance`.\n\t\t */\n\t\t// Go through each list in the listStore and see if there are lists that should have this,\n\t\t// or a list that shouldn't.\n\t\tupdatedData: function(props, params){\n\n\t\t\tvar instance = this.instanceStore.get( this.id(params) );\n\t\t\tthis.updatedInstance(instance, props);\n\t\t\tupdate.call(this, this.serializeInstance(instance));\n\n\t\t\t// Returning undefined prevents other behaviors from running.\n\t\t\treturn undefined;\n\t\t},\n\t\t/**\n\t\t * @function can-connect/real-time/real-time.updateInstance updateInstance\n\t\t * @parent can-connect/real-time/real-time.methods\n\t\t *\n\t\t * Programatically indicate a new instance has been updated.\n\t\t *\n\t\t * @signature `connection.updateInstance(props)`\n\t\t *\n\t\t *   Calls [can-connect/real-time/real-time.updatedData] in the right way so\n\t\t *   that the instance is updated and added to or removed from\n\t\t *   any lists it belongs in.\n\t\t *\n\t\t *   @param {Object} props The properties of the instance that needs to be updated.\n\t\t *\n\t\t *   @return {Promise<Instance>} the updated instance.\n\t\t *\n\t\t * @body\n\t\t *\n\t\t * ## Use\n\t\t *\n\t\t * ```js\n\t\t * socket.on('todo updated', function(todo){\n\t\t *   todoConnection.updateInstance(todo);\n\t\t * });\n\t\t * ```\n\t\t */\n\t\tupdateInstance: function(props){\n\t\t\tvar id = this.id(props);\n\t\t\tvar instance = this.instanceStore.get(id);\n\t\t\tif( !instance ) {\n\t\t\t\tinstance = this.hydrateInstance(props);\n\t\t\t}\n\t\t\tthis.addInstanceReference(instance);\n\n\t\t\tvar serialized = this.serializeInstance(instance),\n\t\t\t\tself = this;\n\n\t\t\treturn Promise.resolve( this.updatedData(props, serialized) ).then(function(){\n\n\t\t\t\tself.deleteInstanceReference(instance);\n\t\t\t\treturn instance;\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * @function can-connect/real-time/real-time.destroyedData destroyedData\n\t\t * @parent can-connect/real-time/real-time.callbacks\n\t\t *\n\t\t * @signature `connection.destroyedData(props, params)`\n\t\t *\n\t\t * Gets the instance for this request.  Then tests if the instance\n\t\t * is in any list in the [can-connect/constructor/store/store.listStore].  If\n\t\t * it is, removes the instance from the list.\n\t\t *\n\t\t * @param {Object} props The properties of the destroyed instance.\n\t\t * @param {Object} [params] The parameters used to destroy the data.\n\t\t */\n\t\tdestroyedData: function(props, params){\n\t\t\tvar id = this.id(params || props);\n\t\t\tvar instance = this.instanceStore.get(id);\n\t\t\tif( !instance ) {\n\t\t\t\tinstance = this.hydrateInstance(props);\n\t\t\t}\n\t\t\tvar serialized = this.serializeInstance(instance);\n\t\t\tthis.destroyedInstance(instance, props);\n\t\t\t// we can pre-register it so everything else finds it\n\t\t\tdestroy.call(this, serialized);\n\t\t\treturn undefined;\n\t\t},\n\t\t/**\n\t\t * @function can-connect/real-time/real-time.destroyInstance destroyInstance\n\t\t * @parent can-connect/real-time/real-time.methods\n\t\t *\n\t\t * Programatically indicate a new instance has been destroyed.\n\t\t *\n\t\t * @signature `connection.destroyInstance(props)`\n\t\t *\n\t\t *   Gets or creates an instance from `props` and uses\n\t\t *   it to call [can-connect/real-time/real-time.destroyedData]\n\t\t *   correctly.\n\t\t *\n\t\t * @param {Object} props The properties of the destroyed instance.\n\t\t * @return {Promise<Instance>}  A promise with the destroyed instance.\n\t\t *\n\t\t * @body\n\t\t * ## Use\n\t\t *\n\t\t * ```js\n\t\t * socket.on('todo destroyed', function(todo){\n\t\t *   todoConnection.destroyInstance(todo);\n\t\t * });\n\t\t * ```\n\t\t */\n\t\tdestroyInstance: function(props){\n\t\t\tvar id = this.id(props);\n\t\t\tvar instance = this.instanceStore.get(id);\n\t\t\tif( !instance ) {\n\t\t\t\tinstance = this.hydrateInstance(props);\n\t\t\t}\n\t\t\tthis.addInstanceReference(instance);\n\n\t\t\tvar serialized = this.serializeInstance(instance),\n\t\t\t\tself = this;\n\n\t\t\treturn Promise.resolve( this.destroyedData(props, serialized) ).then(function(){\n\n\t\t\t\tself.deleteInstanceReference(instance);\n\t\t\t\treturn instance;\n\t\t\t});\n\t\t}\n\t};\n\n\t//!steal-remove-start\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tbehavior.gotListData = function(items, set) {\n\t\t\tvar self = this;\n\t\t\tif (this.queryLogic) {\n\t\t\t\tif(Array.isArray(items)) {\n\t\t\t\t\titems = {data: items};\n\t\t\t\t}\n\t\t\t\tfor(var item, i = 0, l = items.data.length; i < l; i++) {\n\t\t\t\t\titem = items.data[i];\n\t\t\t\t\tif( !self.queryLogic.isMember(set, item) ) {\n\t\t\t\t\t\tvar msg = \"One or more items were retrieved which do not match the 'Set' parameters used to load them. \"\n\t\t\t\t\t\t\t+ \"Read the docs for more information: https://canjs.com/doc/can-query-logic.html#TestingyourQueryLogic\"\n\t\t\t\t\t\t\t+ \"\\n\\nBelow are the 'query' parameters:\"\n\t\t\t\t\t\t\t+ \"\\n\" + canDev.stringify(set)\n\t\t\t\t\t\t\t+ \"\\n\\nAnd below is an item which does not match those parameters:\"\n\t\t\t\t\t\t\t+ \"\\n\" + canDev.stringify(item);\n\t\t\t\t\t\tcanDev.warn(msg);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Promise.resolve(items);\n\t\t}\n\t}\n\t//!steal-remove-end\n\n\treturn behavior;\n});\n\nvar create = function(props){\n\tvar self = this;\n\t// go through each list\n\tthis.listStore.forEach(function(list, id){\n\t\tvar set = JSON.parse(id);\n\t\t// ideally there should be speed up ... but this is fine for now.\n\n\n\t\tvar index = indexByIdentity(list, props, self.queryLogic.schema);\n\n\t\tif(self.queryLogic.isMember(set, props)) {\n\t\t\tvar newIndex = self.queryLogic.index(set, list, props);\n\n\t\t\tupdateListWithItem(list, props, index, newIndex, self, set);\n\t\t}\n\n\t});\n};\n\n// ## update\n// Goes through each list and sees if the list should be updated\n// with the new.\nvar update = function(props) {\n\tvar self = this;\n\n\tthis.listStore.forEach(function(list, id){\n\t\tvar set = JSON.parse(id);\n\t\t// ideally there should be speed up ... but this is fine for now.\n\n\n\t\tvar currentIndex = indexByIdentity(list, props, self.queryLogic.schema);\n\n\t\tif(self.queryLogic.isMember( set, props )) {\n\n\t\t\tvar newIndex = self.queryLogic.index(set, list, props);\n\n\t\t\tupdateListWithItem(list, props, currentIndex, newIndex, self, set);\n\n\t\t}  else if(currentIndex !== -1){ // its still in the list\n\t\t\t// otherwise remove it\n\t\t\tupdateListWithItem(list, props, currentIndex, -1, self, set);\n\t\t}\n\n\t});\n};\n\nvar destroy = function(props) {\n\tvar self = this;\n\tthis.listStore.forEach(function(list, id){\n\t\tvar set = JSON.parse(id);\n\t\t// ideally there should be speed up ... but this is fine for now.\n\n\t\tvar currentIndex = indexByIdentity(list, props, self.queryLogic.schema);\n\n\t\tif(currentIndex !== -1){\n\t\t\t// otherwise remove it\n\t\t\tupdateListWithItem(list, props, currentIndex, -1, self, set);\n\t\t}\n\n\t});\n};\n"],"names":["forEach","callbacks","callbacksOnceBehavior","connect","behavior","baseConnection","call","name","instance","data","lastSerialized","this","getInstanceMetaData","serialize","sortedSetJSON","result","apply","arguments","addInstanceMetaData","module","process","env","NODE_ENV","validate","require$$0","assign","assignMap","WeakReferenceSet","set","prototype","has","item","_getIndex","addReference","referenceCount","index","push","deleteReference","splice","delete","get","every","i","undefined","cb","pendingRequests","noRequestsTimer","requests","increment","connection","clearTimeout","decrement","setTimeout","dispatch","exports","requestCleanupDelay","count","eventQueue","constructorStore","instanceStore","WeakReferenceMap","newInstanceStore","listStore","init","hasOwnProperty","_requestInstances","_requestLists","on","id","deleteInstanceReference","bind","_finishedRequest","addInstanceReference","ID","createdInstance","props","moveCreatedInstanceToInstanceStore","value","deleteInstanceMetaData","addListReference","list","listQuery","deleteListReference","hydratedInstance","hydrateInstance","storeInstance","updatedInstance","hydratedList","hydrateList","listData","storeList","updatedList","getList","self","promise","then","instances","params","save","updating","isNew","destroy","oldList","slice","length","each","pairs","getListData","createData","updateData","destroyData","dataCallbackBehavior","callbackName","cid","require$$1","items","schema","canReflect","size","getSchema","Error","getIdentity","spliceSymbol","canSymbol","for","updateList","getRecord","currentIndex","newIndex","updateListWithItem","recordData","copy","serializeList","createPromise","Promise","resolve","cleanPromise","catch","all","createInstance","reject","serialized","updateInstance","serializeInstance","createdData","cidStore","create","updatedData","update","destroyedData","destroyedInstance","destroyInstance","gotListData","queryLogic","Array","isArray","l","isMember","msg","canDev","stringify","warn","JSON","parse","indexByIdentity"],"mappings":"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"}