{"version":3,"file":"chunk-f8a6947c.js","sources":["../node_modules/can-event-queue/map/map.js"],"sourcesContent":["\"use strict\";\n/**\n * @module {function} can-event-queue/map/map\n * @parent can-event-queue\n * @templateRender true\n *\n * @description Mixin methods and symbols to make this object or prototype object\n * behave like a key-value observable.\n *\n * @signature `mixinMapBindings( obj )`\n *\n * Adds symbols and methods that make `obj` or instances having `obj` on their prototype\n * behave like key-value observables.\n *\n * When `mixinMapBindings` is called on an `obj` like:\n *\n * ```js\n * var mixinMapBindings = require(\"can-event-queue/map/map\");\n *\n * var observable = mixinValueBindings({});\n *\n * observable.on(\"prop\",function(ev, newVal, oldVal){\n *   console.log(newVal);\n * });\n *\n * observable[canSymbol.for(\"can.dispatch\")](\"prop\",[2,1]);\n * // Logs: 2\n * ```\n *\n * `mixinMapBindings` adds the following properties and symbols to the object:\n *\n * {{#each (getChildren [can-event-queue/map/map])}}\n * - [{{name}}] - {{description}}{{/each}}\n *\n * Furthermore, `mixinMapBindings` looks for the following symbols on the object's `.constructor`\n * property:\n *\n * - `@can.dispatchInstanceBoundChange` - Called when the bind status of an instance changes.\n * - `@can.dispatchInstanceOnPatches` - Called if [can-event-queue/map/map.dispatch] is called with `event.patches` as an array of\n *   patches.\n */\nvar canDev = require('can-log/dev/dev');\nvar queues = require(\"can-queues\");\nvar canReflect = require(\"can-reflect\");\nvar canSymbol = require(\"can-symbol\");\nvar KeyTree = require(\"can-key-tree\");\n\nvar domEvents = require(\"can-dom-events\");\nvar isDomEventTarget = require(\"can-dom-events/helpers/util\").isDomEventTarget;\n\nvar mergeDependencyRecords = require(\"../dependency-record/merge\");\n\nvar metaSymbol = canSymbol.for(\"can.meta\"),\n\tdispatchBoundChangeSymbol = canSymbol.for(\"can.dispatchInstanceBoundChange\"),\n\tdispatchInstanceOnPatchesSymbol = canSymbol.for(\"can.dispatchInstanceOnPatches\"),\n\tonKeyValueSymbol = canSymbol.for(\"can.onKeyValue\"),\n\toffKeyValueSymbol = canSymbol.for(\"can.offKeyValue\"),\n\tonEventSymbol = canSymbol.for(\"can.onEvent\"),\n\toffEventSymbol = canSymbol.for(\"can.offEvent\"),\n\tonValueSymbol = canSymbol.for(\"can.onValue\"),\n\toffValueSymbol = canSymbol.for(\"can.offValue\");\n\nvar legacyMapBindings;\n\nfunction addHandlers(obj, meta) {\n\tif (!meta.handlers) {\n\t\t// Handlers are organized by:\n\t\t// event name - the type of event bound to\n\t\t// binding type - \"event\" for things that expect an event object (legacy), \"onKeyValue\" for reflective bindings.\n\t\t// queue name - mutate, queue, etc\n\t\t// handlers - the handlers.\n\t\tmeta.handlers = new KeyTree([Object, Object, Object, Array], {\n\t\t\tonFirst: function() {\n\t\t\t\tif (obj._eventSetup !== undefined) {\n\t\t\t\t\tobj._eventSetup();\n\t\t\t\t}\n\t\t\t\tvar constructor = obj.constructor;\n\t\t\t\tif(constructor[dispatchBoundChangeSymbol] !== undefined && obj instanceof constructor) {\n\t\t\t\t\tconstructor[dispatchBoundChangeSymbol](obj, true);\n\t\t\t\t}\n\t\t\t\t//queues.enqueueByQueue(getLifecycleHandlers(obj).getNode([]), obj, [true]);\n\t\t\t},\n\t\t\tonEmpty: function() {\n\t\t\t\tif (obj._eventTeardown !== undefined) {\n\t\t\t\t\tobj._eventTeardown();\n\t\t\t\t}\n\t\t\t\tvar constructor = obj.constructor;\n\t\t\t\tif(constructor[dispatchBoundChangeSymbol] !== undefined && obj instanceof constructor) {\n\t\t\t\t\tconstructor[dispatchBoundChangeSymbol](obj, false);\n\t\t\t\t}\n\t\t\t\t//queues.enqueueByQueue(getLifecycleHandlers(obj).getNode([]), obj, [false]);\n\t\t\t}\n\t\t});\n\t}\n\n\tif (!meta.listenHandlers) {\n\t\t// context, eventName (might be undefined), queue, handlers\n\t\tmeta.listenHandlers = new KeyTree([Map, Map, Object, Array]);\n\t}\n}\n\n\n// getHandlers returns a KeyTree used for event handling.\n// `handlers` will be on the `can.meta` symbol on the object.\n// Ensure the \"obj\" passed as an argument has an object on @@can.meta\nvar ensureMeta = function ensureMeta(obj) {\n\tvar meta = obj[metaSymbol];\n\n\tif (!meta) {\n\t\tmeta = {};\n\t\tcanReflect.setKeyValue(obj, metaSymbol, meta);\n\t}\n\taddHandlers(obj, meta);\n\n\treturn meta;\n};\n\nfunction stopListeningArgumentsToKeys(bindTarget, event, handler, queueName) {\n\tif(arguments.length && canReflect.isPrimitive(bindTarget)) {\n\t\tqueueName = handler;\n\t\thandler = event;\n\t\tevent = bindTarget;\n\t\tbindTarget = this.context;\n\t}\n\tif(typeof event === \"function\") {\n\t\tqueueName = handler;\n\t\thandler = event;\n\t\tevent = undefined;\n\t}\n\tif(typeof handler === \"string\") {\n\t\tqueueName = handler;\n\t\thandler = undefined;\n\t}\n\tvar keys = [];\n\tif(bindTarget) {\n\t\tkeys.push(bindTarget);\n\t\tif(event || handler || queueName) {\n\t\t\tkeys.push(event);\n\t\t\tif(queueName || handler) {\n\t\t\t\tkeys.push(queueName || this.defaultQueue);\n\t\t\t\tif(handler) {\n\t\t\t\t\tkeys.push(handler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn keys;\n}\n\n\n// These are the properties we are going to add to objects\nvar props = {\n\t/**\n\t * @function can-event-queue/map/map.dispatch dispatch\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Dispatch event and key binding handlers.\n\t *\n\t * @signature `obj.dispatch(event, [args])`\n\t *\n\t * Dispatches registered [can-event-queue/map/map.addEventListener] and\n\t * [can-event-queue/map/map.can.onKeyValue] value binding handlers.\n\t *\n\t * The following shows dispatching the `property` event and\n\t * `keyValue` handlers:\n\t *\n\t *\n\t * ```js\n\t * var mixinMapBindings = require(\"can-event-queue/map/map\");\n\t *\n\t * var obj = mixinMapBindings({});\n\t *\n\t * obj.addEventListener(\"property\", function(event, newVal){\n\t *   event.type //-> \"property\"\n\t *   newVal     //-> 5\n\t * });\n\t *\n\t * canReflect.onKeyValue(\"property\", function(newVal){\n\t *   newVal     //-> 5\n\t * })\n\t *\n\t * obj.dispatch(\"property\", [5]);\n\t * ```\n\t *\n\t * > NOTE: Event handlers have an additional `event` argument.\n\t *\n\t * @param {String|Object} event The event to dispatch. If a string is passed,\n\t *   it will be used as the `type` of the event that will be dispatched and dispatch matching\n\t *   [can-event-queue/map/map.can.onKeyValue] bindings:\n\t *\n\t *   ```js\n\t *   obs.dispatch(\"key\")\n\t *   ```\n\t *\n\t *   If `event` is an object, it __MUST__ have a `type` property. The If a string is passed,\n\t *   it will be used as the `type` of the event that will be dispatched and dispatch matching\n\t *   [can-event-queue/map/map.can.onKeyValue] bindings:\n\t *\n\t *   ```js\n\t *   obs.dispatch({type: \"key\"})\n\t *   ```\n\t *\n\t *   The `event` object can also have the following properties and values:\n\t *   - __reasonLog__ `{Array}` - The reason this event happened. This will be passed to\n\t *     [can-queues.enqueueByQueue] for debugging purposes.\n\t *   - __makeMeta__ `{function}` - Details about the handler being called. This will be passed to\n\t *     [can-queues.enqueueByQueue] for debugging purposes.\n\t *   - __patches__ `{Array<Patch>}` - The patch objects this event represents.  The `.patches` value will be\n\t *     passed to the object's `.constructor`'s `@can.dispatchInstanceOnPatches` method.\n\t *\n\t * @param {Array} [args] Additional arguments to pass to event handlers.\n\t * @return {Object} event The resulting event object.\n\t */\n\tdispatch: function(event, args) {\n\t\t//!steal-remove-start\n\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tif (arguments.length > 4) {\n\t\t\t\tcanDev.warn('Arguments to dispatch should be an array, not multiple arguments.');\n\t\t\t\targs = Array.prototype.slice.call(arguments, 1);\n\t\t\t}\n\n\t\t\tif (args && !Array.isArray(args)) {\n\t\t\t\tcanDev.warn('Arguments to dispatch should be an array.');\n\t\t\t\targs = [args];\n\t\t\t}\n\t\t}\n\t\t//!steal-remove-end\n\n\t\t// Don't send events if initalizing.\n\t\tif (!this.__inSetup) {\n\t\t\tif (typeof event === 'string') {\n\t\t\t\tevent = {\n\t\t\t\t\ttype: event\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar meta = ensureMeta(this);\n\n\t\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\t\tif (!event.reasonLog) {\n\t\t\t\t\tevent.reasonLog = [canReflect.getName(this), \"dispatched\", '\"' + event.type + '\"', \"with\"].concat(args);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof meta._log === \"function\") {\n\t\t\t\tmeta._log.call(this, event, args);\n\t\t\t}\n\t\t\t//!steal-remove-end\n\t\t\tvar handlers = meta.handlers;\n\t\t\tvar handlersByType = event.type !== undefined && handlers.getNode([event.type]);\n\t\t\tvar dispatchConstructorPatches = event.patches && this.constructor[dispatchInstanceOnPatchesSymbol];\n\t\t\tvar patchesNode = event.patches !== undefined && handlers.getNode([\"can.patches\",\"onKeyValue\"]);\n\t\t\tvar keysNode = event.keyChanged !== undefined && handlers.getNode([\"can.keys\",\"onKeyValue\"]);\n\t\t\tvar batch = dispatchConstructorPatches || handlersByType || patchesNode || keysNode;\n\t\t\tif ( batch ) {\n\t\t\t\tqueues.batch.start();\n\t\t\t}\n\t\t\tif(handlersByType) {\n\t\t\t\tif (handlersByType.onKeyValue) {\n\t\t\t\t\tqueues.enqueueByQueue(handlersByType.onKeyValue, this, args, event.makeMeta, event.reasonLog);\n\t\t\t\t}\n\t\t\t\tif (handlersByType.event) {\n\t\t\t\t\tevent.batchNum = queues.batch.number();\n\t\t\t\t\tvar eventAndArgs = [event].concat(args);\n\t\t\t\t\tqueues.enqueueByQueue(handlersByType.event, this, eventAndArgs, event.makeMeta, event.reasonLog);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(keysNode) {\n\t\t\t\tqueues.enqueueByQueue(keysNode, this, [event.keyChanged], event.makeMeta, event.reasonLog);\n\t\t\t}\n\t\t\tif(patchesNode) {\n\t\t\t\tqueues.enqueueByQueue(patchesNode, this, [event.patches], event.makeMeta, event.reasonLog);\n\t\t\t}\n\t\t\tif(dispatchConstructorPatches) {\n\t\t\t\tthis.constructor[dispatchInstanceOnPatchesSymbol](this, event.patches);\n\t\t\t}\n\t\t\tif ( batch ) {\n\t\t\t\tqueues.batch.stop();\n\t\t\t}\n\t\t}\n\t\treturn event;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.addEventListener addEventListener\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Register an event handler to be called when an event is dispatched.\n\t *\n\t * @signature `obj.addEventListener(eventName, handler(event, ...) [,queueName] )`\n\t *\n\t * Add a event listener to an object.  Handlers attached by `.addEventListener` get\n\t * called back with the [can-event-queue/map/map.dispatch]\n\t * `event` object and any arguments used to dispatch. [can-event-queue/map/map.can.onKeyValue] bindings do\n\t * not get the event object.\n\t *\n\t * ```js\n\t * var mixinMapBindings = require(\"can-event-queue/map/map\");\n\t *\n\t * var obj = mixinMapBindings({});\n\t *\n\t * obj.addEventListener(\"foo\", function(event){ ... });\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to listen for.\n\t * @param {Function} handler(event,arg...) The handler that will be executed to handle the event.  The handler will be called\n\t *   with the dispatched `event` and `args`.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler will called\n\t *   back within. Defaults to `\"mutate\"`.\n\t * @return {Object} Returns the object `.addEventListener` was called on.\n\t *\n\t */\n\taddEventListener: function(key, handler, queueName) {\n\t\tensureMeta(this).handlers.add([key, \"event\", queueName || \"mutate\", handler]);\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.removeEventListener removeEventListener\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Unregister an event handler to be called when an event is dispatched.\n\t *\n\t * @signature `obj.removeEventListener(eventName, [handler [,queueName]] )`\n\t *\n\t * Removes one or more handlers from being called when `eventName`\n\t * is [can-event-queue/map/map.dispatch]ed.\n\t *\n\t * ```js\n\t * // Removes `handler` if it is in the notify queue.\n\t * obj.removeEventListener(\"closed\", handler, \"notify\")\n\t *\n\t * // Removes `handler` if it is in the mutate queue.\n\t * obj.removeEventListener(\"closed\", handler)\n\t *\n\t * // Removes all \"closed\" handlers.\n\t * obj.removeEventListener(\"closed\")\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to remove. If not specified, all events are removed.\n\t * @param {Function} [handler] The handler that will be removed from the event. If not specified, all handlers for the event are removed.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler was registered on. Defaults to `\"mutate\"`.\n\t * @return {Object} Returns the object `.removeEventListener` was called on.\n\t */\n\tremoveEventListener: function(key, handler, queueName) {\n\t\tif(key === undefined) {\n\t\t\t// This isn't super fast, but this pattern isn't used much.\n\t\t\t// We could re-arrange the tree so it would be faster.\n\t\t\tvar handlers = ensureMeta(this).handlers;\n\t\t\tvar keyHandlers = handlers.getNode([]);\n\t\t\tObject.keys(keyHandlers).forEach(function(key){\n\t\t\t\thandlers.delete([key,\"event\"]);\n\t\t\t});\n\t\t} else if (!handler && !queueName) {\n\t\t\tensureMeta(this).handlers.delete([key, \"event\"]);\n\t\t} else if (!handler) {\n\t\t\tensureMeta(this).handlers.delete([key, \"event\", queueName || \"mutate\"]);\n\t\t} else {\n\t\t\tensureMeta(this).handlers.delete([key, \"event\", queueName || \"mutate\", handler]);\n\t\t}\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.one one\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Register an event handler that gets called only once.\n\t *\n\t * @signature `obj.one(event, handler(event, args...) )`\n\t *\n\t * Adds a basic event listener that listens to an event once and only once.\n\t *\n\t * ```js\n\t * obj.one(\"prop\", function(){\n\t *   console.log(\"prop dispatched\");\n\t * })\n\t *\n\t * obj[canSymbol.for(\"prop\")](\"prop\") //-> logs \"prop dispatched\"\n\t * obj[canSymbol.for(\"prop\")](\"prop\")\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to listen to.\n\t * @param {Function} handler(event, args...) The handler that will be run when the\n\t *   event is dispached.\n\t * @return {Object} this\n\t */\n\tone: function(event, handler) {\n\t\t// Unbind the listener after it has been executed\n\t\tvar one = function() {\n\t\t\tlegacyMapBindings.off.call(this, event, one);\n\t\t\treturn handler.apply(this, arguments);\n\t\t};\n\n\t\t// Bind the altered listener\n\t\tlegacyMapBindings.on.call(this, event, one);\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.listenTo listenTo\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Listen to an event and register the binding for simplified unbinding.\n\t *\n\t * @signature `obj.listenTo([bindTarget,] event, handler)`\n\t *\n\t * `.listenTo` is useful for creating bindings that can can be torn down with\n\t * [can-event-queue/map/map.stopListening].  This is useful when creating\n\t * rich behaviors that can't be accomplished using computed values, or if you are trying to\n\t * avoid streams.\n\t *\n\t * For example, the following creates an observable that counts how many times its\n\t * `name` property has changed:\n\t *\n\t * ```js\n\t * class Person {\n\t *   constructor(){\n\t *     this.nameChanged = 0;\n\t *     this.listenTo(\"name\", function(){\n\t *       this.nameChanged++;\n\t *     })\n\t *   },\n\t *   setName(newVal) {\n\t *     this.name = newVal;\n\t *     this.dispatch(\"name\",[newVal])\n\t *   }\n\t * }\n\t * mixinMapBindings(Person.prototype);\n\t *\n\t * var person = new Person();\n\t * person.setName(\"Justin\");\n\t * person.setName(\"Ramiya\");\n\t * person.nameChanged //-> 2\n\t * ```\n\t *\n\t * `.listenTo` event bindings are stored on an observable and MUST be unbound using\n\t * [can-event-queue/map/map.stopListening]. `.stopListening` make it easy to unbind\n\t * all of the `.listenTo` event bindings when the observable is no longer needed:\n\t *\n\t * ```js\n\t * person.stopListening();\n\t * ```\n\t *\n\t * If no `bindTarget` is passed, `.listenTo` binds to the current\n\t * observable.\n\t *\n\t * [can-component]'s `connectedCallback` lifecyle hook is often used to call\n\t * `.listenTo` to setup bindings that update viewmodel properties.\n\t *\n\t *\n\t * @param {Object} [bindTarget] The object to listen for events on.  If `bindTarget` is not provided,\n\t * the observable `.listenTo` was called on will be the `bindTarget`.\n\t * @param {String} event The name of the event to listen for.\n\t * @param {Function} handler The handler that will be executed to handle the event.\n\t * @return {Object} this\n\t */\n\tlistenTo: function (bindTarget, event, handler, queueName) {\n\n\t\tif(canReflect.isPrimitive(bindTarget)) {\n\t\t\tqueueName = handler;\n\t\t\thandler = event;\n\t\t\tevent = bindTarget;\n\t\t\tbindTarget = this;\n\t\t}\n\n\t\tif(typeof event === \"function\") {\n\t\t\tqueueName = handler;\n\t\t\thandler = event;\n\t\t\tevent = undefined;\n\t\t}\n\n\t\t// Initialize event cache\n\t\tensureMeta(this).listenHandlers.add([bindTarget, event, queueName || \"mutate\", handler]);\n\n\t\tlegacyMapBindings.on.call(bindTarget, event, handler, queueName || \"mutate\");\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.stopListening stopListening\n\t * @parent can-event-queue/map/map\n\t * @description Stops listening for registered event handlers.\n\t *\n\t * @signature `obj.stopListening( [bindTarget], [event,] handler]] )`\n\t *\n\t * `.stopListening` unbinds on event handlers registered through\n\t * [can-event-queue/map/map.listenTo]. All event handlers\n\t * that match the arguments will be unbound. For example:\n\t *\n\t * ```js\n\t * // Unbinds all .listenTo registered handlers\n\t * obj.stopListening()\n\t *\n\t * // Unbinds all .listenTo registered with `bindTarget`\n\t * obj.stopListening(bindTarget)\n\t *\n\t * // Unbinds all .listenTo registered with `bindTarget`, `event`\n\t * obj.stopListening(bindTarget, event)\n\t *\n\t * // Unbinds the handler registered with `bindTarget`, `event`, `handler`\n\t * obj.stopListening(bindTarget, event, handler)\n\t * ```\n\t *\n\t * `.listenTo` is often returned by [can-component]'s `connectedCallback` lifecyle hook.\n\t *\n\t * @param {Object} [bindTarget] The object we will stop listening to event on. If `bindTarget` is\n\t * not provided, the observable `.stopListening` was called on will be the `bindTarget`.\n\t * @param {String} [event] The name of the event to listen for.\n\t * @param {Function} [handler] The handler that will be executed to handle the event.\n\t * @return {Object} this\n\t *\n\t */\n\tstopListening: function () {\n\t\tvar keys = stopListeningArgumentsToKeys.apply({context: this, defaultQueue: \"mutate\"}, arguments);\n\n\t\tvar listenHandlers = ensureMeta(this).listenHandlers;\n\n\t\tfunction deleteHandler(bindTarget, event, queue, handler){\n\t\t\tlegacyMapBindings.off.call(bindTarget, event, handler, queue);\n\t\t}\n\t\tlistenHandlers.delete(keys, deleteHandler);\n\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.on on\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description A shorthand method for listening to event.\n\t *\n\t * @signature `obj.on( event, handler [, queue] )`\n\t *\n\t * Listen to when `obj` dispatches an event, a [can-reflect/observe.onKeyValue]\n\t * change, or a [can-reflect/observe.onValue] change in that order.\n\t *\n\t * As this is the __legacy__ `.on`, it will look for an `.addEventListener`\n\t * method on the `obj` first, before looking for the [can-symbol/symbols/onKeyValue]\n\t * and then [can-symbol/symbols/onValue] symbol.\n\t *\n\t * @param {String} eventName\n\t * @param {Function} handler\n\t * @param {String} [queue]\n\t * @return {Any} The object `on` was called on.\n\t */\n\ton: function(eventName, handler, queue) {\n\t\tvar listenWithDOM = isDomEventTarget(this);\n\t\tif (listenWithDOM) {\n\t\t\tif (typeof handler === 'string') {\n\t\t\t\tdomEvents.addDelegateListener(this, eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tdomEvents.addEventListener(this, eventName, handler, queue);\n\t\t\t}\n\t\t} else {\n\t\t\tif (\"addEventListener\" in this) {\n\t\t\t\tthis.addEventListener(eventName, handler, queue);\n\t\t\t} else if (this[onKeyValueSymbol]) {\n\t\t\t\tcanReflect.onKeyValue(this, eventName, handler, queue);\n\t\t\t} else if (this[onEventSymbol]) {\n\t\t\t\tthis[onEventSymbol](eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tif (!eventName && this[onValueSymbol]) {\n\t\t\t\t\tcanReflect.onValue(this, handler, queue);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"can-event-queue: Unable to bind \" + eventName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\t/**\n\t * @function can-event-queue/map/map.off off\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description A shorthand method for unbinding an event.\n\t *\n\t * @signature `obj.on( event, handler [, queue] )`\n\t *\n\t * Listen to when `obj` dispatches an event, a [can-reflect/observe.onKeyValue]\n\t * change, or a [can-reflect/observe.onValue] change in that order.\n\t *\n\t * As this is the __legacy__ `.on`, it will look for an `.addEventListener`\n\t * method on the `obj` first, before looking for the [can-symbol/symbols/onKeyValue]\n\t * and then [can-symbol/symbols/onValue] symbol.\n\t *\n\t * @param {String} eventName\n\t * @param {Function} handler\n\t * @param {String} [queue]\n\t * @return {Any} The object `on` was called on.\n\t */\n\toff: function(eventName, handler, queue) {\n\t\tvar listenWithDOM = isDomEventTarget(this);\n\t\tif (listenWithDOM) {\n\t\t\tif (typeof handler === 'string') {\n\t\t\t\tdomEvents.removeDelegateListener(this, eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tdomEvents.removeEventListener(this, eventName, handler, queue);\n\t\t\t}\n\t\t} else {\n\t\t\tif (\"removeEventListener\" in this) {\n\t\t\t\tthis.removeEventListener(eventName, handler, queue);\n\t\t\t} else if (this[offKeyValueSymbol]) {\n\t\t\t\tcanReflect.offKeyValue(this, eventName, handler, queue);\n\t\t\t} else if (this[offEventSymbol]) {\n\t\t\t\tthis[offEventSymbol](eventName, handler, queue);\n\t\t\t} else {\n\t\t\t\tif (!eventName && this[offValueSymbol]) {\n\t\t\t\t\tcanReflect.offValue(this, handler, queue);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"can-event-queue: Unable to unbind \" + eventName);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n};\n\n// The symbols we'll add to objects\nvar symbols = {\n\t/**\n\t * @function can-event-queue/map/map.can.onKeyValue @can.onKeyValue\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Register an event handler to be called when a key value changes.\n\t *\n\t * @signature `canReflect.onKeyValue( obj, key, handler(newVal) [,queueName] )`\n\t *\n\t * Add a key change handler to an object.  Handlers attached by `.onKeyValue` get\n\t * called back with the new value of the `key`. Handlers attached with [can-event-queue/map/map.can.addEventListener]\n\t * get the event object.\n\t *\n\t * ```js\n\t * var mixinMapBindings = require(\"can-event-queue/map/map\");\n\t *\n\t * var obj = mixinMapBindings({});\n\t *\n\t * canReflect.onKeyValue( obj, \"prop\", function(newPropValue){ ... });\n\t * ```\n\t *\n\t * @param {String} key The name of property to listen to changes in values.\n\t * @param {Function} handler(newVal, oldValue) The handler that will be called\n\t *   back with the new and old value of the key.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler will called\n\t *   back within. Defaults to `\"mutate\"`.\n\t */\n\t\"can.onKeyValue\": function(key, handler, queueName) {\n\t\tensureMeta(this).handlers.add([key, \"onKeyValue\", queueName || \"mutate\", handler]);\n\t},\n\t/**\n\t * @function can-event-queue/map/map.can.offKeyValue @can.offKeyValue\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Unregister an event handler to be called when an event is dispatched.\n\t *\n\t * @signature `canReflect.offKeyValue( obj, key, handler, queueName )`\n\t *\n\t * Removes a handlers from being called when `key` changes are\n\t * [can-event-queue/map/map.dispatch]ed.\n\t *\n\t * ```js\n\t * // Removes `handler` if it is in the notify queue.\n\t * canReflect.offKeyValue( obj, \"prop\", handler, \"notify\" )\n\t * ```\n\t *\n\t * @param {String} eventName The name of the event to remove. If not specified, all events are removed.\n\t * @param {Function} [handler] The handler that will be removed from the event. If not specified, all handlers for the event are removed.\n\t * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler was registered on. Defaults to `\"mutate\"`.\n\t */\n\t\"can.offKeyValue\": function(key, handler, queueName) {\n\t\tensureMeta(this).handlers.delete([key, \"onKeyValue\", queueName || \"mutate\", handler]);\n\t},\n\t/**\n\t * @function can-event-queue/map/map.can.isBound @can.isBound\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Return if the observable is bound to.\n\t *\n\t * @signature `canReflect.isBound(obj)`\n\t *\n\t * The `@can.isBound` symbol is added to make [can-reflect/observe.isBound]\n\t * return if `obj` is bound or not.\n\t *\n\t * @return {Boolean} True if the observable has been bound to with `.onKeyValue` or `.addEventListener`.\n\t */\n\t\"can.isBound\": function() {\n\t\treturn !ensureMeta(this).handlers.isEmpty();\n\t},\n\t/**\n\t * @function can-event-queue/map/map.can.getWhatIChange @can.getWhatIChange\n\t * @parent can-event-queue/map/map\n\t *\n\t * @description Return observables whose values are affected by attached event handlers\n\t * @signature `@can.getWhatIChange(key)`\n\t *\n\t * The `@@can.getWhatIChange` symbol is added to make sure [can-debug] can report\n\t * all the observables whose values are set by a given observable's key.\n\t *\n\t * This function iterates over the event handlers attached to a given `key` and\n\t * collects the result of calling `@@can.getChangesDependencyRecord` on each handler;\n\t * this symbol allows the caller to tell what observables are being mutated by\n\t * the event handler when it is executed.\n\t *\n\t * In the following example a [can-simple-map] instance named `me` is created\n\t * and when its `age` property changes, the value of a [can-simple-observable]\n\t * instance is set. The event handler that causes the mutation is then decatorated\n\t * with `@@can.getChangesDependencyRecord` to register the mutation dependency.\n\t *\n\t * ```js\n\t * var obs = new SimpleObservable(\"a\");\n\t * var me = new SimpleMap({ age: 30 });\n\t * var canReflect = require(\"can-reflect\");\n\t *\n\t * var onAgeChange = function onAgeChange() {\n\t *\tcanReflect.setValue(obs, \"b\");\n\t * };\n\t *\n\t * onAgeChange[canSymbol.for(\"can.getChangesDependencyRecord\")] = function() {\n\t *\treturn {\n\t *\t\tvalueDependencies: new Set([ obs ]);\n\t *\t}\n\t * };\n\t *\n\t * canReflect.onKeyValue(me, \"age\", onAgeChange);\n\t * me[canSymbol.for(\"can.getWhatIChange\")](\"age\");\n\t * ```\n\t *\n\t * The dependency records collected from the event handlers are divided into\n\t * two categories:\n\t *\n\t * - mutate: Handlers in the mutate/domUI queues\n\t * - derive: Handlers in the notify queue\n\t *\n\t * Since event handlers are added by default to the \"mutate\" queue, calling\n\t * `@@can.getWhatIChange` on the `me` instance returns an object with a mutate\n\t * property and the `valueDependencies` Set registered on the `onAgeChange`\n\t * handler.\n\t *\n\t * Please check out the [can-reflect-dependencies] docs to learn more about\n\t * how this symbol is used to keep track of custom observable dependencies.\n\t */\n\t\"can.getWhatIChange\": function getWhatIChange(key) {\n\t\t//!steal-remove-start\n\t\t\tif(process.env.NODE_ENV !== 'production') {\n\t\t\tvar whatIChange = {};\n\t\t\tvar meta = ensureMeta(this);\n\n\t\t\tvar notifyHandlers = [].concat(\n\t\t\t\tmeta.handlers.get([key, \"event\", \"notify\"]),\n\t\t\t\tmeta.handlers.get([key, \"onKeyValue\", \"notify\"])\n\t\t\t);\n\n\t\t\tvar mutateHandlers = [].concat(\n\t\t\t\tmeta.handlers.get([key, \"event\", \"mutate\"]),\n\t\t\t\tmeta.handlers.get([key, \"event\", \"domUI\"]),\n\t\t\t\tmeta.handlers.get([key, \"onKeyValue\", \"mutate\"]),\n\t\t\t\tmeta.handlers.get([key, \"onKeyValue\", \"domUI\"])\n\t\t\t);\n\n\t\t\tif (notifyHandlers.length) {\n\t\t\t\tnotifyHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.derive;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.derive = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (mutateHandlers.length) {\n\t\t\t\tmutateHandlers.forEach(function(handler) {\n\t\t\t\t\tvar changes = canReflect.getChangesDependencyRecord(handler);\n\n\t\t\t\t\tif (changes) {\n\t\t\t\t\t\tvar record = whatIChange.mutate;\n\t\t\t\t\t\tif (!record) {\n\t\t\t\t\t\t\trecord = (whatIChange.mutate = {});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmergeDependencyRecords(record, changes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn Object.keys(whatIChange).length ? whatIChange : undefined;\n\t\t}\n\t\t//!steal-remove-end\n\t},\n\t\"can.onPatches\": function(handler, queue) {\n\t\tvar handlers = ensureMeta(this).handlers;\n\t\thandlers.add([\"can.patches\", \"onKeyValue\", queue || \"notify\", handler]);\n\t},\n\t\"can.offPatches\": function(handler, queue) {\n\t\tvar handlers = ensureMeta(this).handlers;\n\t\thandlers.delete([\"can.patches\", \"onKeyValue\", queue || \"notify\", handler]);\n\t}\n};\n\n// This can be removed in a future version.\nfunction defineNonEnumerable(obj, prop, value) {\n\tObject.defineProperty(obj, prop, {\n\t\tenumerable: false,\n\t\tvalue: value\n\t});\n}\n\n// The actual legacyMapBindings mixin function\nlegacyMapBindings = function(obj) {\n\t// add properties\n\tcanReflect.assignMap(obj, props);\n\t// add symbols\n\treturn canReflect.assignSymbols(obj, symbols);\n};\n\ndefineNonEnumerable(legacyMapBindings, \"addHandlers\", addHandlers);\ndefineNonEnumerable(legacyMapBindings, \"stopListeningArgumentsToKeys\", stopListeningArgumentsToKeys);\n\n\n\n// ## LEGACY\n// The following is for compatability with the old can-event\nprops.bind = props.addEventListener;\nprops.unbind = props.removeEventListener;\n\n\n\n// Adds methods directly to method so it can be used like `can-event` used to be used.\ncanReflect.assignMap(legacyMapBindings, props);\ncanReflect.assignSymbols(legacyMapBindings, symbols);\n\ndefineNonEnumerable(legacyMapBindings, \"start\", function() {\n\tconsole.warn(\"use can-queues.batch.start()\");\n\tqueues.batch.start();\n});\ndefineNonEnumerable(legacyMapBindings, \"stop\", function() {\n\tconsole.warn(\"use can-queues.batch.stop()\");\n\tqueues.batch.stop();\n});\ndefineNonEnumerable(legacyMapBindings, \"flush\", function() {\n\tconsole.warn(\"use can-queues.flush()\");\n\tqueues.flush();\n});\n\ndefineNonEnumerable(legacyMapBindings, \"afterPreviousEvents\", function(handler) {\n\tconsole.warn(\"don't use afterPreviousEvents\");\n\tqueues.mutateQueue.enqueue(function afterPreviousEvents() {\n\t\tqueues.mutateQueue.enqueue(handler);\n\t});\n\tqueues.flush();\n});\n\ndefineNonEnumerable(legacyMapBindings, \"after\", function(handler) {\n\tconsole.warn(\"don't use after\");\n\tqueues.mutateQueue.enqueue(handler);\n\tqueues.flush();\n});\n\nmodule.exports = legacyMapBindings;\n"],"names":["legacyMapBindings","isDomEventTarget","require$$0","metaSymbol","canSymbol","for","dispatchBoundChangeSymbol","dispatchInstanceOnPatchesSymbol","onKeyValueSymbol","offKeyValueSymbol","onEventSymbol","offEventSymbol","onValueSymbol","offValueSymbol","addHandlers","obj","meta","handlers","KeyTree","Object","Array","onFirst","undefined","_eventSetup","constructor","onEmpty","_eventTeardown","listenHandlers","Map","ensureMeta","canReflect","setKeyValue","stopListeningArgumentsToKeys","bindTarget","event","handler","queueName","arguments","length","isPrimitive","this","context","keys","push","defaultQueue","props","dispatch","args","process","env","NODE_ENV","canDev","warn","prototype","slice","call","isArray","__inSetup","type","reasonLog","getName","concat","_log","handlersByType","getNode","dispatchConstructorPatches","patches","patchesNode","keysNode","keyChanged","batch","queues","start","onKeyValue","enqueueByQueue","makeMeta","batchNum","number","eventAndArgs","stop","addEventListener","key","add","removeEventListener","keyHandlers","forEach","delete","one","off","apply","on","listenTo","stopListening","queue","eventName","domEvents","addDelegateListener","Error","onValue","removeDelegateListener","offKeyValue","offValue","symbols","can.onKeyValue","can.offKeyValue","can.isBound","isEmpty","can.getWhatIChange","whatIChange","notifyHandlers","get","mutateHandlers","changes","getChangesDependencyRecord","record","derive","mergeDependencyRecords","mutate","can.onPatches","can.offPatches","defineNonEnumerable","prop","value","defineProperty","enumerable","assignMap","assignSymbols","bind","unbind","console","flush","mutateQueue","enqueue"],"mappings":"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"}